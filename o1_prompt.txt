moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/ChainerCrafterInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Block.ChainerCrafter;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class ChainerCrafterInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        [SerializeField] private List<ItemSlotObject> recipeInputItemSlotObjects;
        [SerializeField] private List<ItemSlotObject> recipeOutputItemSlotObjects;
        
        [SerializeField] private ChainerCrafterItemSelectModal itemSelectModal;
        
        private BlockGameObject _blockGameObject;
        private CancellationToken _gameObjectCancellationToken;
        
        private CraftingSolverRecipe _currentRecipe;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            _gameObjectCancellationToken = this.GetCancellationTokenOnDestroy();
            
            // アイテムリストを初期化
            // Initialize item list
            InitializeItemList();
            
            // レシピの情報を取得
            // Get recipe information
            InitializeRecipeSlots().Forget();
            
            itemSelectModal.Initialize();
            
            #region Internal
            
            void InitializeItemList()
            {
                var itemList = new List<IItemStack>();
                var param = (CraftChainerCrafterBlockParam)blockGameObject.BlockMasterElement.BlockParam;
                for (var i = 0; i < param.ItemSlotCount; i++)
                {
                    var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                    _blockItemSlotObjects.Add(slotObject);
                    itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
                }
                UpdateItemList(itemList);
            }
            
  #endregion
        }
        
        private async UniTask InitializeRecipeSlots()
        {
            _currentRecipe = await GetRecipe();
            if (_currentRecipe == null) return;
            
            SetRecipeUI(_currentRecipe);
            
            SetupRecipeSlotEvent();
            
            #region Internal
            
            async UniTask<CraftingSolverRecipe> GetRecipe()
            {
                var pos = _blockGameObject.BlockPosInfo.OriginalPos;
                var blockStates = await ClientContext.VanillaApi.Response.GetBlockState(pos, _gameObjectCancellationToken);
                if (blockStates == null) return null;
                
                var chainerState = blockStates.GetStateDetail<ChainerCrafterComponentSerializeObject>(ChainerCrafterComponentSerializeObject.StateDetailKey);
                if (chainerState == null) return null;
                
                return chainerState.Recipe.ToCraftingSolverRecipe();
            }
            
            void SetupRecipeSlotEvent()
            {
                for (var i = 0; i < recipeInputItemSlotObjects.Count; i++)
                {
                    var input = recipeInputItemSlotObjects[i];
                    var index = i;
                    input.OnLeftClickUp.Subscribe(item => ClickRecipeInputItem(item, index, true).Forget());
                }
                for (var i = 0; i < recipeOutputItemSlotObjects.Count; i++)
                {
                    var output = recipeOutputItemSlotObjects[i];
                    var index = i;
                    output.OnLeftClickUp.Subscribe(item => ClickRecipeInputItem(item, index, false).Forget());
                }
            }
            
            #endregion
        }
        
        private async UniTask ClickRecipeInputItem(ItemSlotObject itemSlotObject, int index, bool isInput)
        {
            // アイテムを選択
            // Select item
            var (resultId, resultCount) = await SelectItem();
            
            // レシピ情報を更新
            // Update recipe information
            UpdateRecipe();
            
            // UIを更新
            // Update UI
            SetRecipeUI(_currentRecipe);
            
            // レシピ情報を送信
            // Send recipe information
            SendRecipeInfo();
            
            #region Internal
            
            async UniTask<(ItemId,int)> SelectItem()
            {
                // モーダルを開いてアイテムを選択
                var currentId = itemSlotObject.ItemViewData?.ItemId ?? ItemMaster.EmptyItemId;
                var currentCount = itemSlotObject.Count;
                
                var (id, count) = await itemSelectModal.GetSelectItem(currentId, currentCount);
                
                return (id, count);
            }
            
            void UpdateRecipe()
            {
                var recipeItems = isInput ? _currentRecipe.Inputs : _currentRecipe.Outputs;
                
                if (index < recipeItems.Count)
                {
                    recipeItems[index] = new CraftingSolverItem(resultId, resultCount);
                }
                else
                {
                    for (var i = recipeItems.Count; i < index; i++)
                    {
                        recipeItems.Add(new CraftingSolverItem(ItemMaster.EmptyItemId, 0));
                    }
                    
                    recipeItems.Add(new CraftingSolverItem(resultId, resultCount));
                }
            }
            
            void SendRecipeInfo()
            {
                // 送る用に適切な形に変換
                var input = _currentRecipe.Inputs.Where(i => i.ItemId != ItemMaster.EmptyItemId).ToList();
                var output = _currentRecipe.Outputs.Where(i => i.ItemId != ItemMaster.EmptyItemId).ToList();
                
                var pos = _blockGameObject.BlockPosInfo.OriginalPos;
                ClientContext.VanillaApi.SendOnly.SetCraftChainerCrafterRecipe(pos, input, output);
            }
            
  #endregion
            
        }
        
        
        private void SetRecipeUI(CraftingSolverRecipe recipe)
        {
            SetItemSlot(recipeInputItemSlotObjects, recipe.Inputs);
            SetItemSlot(recipeOutputItemSlotObjects, recipe.Outputs);
            
            #region Internal
            
            void SetItemSlot(List<ItemSlotObject> itemSlots, List<CraftingSolverItem> items)
            {
                for (var i = 0; i < itemSlots.Count; i++)
                {
                    if (i >= items.Count)
                    {
                        itemSlots[i].SetItem(null, 0);
                        continue;
                    }
                    
                    var item = items[i];
                    var slotObject = itemSlots[i];
                    var itemView = ClientContext.ItemImageContainer.GetItemView(item.ItemId);
                    slotObject.SetItem(itemView, item.Count);
                }
            }
            
  #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/MachineSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Assert = UnityEngine.Assertions.Assert;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class MachineSaveLoadTest
    {
        //インベントリのあるブロックを追加した時のテスト
        //レシピやブロックが変わった時はテストコードを修正してください
        [Test]
        public void InventoryBlockTest()
        {
            //機械の追加
            var (blockFactory, worldBlockDatastore, _, assembleSaveJsonText, _) = CreateBlockTestModule();
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId , new Vector3Int(0, 0), BlockDirection.North, out var machineBlock);
            var machineInventory = machineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            
            //レシピ用のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(1), 3));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 1));
            //処理を開始
            GameUpdater.UpdateWithWait();
            //別のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(5), 6));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 4));
            
            //リフレクションで機械の状態を設定
            //機械のレシピの残り時間設定
            var vanillaMachineProcessor = machineBlock.GetComponent<VanillaMachineProcessorComponent>();
            //ステータスをセット
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("RemainingSecond")
                .SetValue(vanillaMachineProcessor, 0.3);
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("CurrentState")
                .SetValue(vanillaMachineProcessor, ProcessState.Processing);
            
            //機械のアウトプットスロットの設定
            var outputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(machineInventory);
            
            outputInventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            outputInventory.SetItem(2, itemStackFactory.Create(new ItemId(3), 2));
            
            //レシピIDを取得
            var recipeId = vanillaMachineProcessor.RecipeGuid;
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            //配置したブロックを削除
            worldBlockDatastore.RemoveBlock(new Vector3Int(0, 0));
            
            
            //ロードした時に機械の状態が正しいことを確認
            var (_, loadWorldBlockDatastore, _, _, loadJsonFile) = CreateBlockTestModule();
            
            loadJsonFile.Load(json);
            
            var loadMachineBlock = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            
            //ブロックID、intIDが同じであることを確認
            Assert.AreEqual(machineBlock.BlockId, loadMachineBlock.BlockId);
            Assert.AreEqual(machineBlock.BlockInstanceId, loadMachineBlock.BlockInstanceId);
            
            
            //機械のレシピの残り時間のチェック
            var machineProcessor = loadMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            Assert.AreEqual(0.3, machineProcessor.RemainingSecond);
            //レシピIDのチェック
            Assert.AreEqual(recipeId, machineProcessor.RecipeGuid);
            //機械のステータスのチェック
            Assert.AreEqual(ProcessState.Processing, machineProcessor.CurrentState);
            
            
            var loadMachineInventory = loadMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            //インプットスロットのチェック
            var inputInventoryField = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(5), 6), inputInventoryField.InputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 4), inputInventoryField.InputSlot[1]);
            
            //アウトプットスロットのチェック
            var outputInventoryField = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.CreatEmpty(), outputInventoryField.OutputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 1), outputInventoryField.OutputSlot[1]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), outputInventoryField.OutputSlot[2]);
        }
        
        private (IBlockFactory, IWorldBlockDatastore, PlayerInventoryDataStore, AssembleSaveJsonText, WorldLoaderFromJson)
            CreateBlockTestModule()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var playerInventoryDataStore = serviceProvider.GetService<PlayerInventoryDataStore>();
            var loadJsonFile = serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson;
            
            return (blockFactory, worldBlockDatastore, playerInventoryDataStore, assembleSaveJsonText, loadJsonFile);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/RequestBlockInventoryTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.BlockInventoryRequestProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class RequestBlockInventoryTest
    {
        private const int InputSlotNum = 2;
        private const int OutPutSlotNum = 3;
        
        //通常の機械のテスト
        [Test]
        public void MachineInventoryRequest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(5, 10), BlockDirection.North, out var machineBlock);
            var machineComponent = machineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            machineComponent.SetItem(0, itemStackFactory.Create(new ItemId(1), 2));
            machineComponent.SetItem(2, itemStackFactory.Create(new ItemId(4), 5));
            
            //レスポンスの取得
            var data = MessagePackSerializer.Deserialize<BlockInventoryResponseProtocolMessagePack>(packet.GetPacketResponse(RequestBlock(new Vector3Int(5, 10)))[0].ToArray());
            
            Assert.AreEqual(InputSlotNum + OutPutSlotNum, data.Items.Length); // slot num
            
            
            Assert.AreEqual(ForUnitTestModBlockId.MachineId, data.BlockId); // block id
            
            Assert.AreEqual(1, data.Items[0].Id.AsPrimitive()); // item id
            Assert.AreEqual(2, data.Items[0].Count); // item count
            
            Assert.AreEqual(0, data.Items[1].Id.AsPrimitive());
            Assert.AreEqual(0, data.Items[1].Count);
            
            Assert.AreEqual(4, data.Items[2].Id.AsPrimitive());
            Assert.AreEqual(5, data.Items[2].Count);
        }
        
        private List<byte> RequestBlock(Vector3Int pos)
        {
            return MessagePackSerializer.Serialize(new RequestBlockInventoryRequestProtocolMessagePack(pos)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearMachineIoTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.MachineRecipesModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class GearMachineIoTest
    {
        public int GearMachineRecipeIndex = 3;
        
        //アイテムが通常通り処理されるかのテスト
        [Test]
        public void ItemProcessingOutputTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[GearMachineRecipeIndex];
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var block = blockFactory.Create(blockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var blockInventory = block.GetComponent<VanillaMachineBlockInventoryComponent>();
            foreach (var inputItem in recipe.InputItems)
            {
                blockInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var gearEnergyTransformer = block.GetComponent<GearEnergyTransformer>();
            var gearMachineParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearMachine).BlockParam as GearMachineBlockParam;
            var machineProcessor = block.GetComponent<VanillaMachineProcessorComponent>();
            
            //最大クラフト時間を超過するまでクラフトする
            var craftTime = DateTime.Now.AddSeconds(recipe.Time);
            while (craftTime.AddSeconds(0.4).CompareTo(DateTime.Now) == 1)
            {
                var requiredRpm = new RPM(gearMachineParam.RequiredRpm);
                var requiredTorque = new Torque(gearMachineParam.RequireTorque);
                gearEnergyTransformer.SupplyPower(requiredRpm, requiredTorque, true);
                machineProcessor.Update();
                GameUpdater.Wait();
                GameUpdater.UpdateDeltaTime();
            }
            
            //検証
            AssertInventory(blockInventory, recipe);
        }
        
        
        [Test]
        // RPM、トルクが足りないときに処理に時間がかかるテスト
        public void NotEnoughTorqueOrRpmTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[GearMachineRecipeIndex];
            
            var recipeBlockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var lackRpmBlock = blockFactory.Create(recipeBlockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var lackTorqueBlock = blockFactory.Create(recipeBlockId, new BlockInstanceId(2), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.zero));
            
            var lackRpmInventory = lackRpmBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            var lackTorqueInventory = lackTorqueBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            foreach (var inputItem in recipe.InputItems)
            {
                lackRpmInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
                lackTorqueInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var lackRpmGearMachine = lackRpmBlock.GetComponent<GearEnergyTransformer>();
            var lackTorqueGearMachine = lackTorqueBlock.GetComponent<GearEnergyTransformer>();
            var gearMachineParam = lackRpmBlock.BlockMasterElement.BlockParam as GearMachineBlockParam;
            
            var lackRpmProcessor = lackRpmBlock.GetComponent<VanillaMachineProcessorComponent>();
            var lackTorqueProcessor = lackTorqueBlock.GetComponent<VanillaMachineProcessorComponent>();
            
            //最大クラフト時間を超過するまでクラフトする
            var craftTime = DateTime.Now.AddSeconds(recipe.Time * 2);
            while (craftTime.AddSeconds(0.3).CompareTo(DateTime.Now) == 1)
            {
                var rpm = new RPM(gearMachineParam.RequiredRpm / 2f);
                lackRpmGearMachine.SupplyPower(rpm, new Torque(gearMachineParam.RequireTorque), true);
                lackTorqueGearMachine.SupplyPower(new RPM(gearMachineParam.RequiredRpm), (Torque)gearMachineParam.RequireTorque / 2f, true);
                
                lackRpmProcessor.Update();
                lackTorqueProcessor.Update();
                
                GameUpdater.Wait();
                GameUpdater.UpdateDeltaTime();
            }
            
            //検証
            AssertInventory(lackRpmInventory, recipe);
            AssertInventory(lackTorqueInventory, recipe);
        }
        
        private void AssertInventory(VanillaMachineBlockInventoryComponent inventory, MachineRecipeMasterElement recipe)
        {
            (List<IItemStack> input, List<IItemStack> output) = GetInputOutputSlot(inventory);
            
            Assert.AreEqual(0, input.Count);
            foreach (var inputItem in input) Assert.AreEqual(ItemMaster.EmptyItemId, inputItem.Id);
            
            Assert.AreNotEqual(0, output.Count);
            for (var i = 0; i < output.Count; i++)
            {
                var outputItemId = MasterHolder.ItemMaster.GetItemId(recipe.OutputItems[i].ItemGuid);
                Assert.AreEqual(outputItemId, output[i].Id);
                Assert.AreEqual(recipe.OutputItems[i].Count, output[i].Count);
            }
        }
        
        private (List<IItemStack>, List<IItemStack>) GetInputOutputSlot(VanillaMachineBlockInventoryComponent vanillaMachineInventory)
        {
            var vanillaMachineInputInventory = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            var vanillaMachineOutputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            
            var inputSlot = vanillaMachineInputInventory.InputSlot.Where(i => i.Count != 0).ToList();
            inputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            var outputSlot = vanillaMachineOutputInventory.OutputSlot.Where(i => i.Count != 0).ToList();
            outputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            return (inputSlot, outputSlot);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/MachineIOTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Core.Const;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class MachineIOTest
    {
        //アイテムが通常通り処理されるかのテスト
        [Test]
        public void ItemProcessingOutputTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[0];
            
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var block = blockFactory.Create(blockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var blockInventory = block.GetComponent<VanillaMachineBlockInventoryComponent>();
            foreach (var inputItem in recipe.InputItems)
            {
                blockInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var blockMachineComponent = block.GetComponent<VanillaElectricMachineComponent>();
            
            var craftTime = DateTime.Now.AddSeconds(recipe.Time);
            //最大クラフト時間を超過するまでクラフトする
            while (craftTime.AddSeconds(0.2).CompareTo(DateTime.Now) == 1)
            {
                blockMachineComponent.SupplyEnergy(new ElectricPower(10000));
                GameUpdater.UpdateWithWait();
            }
            
            //検証
            (List<IItemStack> input, List<IItemStack> output) = GetInputOutputSlot(blockInventory);
            
            Assert.AreEqual(0, input.Count);
            foreach (var inputItem in input) Assert.AreEqual(ItemMaster.EmptyItemId, inputItem.Id);
            
            Assert.AreNotEqual(0, output.Count);
            for (var i = 0; i < output.Count; i++)
            {
                var expectedOutputId = MasterHolder.ItemMaster.GetItemId(recipe.OutputItems[i].ItemGuid);
                Assert.AreEqual(expectedOutputId, output[i].Id);
                Assert.AreEqual(recipe.OutputItems[i].Count, output[i].Count);
            }
        }
        
        public (List<IItemStack>, List<IItemStack>) GetInputOutputSlot(VanillaMachineBlockInventoryComponent vanillaMachineInventory)
        {
            var vanillaMachineInputInventory = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            var vanillaMachineOutputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            
            var inputSlot = vanillaMachineInputInventory.InputSlot.Where(i => i.Count != 0).ToList();
            inputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            var outputSlot = vanillaMachineOutputInventory.OutputSlot.Where(i => i.Count != 0).ToList();
            outputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            return (inputSlot, outputSlot);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/OneClickCraft.cs
```cs
using System;
using System.Collections.Generic;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.Crafting.Interface;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.CraftRecipesModule;

namespace Server.Protocol.PacketResponse
{
    public class OneClickCraft : IPacketResponse
    {
        public const string ProtocolTag = "va:oneClickCraft";
        private readonly CraftEvent _craftEvent;
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public OneClickCraft(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
            _craftEvent = serviceProvider.GetService<CraftEvent>();
        }
        
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestOneClickCraftProtocolMessagePack>(payload.ToArray());
            
            var craftConfig = MasterHolder.CraftRecipeMaster.GetCraftRecipe(data.CraftRecipeGuid);
            //プレイヤーインベントリを取得
            var playerInventory = _playerInventoryDataStore.GetInventoryData(data.PlayerId);
            var mainInventory = playerInventory.MainOpenableInventory;
            
            //クラフト可能かどうかを確認
            if (!IsCraftable(mainInventory, craftConfig))
                //クラフト不可能な場合は何もしない
                return null;
            
            //クラフト可能な場合はクラフトを実行
            
            //クラフトに必要なアイテムを消費
            ConsumptionItem(mainInventory, craftConfig);
            //クラフト結果をプレイヤーインベントリに追加
            var resultItem = ServerContext.ItemStackFactory.Create(craftConfig.CraftResultItemGuid, craftConfig.CraftResultCount);
            playerInventory.MainOpenableInventory.InsertItem(resultItem);
            
            _craftEvent.InvokeCraftItem(craftConfig);
            
            return null;
        }
        
        private static bool IsCraftable(IOpenableInventory mainInventory, CraftRecipeMasterElement recipe)
        {
            //クラフト結果のアイテムをインサートできるかどうかをチェックする
            var resultItem = ServerContext.ItemStackFactory.Create(recipe.CraftResultItemGuid, recipe.CraftResultCount);
            var resultItemList = new List<IItemStack> { resultItem };
            if (!mainInventory.InsertionCheck(resultItemList))
                return false;
            
            //クラフトに必要なアイテムを収集する
            //key itemId value count
            var requiredItems = new Dictionary<ItemId, int>();
            foreach (var requiredItem in recipe.RequiredItems)
            {
                var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (requiredItems.ContainsKey(requiredItemId))
                {
                    requiredItems[requiredItemId] += requiredItem.Count;
                }
                else
                {
                    requiredItems.Add(requiredItemId, requiredItem.Count);
                }
            }
            
            //クラフトに必要なアイテムを持っているか確認する
            var checkResult = new Dictionary<ItemId, int>();
            foreach (var itemStack in mainInventory.InventoryItems)
            {
                if (!requiredItems.ContainsKey(itemStack.Id)) continue;
                
                if (checkResult.ContainsKey(itemStack.Id))
                    checkResult[itemStack.Id] += itemStack.Count;
                else
                    checkResult[itemStack.Id] = itemStack.Count;
            }
            
            //必要なアイテムを持っていない場合はクラフトできない
            foreach (var requiredItem in requiredItems)
            {
                if (!checkResult.ContainsKey(requiredItem.Key)) return false;
                if (checkResult[requiredItem.Key] < requiredItem.Value) return false;
            }
            
            
            return true;
        }
        
        
        /// <summary>
        ///     クラフトしてアイテムを消費する
        /// </summary>
        private static void ConsumptionItem(IOpenableInventory mainInventory, CraftRecipeMasterElement recipe)
        {
            //クラフトに必要なアイテムを収集する
            //key itemId value count
            var requiredItems = new Dictionary<ItemId, int>();
            foreach (var requiredItem in recipe.RequiredItems)
            {
                if (requiredItem.IsRemain.HasValue && requiredItem.IsRemain.Value) 
                {
                    continue;
                }
                
                var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (requiredItems.ContainsKey(requiredItemId))
                    requiredItems[requiredItemId] += requiredItem.Count;
                else
                    requiredItems.Add(requiredItemId, requiredItem.Count);
            }
            
            //クラフトのために消費する
            for (var i = 0; i < mainInventory.InventoryItems.Count; i++)
            {
                var inventoryItem = mainInventory.InventoryItems[i];
                if (!requiredItems.TryGetValue(inventoryItem.Id, out var subCount)) continue;
                
                if (inventoryItem.Count <= subCount)
                {
                    mainInventory.SetItem(i, inventoryItem.SubItem(inventoryItem.Count));
                    requiredItems[inventoryItem.Id] -= inventoryItem.Count;
                }
                else
                {
                    mainInventory.SetItem(i, inventoryItem.SubItem(subCount));
                    requiredItems[inventoryItem.Id] -= subCount;
                }
            }
        }
        
        [MessagePackObject]
        public class RequestOneClickCraftProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Key(3)] public string CraftRecipeGuidStr { get; set; }
            [IgnoreMember] public Guid CraftRecipeGuid => Guid.Parse(CraftRecipeGuidStr);
            
            public RequestOneClickCraftProtocolMessagePack(int playerId, Guid craftRecipeGuid)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                CraftRecipeGuidStr = craftRecipeGuid.ToString();
            }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RequestOneClickCraftProtocolMessagePack() { }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerMainComputerSaveLoadTest.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerMainComputerSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);
            
            // ChainerMainComputerブロックを作成
            // Create a ChainerMainComputer block
            var mainComputerBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerMainComputer, new BlockInstanceId(1), posInfo);
            var originalMainComputerComponent = mainComputerBlock.GetComponent<CraftChainerMainComputerComponent>();
            
            
            // セーブデータを取得
            // Get the save data
            var saveState = mainComputerBlock.GetSaveState();
            
            // ブロックをロード
            // Load the block
            var loadedBlock = blockFactory.Load(mainComputerBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedMainComputerComponent = loadedBlock.GetComponent<CraftChainerMainComputerComponent>();
            
            // NodeIdが正しく保存・ロードされているか確認
            // Check if NodeId is correctly saved and loaded
            Assert.AreEqual(originalMainComputerComponent.NodeId, loadedMainComputerComponent.NodeId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Transporter/CraftChainerTransporterInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent
{
    /// <summary>
    /// そのアイテムがどのクラフトノードに挿入されるべきかを判断し、挿入するためのクラス
    /// Class for determining which craft node the item should be inserted into and inserting it
    /// </summary>
    public class CraftChainerTransporterInserter : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        private readonly CraftChainerNodeId _startChainerNodeId;
        
        public CraftChainerTransporterInserter(BlockConnectorComponent<IBlockInventory> blockConnectorComponent, CraftChainerNodeId startChainerNodeId)
        {
            _blockConnectorComponent = blockConnectorComponent;
            _startChainerNodeId = startChainerNodeId;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var context = CraftChainerMainComputerManager.Instance.GetChainerNetworkContext(_startChainerNodeId);
            if (context == null)
            {
                return itemStack;
            }
            
            // transporterの場合は既に1個になっているアイテムを挿入する想定
            // In the case of a transporter, it is assumed that the item has already been reduced to one
            return context.InsertNodeNetworkNextBlock(itemStack, _startChainerNodeId, _blockConnectorComponent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/MachineRecipeConfigTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Block
{
    public class MachineRecipeConfigTest
    {
        /// <summary>
        ///     レシピがある時のテスト
        /// </summary>
        [TestCase(1, new int[2] { 1, 2 }, 3, 1)]
        [TestCase(1, new int[2] { 2, 1 }, 3, 1)]
        [TestCase(3, new int[3] { 1, 2, 3 }, 5, 1)]
        [TestCase(3, new int[3] { 2, 1, 3 }, 5, 1)]
        public void RecipeInputItemBlockIdTest(int BlocksId, int[] items, int output0Id, double output0Percent)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var input = new List<IItemStack>();
            items.ToList().ForEach(i => input.Add(itemStackFactory.Create(new ItemId(i), 1)));
            
            MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)BlocksId, input, out var ans);
            
            Assert.AreEqual(output0Id, MasterHolder.ItemMaster.GetItemId(ans.OutputItems[0].ItemGuid).AsPrimitive());
            Assert.AreEqual(output0Percent, ans.OutputItems[0].Percent);
        }
        
        [TestCase(3, new int[4] { 2, 1, 0, 5 }, 0)] //レシピが存在しない時のテスト
        [TestCase(0, new int[3] { 2, 1, 0 }, 0)] // not exist test
        [TestCase(3, new int[3] { 4, 1, 0 }, 0)]
        [TestCase(10, new int[1] { 2 }, 0)]
        [TestCase(0, new int[0], 0)]
        [TestCase(1, new int[2] { 2, 1 }, 1)] //存在するときのテストケース exist test
        public void NullRecipeTest(int BlocksId, int[] items, int outputLength)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var input = new List<IItemStack>();
            items.ToList().ForEach(i => input.Add(itemStackFactory.Create(new ItemId(i), 1)));
            
            var ans = MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)BlocksId, input, out _);
            Assert.AreEqual(outputLength == 1, ans);
        }
        
        [TestCase(1, new int[2] { 1, 2 }, new int[2] { 3, 1 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 3 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 30 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 1 }, false)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 2, 3, 4 }, true)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 4, 6, 8 }, true)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 4, 6, 1 }, false)]
        [TestCase(3, new int[3] { 2, 1, 3 }, new int[3] { 3, 2, 4 }, true)]
        [TestCase(3, new int[3] { 2, 1, 3 }, new int[3] { 3, 1, 4 }, false)]
        [TestCase(3, new int[4] { 2, 1, 0, 5 }, new int[4] { 3, 1, 4, 5 }, false)]
        public void RecipeConfirmationTest(int blocksId, int[] items, int[] itemcount, bool ans)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var itemStacks = new List<IItemStack>();
            for (var i = 0; i < items.Length; i++)
            {
                var itemId = new ItemId(items[i]);
                itemStacks.Add(itemStackFactory.Create(itemId, itemcount[i]));
            }
            
            MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)blocksId, itemStacks, out var machineRecipeElement);
            
            if (!ans && machineRecipeElement == null)
            {
                Assert.Pass();
                return;
            }
            
            var a = machineRecipeElement.RecipeConfirmation((BlockId)blocksId, itemStacks);
            Assert.AreEqual(ans, a);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/ProviderChest/CraftChainerProviderChestBlockInventoryInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.Context;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent.ProviderChest
{
    /// <summary>
    /// CraftChainerネットワークへのアイテムの供給リクエストを受け、InsertItemがそれに合致しているアイテムをCraftChainerネットワークに供給する
    /// InsertItemメソッドはチェスト等から毎フレーム叩かれているため、明示的にInsertを呼び出すと言ったことはしない。
    ///
    /// Receive a request to supply an item to the CraftChainer network, and InsertItem will supply the matching item to the CraftChainer network.
    /// The InsertItem method is hit every frame from the chest, etc., so it does not explicitly call Insert.
    /// </summary>
    public class CraftChainerProviderChestBlockInventoryInserter : IBlockInventoryInserter
    {
        private readonly CraftChainerNodeId _providerChestNodeId;
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        public CraftChainerProviderChestBlockInventoryInserter(CraftChainerNodeId providerChestNodeId, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _providerChestNodeId = providerChestNodeId;
            _blockConnectorComponent = blockConnectorComponent;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var context = CraftChainerMainComputerManager.Instance.GetChainerNetworkContext(_providerChestNodeId);
            if (context == null)
            {
                return itemStack;
            }
            
            // 1個ずつアイテムを挿入し、それを返すため、1個分のアイテムを作成
            // Insert items one by one and return them, so create an item for one item
            var oneItem = ServerContext.ItemStackFactory.Create(itemStack.Id, 1);
            
            var insertResult = context.InsertNodeNetworkNextBlock(oneItem, _providerChestNodeId, _blockConnectorComponent);
            
            // アイテムが消失しないように、1個ひいたアイテムと、挿入結果のアイテムを合成して返す
            // To prevent the item from disappearing, return a composite of the item with one item subtracted and the inserted item
            var subOneItem = itemStack.SubItem(1);
            return insertResult.AddItem(subOneItem).ProcessResultItemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/CraftChainer/CraftChainerSolverTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;

namespace Tests.UnitTest.Game.CraftChainer
{
    /// <summary>
    /// 凡例 legend
    /// 
    /// recipesStr
    /// レシピ番号:アウトプットアイテム名 数量, アウトプットアイテム名 数量 ← インプットアイテム名 数量, インプットアイテム名 数量
    /// RecipeId:OutputItemName Count, OutputItemName Count ← InputItemName Count, InputItemName Count
    ///
    /// initialInventoryStr
    /// アイテム名 数量
    /// ItemName Count
    ///
    /// targetItemStr
    /// アイテム名 数量
    /// ItemName Count
    ///
    /// expectedStr
    /// レシピ番号:使用レシピ回数
    /// RecipeId:UseRecipeCount
    /// 
    /// </summary>
    public class CraftChainerSolverTest
    {
        [Test]
        public void TestCase01()
        {
            var recipesStr = @"
1:A 1 ← B 1, C 2
2:B 1 ← C 2";
            var initialInventoryStr = @"
B 1";
            var targetItem = "A 1";
            var expectedStr = @""; // 解が存在しない場合、期待される結果は空文字列
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase02()
        {
            var recipesStr = @"
1:A 1 ← B 1, C 2
2:B 1 ← C 2";
            var initialInventoryStr = @""; // 初期在庫なし
            var targetItem = "A 1";
            var expectedStr = @""; // 解が存在しない
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase03()
        {
            var recipesStr = @"
1:D 1 ← E 8
2:E 4 ← F 2
3:E 4 ← G 2";
            var initialInventoryStr = @""; // 初期在庫なし
            var targetItem = "D 1";
            var expectedStr = @""; // 解が存在しない
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase04()
        {
            var recipesStr = @"
1:A 1 ← B 2
2:A 1 ← B 4";
            var initialInventoryStr = @"
B 3";
            var targetItem = "A 1";
            var expectedStr = @"
1:1"; // レシピ1を1回使用
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase05()
        {
            var recipesStr = @"
1:A 1 ← B 3
2:B 1 ← C 2
3:B 1 ← D 2
4:D 1 ← E 1";
            var initialInventoryStr = @"
C 4
D 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:2
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase06()
        {
            var recipesStr = @"
1:A 1 ← B 2, C 2
2:C 1 ← D 1
3:B 1, C 1 ← D 3";
            var initialInventoryStr = @"
B 1
D 10";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
3:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase07()
        {
            var recipesStr = @"
1:X 1 ← Y 1, Z 1
2:Y 1 ← W 5
3:Z 1 ← W 10";
            var initialInventoryStr = @"
W 15";
            var targetItem = "X 1";
            var expectedStr = @"
1:1
2:1
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase08()
        {
            var recipesStr = @"
1:A 1 ← B 2, C 1
2:A 1 ← B 1, D 2
3:B 1 ← E 3
4:C 1 ← E 2
5:D 1 ← E 1";
            var initialInventoryStr = @"
E 10";
            var targetItem = "A 2";
            var expectedStr = @"
2:2
3:2
5:4";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase09()
        {
            var recipesStr = @"
1:A 1 ← B 10
2:B 1 ← C 5
3:C 1 ← D 2
4:D 1 ← E 1";
            var initialInventoryStr = @"
C 2
E 10";
            var targetItem = "A 1";
            var expectedStr = @""; // 解が存在しない
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase10()
        {
            var recipesStr = @"
1:A 1 ← B 1
2:B 3 ← C 2
3:C 5 ← D 1";
            var initialInventoryStr = @"
D 1";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:1
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase11()
        {
            var recipesStr = @"
1:A 1 ← B 1, C 2
2:B 1 ← D 3
3:C 1 ← D 2
4:D 1 ← E 1
5:B 1 ← F 1
6:C 1 ← G 1";
            var initialInventoryStr = @"
D 1
F 1
G 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
5:1
6:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase12()
        {
            var recipesStr = @"
1:A 1 ← B 1, C 1
2:B 1 ← C 2
3:C 1 ← E 1
4:E 1 ← B 1
5:B 1 ← D 1";
            var initialInventoryStr = @"
D 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
3:1
4:1
5:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase13()
        {
            var recipesStr = @"
1:A 1 ← B1 1, B2 1, B3 1, B4 1
2:B1 1 ← C1 1
3:B2 1 ← C2 1
4:B3 1 ← C3 1
5:B4 1 ← C4 1
6:C1 1 ← D 1
7:C2 1 ← D 1
8:C3 1 ← D 1
9:C4 1 ← D 1";
            var initialInventoryStr = @"
D 5";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:1
3:1
4:1
5:1
6:1
7:1
8:1
9:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase14()
        {
            var recipesStr = @"
1:A 1 ← B 2
2:B 1 ← C 2
3:B 1 ← D 1";
            var initialInventoryStr = @"
C 1
D 1";
            var targetItem = "A 1";
            var expectedStr = @""; // 解が存在しない
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        
        private void ExecuteTest(
            string recipesStr,
            string initialInventoryStr,
            string targetItemStr,
            string expectedStr)
        {
            var (recipes, initialInventory, targetItem, expected) = ParseInput(recipesStr, initialInventoryStr, targetItemStr, expectedStr);
            var actual = CraftChainerCraftingSolver.Solve(recipes, initialInventory, targetItem);
            
            if (expected == null)
            {
                Assert.IsNull(actual);
                return;
            }
            
            Assert.IsNotNull(actual);
            Assert.AreEqual(expected.Count, actual.Count);
            
            foreach (var kvp in expected)
            {
                Assert.IsTrue(actual.ContainsKey(kvp.Key));
                Assert.AreEqual(kvp.Value, actual[kvp.Key]);
            }
        }
        
        private (List<CraftingSolverRecipe> recipes, Dictionary<ItemId, int> initialInventory, CraftingSolverItem targetItem, Dictionary<CraftingSolverRecipeId, int> expected) ParseInput(
            string recipesStr,
            string initialInventoryStr,
            string targetItemStr,
            string expectedStr)
        {
            var recipes = ParseRecipes();
            var initialInventory = ParseInitialInventory();
            var targetItem = ParseTargetItem();
            var expected = ParseExpected();
            
            return (recipes, initialInventory, targetItem, expected);
            
            #region Internal
            
            List<CraftingSolverRecipe> ParseRecipes()
            {
                var result = new List<CraftingSolverRecipe>();
                
                var recipeLines = recipesStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x));
                foreach (var recipeLine in recipeLines)
                {
                    var recipeId = new CraftingSolverRecipeId(int.Parse(recipeLine.Split(':')[0]));
                    var inputItemsStr = recipeLine.Split(':')[1].Split('←')[1].Trim();
                    var outputItemStr = recipeLine.Split(':')[1].Split('←')[0].Trim();
                    
                    var inputItems = ParseRecipeItems(inputItemsStr);
                    var outputItems = ParseRecipeItems(outputItemStr);
                    
                    result.Add(new CraftingSolverRecipe(recipeId, inputItems, outputItems));
                }
                
                return result;
            }
            
            Dictionary<ItemId, int> ParseInitialInventory()
            {
                var result = new Dictionary<ItemId, int>();
                
                var inventoryLines = initialInventoryStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x));
                foreach (var inventoryLine in inventoryLines)
                {
                    var itemName = inventoryLine.Split(' ')[0];
                    var itemId = new ItemId(GetItemId(itemName));
                    var quantity = int.Parse(inventoryLine.Split(' ')[1]);
                    
                    result.Add(itemId, quantity);
                }
                
                return result;
            }
            
            CraftingSolverItem ParseTargetItem()
            {
                var itemName = targetItemStr.Split(' ')[0];
                var itemId = new ItemId(GetItemId(itemName));
                var quantity = int.Parse(targetItemStr.Split(' ')[1]);
                
                return new CraftingSolverItem(itemId, quantity);
            }
            
            Dictionary<CraftingSolverRecipeId, int> ParseExpected()
            {
                var result = new Dictionary<CraftingSolverRecipeId, int>();
                
                var expectedLines = expectedStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x)).ToList();
                if (expectedLines.Count == 0)
                {
                    return null;
                }
                
                foreach (var expectedLine in expectedLines)
                {
                    var recipeId = new CraftingSolverRecipeId(int.Parse(expectedLine.Split(':')[0]));
                    var quantity = int.Parse(expectedLine.Split(':')[1]);
                    
                    result.Add(recipeId, quantity);
                }
                
                return result;
            }
            
            List<CraftingSolverItem> ParseRecipeItems(string itemRecipes)
            {
                var result = new List<CraftingSolverItem>();
                foreach (var item in itemRecipes.Split(','))
                {
                    var trimItem = item.Trim();
                    var itemName = trimItem.Split(' ')[0];
                    var itemId = new ItemId(GetItemId(itemName));
                    var quantity = int.Parse(trimItem.Split(' ')[1]);
                    
                    result.Add(new CraftingSolverItem(itemId, quantity));
                }
                return result;
            }
            
  #endregion
        }
        
        private int _nextItemId = 1;
        private Dictionary<string, int> _itemNameToId = new();
        
        private int GetItemId(string itemName)
        {
            // アイテム名をユニークなIDにマッピングするメソッド
            // ここでは簡単のために静的な辞書を使用
            if (!_itemNameToId.TryGetValue(itemName, out var itemId))
            {
                itemId = _nextItemId++;
                _itemNameToId[itemName] = itemId;
            }
            return itemId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerNetworkContext.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.BlockComponent.ProviderChest;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using UnityEngine;

namespace Game.CraftChainer.BlockComponent.Computer
{
    public class CraftChainerNetworkContext
    {
        // チェインネットワークに関する情報
        // Information about the chain network
        public IReadOnlyList<CraftChainerProviderChestComponent> ProviderChests => _providerChests;
        private readonly List<CraftChainerProviderChestComponent> _providerChests = new();
        public IReadOnlyList<CraftCraftChainerCrafterComponent> CrafterComponents => _crafterComponents;
        private readonly List<CraftCraftChainerCrafterComponent> _crafterComponents = new();
        private readonly Dictionary<CraftChainerNodeId, ICraftChainerNode> _nodes = new();
        
        // このコンテキストを保持するメインコンピューターの情報
        // Information about the main computer that holds this context
        private readonly BlockConnectorComponent<IBlockInventory> _mainComputerConnector; 
        private readonly ICraftChainerNode _mainComputerNode;
        
        // 現在クラフト中のアイテム情報
        // Information about the item currently being crafted
        private readonly Dictionary<ItemInstanceId,CraftChainerNodeId> _requestedMoveItems = new();
        // アイテムごとにどのノードに何個アイテムを入れなければならないか
        // How many items of each item type must be placed in each node?
        private Dictionary<ItemId,Dictionary<CraftChainerNodeId,int>> _craftChainRecipeQue;
        
        public CraftChainerNetworkContext(BlockConnectorComponent<IBlockInventory> mainComputerConnector, ICraftChainerNode mainComputerNode)
        {
            _mainComputerConnector = mainComputerConnector;
            _mainComputerNode = mainComputerNode;
        }
        
        public bool IsExistNode(CraftChainerNodeId nodeId)
        {
            return _nodes.ContainsKey(nodeId);
        }
        
        public void SetCraftChainRecipeQue(Dictionary<CraftingSolverRecipeId, int> solvedResults, CraftingSolverItem targetItem)
        {
            var craftRecipeIdMap = GetCraftRecipeIdMap();
            
            _craftChainRecipeQue = CreateRecipeQue(solvedResults, craftRecipeIdMap);
            // ターゲットのアイテムをコンピューターに移動するようにリクエストを追加しておく
            _craftChainRecipeQue.Add(targetItem.ItemId, new Dictionary<CraftChainerNodeId, int> {{_mainComputerNode.NodeId, targetItem.Count}});
            
            #region Internal
            
            Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent> GetCraftRecipeIdMap()
            {
                var map = new Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent>();
                foreach (var crafter in _crafterComponents)
                {
                    var recipeId = crafter.CraftingSolverRecipe.CraftingSolverRecipeId;
                    if (recipeId != CraftingSolverRecipeId.InvalidId)
                    {
                        map[recipeId] = crafter;
                    }
                }
                return map;
            }
            
            Dictionary<ItemId, Dictionary<CraftChainerNodeId,int>> CreateRecipeQue(Dictionary<CraftingSolverRecipeId, int> solved, Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent> recipes)
            {
                var result = new Dictionary<ItemId, Dictionary<CraftChainerNodeId,int>>();
                foreach (var solvedResult in solved)
                {
                    var crafter = recipes[solvedResult.Key];
                    var recipe = crafter.CraftingSolverRecipe;
                    foreach (var inputItems in recipe.Inputs)
                    {
                        var count = inputItems.Count * solvedResult.Value;
                        if (result.TryGetValue(inputItems.ItemId, out var que))
                        {
                            if (!que.TryAdd(crafter.NodeId,count))
                            {
                                que[crafter.NodeId] += count;
                            }
                        }
                        else
                        {
                            result[inputItems.ItemId] = new Dictionary<CraftChainerNodeId, int>()
                            {
                                { crafter.NodeId, count }
                            };
                        }
                    }
                }
                
                return result;
            }
            
            #endregion
        }
        
        /// <summary>
        /// クラフトチェインのネットワークを再検索する
        /// Re-search the network of the craft chain
        /// </summary>
        public void ReSearchNetwork()
        {
            _providerChests.Clear();
            _nodes.Clear();
            
            _nodes.Add(_mainComputerNode.NodeId, _mainComputerNode);
            
            // 単純に深さ優先探索で探索し、途中にあったチェストをリストに追加
            // Simply search by depth-first search and add the chests found on the way to the list
            Search(_mainComputerConnector);
            
            #region Internal
            
            void Search(BlockConnectorComponent<IBlockInventory> connector)
            {
                foreach (var connectedTarget in connector.ConnectedTargets)
                {
                    var targetBlock = connectedTarget.Value.TargetBlock;
                    if (!targetBlock.TryGetComponent<ICraftChainerNode>(out var node))
                    {
                        continue;
                    }
                    if (!_nodes.TryAdd(node.NodeId, node))
                    {
                        continue;
                    }
                    
                    if (targetBlock.TryGetComponent<CraftChainerProviderChestComponent>(out var chest))
                    {
                        _providerChests.Add(chest);
                    }
                    if (targetBlock.TryGetComponent<CraftCraftChainerCrafterComponent>(out var crafter))
                    {
                        _crafterComponents.Add(crafter);
                    }
                    if (targetBlock.TryGetComponent<BlockConnectorComponent<IBlockInventory>>(out var nextConnector))
                    {
                        Search(nextConnector);
                    }
                }
            }
            
            #endregion
        }
        
        /// <summary>
        /// アイテムのIDとつながっているコネクターから、次にインサートすべきブロックを取得し、インサート出来る場合はインサートする
        /// Get the next block to insert from the item ID and connected connector, and insert it if possible
        /// </summary>
        public IItemStack InsertNodeNetworkNextBlock(IItemStack item, CraftChainerNodeId startChainerNodeId, BlockConnectorComponent<IBlockInventory> blockConnector)
        {
            if (item.Id == ItemMaster.EmptyItemId) return item;
            
            // ターゲットとなるノードがあるか
            var targetNodeId = GetTargetNodeId(item);
            if (targetNodeId == CraftChainerNodeId.Invalid)
            {
                return item;
            }
            
            // たどり着けるか
            var result = ExecuteBfs(targetNodeId);
            if (result == null || result.Count == 0)
            {
                return item;
            }
            
            // 次のインベントリにアイテムを入れられるか
            var nextInventory = result[0].Item2;
            if (!nextInventory.InsertionCheck(new List<IItemStack> {item}))
            {
                return item;
            }
            
            // アイテムを入れられるのでキューの情報を更新する
            DebugExportCraftChainRecipeQueLog();
            UpdateCraftQue();
            
            // 次のインベントリにアイテムを入れる
            return nextInventory.InsertItem(item);
            
            #region Internal
            
            CraftChainerNodeId GetTargetNodeId(IItemStack item)
            {
                // 移動先が既に指定されている場合はそのまま返す
                // If the destination is already specified, return it as it is
                if (_requestedMoveItems.TryGetValue(item.ItemInstanceId, out var nodeId))
                {
                    return nodeId;
                }
                
                // 現在のアイテムがクラフト対象の材料かどうかをチェック
                // Check if the current item is a crafting target material
                if (!_craftChainRecipeQue.TryGetValue(item.Id, out var craftQue))
                {
                    return CraftChainerNodeId.Invalid;
                }
                
                // クラフト対象の材料なのでそのうちの一つを取得
                // It is a crafting target material, so get one of them
                foreach (var nodeReminder in craftQue)
                {
                    return nodeReminder.Key;
                }
                
                // 移動先が特に指定されていない場合はInvalidを返す
                // If no destination is specified, return Invalid
                return CraftChainerNodeId.Invalid;
            }
            
            List<(CraftChainerNodeId,IBlockInventory)> ExecuteBfs(CraftChainerNodeId targetNode)
            {
                var idToConnector = new Dictionary<CraftChainerNodeId, (BlockConnectorComponent<IBlockInventory> connector, IBlockInventory blockInventory)>();
                var searchQueue = new Queue<CraftChainerNodeId>();
                var searched = new HashSet<CraftChainerNodeId>();
                var reverseSearch = new Dictionary<CraftChainerNodeId, CraftChainerNodeId>();
                var stepLog = new Dictionary<CraftChainerNodeId, int>();
                var isFound = false;
                
                searchQueue.Enqueue(startChainerNodeId);
                searched.Add(startChainerNodeId);
                idToConnector[startChainerNodeId] = (blockConnector, null);
                stepLog[startChainerNodeId] = 0;
                
                // キューがなくなるまでループ
                // Loop until the queue is empty
                while (0 < searchQueue.Count)
                {
                    var searchingId = searchQueue.Dequeue();
                    if (searchingId == targetNode)
                    {
                        isFound = true;
                        break;
                    }
                    
                    var step = stepLog[searchingId] + 1;
                    foreach (var connectedTarget in idToConnector[searchingId].connector.ConnectedTargets)
                    {
                        var targetBlock = connectedTarget.Value.TargetBlock;
                        var next = GetNext(targetBlock);
                        
                        // 接続先がChainerNodeではないので無視
                        // Ignore if the connection destination is not a ChainerNode
                        if (!next.HasValue) continue;
                        
                        var (nodeId, nextConnector, blockInventory) = next.Value;
                        
                        // すでに探索済みの場合は無視
                        // Ignore if already searched
                        if (searched.Contains(nodeId)) continue;
                        
                        searched.Add(nodeId); // Mark as searched before enqueuing
                        reverseSearch[nodeId] = searchingId;
                        idToConnector[nodeId] = (nextConnector, blockInventory);
                        stepLog[nodeId] = step;
                        searchQueue.Enqueue(nodeId);
                    }
                }
                
                if (!isFound)
                {
                    return null;
                }
                
                // 経路をたどっていく
                // Follow the path
                var result = new List<(CraftChainerNodeId,IBlockInventory)>();
                var current = targetNode;
                while (current != startChainerNodeId)
                {
                    result.Add((current,idToConnector[current].blockInventory));
                    current = reverseSearch[current];
                }
                
                result.Reverse();
                return result;
            }
            
            (CraftChainerNodeId nodeId, BlockConnectorComponent<IBlockInventory> connector, IBlockInventory blockInventory)? GetNext(IBlock block)
            {
                if (!block.TryGetComponent<ICraftChainerNode>(out var node)) return null;
                if (node.NodeId == startChainerNodeId) return null;
                if (!block.TryGetComponent<BlockConnectorComponent<IBlockInventory>>(out var connector)) return null;
                if (!block.TryGetComponent<IBlockInventory>(out var inventory)) return null;
                
                return (node.NodeId, connector, inventory);
            }
            
            void UpdateCraftQue()
            {
                // 新しく挿入されたアイテムのみ更新を行うので、既に移動先が指定されているアイテムは無視
                // Only newly inserted items are updated, so items that already have a destination specified are ignored
                if (_requestedMoveItems.ContainsKey(item.ItemInstanceId))
                {
                    return;
                }
                
                // クラフトキューの情報をアップデート
                // Update the craft queue information
                var craftQue = _craftChainRecipeQue[item.Id];
                var reminder = craftQue[targetNodeId];
                reminder--;
                if (reminder <= 0)
                {
                    craftQue.Remove(targetNodeId);
                }
                else
                {
                    craftQue[targetNodeId] = reminder;
                }
                
                // 計算したアイテムの移動先を保持
                // Keep the destination of the calculated item
                _requestedMoveItems[item.ItemInstanceId] = targetNodeId;
            }
            
            void DebugExportCraftChainRecipeQueLog()
            {
                // 使う場合はこのreturnを取る
                // If you want to use it, remove this return
                return;
                
                var str = "";
                
                foreach (var ques in _craftChainRecipeQue)
                {
                    foreach (var que in ques.Value)
                    {
                        var crafter = _crafterComponents.Find(c => c.NodeId == que.Key);
                        if (crafter != null)
                        {
                            var outputId = crafter.CraftingSolverRecipe.Outputs[0].ItemId;
                            var outItemName = MasterHolder.ItemMaster.GetItemMaster(outputId).Name;
                            var itemName = MasterHolder.ItemMaster.GetItemMaster(ques.Key).Name;
                            
                            str += $"Id {itemName} Count {que.Value} Output {outItemName},  ";
                        }
                    }
                }
                
                Debug.Log(str);
            }
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/OneClickCraftProtocolTest.cs
```cs
using System.Linq;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.OneClickCraft;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class OneClickCraftProtocolTest
    {
        private const int PlayerId = 0;
        private const int CraftRecipeId = 1;
        
        [Test]
        public void CanNotCraftTest()
        {
            //アイテムがないときにクラフトできないかのテスト
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Id.AsPrimitive());
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void CanCraftTest()
        {
            //アイテムがあるときにクラフトできるかのテスト
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            //必要なアイテムをインベントリに追加
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = ServerContext.ItemStackFactory.Create(info.ItemGuid, info.Count);
                playerInventoryData.MainOpenableInventory.SetItem(i, item);
            }
            
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            var resultItemGuid = MasterHolder.ItemMaster.GetItemId(craftElement.CraftResultItemGuid);
            Assert.AreEqual(resultItemGuid, playerInventoryData.MainOpenableInventory.GetItem(slot).Id);
            Assert.AreEqual(craftElement.CraftResultCount, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void CanNotOneItemIsMissingTest()
        {
            //アイテムが一つ足りないときにクラフトできないかのテスト
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            //必要なアイテムをインベントリに追加
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = ServerContext.ItemStackFactory.Create(info.ItemGuid, info.Count);
                playerInventoryData.MainOpenableInventory.SetItem(i, item);
            }
            
            //一つのアイテムを消費
            var oneSubItem = playerInventoryData.MainOpenableInventory.GetItem(0).SubItem(1);
            playerInventoryData.MainOpenableInventory.SetItem(0, oneSubItem);
            
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            //アイテムがクラフトされていないことをテスト
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Id.AsPrimitive());
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void ItemFullToCanNotCraftTest()
        {
            //グラブインベントリのアイテムが満杯の時にクラフトできないテスト
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInv = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var itemStackFactory = ServerContext.ItemStackFactory;
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            
            //不要なアテムを追加
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var item = itemStackFactory.Create(new ItemId(10), 100);
                playerInv.MainOpenableInventory.SetItem(i, item);
            }
            
            
            //必要なアイテムをインベントリに追加
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = itemStackFactory.Create(info.ItemGuid, info.Count);
                playerInv.MainOpenableInventory.SetItem(i, item);
            }
            
            
            //クラフト実行
            var craftGuid = craftElement.CraftRecipeGuid;
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftGuid)).ToList());
            
            //アイテムが維持されていることをテスト
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var itemId = MasterHolder.ItemMaster.GetItemId(info.ItemGuid);
                Assert.AreEqual(itemId, playerInv.MainOpenableInventory.GetItem(i).Id.AsPrimitive());
                Assert.AreEqual(info.Count, playerInv.MainOpenableInventory.GetItem(i).Count);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerCrafterSaveLoadTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerCrafterSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);

            // クラフターを作成
            // Create a Crafter block
            var crafterBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerCrafter, new BlockInstanceId(1), posInfo);

            // レシピを設定
            // Set the recipe
            var originalCrafter = crafterBlock.GetComponent<CraftCraftChainerCrafterComponent>();
            var inputItems = new List<CraftingSolverItem>
            {
                new(new ItemId(1), 10),
                new(new ItemId(2), 5)
            };

            var outputItems = new List<CraftingSolverItem>
            {
                new(new ItemId(3), 15)
            };

            originalCrafter.SetRecipe(inputItems, outputItems);
            
            // セーブデータを取得
            // Get the save data
            var saveState = crafterBlock.GetSaveState();
            
            // ブロックをロード
            // Load the block
            var loadedBlock = blockFactory.Load( crafterBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedCrafterComponent = loadedBlock.GetComponent<CraftCraftChainerCrafterComponent>();

            // ノードIDのチェック
            // Check the node ID
            Assert.AreEqual(originalCrafter.NodeId, loadedCrafterComponent.NodeId);

            // レシピの設定をチェック
            // Check the recipe settings
            Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs.Count, loadedCrafterComponent.CraftingSolverRecipe.Inputs.Count);
            Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs.Count, loadedCrafterComponent.CraftingSolverRecipe.Outputs.Count);

            for (int i = 0; i < originalCrafter.CraftingSolverRecipe.Inputs.Count; i++)
            {
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs[i].ItemId, loadedCrafterComponent.CraftingSolverRecipe.Inputs[i].ItemId);
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs[i].Count, loadedCrafterComponent.CraftingSolverRecipe.Inputs[i].Count);
            }

            for (int i = 0; i < originalCrafter.CraftingSolverRecipe.Outputs.Count; i++)
            {
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs[i].ItemId, loadedCrafterComponent.CraftingSolverRecipe.Outputs[i].ItemId);
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs[i].Count, loadedCrafterComponent.CraftingSolverRecipe.Outputs[i].Count);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;

namespace Game.CraftChainer.BlockComponent.Computer
{
    /// <summary>
    /// メインコンピューターはアイテムを外に出さないので、そのためのクラス
    /// The main computer does not take items out, so this class is for that
    /// </summary>
    public class CraftChainerMainComputerInserter : IBlockInventoryInserter
    {
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return itemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerComponent.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using Newtonsoft.Json;

namespace Game.CraftChainer.BlockComponent.Computer
{
    public class CraftChainerMainComputerComponent : ICraftChainerNode
    {
        public readonly CraftChainerNetworkContext CraftChainerNetworkContext;
        
        public CraftChainerNodeId NodeId { get; } = CraftChainerNodeId.Create();
        
        public CraftChainerMainComputerComponent(BlockConnectorComponent<IBlockInventory> mainComputerConnector)
        {
            CraftChainerNetworkContext = new CraftChainerNetworkContext(mainComputerConnector, this);
        }
        
        public CraftChainerMainComputerComponent(Dictionary<string, string> componentStates, BlockConnectorComponent<IBlockInventory> mainComputerConnector) : this(mainComputerConnector)
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerMainComputerComponentJsonObject>(state);
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        /// <summary>
        /// アイテムのクラフトをリクエストする
        /// Request to create an item
        /// </summary>
        /// <returns>
        /// クラフトリクエストが成功したかどうか
        /// Whether the craft request was successful
        /// </returns>
        public bool StartCreateItem(ItemId itemId, int count)
        {
            var (recipes, initialInventory, targetItem) = CreateInitialData();
            
            var solverResult = CraftChainerCraftingSolver.Solve(recipes, initialInventory, targetItem);
            
            // アイテムは作成できなかった
            // The item could not be created
            if (solverResult == null)
            {
                return false;
            }
            
            CraftChainerNetworkContext.SetCraftChainRecipeQue(solverResult, targetItem);
            return true;
            
            #region Internal
            
            (List<CraftingSolverRecipe> recipes, Dictionary<ItemId, int> initialInventory, CraftingSolverItem targetItem) CreateInitialData()
            {
                var recipeResults = new List<CraftingSolverRecipe>();
                foreach (var crafterComponent in CraftChainerNetworkContext.CrafterComponents)
                {
                    recipeResults.Add(crafterComponent.CraftingSolverRecipe);
                }
                
                var initialInventoryResults = new Dictionary<ItemId, int>();
                foreach (var chest in CraftChainerNetworkContext.ProviderChests)
                {
                    foreach (var item in chest.Inventory)
                    {
                        if (initialInventoryResults.ContainsKey(item.Id))
                        {
                            initialInventoryResults[item.Id] += item.Count;
                        }
                        else
                        {
                            initialInventoryResults[item.Id] = item.Count;
                        }
                    }
                }
                
                var target = new CraftingSolverItem(itemId, count);
                
                return (recipeResults, initialInventoryResults, target);
            }
            
  #endregion
        }
        
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        public string SaveKey { get; } = typeof(CraftChainerMainComputerComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerMainComputerComponentJsonObject(this));
        }
    }
    
    public class ChainerMainComputerComponentJsonObject
    {
        [JsonProperty("nodeId")] public int NodeId { get; set; }
        
        public ChainerMainComputerComponentJsonObject(){}
        public ChainerMainComputerComponentJsonObject(CraftChainerMainComputerComponent component)
        {
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetCraftChainerCrafterRecipeProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SetCraftChainerCrafterRecipeProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:setChainerRecipe";
        
        public SetCraftChainerCrafterRecipeProtocol(ServiceProvider serviceProvider) { }
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SetCraftChainerCrafterRecipeProtocolMessagePack>(payload.ToArray());
            
            var blockPos = data.BlockPos.Vector3Int;
            
            var crafterBlock = ServerContext.WorldBlockDatastore.GetBlock(blockPos);
            if (crafterBlock == null) return null;
            
            var chainerCrafter = crafterBlock.ComponentManager.GetComponent<CraftCraftChainerCrafterComponent>();
            
            var inputs = data.GetInputs();
            var outputs = data.GetOutputs();
            chainerCrafter.SetRecipe(inputs, outputs);
            
            return null;
        }
        
        [MessagePackObject]
        public class SetCraftChainerCrafterRecipeProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            [Key(3)] public List<CraftingSolverItemJsonObjectMessagePack> Inputs { get; set; }
            [Key(4)] public List<CraftingSolverItemJsonObjectMessagePack> Outputs { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public SetCraftChainerCrafterRecipeProtocolMessagePack() { }
            
            public SetCraftChainerCrafterRecipeProtocolMessagePack(Vector3Int blockPos, List<CraftingSolverItem> inputs, List<CraftingSolverItem> outputs)
            {
                Tag = ProtocolTag;
                BlockPos = new Vector3IntMessagePack(blockPos);
                Inputs = inputs.Select(item => new CraftingSolverItemJsonObjectMessagePack(item)).ToList();
                Outputs = outputs.Select(item => new CraftingSolverItemJsonObjectMessagePack(item)).ToList();
            }
            
            public List<CraftingSolverItem> GetInputs()
            {
                return Inputs.Select(item => item.ToCraftingSolverItem()).ToList();
            }
            public List<CraftingSolverItem> GetOutputs()
            {
                return Outputs.Select(item => item.ToCraftingSolverItem()).ToList();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/CraftChainerTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.CraftChainer.BlockComponent;
using Game.CraftChainer.BlockComponent.Computer;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Tests.Module.TestMod.ForUnitTestModBlockId;

namespace Tests.CombinedTest.Game
{
    public class CraftChainerTest
    {
        public ItemId ItemAId;
        public ItemId ItemBId;
        public ItemId ItemCId;
        
        [SetUp]
        public void SetupCraftChainerTest()
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            Guid itemAGuid = new("189672cb-6811-4080-bde1-1f9ff0ec63ff");
            Guid itemBGuid = new("547791fe-bfd8-4748-aafa-c7449391eca5");
            Guid itemCGuid = new("c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627");
            ItemAId = MasterHolder.ItemMaster.GetItemId(itemAGuid);
            ItemBId = MasterHolder.ItemMaster.GetItemId(itemBGuid);
            ItemCId = MasterHolder.ItemMaster.GetItemId(itemCGuid);
        }
        
        [Test]
        public void CreateItemA1ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 5),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 1, true);
        }
        
        [Test]
        public void CreateItemA2ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 10),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 2, true);
        }
        
        [Test]
        public void CreateItemA3ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 15),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 3, true);
        }
        
        [Test]
        public void CreateItemBTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 2),
            };
            ExecuteChainerCraftTest(chestItems, ItemBId, 1, true);
        }
        
        [Test]
        public void NoneItemFailCraftTest()
        {
            ExecuteChainerCraftTest(new List<(ItemId id,int count)>(), ItemAId, 1, false);
        }
        
        [Test]
        public void OneItemIsNotEnoughFailCraftTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 4),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 1, false);
        }
        
        public void ExecuteChainerCraftTest(List<(ItemId id,int count)> materials, ItemId targetId, int targetCount, bool isSuccess)
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            // ネットワークの作成
            // Create a network
            var network = CreateNetwork();
            
            // 供給チェストにアイテム設定
            // Set items in the provider chest
            var materialItemStacks = new List<IItemStack>();
            foreach (var (id, count) in materials)
            {
                var item = ServerContext.ItemStackFactory.Create(id, count);
                materialItemStacks.Add(item);
            }
            network.SetProviderChestItem(materialItemStacks);
            
            // メインコンピュータにアイテム作成リクエスト
            // Item creation request to the main computer
            var success = network.SetRequestMainComputer(targetId, targetCount);
            Assert.AreEqual(isSuccess, success);
            
            // 失敗が正しい場合はテストを終了
            if (!isSuccess)
            {
                return;
            }
            
            // 10秒たってもクラフトされない場合は失敗
            // Fail if not crafted after 10 seconds
            var now = DateTime.Now;
            
            while (true)
            {
                try
                {
                    GameUpdater.UpdateWithWait();
                }
                catch (Exception e)
                {
                    ExportItemLog();
                    Debug.LogException(e);
                    throw;
                }
                
                if (network.OnMainComputerItemExist(targetId, targetCount))
                {
                    Debug.Log("Success Time:" + (DateTime.Now - now).TotalSeconds);
                    Assert.Pass();
                    break;
                }
                
                if (DateTime.Now - now > TimeSpan.FromSeconds(10))
                {
                    ExportItemLog();
                    var block = ServerContext.WorldBlockDatastore.GetBlock(new Vector3Int(2, 0, 1));
                    Assert.Fail("Failed to create item");
                }
            }
        }
        
        
        private void ExportItemLog()
        {
            foreach (var blocks in ServerContext.WorldBlockDatastore.BlockMasterDictionary.Values)
            {
                if (!blocks.Block.ComponentManager.TryGetComponent<IBlockInventory>(out var blockComponent))
                {
                    continue;
                }
                
                var slotSize = blockComponent.GetSlotSize();
                for (int i = 0; i < slotSize; i++)
                {
                    var item = blockComponent.GetItem(i);
                    if (item.Id == ItemMaster.EmptyItemId)
                    {
                        continue;
                    }
                    
                    var pos = blocks.BlockPositionInfo.OriginalPos;
                    var type = blocks.Block.BlockMasterElement.BlockType;
                    var itemName = MasterHolder.ItemMaster.GetItemMaster(item.Id).Name;
                    Debug.Log($"Type:{type} {pos} Slot:{i}, ItemName: \"{itemName}\" Count: {item.Count}");
                }
            }
        }
        
        private CraftChainerTestNetworkContainer CreateNetwork()
        {
            //イメージ図
            // Image diagram
            // https://miro.com/app/board/uXjVOPclBmk=/?moveToWidget=3458764607209547942&cot=10

            // クラフトチェイナーの部分
            // Parts of the craft chainer
            AddBlock(CraftChainerTransporter, 1, 0, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 0, 1, BlockDirection.South);
            AddBlock(CraftChainerTransporter, 1, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 2, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 3, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 3, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 4, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 4, 0, BlockDirection.South);
            AddBlock(CraftChainerTransporter, 4, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 3, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 2, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 1, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 0, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, -1, -1, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 0, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 1, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 2, BlockDirection.East);
            var providerChest = AddBlock(CraftChainerProviderChest, 0, 2, BlockDirection.North);
            var crafter1 = AddBlock(CraftChainerCrafter, 2, 2, BlockDirection.North); // C -> B
            var crafter2 = AddBlock(CraftChainerCrafter, 4, 2, BlockDirection.North); // B + C -> A
            var mainComputer = AddBlock(CraftChainerMainComputer, 0, 0, BlockDirection.North);
            
            // 工場の部分
            // Parts of the factory
            AddBlock(CraftChainerBeltConveyor, 2, 3, BlockDirection.North);
            AddBlock(CraftChainerBeltConveyor, 4, 3, BlockDirection.North);
            
            AddBlock(CraftChainerBeltConveyor, 0, 5, BlockDirection.South);
            AddBlock(CraftChainerBeltConveyor, 1, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 2, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 3, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 4, 5, BlockDirection.West);
            
            AddBlock(CraftChainerBeltConveyor, 0, 4, BlockDirection.South);
            AddBlock(CraftChainerBeltConveyor, 0, 3, BlockDirection.South);
            AddBlock(CraftChainerMachine1, 2, 4, BlockDirection.North); // C -> B
            AddBlock(CraftChainerMachine2, 4, 4, BlockDirection.North); // B + C -> A
            
            var container = new CraftChainerTestNetworkContainer(mainComputer, crafter1, crafter2, providerChest);
            
            // レシピの設定
            // Recipe setting
            var inputItem1 = new List<CraftingSolverItem>
            {
                new(ItemCId, 2),
            };
            var outputItem1 = new List<CraftingSolverItem>
            {
                new(ItemBId, 1),
            };
            container.SetCrafter1Recipe(inputItem1, outputItem1);
            
            var inputItem2 = new List<CraftingSolverItem>
            {
                new(ItemBId, 2),
                new(ItemCId, 1),
            };
            var outputItem2 = new List<CraftingSolverItem>
            {
                new(ItemAId, 1),
            };
            container.SetCrafter2Recipe(inputItem2, outputItem2);
            
            // assert chain network
            var computerComputer = mainComputer.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
            Assert.AreEqual(computerComputer.CraftChainerNetworkContext.CrafterComponents.Count, 2);
            Assert.AreEqual(computerComputer.CraftChainerNetworkContext.ProviderChests.Count, 1);
            
            
            return container;
        }
        
        private IBlock AddBlock(BlockId blockId, int x, int z, BlockDirection direction)
        {
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            worldBlockDatastore.TryAddBlock(blockId, new Vector3Int(x, 0, z), direction, out var block);
            
            return block;
        }
        
        public class CraftChainerTestNetworkContainer
        {
            public readonly IBlock MainComputer;
            public readonly IBlock Crafter1;
            public readonly IBlock Crafter2;
            public readonly IBlock ProviderChest;
            public CraftChainerTestNetworkContainer(IBlock mainComputer, IBlock crafter1, IBlock crafter2, IBlock providerChest)
            {
                MainComputer = mainComputer;
                Crafter1 = crafter1;
                Crafter2 = crafter2;
                ProviderChest = providerChest;
            }
            
            public void SetCrafter1Recipe(List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                SetCrafterRecipe(Crafter1, inputItems, outputItem);
            }
            public void SetCrafter2Recipe(List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                SetCrafterRecipe(Crafter2, inputItems, outputItem);
            }
            
            private void SetCrafterRecipe(IBlock crafter, List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                var crafterComponent = crafter.ComponentManager.GetComponent<CraftCraftChainerCrafterComponent>();
                crafterComponent.SetRecipe(inputItems, outputItem);
            }
            
            public void SetProviderChestItem(List<IItemStack> items)
            {
                var chestComponent = ProviderChest.ComponentManager.GetComponent<VanillaChestComponent>();
                chestComponent.InsertItem(items);
            }
            
            public bool SetRequestMainComputer(ItemId item, int count)
            {
                var mainComputerComponent = MainComputer.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
                return mainComputerComponent.StartCreateItem(item, count);
            }
            
            public bool OnMainComputerItemExist(ItemId targetItem, int count)
            {
                var chest = MainComputer.ComponentManager.GetComponent<VanillaChestComponent>();
                
                var existCount = 0;
                foreach (var item in chest.InventoryItems)
                {
                    if (item.Id == targetItem)
                    {
                        existCount += item.Count;
                    }
                }
                
                return existCount >= count;
            }
        }
    }
    
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetCraftChainerMainComputerRequestItemProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using Game.CraftChainer.BlockComponent.Crafter;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SetCraftChainerMainComputerRequestItemProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:setReuqestComputer";
        
        public SetCraftChainerMainComputerRequestItemProtocol(ServiceProvider serviceProvider) { }
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SetCraftChainerMainComputerRequestItemProtocolMessagePack>(payload.ToArray());
            
            var blockPos = data.BlockPos.Vector3Int;
            
            var crafterBlock = ServerContext.WorldBlockDatastore.GetBlock(blockPos);
            if (crafterBlock == null) return null;
            
            var itemId = data.ItemId;
            var count = data.Count;
            var computerComponent = crafterBlock.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
            computerComponent.StartCreateItem(itemId, count);
            
            return null;
        }
        
        [MessagePackObject]
        public class SetCraftChainerMainComputerRequestItemProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            [Key(3)] public int ItemIdInt { get; set; }
            [IgnoreMember] public ItemId ItemId => new(ItemIdInt);
            [Key(4)] public int Count { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public SetCraftChainerMainComputerRequestItemProtocolMessagePack() { }
            
            public SetCraftChainerMainComputerRequestItemProtocolMessagePack(Vector3Int blockPos, ItemId itemId, int count)
            {
                Tag = ProtocolTag;
                BlockPos = new Vector3IntMessagePack(blockPos);
                ItemIdInt = itemId.AsPrimitive();
                Count = count;
            }
        }
    }
}
```


# Instructions
CraftChainerTestのレシピの設定とコンピューターへのリクエストを、メソッドの呼び出しではなく、SetCraftChainerCrafterRecipeProtocolとSetCraftChainerMainComputerRequestItemProtocolを経由して呼び出すように変更をしてください