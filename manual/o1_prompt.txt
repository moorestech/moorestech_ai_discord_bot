moorestech_server/Assets/Scripts/Game.Gear/Common/GearNetworkDatastore.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Update;
using Game.Block.Interface;
using UniRx;
using Random = System.Random;

namespace Game.Gear.Common
{
    public class GearNetworkDatastore
    {
        // TODO これってなんでstaticにしたんだっけ？こういうのは全般的にサービスロケーターにしたほうが良いような気がしてきた
        private static GearNetworkDatastore _instance;
        
        private readonly Dictionary<BlockInstanceId, GearNetwork> _blockEntityToGearNetwork; // key ブロックのEntityId value そのブロックが所属するNW
        private readonly Dictionary<GearNetworkId, GearNetwork> _gearNetworks = new();
        private readonly Random _random = new(215180);
        
        public GearNetworkDatastore()
        {
            _instance = this;
            _blockEntityToGearNetwork = new Dictionary<BlockInstanceId, GearNetwork>();
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        public IReadOnlyDictionary<GearNetworkId, GearNetwork> GearNetworks => _gearNetworks;
        
        public static void AddGear(IGearEnergyTransformer gear)
        {
            _instance.AddGearInternal(gear);
        }
        
        private void AddGearInternal(IGearEnergyTransformer gear)
        {
            var connectedNetworkIds = new HashSet<GearNetworkId>();
            foreach (var connectedGear in gear.GetGearConnects())
                //新しく設置された歯車に接続している歯車は、すべて既存のNWに接続している前提
                if (_blockEntityToGearNetwork.ContainsKey(connectedGear.Transformer.BlockInstanceId))
                {
                    var networkId = _blockEntityToGearNetwork[connectedGear.Transformer.BlockInstanceId].NetworkId;
                    connectedNetworkIds.Add(networkId);
                }
            
            //接続しているNWが1つもない場合は新規NWを作成
            switch (connectedNetworkIds.Count)
            {
                case 0:
                    CreateNetwork();
                    break;
                case 1:
                    ConnectNetwork();
                    break;
                default:
                    MergeNetworks();
                    break;
            }
            
            #region Internal
            
            void CreateNetwork()
            {
                var networkId = GearNetworkId.CreateNetworkId();
                var network = new GearNetwork(networkId);
                network.AddGear(gear);
                _blockEntityToGearNetwork.Add(gear.BlockInstanceId, network);
                _gearNetworks.Add(networkId, network);
            }
            
            void ConnectNetwork()
            {
                var networkId = connectedNetworkIds.First();
                var network = _gearNetworks[networkId];
                network.AddGear(gear);
                _blockEntityToGearNetwork.Add(gear.BlockInstanceId, network);
            }
            
            void MergeNetworks()
            {
                // マージのために歯車を取得
                var transformers = new List<IGearEnergyTransformer>();
                var generators = new List<IGearGenerator>();
                
                foreach (var networkId in connectedNetworkIds.ToList())
                {
                    var network = _gearNetworks[networkId];
                    transformers.AddRange(network.GearTransformers);
                    generators.AddRange(network.GearGenerators);
                    _gearNetworks.Remove(networkId);
                }
                
                var newNetworkId = GearNetworkId.CreateNetworkId();
                var newNetwork = new GearNetwork(newNetworkId);
                
                foreach (var transformer in transformers) newNetwork.AddGear(transformer);
                foreach (var generator in generators) newNetwork.AddGear(generator);
                
                transformers.Add(gear);
                newNetwork.AddGear(gear);
                _blockEntityToGearNetwork[gear.BlockInstanceId] = newNetwork;
                
                // マージしたNWに所属する歯車のNWを更新
                for (var i = 0; i < _blockEntityToGearNetwork.Keys.Count; i++)
                {
                    var pair = _blockEntityToGearNetwork.ElementAt(i);
                    if (connectedNetworkIds.Contains(pair.Value.NetworkId)) _blockEntityToGearNetwork[pair.Key] = newNetwork;
                }
                
                _gearNetworks.Add(newNetworkId, newNetwork);
                foreach (var removeNetworkId in connectedNetworkIds) _gearNetworks.Remove(removeNetworkId);
            }
            
            #endregion
        }
        
        public static void RemoveGear(IGearEnergyTransformer gear)
        {
            // 自身をnetworkから削除
            var network = _instance._blockEntityToGearNetwork[gear.BlockInstanceId];
            network.RemoveGear(gear);
            _instance._blockEntityToGearNetwork.Remove(gear.BlockInstanceId);
            
            //削除する歯車以外の元々接続していたブロックをすべて取得
            var transformers = new List<IGearEnergyTransformer>();
            transformers.AddRange(network.GearTransformers);
            transformers.AddRange(network.GearGenerators);
            
            //接続していた歯車ネットワークをデータベースから破棄
            _instance._gearNetworks.Remove(network.NetworkId);
            
            //gearに接続されている全てのgearをblockEntityToGearNetworkから削除
            foreach (var transformer in transformers)
            {
                _instance._blockEntityToGearNetwork.Remove(transformer.BlockInstanceId);
            }
            
            // 歯車を再追加する。重くなったらアルゴリズムを変える。
            foreach (var transformer in transformers) AddGear(transformer);
        }
        
        private void Update()
        {
            foreach (var gearNetwork in _gearNetworks.Values) // TODO パフォーマンスがやばくなったらやめる
                gearNetwork.ManualUpdate();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlacePreview.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Mooresmaster.Model.BlocksModule;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPlacePreview : MonoBehaviour, IBlockPlacePreview
    {
        private BlockMasterElement _previewBlockMasterElement;
        private BlockPlacePreviewObjectPool _blockPlacePreviewObjectPool;
        
        public bool IsActive => gameObject.activeSelf;
        
        
        private void Awake()
        {
            _blockPlacePreviewObjectPool = new BlockPlacePreviewObjectPool(transform);
            SetActive(false);
        }
        
        public List<bool> SetPreviewAndGroundDetect(List<PlaceInfo> placePointInfos, BlockMasterElement holdingBlockMaster)
        {
            // さっきと違うブロックだったら削除する
            if (_previewBlockMasterElement == null || _previewBlockMasterElement.BlockGuid != holdingBlockMaster.BlockGuid)
            {
                _previewBlockMasterElement = holdingBlockMaster;
                _blockPlacePreviewObjectPool.AllDestroy();
            }
            
            _blockPlacePreviewObjectPool.AllUnUse();
            
            // プレビューブロックの位置を設定
            var isGroundDetectedList = new List<bool>();
            foreach (var placeInfo in placePointInfos)
            {
                var blockId = holdingBlockMaster.BlockGuid.GetVerticalOverrideBlockId(placeInfo.VerticalDirection);
                
                var pos = SlopeBlockPlaceSystem.GetBlockPositionToPlacePosition(placeInfo.Position, placeInfo.Direction, blockId);
                var rot = placeInfo.Direction.GetRotation();
                
                var previewBlock = _blockPlacePreviewObjectPool.GetObject(blockId);
                previewBlock.SetTransform(pos,rot);
                var isGroundDetected = previewBlock.IsCollisionGround;
                isGroundDetectedList.Add(isGroundDetected);
                
                previewBlock.SetPlaceableColor(!isGroundDetected && placeInfo.Placeable);
            }
            
            return isGroundDetectedList;
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetCraftChainerMainComputerRequestItemProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using Game.CraftChainer.BlockComponent.Crafter;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SetCraftChainerMainComputerRequestItemProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:setReuqestComputer";
        
        public SetCraftChainerMainComputerRequestItemProtocol(ServiceProvider serviceProvider) { }
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SetCraftChainerMainComputerRequestItemProtocolMessagePack>(payload.ToArray());
            
            var blockPos = data.BlockPos.Vector3Int;
            
            var crafterBlock = ServerContext.WorldBlockDatastore.GetBlock(blockPos);
            if (crafterBlock == null) return null;
            
            var itemId = data.ItemId;
            var count = data.Count;
            var computerComponent = crafterBlock.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
            computerComponent.StartCreateItem(itemId, count);
            
            return null;
        }
        
        [MessagePackObject]
        public class SetCraftChainerMainComputerRequestItemProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            [Key(3)] public int ItemIdInt { get; set; }
            [IgnoreMember] public ItemId ItemId => new(ItemIdInt);
            [Key(4)] public int Count { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public SetCraftChainerMainComputerRequestItemProtocolMessagePack() { }
            
            public SetCraftChainerMainComputerRequestItemProtocolMessagePack(Vector3Int blockPos, ItemId itemId, int count)
            {
                Tag = ProtocolTag;
                BlockPos = new Vector3IntMessagePack(blockPos);
                ItemIdInt = itemId.AsPrimitive();
                Count = count;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/FindMachineAndGeneratorFromPeripheralService.cs
```cs
using System.Collections.Generic;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class FindMachineAndGeneratorFromPeripheralService
    {
        public static (List<IElectricConsumer>, List<IElectricGenerator>) Find(Vector3Int pos, ElectricPoleBlockParam poleConfigParam)
        {
            var blocks = new List<IElectricConsumer>();
            var generators = new List<IElectricGenerator>();
            var machineRange = poleConfigParam.MachineConnectionRange;
            
            var startMachineX = pos.x - machineRange / 2;
            var startMachineY = pos.y - machineRange / 2;
            for (var i = startMachineX; i < startMachineX + machineRange; i++)
            for (var j = startMachineY; j < startMachineY + machineRange; j++)
            {
                var machinePos = new Vector3Int(i, j);
                
                var worldBlockDatastore = ServerContext.WorldBlockDatastore;
                //範囲内に機械がある場合
                if (worldBlockDatastore.TryGetBlock<IElectricConsumer>(machinePos, out var consumer))
                    //機械を電力セグメントに追加
                    blocks.Add(consumer);
                
                //範囲内に発電機がある場合
                if (worldBlockDatastore.TryGetBlock<IElectricGenerator>(machinePos, out var generator))
                    //機械を電力セグメントに追加
                    generators.Add(generator);
            }
            
            return (blocks, generators);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/CraftInventoryView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Main;
using Core.Master;
using Game.CraftChainer.Util;
using Mooresmaster.Model.CraftRecipesModule;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    //TODO CraftITemViewにリネーム
    public class CraftInventoryView : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform craftMaterialParent;
        [SerializeField] private RectTransform craftResultParent;
        
        [SerializeField] private CraftButton craftButton;
        [SerializeField] private Button nextRecipeButton;
        [SerializeField] private Button prevRecipeButton;
        
        [SerializeField] private TMP_Text itemNameText;
        [SerializeField] private TMP_Text recipeCountText;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private readonly List<ItemSlotObject> _craftMaterialSlotList = new();
        private ItemSlotObject _craftResultSlot;
        private ILocalPlayerInventory _localPlayerInventory;
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        
        private int CraftRecipeCount => _currentItemRecipes.CraftRecipes.Count;
        private RecipeViewerItemRecipes _currentItemRecipes;
        private int _currentIndex;
        
        [Inject]
        public void Construct(ILocalPlayerInventory localPlayerInventory, ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;
            _localPlayerInventory = localPlayerInventory;
            _localPlayerInventory.OnItemChange.Subscribe(_ =>
            {
                if (_currentItemRecipes != null && _currentIndex < CraftRecipeCount)
                {
                    UpdateCraftButton(_currentItemRecipes.CraftRecipes[_currentIndex]);
                }
            });
            
            nextRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex++;
                if (CraftRecipeCount <= _currentIndex) _currentIndex = 0;
                DisplayRecipe(_currentIndex);
            });
            
            prevRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex--;
                if (_currentIndex < 0) _currentIndex = CraftRecipeCount - 1;
                DisplayRecipe(_currentIndex);
            });
            
            craftButton.OnCraftFinish.Subscribe(_ =>
            {
                if (_currentItemRecipes == null || CraftRecipeCount == 0)
                {
                    return;
                }
                
                var currentCraftGuid = _currentItemRecipes.CraftRecipes[_currentIndex].CraftRecipeGuid;
                ClientContext.VanillaApi.SendOnly.Craft(currentCraftGuid);
            }).AddTo(this);
        }
        
        private void UpdateCraftButton(CraftRecipeMasterElement craftRecipe)
        {
            craftButton.SetInteractable(IsCraftable(craftRecipe));
        }
        
        public void SetRecipes(RecipeViewerItemRecipes recipeViewerItemRecipes)
        {
            _currentItemRecipes = recipeViewerItemRecipes;
            _currentIndex = 0;
        }
        
        public void DisplayRecipe(int index)
        {
            var craftRecipe = _currentItemRecipes.CraftRecipes[index];
            
            ClearSlotObject();
            
            SetMaterialSlot();
            
            SetResultSlot();
            
            UpdateButtonAndText();
            
            #region InternalMethod
            
            void ClearSlotObject()
            {
                foreach (var materialSlot in _craftMaterialSlotList) Destroy(materialSlot.gameObject);
                _craftMaterialSlotList.Clear();
                if (_craftResultSlot != null) Destroy(_craftResultSlot.gameObject);
            }
            
            void SetMaterialSlot()
            {
                foreach (var requiredItem in craftRecipe.RequiredItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, craftMaterialParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _craftMaterialSlotList.Add(itemSlotObject);
                    
                    // 原材料をクリックしたときにそのレシピを表示するようにする
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetResultSlot()
            {
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(craftRecipe.CraftResultItemGuid);
                _craftResultSlot = Instantiate(itemSlotObjectPrefab, craftResultParent);
                _craftResultSlot.SetItem(itemViewData, craftRecipe.CraftResultCount);
            }
            
            void UpdateButtonAndText()
            {
                prevRecipeButton.interactable = CraftRecipeCount != 1;
                nextRecipeButton.interactable = CraftRecipeCount != 1;
                recipeCountText.text = $"{_currentIndex + 1} / {CraftRecipeCount}";
                craftButton.SetCraftTime(craftRecipe.CraftTime);
                UpdateCraftButton(craftRecipe);
                
                var itemName = MasterHolder.ItemMaster.GetItemMaster(craftRecipe.CraftResultItemGuid).Name;
                itemNameText.text = itemName;
            }
            
            void OnClickMaterialItem(ItemSlotObject itemSlotObject)
            {
                var itemId = itemSlotObject.ItemViewData.ItemId;
                var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
                _onClickItem.OnNext(itemRecipes);
            }
            
            #endregion
        }
        
        /// <summary>
        ///     そのレシピがクラフト可能かどうかを返す
        ///     この処理はある1つのレシピに対してのみ使い、一気にすべてのアイテムがクラフト可能かチェックするには<see cref="IsAllItemCraftable" />を用いる
        /// </summary>
        private bool IsCraftable(CraftRecipeMasterElement craftRecipeMasterElement)
        {
            var itemPerCount = new Dictionary<ItemId, int>();
            foreach (var item in _localPlayerInventory)
            {
                if (item.Id == ItemMaster.EmptyItemId) continue;
                if (itemPerCount.ContainsKey(item.Id))
                    itemPerCount[item.Id] += item.Count;
                else
                    itemPerCount.Add(item.Id, item.Count);
            }
            
            foreach (var requiredItem in craftRecipeMasterElement.RequiredItems)
            {
                var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (!itemPerCount.ContainsKey(itemId)) return false;
                if (itemPerCount[itemId] < requiredItem.Count) return false;
            }
            
            return true;
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/GearNetworkTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    public class GearNetworkTest
    {
        [Test]
        //シンプルジェネレーターを設置し、簡易的な歯車NWを作り、RPM、回転方向があっているかをテスト
        //Install a simple generator, make a simple gear NW, and test if RPM and direction of rotation are correct.
        public void SimpleGeneratorAndGearRpmTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, new Vector3Int(0, 0, 0), BlockDirection.North, out var generator);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Shaft, new Vector3Int(0, 0, 1), BlockDirection.North, out var shaft);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BigGear, new Vector3Int(-1, -1, 2), BlockDirection.North, out var bigGear);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, new Vector3Int(2, 0, 2), BlockDirection.North, out var smallGear);
            
            //ネットワークをアップデート
            //Update the network
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDatastore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            //ジェネレーターの供給が正しいか
            //Is the generator supply correct?
            var generatorComponent = generator.GetComponent<IGearGenerator>();
            Assert.AreEqual(10.0f, generatorComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, generatorComponent.GenerateIsClockwise);
            
            //シャフトの回転は正しいか
            //Is the rotation of the shaft correct?
            var shaftComponent = shaft.GetComponent<GearEnergyTransformer>();
            Assert.AreEqual(10.0f, shaftComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, shaftComponent.IsCurrentClockwise);
            
            //BigGearの回転は正しいか
            //Is the rotation of BigGear correct?
            var bigGearComponent = bigGear.GetComponent<GearComponent>();
            Assert.AreEqual(10.0f, bigGearComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, bigGearComponent.IsCurrentClockwise);
            
            //SmallGearの回転は正しいか
            //Is the rotation of SmallGear correct?
            var smallGearComponent = smallGear.GetComponent<GearComponent>();
            Assert.AreEqual(20.0f, smallGearComponent.CurrentRpm.AsPrimitive()); // ギア比2:1 Gear ratio 2:1
            Assert.AreEqual(false, smallGearComponent.IsCurrentClockwise); // 回転が反転する Rotation is reversed
        }
        
        [Test]
        // ループした歯車NWを作成し、RPM、回転方向があっているかをテスト
        // Create a looped gear NW and test if RPM and direction of rotation are correct.
        public void LoopGearNetworkTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            // C - D
            // |   |
            // A - B
            //
            // A = 0,0,0
            // GeneratorはGearの下に
            
            const float rpm = 10.0f;
            
            var gearPositionA = new Vector3Int(0, 0, 0);
            var gearPositionB = new Vector3Int(1, 0, 0);
            var gearPositionC = new Vector3Int(0, 0, 1);
            var gearPositionD = new Vector3Int(1, 0, 1);
            var generatorPosition = new Vector3Int(0, 0, -1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.InfinityTorqueSimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionA, BlockDirection.North, out var smallGearABlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionB, BlockDirection.North, out var smallGearBBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionC, BlockDirection.North, out var smallGearCBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionD, BlockDirection.North, out var smallGearDBlock);
            
            var generator = generatorBlock.GetComponent<IGearGenerator>();
            var smallGearA = smallGearABlock.GetComponent<GearComponent>();
            var smallGearB = smallGearBBlock.GetComponent<GearComponent>();
            var smallGearC = smallGearCBlock.GetComponent<GearComponent>();
            var smallGearD = smallGearDBlock.GetComponent<GearComponent>();
            
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            // Generatorの回転方向とRPMのテスト
            Assert.AreEqual(rpm, generator.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, generator.IsCurrentClockwise);
            
            // smallGearAの回転方向とRPMのテスト
            Assert.AreEqual(rpm, smallGearA.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, smallGearA.IsCurrentClockwise);
            
            // smallGearBの回転方向とRPMのテスト
            Assert.AreEqual(rpm, smallGearB.CurrentRpm.AsPrimitive());
            Assert.AreEqual(false, smallGearB.IsCurrentClockwise);
            
            // smallGearCの回転方向とRPMのテスト
            Assert.AreEqual(rpm, smallGearC.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, smallGearC.IsCurrentClockwise);
            
            // smallGearDの回転方向とRPMのテスト
            Assert.AreEqual(rpm, smallGearD.CurrentRpm.AsPrimitive());
            Assert.AreEqual(false, smallGearD.IsCurrentClockwise);
        }
        
        [Test]
        // BigGearを使ってRPMを変えたSmallGearと、RPMを変えていないSmallGearを無理やりつなぎ、ロックされることをテストする
        // Using BigGear, forcibly connect SmallGear with a different RPM and SmallGear with an unchanged RPM, and test that it locks.
        public void DifferentRpmGearNetworkToRockTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPos = new Vector3Int(1, 1, 0); // 大歯車を使ってRPMを変化させた側の歯車
            var bigGearPos = new Vector3Int(0, 0, 1); // Gears on the side that changed RPM with large gears
            var smallGear1Pos = new Vector3Int(3, 1, 1);
            
            var smallGear2Pos = new Vector3Int(1, 1, 2); // RPMを変化させていない側の歯車（回転方向を変えないために2つの小歯車をつかう）
            
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPos, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BigGear, bigGearPos, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear2Pos, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear1Pos, BlockDirection.North, out var smallGear1);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear2Pos, BlockDirection.North, out var smallGear2);
            
            //RPMが違う歯車同士を強制的に接続
            //Force connection between gears with different RPM
            ForceConnectGear(smallGear1, smallGear2);
            
            // find the network
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDatastore.GearNetworks.First().Value;
            
            Assert.NotNull(gearNetwork);
            
            //ネットワークをアップデート
            //Update the network
            gearNetwork.ManualUpdate();
            
            // ネットワークがロックされているかどうかを確認する
            Assert.IsTrue(gearNetwork.GearTransformers.All(g => g.IsRocked));
            Assert.IsTrue(gearNetwork.GearGenerators.All(g => g.IsRocked));
        }
        
        [Test]
        public void DifferentDirectionGearNetworkToRockTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 0);
            
            var gearPosition3 = new Vector3Int(0, 0, -1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out var gear2);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition3, BlockDirection.North, out var gear3);
            
            //回転方向が違う歯車同士を強制的に接続
            //Forced connection of gears with different directions of rotation
            ForceConnectGear(gear2, gear3);
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            // ネットワークがロックされているかどうかを確認する
            Assert.IsTrue(gearNetwork.GearTransformers.All(g => g.IsRocked));
            Assert.IsTrue(gearNetwork.GearGenerators.All(g => g.IsRocked));
        }
        
        [Test]
        public void MultiGeneratorOverrideRpmTest()
        {
            // 複数のジェネレーターのRPMがオーバーライドされるテスト
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var fastGeneratorPosition = new Vector3Int(0, 0, 0);
            var fastGeneratorGearPosition = new Vector3Int(0, 0, 1);
            var smallGearAPosition = new Vector3Int(1, 0, 1);
            var generatorPosition = new Vector3Int(2, 0, 0);
            var generatorGearPosition = new Vector3Int(2, 0, 1);
            var smallGearBPosition = new Vector3Int(3, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleFastGearGenerator, fastGeneratorPosition, BlockDirection.North, out var fastGeneratorBlock);
            var fastGenerator = fastGeneratorBlock.GetComponent<IGearGenerator>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, fastGeneratorGearPosition, BlockDirection.North, out _);
            
            // SmallGearA
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGearAPosition, BlockDirection.North, out var smallGearABlock);
            var smallGearA = smallGearABlock.GetComponent<GearComponent>();
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            var generator = generatorBlock.GetComponent<IGearGenerator>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, generatorGearPosition, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGearBPosition, BlockDirection.North, out var smallGearBBlock);
            var smallGearB = smallGearBBlock.GetComponent<GearComponent>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(fastGenerator.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(smallGearA.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(generator.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(smallGearB.CurrentRpm.AsPrimitive(), 20f);
        }
        
        [Test]
        public void MultiGeneratorDifferentDirectionToRockTest()
        {
            // 複数のジェネレーターの回転方向が違うことでロックされるテスト
            // Gen1 - Gear1 このような構成になっている
            //        Gear2
            // Gen2 - Gear3
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generator1Position = new Vector3Int(0, 0, 0);
            var generator2Position = new Vector3Int(1, 0, 0);
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generator1Position, BlockDirection.North, out var generator1Block);
            var generator1 = generator1Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generator2Position, BlockDirection.North, out var generator2Block);
            var generator2 = generator2Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out var gear1Block);
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out var gear2Block);
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.IsTrue(generator1.IsRocked);
            Assert.IsTrue(generator2.IsRocked);
            Assert.IsTrue(gear1.IsRocked);
            Assert.IsTrue(gear2.IsRocked);
        }
        
        [Test]
        public void ServeTorqueTest()
        {
            // 機械によってトルクが消費されるテスト（正しいトルクが供給されるかのテスト
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 1);
            var gearPosition3 = new Vector3Int(2, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition1, BlockDirection.North, out var gear1Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition2, BlockDirection.North, out var gear2Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition3, BlockDirection.North, out var gear3Block);
            
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            var gear3 = gear3Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(10, gear1.CurrentPower.AsPrimitive());
            Assert.AreEqual(10, gear2.CurrentPower.AsPrimitive());
            Assert.AreEqual(10, gear3.CurrentPower.AsPrimitive());
        }
        
        [Test]
        public void ServeTorqueOverTest()
        {
            //トルクが多いとその分供給トルクが減るテスト
            // ジェネレーターは3のトルクを生成するが、6つの歯車がつながっているため、要求するトルクは6になる
            // 結果、供給されるトルクは3/6=0.5になる
            // Test that the supply torque decreases as the torque increases
            // The generator generates 3 torque, but since it is connected to 6 gears, the required torque becomes 6
            // As a result, the supplied torque becomes 3/6=0.5
            
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            var generator = generatorBlock.GetComponent<SimpleGearGeneratorComponent>();
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(0, 0, 2);
            var gearPosition3 = new Vector3Int(1, 0, 2);
            var gearPosition4 = new Vector3Int(2, 0, 2);
            var gearPosition5 = new Vector3Int(2, 0, 3);
            var gearPosition6 = new Vector3Int(3, 0, 3);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition1, BlockDirection.North, out var gear1Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth20RequireTorqueTestGear, gearPosition2, BlockDirection.North, out var gear2Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition3, BlockDirection.North, out var gear3Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition4, BlockDirection.North, out var gear4Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth20RequireTorqueTestGear, gearPosition5, BlockDirection.North, out var gear5Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition6, BlockDirection.North, out var gear6Block);
            
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            var gear3 = gear3Block.GetComponent<IGearEnergyTransformer>();
            var gear4 = gear4Block.GetComponent<IGearEnergyTransformer>();
            var gear5 = gear5Block.GetComponent<IGearEnergyTransformer>();
            var gear6 = gear6Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(5, gear1.CurrentRpm.AsPrimitive());
            Assert.AreEqual(5, gear2.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.5f, gear1.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.5f, gear2.CurrentTorque.AsPrimitive());
            
            Assert.AreEqual(10, gear3.CurrentRpm.AsPrimitive());
            Assert.AreEqual(10, gear4.CurrentRpm.AsPrimitive());
            Assert.AreEqual(10, gear5.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.25f, gear3.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.25f, gear4.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.25f, gear5.CurrentTorque.AsPrimitive());
            
            Assert.AreEqual(20, gear6.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.125f, gear6.CurrentTorque.AsPrimitive());
        }
        
        [Test]
        public void GearNetworkMergeTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            var gearPosition1 = new Vector3Int(1, 0, 0);
            var gearPosition2 = new Vector3Int(2, 0, 0);
            var gearPosition3 = new Vector3Int(3, 0, 0);
            
            // 2つのネットワークを作成
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition3, BlockDirection.North, out _);
            Assert.AreEqual(2, gearNetworkDataStore.GearNetworks.Count);
            
            // ネットワークをマージ
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out _);
            Assert.AreEqual(1, gearNetworkDataStore.GearNetworks.Count);
            
            // ネットワークの分離のテスト
            ServerContext.WorldBlockDatastore.RemoveBlock(gearPosition2);
            Assert.AreEqual(2, gearNetworkDataStore.GearNetworks.Count);
        }
        
        private static void ForceConnectGear(IBlock gear1, IBlock gear2)
        {
            BlockConnectorComponent<IGearEnergyTransformer> gear1Connector = gear1.GetComponent<BlockConnectorComponent<IGearEnergyTransformer>>();
            var gear1Transform = gear1.GetComponent<IGearEnergyTransformer>();
            
            BlockConnectorComponent<IGearEnergyTransformer> gear2Connector = gear2.GetComponent<BlockConnectorComponent<IGearEnergyTransformer>>();
            var gear2Transform = gear2.GetComponent<IGearEnergyTransformer>();
            
            
            var gear1Info = new ConnectedInfo(new GearConnectOption(true), new GearConnectOption(true), gear1);
            var gear2Info = new ConnectedInfo(new GearConnectOption(true), new GearConnectOption(true), gear2);
            
            ((Dictionary<IGearEnergyTransformer, ConnectedInfo>)gear1Connector.ConnectedTargets).Add(gear2Transform, gear2Info);
            ((Dictionary<IGearEnergyTransformer, ConnectedInfo>)gear2Connector.ConnectedTargets).Add(gear1Transform, gear1Info);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/Implementation/NullItemStack.cs
```cs
#nullable enable
using System;
using Core.Const;
using Core.Item.Interface;
using Core.Master;

namespace Core.Item.Implementation
{
    internal class NullItemStack : IItemStack
    {
        public ItemId Id => ItemMaster.EmptyItemId;
        public int Count => 0;
        public long ItemHash => 0;
        public ItemInstanceId ItemInstanceId { get; }
        
        public ItemProcessResult AddItem(IItemStack receiveItemStack)
        {
            //そのまま足すとインスタスIDが同じになってベルトコンベアなどで運ぶときに問題が生じるので、新しいインスタンスを生成する
            var tmpItem = InternalItemContext.ItemStackFactory.Create(receiveItemStack.Id, receiveItemStack.Count);
            var empty = InternalItemContext.ItemStackFactory.CreatEmpty();
            return new ItemProcessResult(tmpItem, empty);
        }
        
        public IItemStack SubItem(int subCount)
        {
            return this;
        }
        
        public bool IsAllowedToAdd(IItemStack item)
        {
            return true;
        }
        
        public bool IsAllowedToAddWithRemain(IItemStack item)
        {
            return true;
        }
        
        public ItemStackMetaData GetMeta(string key)
        {
            //TODO ログに入れる
            throw new InvalidOperationException("空のアイテムにメタデータは存在しません");
        }
        
        public bool TryGetMeta(string key, out ItemStackMetaData value)
        {
            throw new InvalidOperationException("空のアイテムにメタデータは存在しません");
        }
        
        public IItemStack SetMeta(string key, ItemStackMetaData value)
        {
            throw new InvalidOperationException("空のアイテムにメタデータは入れられません");
        }
        
        public IItemStack Clone()
        {
            return InternalItemContext.ItemStackFactory.CreatEmpty();
        }
        
        public override bool Equals(object? obj)
        {
            if (typeof(NullItemStack) != obj?.GetType()) return false;
            return ((NullItemStack)obj).Id == Id && ((NullItemStack)obj).Count == Count;
        }
        
        protected bool Equals(NullItemStack other)
        {
            return ItemInstanceId == other.ItemInstanceId;
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(ItemInstanceId);
        }
        
        public override string ToString()
        {
            return $"ID:{Id} Count:{Count}";
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/MainGameStarter.cs
```cs
using System.Diagnostics;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.Control;
using Client.Game.InGame.Electric;
using Client.Game.InGame.Entity;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Mining;
using Client.Game.InGame.Player;
using Client.Game.InGame.Presenter.Command;
using Client.Game.InGame.Presenter.PauseMenu;
using Client.Game.InGame.Presenter.Player;
using Client.Game.InGame.Tutorial;
using Client.Game.InGame.Tutorial.UIHighlight;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.Inventory.RecipeViewer;
using Client.Game.InGame.UI.Inventory.Sub;
using Client.Game.InGame.UI.UIState;
using Client.Game.InGame.UI.UIState.UIObject;
using Client.Game.InGame.World;
using Client.Game.Sequence;
using Client.Game.Skit;
using Client.Game.Skit.Starter;
using Client.Network.API;
using Game.CraftChainer.Util;
using UnityEngine;
using VContainer;
using VContainer.Unity;

namespace Client.Starter
{
    /// <summary>
    ///     ゲームの起動と依存解決を行うクラス
    ///     誰かこの最初に全部依存を解決する方法じゃない方法で、いい感じに依存解決できる方法あったら教えてください
    /// </summary>
    public class MainGameStarter : LifetimeScope
    {
        // Hierarchy上にある依存解決が必要なものをまとめたところ
        //TODO regionでちゃんと分類分けしたい
        
        [Header("InHierarchy")] [SerializeField]
        private Camera mainCamera;
        
        [SerializeField] private BlockGameObjectDataStore blockGameObjectDataStore;
        [SerializeField] private MapObjectGameObjectDatastore mapObjectGameObjectDatastore;
        
        [SerializeField] private CommandUIInput commandUIInput;
        [SerializeField] private HotBarView hotBarView;
        [SerializeField] private PlayerObjectController playerObjectController;
        [SerializeField] private MapObjectMiningController mapObjectMiningController;
        
        [SerializeField] private EntityObjectDatastore entityObjectDatastore;
        
        [SerializeField] private UIStateControl uIStateControl;
        [SerializeField] private PauseMenuObject pauseMenuObject;
        [SerializeField] private DeleteBarObject deleteBarObject;
        [SerializeField] private PlayerInventoryViewController playerInventoryViewController;
        [SerializeField] private CraftInventoryView craftInventoryView;
        [SerializeField] private MachineRecipeView machineRecipeView;
        [SerializeField] private RecipeViewerView recipeViewerView;
        [SerializeField] private ItemListView itemListView;
        
        [SerializeField] private MapObjectPin mapObjectPin;
        [SerializeField] private UIHighlightTutorialManager uiHighlightTutorialManager;
        [SerializeField] private KeyControlTutorialManager keyControlTutorialManager;
        
        [SerializeField] private BlockPlacePreview blockPlacePreview;
        [SerializeField] private SaveButton saveButton;
        [SerializeField] private BackToMainMenu backToMainMenu;
        [SerializeField] private NetworkDisconnectPresenter networkDisconnectPresenter;
        [SerializeField] private ChallengeManager challengeManager;
        
        [SerializeField] private PlayerSkitStarterDetector playerSkitStarterDetector;
        [SerializeField] private SkitManager skitManager;
        
        [SerializeField] private DisplayEnergizedRange displayEnergizedRange;
        
        [SerializeField] private InGameCameraController inGameCameraController;
        
        
        private IObjectResolver _resolver;
        private string IPAddress = ServerConst.LocalServerIp;
        
        private bool isLocal;
        private Process localServerProcess;
        
        private int PlayerId = ServerConst.DefaultPlayerId;
        private int Port = ServerConst.LocalServerPort;
        
        protected override void OnDestroy()
        {
            _resolver?.Dispose();
        }
        
        public IObjectResolver StartGame(InitialHandshakeResponse initialHandshakeResponse)
        {
            var builder = new ContainerBuilder();
            
            //最初に取得したデータを登録
            // register initial data
            builder.RegisterInstance(initialHandshakeResponse);
            
            //インベントリのUIコントロール
            // register inventory UI control
            builder.Register<LocalPlayerInventoryController>(Lifetime.Singleton);
            builder.Register<ILocalPlayerInventory, LocalPlayerInventory>(Lifetime.Singleton);
            builder.RegisterEntryPoint<NetworkEventInventoryUpdater>();
            
            //プレゼンターアセンブリ
            // register presenter assembly
            builder.RegisterEntryPoint<CommonMachineBlockStateChangeProcessor>();
            builder.RegisterEntryPoint<WorldDataHandler>();
            builder.RegisterEntryPoint<PlayerPositionSender>();
            builder.RegisterEntryPoint<BlockStateEventHandler>();
            builder.RegisterEntryPoint<BlockPlaceSystem>().AsSelf();
            
            
            //UIコントロール
            // register UI control
            builder.Register<UIStateDictionary>(Lifetime.Singleton);
            builder.Register<BlockInventoryState>(Lifetime.Singleton);
            builder.Register<GameScreenState>(Lifetime.Singleton);
            builder.Register<PauseMenuState>(Lifetime.Singleton);
            builder.Register<PlayerInventoryState>(Lifetime.Singleton);
            builder.Register<DeleteBlockState>(Lifetime.Singleton);
            builder.Register<SkitState>(Lifetime.Singleton);
            builder.Register<PlaceBlockState>(Lifetime.Singleton);
            builder.Register<ItemRecipeViewerDataContainer>(Lifetime.Singleton);
            
            // チュートリアル関連
            // register tutorial
            builder.Register<TutorialManager>(Lifetime.Singleton);
            
            //Hierarchy上にあるcomponent
            // register component on hierarchy
            builder.RegisterComponent(blockGameObjectDataStore);
            builder.RegisterComponent(mapObjectGameObjectDatastore);
            
            builder.RegisterComponent(mainCamera);
            builder.RegisterComponent(commandUIInput);
            builder.RegisterComponent(hotBarView);
            
            builder.RegisterComponent(uIStateControl);
            builder.RegisterComponent(pauseMenuObject);
            builder.RegisterComponent(deleteBarObject);
            builder.RegisterComponent(saveButton);
            builder.RegisterComponent(backToMainMenu);
            builder.RegisterComponent(networkDisconnectPresenter);
            builder.RegisterComponent(mapObjectMiningController);
            
            builder.RegisterComponent(displayEnergizedRange);
            builder.RegisterComponent(entityObjectDatastore);
            builder.RegisterComponent(playerInventoryViewController);
            builder.RegisterComponent(challengeManager);
            builder.RegisterComponent(craftInventoryView);
            builder.RegisterComponent(machineRecipeView);
            builder.RegisterComponent(recipeViewerView);
            builder.RegisterComponent(itemListView);
            
            builder.RegisterComponent(mapObjectPin);
            builder.RegisterComponent(uiHighlightTutorialManager);
            builder.RegisterComponent(keyControlTutorialManager);
            
            builder.RegisterComponent(playerSkitStarterDetector);
            builder.RegisterComponent(skitManager);
            
            builder.RegisterComponent(inGameCameraController);
            
            builder.RegisterComponent<IPlayerObjectController>(playerObjectController).AsSelf();
            builder.RegisterComponent<IBlockPlacePreview>(blockPlacePreview);
            
            builder.RegisterBuildCallback(objectResolver => { });
            
            //依存関係を解決
            // resolve dependency
            _resolver = builder.Build();
            _resolver.Resolve<BlockGameObjectDataStore>();
            _resolver.Resolve<CommandUIInput>();
            _resolver.Resolve<UIStateControl>();
            _resolver.Resolve<DisplayEnergizedRange>();
            _resolver.Resolve<EntityObjectDatastore>();
            _resolver.Resolve<ChallengeManager>();
            
            return _resolver;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MachineRecipesMaster.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Mooresmaster.Loader.MachineRecipesModule;
using Mooresmaster.Model.MachineRecipesModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class MachineRecipesMaster
    {
        public readonly MachineRecipes MachineRecipes; // TODO 個々の使用箇所をメソッドか
        private readonly Dictionary<string, MachineRecipeMasterElement> _machineRecipesByRecipeKey;
        
        public MachineRecipesMaster(JToken jToken)
        {
            MachineRecipes = MachineRecipesLoader.Load(jToken);
            
            _machineRecipesByRecipeKey = new Dictionary<string, MachineRecipeMasterElement>();
            BuildMachineRecipes();
            
            #region Internal
            
            void BuildMachineRecipes()
            {
                foreach (var recipe in MachineRecipes.Data)
                {
                    var inputItemIds = new List<ItemId>();
                    foreach (var inputItem in recipe.InputItems)
                    {
                        var itemId = MasterHolder.ItemMaster.GetItemId(inputItem.ItemGuid);
                        inputItemIds.Add(itemId);
                    }
                    
                    var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
                    
                    var key = GetRecipeElementKey(blockId, inputItemIds);
                    _machineRecipesByRecipeKey.Add(key, recipe);
                }
            }
            
            #endregion
        }
        
        public bool TryGetRecipeElement(BlockId blockId, List<ItemId> inputItemIds, out MachineRecipeMasterElement recipe)
        {
            var key = GetRecipeElementKey(blockId, inputItemIds);
            return _machineRecipesByRecipeKey.TryGetValue(key, out recipe);
        }
        
        public MachineRecipeMasterElement GetRecipeElement(Guid machineRecipeGuid)
        {
            return MachineRecipes.Data.ToList().Find(x => x.MachineRecipeGuid == machineRecipeGuid);
        }
        
        private static string GetRecipeElementKey(BlockId blockId, List<ItemId> itemIds)
        {
            StringBuilder items = new StringBuilder();
            items.Append(blockId);
            
            itemIds.Sort((a, b) => a.AsPrimitive() - b.AsPrimitive());
            itemIds.ForEach(i =>
            {
                items.Append('_');
                items.Append(i.AsPrimitive());
            });
            
            return items.ToString();
        }
    }
    
    public static class MachineRecipeMasterExtension
    {
        public static ItemId GetBlockItemId(this MachineRecipeMasterElement recipe)
        {
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            return MasterHolder.BlockMaster.GetItemId(blockId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Inventory/InsertItemLogicTest.cs
```cs
using Core.Inventory;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Inventory
{
    /// <summary>
    ///     <see cref="InventoryInsertItem" /> をテストする
    /// </summary>
    public class InsertItemLogicTest
    {
        [Test]
        public void InsertItemWithPrioritySlotTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var toInventory = new OpenableInventoryItemDataStoreService((_, _) => { }, itemStackFactory, 10);
            
            
            // 8,9番目のスロットに優先的にアイテムを入れるようにする
            var insertItem = itemStackFactory.Create(new ItemId(1), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //8番目に入っているか確認
            Assert.AreEqual(insertItem, toInventory.GetItem(8));
            
            //ID2を入れて、9番目に入っているかを確認する
            insertItem = itemStackFactory.Create(new ItemId(2), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //9番目に入っているか確認
            Assert.AreEqual(insertItem, toInventory.GetItem(9));
            
            //ID3を入れて、8,9番目に入らないので0番目に入ることを確認する
            insertItem = itemStackFactory.Create(new ItemId(3), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //0番目に入っているか確認
            Assert.AreEqual(insertItem, toInventory.GetItem(0));
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/ChangeBlockEventPacketTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Block.Interface.State;
using Game.Context;
using Game.EnergySystem;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class ChangeBlockEventPacketTest
    {
        [Test]
        public void MachineChangeStateEvent()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            Vector3Int pos = new(0, 0);
            
            //機械のブロックを作る
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, pos, BlockDirection.North, out var machine);
            //機械ブロックにアイテムを挿入するのでそのアイテムを挿入する
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var item1 = itemStackFactory.Create(new ItemId(1), 3);
            var item2 = itemStackFactory.Create(new ItemId(2), 1);
            
            var blockInventory = machine.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            blockInventory.InsertItem(item1);
            blockInventory.InsertItem(item2);
            
            
            //稼働用の電気を供給する
            var electricMachineComponent = machine.GetComponent<VanillaElectricMachineComponent>();
            electricMachineComponent.SupplyEnergy(new ElectricPower(100));
            
            //最初にイベントをリクエストして、ブロードキャストを受け取れるようにする
            packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(0));
            
            //アップデートしてステートを更新する
            GameUpdater.UpdateWithWait();
            
            
            //ステートが実行中になっているかをチェック
            List<List<byte>> response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var payLoad = eventMessagePack.Events[0].Payload;
            
            var changeStateData = MessagePackSerializer.Deserialize<BlockStateMessagePack>(payLoad);
            var stateDetail = changeStateData.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            
            Assert.AreEqual(VanillaMachineBlockStateConst.IdleState, stateDetail.PreviousStateType);
            Assert.AreEqual(VanillaMachineBlockStateConst.ProcessingState, stateDetail.CurrentStateType);
            Assert.AreEqual(0, changeStateData.Position.X);
            Assert.AreEqual(0, changeStateData.Position.Y);
            
            var detailChangeData = changeStateData.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            Assert.AreEqual(1.0f, detailChangeData.PowerRate);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs
```cs
using System.Collections.Generic;

namespace Game.Train.Train
{
    /// <summary>
    /// 列車一編成を表すクラス
    /// 現在地はRailPositionという抽象的なクラスで表すことに注意
    /// 
    /// </summary>
    public class TrainUnit
    {
        // 列車の編成
        private List<TrainCar> _trainFormation;
        private int _currentSpeed;
        private bool _isRunning;

        // 車両を追加
        public void AddTrainCar(TrainCar trainCar)
        {
        }

        // 列車全体の速度を計算
        public void CalcSpeed(int speed)
        {
            _currentSpeed = speed;
        }

    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearBeltConveyorTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlockConnectInfoModule;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class GearBeltConveyorTest
    {
        // トルクの供給率が100%のとき、指定した時間でアイテムが出てくるテスト
        [Test]
        public void OutputTestWhenTorqueSuppliedRateIs100()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            const int id = 2;
            const int count = 3;
            var item = itemStackFactory.Create(new ItemId(id), count);
            var dummy = new DummyBlockInventory();
            
            
            // gearBeltConveyorブロックを生成
            var gearBeltConveyorPosition = new Vector3Int(0, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GearBeltConveyor, gearBeltConveyorPosition, BlockDirection.North, out var gearBeltConveyor);
            var beltConveyorComponent = gearBeltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)gearBeltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            connectInventory.Add(dummy, new ConnectedInfo());
            
            // generatorブロックを作成
            var generatorPosition = new Vector3Int(1, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.East, out var generator);
            
            // testGearブロックを作成
            var testGearPosition = new Vector3Int(2, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, testGearPosition, BlockDirection.East, out var testGear);
            
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            IReadOnlyDictionary<GearNetworkId, GearNetwork> gearNetwork = gearNetworkDatastore.GearNetworks;
            
            
            const int torqueRate = 1;
            const int generatorRpm = 10;
            var gearBeltConveyorBlockParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearBeltConveyor).BlockParam as GearBeltConveyorBlockParam;
            var duration = 1f / (generatorRpm * torqueRate * gearBeltConveyorBlockParam.BeltConveyorSpeed);
            var expectedEndTime = DateTime.Now.AddSeconds(duration);
            var startTime = DateTime.Now;
            beltConveyorComponent.InsertItem(item);
            
            // for (var i = 0; i < 100; i++)
            // {
            //     GameUpdater.UpdateWithWait();
            // }
            var c = 0;
            while (!dummy.IsItemExists)
            {
                c++;
                GameUpdater.UpdateWithWait();
                var elapsed = DateTime.Now - startTime;
                if (elapsed.TotalSeconds > 20) Assert.Fail();
            }
            
            Assert.True(dummy.IsItemExists);
            
            var now = DateTime.Now;
            Debug.Log($"{now} {expectedEndTime}\n{(now - startTime).TotalSeconds}\n{(expectedEndTime - now).TotalSeconds}\n{duration}\n{c}");
            Assert.True(now <= expectedEndTime.AddSeconds(0.4));
            Assert.True(expectedEndTime.AddSeconds(-0.4) <= now);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Component/BlockConnectorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.ComponentAttribute;
using Game.Context;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlockConnectInfoModule;
using UnityEngine;

namespace Game.Block.Component
{
    [DisallowMultiple]
    public class BlockConnectorComponent<TTarget> : IBlockConnectorComponent<TTarget> where TTarget : IBlockComponent
    {
        public IReadOnlyDictionary<TTarget, ConnectedInfo> ConnectedTargets => _connectedTargets;
        private readonly Dictionary<TTarget, ConnectedInfo> _connectedTargets = new();
        
        private readonly List<IDisposable> _blockUpdateEvents = new();
        
        private readonly Dictionary<Vector3Int, List<(Vector3Int position, IConnectOption targetOption)>> _inputConnectPoss = new(); // key インプットコネクターの位置 value そのコネクターと接続できる位置
        private readonly Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)> _outputTargetToOutputConnector = new(); // key アウトプット先の位置 value そのアウトプット先と接続するアウトプットコネクターの位置
        
        public BlockConnectorComponent(BlockConnectInfo inputConnectInfo, BlockConnectInfo outputConnectInfo, BlockPositionInfo blockPositionInfo)
        {
            var blockPos = blockPositionInfo.OriginalPos;
            var blockDirection = blockPositionInfo.BlockDirection;
            var worldBlockUpdateEvent = ServerContext.WorldBlockUpdateEvent;
            
            CreateInputConnectPoss();
            CreateOutputTargetToOutputConnector();
            
            foreach (var outputPos in _outputTargetToOutputConnector.Keys)
            {
                _blockUpdateEvents.Add(worldBlockUpdateEvent.SubscribePlace(outputPos, b => OnPlaceBlock(b.Pos)));
                _blockUpdateEvents.Add(worldBlockUpdateEvent.SubscribeRemove(outputPos, OnRemoveBlock));
                
                //アウトプット先にブロックがあったら接続を試みる
                if (ServerContext.WorldBlockDatastore.Exists(outputPos)) OnPlaceBlock(outputPos);
            }
            
            #region Internal
            
            void CreateInputConnectPoss()
            {
                if (inputConnectInfo == null) return;
                foreach (var inputConnectSetting in inputConnectInfo.items)
                {
                    var blockPosConvertAction = blockDirection.GetCoordinateConvertAction();
                    
                    var inputConnectorPos = blockPos + blockPosConvertAction(inputConnectSetting.Offset);
                    var directions = inputConnectSetting.Directions;
                    if (directions == null)
                    {
                        _inputConnectPoss.Add(inputConnectorPos, null);
                        continue;
                    }
                    
                    var targetPositions = directions.Select(c => (blockPosConvertAction(c) + inputConnectorPos, inputConnectSetting.ConnectOption)).ToList();
                    if (!_inputConnectPoss.TryAdd(inputConnectorPos, targetPositions)) _inputConnectPoss[inputConnectorPos] = _inputConnectPoss[inputConnectorPos].Concat(targetPositions).ToList();
                }
            }
            
            void CreateOutputTargetToOutputConnector()
            {
                if (outputConnectInfo == null) return;
                
                foreach (var connectSetting in outputConnectInfo.items)
                {
                    var blockPosConvertAction = blockDirection.GetCoordinateConvertAction();
                    
                    var outputConnectorPos = blockPos + blockPosConvertAction(connectSetting.Offset);
                    var directions = connectSetting.Directions;
                    var targetPoss = directions.Select(c => blockPosConvertAction(c) + outputConnectorPos).ToList();
                    
                    foreach (var targetPos in targetPoss) _outputTargetToOutputConnector.Add(targetPos, (outputConnectorPos, connectSetting.ConnectOption));
                }
            }
            
            #endregion
        }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            _connectedTargets.Clear();
            _blockUpdateEvents.ForEach(x => x.Dispose());
            _blockUpdateEvents.Clear();
            IsDestroy = true;
        }
        
        /// <summary>
        ///     ブロックを接続元から接続先に接続できるなら接続する
        ///     その場所にブロックがあるか、
        ///     それぞれインプットとアウトプットの向きはあっているかを確認し、接続する TODO ここのドキュメントを書く
        /// </summary>
        private void OnPlaceBlock(Vector3Int outputTargetPos)
        {
            //接続先にBlockInventoryがなければ処理を終了
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            if (!worldBlockDatastore.TryGetBlock(outputTargetPos, out BlockConnectorComponent<TTarget> targetConnector)) return;
            if (!worldBlockDatastore.TryGetBlock<TTarget>(outputTargetPos, out var targetComponent)) return;
            
            // アウトプット先にターゲットのインプットオブジェクトがあるかどうかをチェックする
            var isConnect = false;
            IConnectOption selfOption = null;
            IConnectOption targetOption = null;
            foreach (var targetInput in targetConnector._inputConnectPoss)
            {
                // アウトプット先に、インプットのコネクターがあるかどうかをチェックする
                if (targetInput.Key != outputTargetPos) continue;
                
                // インプットがどこからでも接続できるならそのまま接続
                if (targetInput.Value == null)
                {
                    isConnect = true;
                    break;
                }
                
                // インプット先に制限がある場合、その座標にアウトプットのコネクターがあるかをチェックする
                var outputConnector = _outputTargetToOutputConnector[outputTargetPos];
                
                // インプット先にアウトプットのコネクターがある場合は接続できる
                foreach (var target in targetInput.Value)
                    if (target.position == outputConnector.position)
                    {
                        isConnect = true;
                        selfOption = outputConnector.selfOption;
                        targetOption = target.targetOption;
                        break;
                    }
            }
            
            if (!isConnect) return;
            
            //接続元ブロックと接続先ブロックを接続
            if (!_connectedTargets.ContainsKey(targetComponent))
            {
                var block = ServerContext.WorldBlockDatastore.GetBlock(outputTargetPos);
                var connectedInfo = new ConnectedInfo(selfOption, targetOption, block);
                _connectedTargets.Add(targetComponent, connectedInfo);
            }
        }
        
        private void OnRemoveBlock(BlockUpdateProperties updateProperties)
        {
            //削除されたブロックがInputConnectorComponentでない場合、処理を終了する
            if (!ServerContext.WorldBlockDatastore.TryGetBlock<TTarget>(updateProperties.Pos, out var component)) return;
            
            _connectedTargets.Remove(component);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/InventoryItemMoveProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Inventory;
using Game.Block.Interface.Component;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using Server.Protocol.PacketResponse.Util.InventoryService;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     インベントリでマウスを使ってアイテムの移動を操作するプロトコルです
    /// </summary>
    public class InventoryItemMoveProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:invItemMove";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public InventoryItemMoveProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<InventoryItemMoveProtocolMessagePack>(payload.ToArray());
            
            var fromInventory = GetInventory(data.FromInventory.InventoryType, data.PlayerId, data.FromInventory.Pos);
            if (fromInventory == null) return null;
            
            var fromSlot = data.FromInventory.Slot;
            if (data.FromInventory.InventoryType == ItemMoveInventoryType.BlockInventory)
                fromSlot -= PlayerInventoryConst.MainInventorySize;
            
            
            var toInventory = GetInventory(data.ToInventory.InventoryType, data.PlayerId, data.ToInventory.Pos);
            if (toInventory == null) return null;
            
            var toSlot = data.ToInventory.Slot;
            if (data.ToInventory.InventoryType == ItemMoveInventoryType.BlockInventory)
                toSlot -= PlayerInventoryConst.MainInventorySize;
            
            
            switch (data.ItemMoveType)
            {
                case ItemMoveType.SwapSlot:
                    InventoryItemMoveService.Move(fromInventory, fromSlot, toInventory, toSlot, data.Count);
                    break;
                case ItemMoveType.InsertSlot:
                    InventoryItemInsertService.Insert(fromInventory, fromSlot, toInventory, data.Count);
                    break;
            }
            
            return null;
        }
        
        private IOpenableInventory GetInventory(ItemMoveInventoryType inventoryType, int playerId, Vector3Int pos)
        {
            IOpenableInventory inventory = null;
            switch (inventoryType)
            {
                case ItemMoveInventoryType.MainInventory:
                    inventory = _playerInventoryDataStore.GetInventoryData(playerId).MainOpenableInventory;
                    break;
                case ItemMoveInventoryType.GrabInventory:
                    inventory = _playerInventoryDataStore.GetInventoryData(playerId).GrabInventory;
                    break;
                case ItemMoveInventoryType.BlockInventory:
                    inventory = ServerContext.WorldBlockDatastore.ExistsComponent<IOpenableBlockInventoryComponent>(pos)
                        ? ServerContext.WorldBlockDatastore.GetBlock<IOpenableBlockInventoryComponent>(pos)
                        : null;
                    break;
            }
            
            return inventory;
        }
        
        [MessagePackObject]
        public class InventoryItemMoveProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public int Count { get; set; }
            [Key(4)] public int ItemMoveTypeId { get; set; }
            [IgnoreMember] public ItemMoveType ItemMoveType => (ItemMoveType)ItemMoveTypeId;
            [Key(5)] public ItemMoveInventoryInfoMessagePack FromInventory { get; set; }
            [Key(6)] public ItemMoveInventoryInfoMessagePack ToInventory { get; set; }
            
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public InventoryItemMoveProtocolMessagePack() { }
            public InventoryItemMoveProtocolMessagePack(int playerId, int count, ItemMoveType itemMoveType,
                ItemMoveInventoryInfo inventory, int fromSlot,
                ItemMoveInventoryInfo toInventory, int toSlot)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Count = count;
                
                ItemMoveTypeId = (int)itemMoveType;
                FromInventory = new ItemMoveInventoryInfoMessagePack(inventory, fromSlot);
                ToInventory = new ItemMoveInventoryInfoMessagePack(toInventory, toSlot);
            }
        }
        
        [MessagePackObject]
        public class ItemMoveInventoryInfoMessagePack
        {
            [Obsolete("シリアライズ用の値です。InventoryTypeを使用してください。")]
            [Key(2)] public int InventoryId { get; set; }
            
            [IgnoreMember] public ItemMoveInventoryType InventoryType => (ItemMoveInventoryType)Enum.ToObject(typeof(ItemMoveInventoryType), InventoryId);
            
            [Key(3)] public int Slot { get; set; }
            
            [Key(4)] public Vector3IntMessagePack Pos { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ItemMoveInventoryInfoMessagePack() { }
            public ItemMoveInventoryInfoMessagePack(ItemMoveInventoryInfo info, int slot)
            {
                //メッセージパックでenumは重いらしいのでintを使う
                InventoryId = (int)info.ItemMoveInventoryType;
                Slot = slot;
                Pos = new Vector3IntMessagePack(info.Pos);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/ChestLogicTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Blocks.Chest;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Random = System.Random;

namespace Tests.CombinedTest.Core
{
    public class ChestLogicTest
    {
        //ベルトコンベアからアイテムを搬入する
        [Test]
        public void BeltConveyorInsertChestLogicTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var random = new Random(4123);
            
            var id = new ItemId(random.Next(1, 11));
            var count = 1;
            var item = itemStackFactory.Create(id, count);
            
            var chest = blockFactory.Create(ForUnitTestModBlockId.ChestId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var chestComponent = chest.GetComponent<VanillaChestComponent>();
            
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            beltConveyorComponent.InsertItem(item);
            
            var beltConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            beltConnectInventory.Add(chestComponent, new ConnectedInfo());
            
            
            while (!chestComponent.GetItem(0).Equals(item)) GameUpdater.UpdateWithWait();
            
            Assert.True(chestComponent.GetItem(0).Equals(item));
        }
        
        [Test]
        public void BeltConveyorOutputChestLogicTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            
            var chest = blockFactory.Create(ForUnitTestModBlockId.ChestId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var chestComponent = chest.GetComponent<VanillaChestComponent>();
            
            var beltconveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltconveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            chestComponent.SetItem(0, new ItemId(1), 1);
            
            var chestConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)chest.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            chestConnectInventory.Add(beltConveyorComponent, new ConnectedInfo());
            GameUpdater.UpdateWithWait();
            
            
            Assert.AreEqual(chestComponent.GetItem(0).Count, 0);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ItemStackTest.cs
```cs
using System;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Other
{
    public class ItemStackTest
    {
        private const int EmptyItemId = 0;
        private IItemStackFactory _itemStackFactory;
        
        [SetUp]
        public void Setup()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            _itemStackFactory = ServerContext.ItemStackFactory;
        }
        
        [TestCase(1, 1, 1, 1, 2, 0, 1, EmptyItemId)]
        [TestCase(1, 5, 1, 1, 6, 0, 1, EmptyItemId)]
        [TestCase(EmptyItemId, 0, 1, 3, 3, 0, 1, EmptyItemId)]
        [TestCase(EmptyItemId, 0, 2, 9, 9, 0, 2, EmptyItemId)]
        [TestCase(EmptyItemId, 5, 1, 1, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 1, EmptyItemId, 0, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 1, EmptyItemId, 0, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 5, EmptyItemId, 0, 5, 0, 1, EmptyItemId)]
        [TestCase(3, 1, 1, 8, 1, 8, 3, 1)]
        [TestCase(1, 1, 3, 1, 1, 1, 1, 3)]
        [TestCase(2, 5, 5, 3, 5, 3, 2, 5)]
        public void AddTest(int mid, int mamo, int rid, int ramo, int ansMAmo, int ansRAmo, int ansMid, int ansRID)
        {
            IItemStack mineItemStack;
            if (mid == EmptyItemId)
                mineItemStack = _itemStackFactory.CreatEmpty();
            else
                mineItemStack = _itemStackFactory.Create(new ItemId(mid), mamo);
            
            IItemStack receivedItemStack;
            if (rid == EmptyItemId)
                receivedItemStack = _itemStackFactory.CreatEmpty();
            else
                receivedItemStack = _itemStackFactory.Create(new ItemId(rid), ramo);
            
            var result = mineItemStack.AddItem(receivedItemStack);
            Assert.AreEqual(result.ProcessResultItemStack.Count, ansMAmo);
            Assert.AreEqual(result.RemainderItemStack.Count, ansRAmo);
            Assert.AreEqual(result.ProcessResultItemStack.Id, ansMid);
            Assert.AreEqual(result.RemainderItemStack.Id, ansRID);
        }
        
        [TestCase(1, 5, 1, 4, 1)]
        [TestCase(EmptyItemId, 5, 1, 0, EmptyItemId)]
        [TestCase(1, 5, 10, 0, EmptyItemId)]
        [TestCase(1, 8, 8, 0, EmptyItemId)]
        [TestCase(1, 8, 9, 0, EmptyItemId)]
        public void SubTest(int mid, int mamo, int subamo, int ansamo, int ansID)
        {
            IItemStack mineItemStack;
            if (mid == EmptyItemId)
                mineItemStack = _itemStackFactory.CreatEmpty();
            else
                mineItemStack = _itemStackFactory.Create(new ItemId(mid), mamo);
            
            var result = mineItemStack.SubItem(subamo);
            Assert.AreEqual(ansamo, result.Count);
            Assert.AreEqual(ansID, result.Id.AsPrimitive());
        }
        
        
        [TestCase(3, 299, 0, 0)]
        [TestCase(3, 299, 1, 0)]
        [TestCase(3, 150, 150, 0)]
        [TestCase(3, 300, 1, 1)]
        [TestCase(3, 1, 300, 1)]
        [TestCase(3, 300, 300, 300)]
        public void ItemAddToOverFlowTest(int id, int baseAmount, int addAmount, int overflowAmount)
        {
            var baseItem = _itemStackFactory.Create(new ItemId(id), baseAmount);
            
            
            var result = baseItem.AddItem(_itemStackFactory.Create(new ItemId(id), addAmount));
            Assert.True(_itemStackFactory.Create(new ItemId(id), overflowAmount).Equals(result.RemainderItemStack));
        }
        
        [TestCase(1, 100, false)]
        [TestCase(1, 1001, true)]
        [TestCase(1, 200, true)]
        public void ItemAddToOverFlowThrowTest(int id, int baseAmo, bool isthrow)
        {
            try
            {
                _itemStackFactory.Create(new ItemId(id), baseAmo);
                Assert.False(isthrow);
            }
            catch (Exception e)
            {
                Assert.True(isthrow);
            }
        }
        
        
        //関係ないオブジェクトを渡すFalseになるテスト
        [TestCase(0)]
        [TestCase(1.5)]
        [TestCase("aaa")]
        public void NotRelatedObjectPassFalseHaveTest(object obj)
        {
            var nullItem = _itemStackFactory.CreatEmpty();
            Assert.False(nullItem.Equals(obj));
            var item = _itemStackFactory.Create(new ItemId(5), 1);
            Assert.False(item.Equals(obj));
        }
        
        [Test]
        public void ToStringTest()
        {
            var item = _itemStackFactory.CreatEmpty();
            Assert.True(item.ToString() == "ID:0 Count:0");
            item = _itemStackFactory.Create(new ItemId(1), 5);
            Assert.True(item.ToString() == "ID:1 Count:5");
            item = _itemStackFactory.Create(new ItemId(13), 10);
            Assert.True(item.ToString() == "ID:13 Count:10");
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailNode.cs
```cs
using Game.Train.Blocks;
using System.Collections.Generic;
/// <summary>
/// 距離はint型で表現している。理由はNotion参照
/// </summary>

namespace Game.Train.RailGraph
{ 
    public class RailNode
    {
        public RailNodeId NodeId { get; }  // ノードを識別するためのユニークなID
        public Dictionary<RailNode, int> ConnectedNodes { get; }  // このノードからつながるノードとその距離

        public StationComponent Station { get; }  // 駅であれば駅のコンポーネント、なければnull

        public RailNode(StationComponent station = null)
        {
            NodeId = RailNodeId.Create();
            Station = station;
            ConnectedNodes = new Dictionary<RailNode, int>();
        }

        public void ConnectNode(RailNode targetNode, int distance)
        {
            if (!ConnectedNodes.ContainsKey(targetNode))
            {
                ConnectedNodes[targetNode] = distance;
            }
        }

        public override string ToString()
        {
            return $"RailNode {{ NodeId: {NodeId}, IsStation: {Station != null}, Connections: {ConnectedNodes.Count} }}";
        }
    }

}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/CraftButton.cs
```cs
using System;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Util;
using UniRx;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    public class CraftButton : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler
    {
        [SerializeField] private RectTransform rectTransform;
        
        [SerializeField] private Image buttonImage;
        [SerializeField] private Color interactableColor = Color.white;
        [SerializeField] private Color nonInteractableColor = Color.gray;
        
        [SerializeField] private ProgressArrowView progressArrow;
        
        public IObservable<Unit> OnCraftFinish => _onCraftFinishSubject;
        private readonly Subject<Unit> _onCraftFinishSubject = new();
        
        private float _currentCraftTime;
        private float _buttonDownElapsed;
        private bool _isButtonDown;
        private bool _isCursorStay = true;
        private bool _isInteractable = true;
        
        private void Update()
        {
            if (_isButtonDown && _isCursorStay) _buttonDownElapsed += Time.deltaTime;
            
            if (_buttonDownElapsed >= _currentCraftTime)
            {
                _buttonDownElapsed = 0;
                _onCraftFinishSubject.OnNext(Unit.Default);
            }
            
            if (_isButtonDown)
            {
                var percent = Mathf.Clamp(_buttonDownElapsed, 0, _currentCraftTime) / _currentCraftTime;
                progressArrow.SetProgress(percent);
            }
            else
            {
                progressArrow.SetProgress(1);
            }
        }
        
        public void SetCraftTime(float craftTime)
        {
            _currentCraftTime = craftTime;
        }
        
        private void OnDestroy()
        {
            _onCraftFinishSubject.Dispose();
        }
        
        public void SetInteractable(bool interactable)
        {
            _isInteractable = interactable;
            buttonImage.color = interactable ? interactableColor : nonInteractableColor;
            
            if (!_isInteractable)
            {
                ResetButton();
            }
        }
        
        #region このフラグはあとで決定して消す
        
        [SerializeField] private bool resetElapsedTimeOnPointerExit;
        [SerializeField] private bool stopElapsedTimeUpdateOnPointerExit;
        [SerializeField] private bool restartElapsedTimeUpdateOnPointerEnter;
        
        #endregion
        
        
        public void OnPointerDown(PointerEventData eventData)
        {
            if (_isInteractable)
            {
                _isButtonDown = true;
            }
        }
        
        public void OnPointerUp(PointerEventData eventData)
        {
            if (_isInteractable)
            {
                _isButtonDown = false;
                _buttonDownElapsed = 0;
            }
        }
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            if (!_isInteractable)
            {
                MouseCursorExplainer.Instance.Show("アイテムが足りないためクラフトできません", isLocalize: false);
            }
            
            if (restartElapsedTimeUpdateOnPointerEnter) _isCursorStay = true;
        }
        
        public void OnPointerExit(PointerEventData eventData)
        {
            MouseCursorExplainer.Instance.Hide();
            if (resetElapsedTimeOnPointerExit) _buttonDownElapsed = 0;
            if (stopElapsedTimeUpdateOnPointerExit) _isCursorStay = false;
        }
        
        private void OnDisable()
        {
            ResetButton();
        }
        
        private void ResetButton()
        {
            MouseCursorExplainer.Instance.Hide();
            _buttonDownElapsed = 0;
            _isCursorStay = false;
            _isButtonDown = false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/BlockInventoryUpdateEventPacketTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    /// <summary>
    ///     ブロックのインベントリが更新された時、イベントのパケットが更新されているかをテストする
    /// </summary>
    public class BlockInventoryUpdateEventPacketTest
    {
        private const int PlayerId = 3;
        private const short PacketId = 16;
        
        //正しくインベントリの情報が更新されたことを通知するパケットが送られるかチェックする
        [Test]
        public void BlockInventoryUpdatePacketTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDataStore = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            Vector3Int pos = new(5, 7);
            
            //ブロックをセットアップ
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, pos, BlockDirection.North, out var block);
            var blockInventory = block.GetComponent<IBlockInventory>();
            
            
            //インベントリを開く
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), true));
            //ブロックにアイテムを入れる
            blockInventory.SetItem(1, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //パケットが送られていることをチェック
            //イベントパケットを取得
            List<List<byte>> eventPacket = packetResponse.GetPacketResponse(GetEventPacket());
            
            
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(eventPacket[0].ToArray());
            //イベントパケットをチェック
            Assert.AreEqual(1, eventMessagePack.Events.Count);
            var payLoad = eventMessagePack.Events[0].Payload;
            var data = MessagePackSerializer.Deserialize<OpenableBlockInventoryUpdateEventMessagePack>(payLoad);
            
            Assert.AreEqual(1, data.Slot); // slot id
            Assert.AreEqual(4, data.Item.Id.AsPrimitive()); // item id
            Assert.AreEqual(8, data.Item.Count); // item count
            Assert.AreEqual(5, data.Position.X); // x
            Assert.AreEqual(7, data.Position.Y); // y
            
            
            //ブロックのインベントリを閉じる
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), false));
            
            //ブロックにアイテムを入れる
            blockInventory.SetItem(2, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //パケットが送られていないことをチェック
            //イベントパケットを取得
            eventPacket = packetResponse.GetPacketResponse(GetEventPacket());
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(eventPacket[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        
        //インベントリが開けるのは１つまでであることをテストする
        [Test]
        public void OnlyOneInventoryCanBeOpenedTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDataStore = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //ブロック1をセットアップ
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(5, 7), BlockDirection.North, out var block1);
            
            //ブロック2をセットアップ
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(10, 20), BlockDirection.North, out var block2);
            
            
            //一つ目のブロックインベントリを開く
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), true));
            //二つ目のブロックインベントリを開く
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(10, 20), true));
            
            
            //一つ目のブロックインベントリにアイテムを入れる
            var block1Inventory = block1.GetComponent<VanillaMachineBlockInventoryComponent>();
            block1Inventory.SetItem(2, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //パケットが送られていないことをチェック
            List<List<byte>> response = packetResponse.GetPacketResponse(GetEventPacket());
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        
        private List<byte> OpenCloseBlockInventoryPacket(Vector3Int pos, bool isOpen)
        {
            return MessagePackSerializer
                .Serialize(new BlockInventoryOpenCloseProtocol.BlockInventoryOpenCloseProtocolMessagePack(PlayerId, pos, isOpen)).ToList();
        }
        
        private List<byte> GetEventPacket()
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(PlayerId)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/BeltConveyorInsertTest.cs
```cs
using System;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    public class BeltConveyorInsertTest
    {
        //2つのアイテムがチェストから出されてベルトコンベアに入り、全てチェストに入るテスト
        [Test]
        public void TwoItemIoTest()
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //それぞれを設置
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, Vector3Int.zero, BlockDirection.North, out var inputChest);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(0, 0, 1), BlockDirection.North, out var beltConveyor);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 0, 2), BlockDirection.North, out var outputChest);
            
            //インプットチェストにアイテムを2つ入れる
            var inputChestComponent = inputChest.GetComponent<VanillaChestComponent>();
            inputChestComponent.SetItem(0, new ItemId(1), 2);
            
            //ベルトコンベアのアイテムが出てから入るまでの6秒間アップデートする
            var now = DateTime.Now;
            while (DateTime.Now - now < TimeSpan.FromSeconds(5)) GameUpdater.UpdateWithWait();
            
            //アイテムが出ているか確認
            Assert.AreEqual(0, inputChestComponent.GetItem(0).Count);
            //アイテムが入っているか確認
            var outputChestComponent = outputChest.GetComponent<VanillaChestComponent>();
            Assert.AreEqual(2, outputChestComponent.GetItem(0).Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/ItemListView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.Tutorial.UIHighlight;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Main;
using Core.Master;
using Game.CraftChainer.Util;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    public class ItemListView : MonoBehaviour
    {
        public const string ItemRecipeListHighlightKey = "itemRecipeList:{0}";
        
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        [SerializeField] private RectTransform itemListParent;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private ILocalPlayerInventory _localPlayerInventory;
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        private readonly List<ItemSlotObject> _itemListObjects = new();
        
        [Inject]
        public void Construct(ILocalPlayerInventory localPlayerInventory, ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            _localPlayerInventory = localPlayerInventory;
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;
            
            _localPlayerInventory.OnItemChange.Subscribe(OnInventoryItemChange);
            
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                
                // アイテムリストを設定
                // Set the item list
                var itemSlotObject = Instantiate(itemSlotObjectPrefab, itemListParent);
                itemSlotObject.SetItem(itemViewData, 0);
                itemSlotObject.OnLeftClickUp.Subscribe(OnClickItemList);
                _itemListObjects.Add(itemSlotObject);
                
                // ハイライトオブジェクトを設定
                // Set the highlight object
                var target = itemSlotObject.gameObject.AddComponent<UIHighlightTutorialTargetObject>();
                var itemMaster = MasterHolder.ItemMaster.GetItemMaster(itemId);
                target.Initialize(string.Format(ItemRecipeListHighlightKey, itemMaster.Name));
            }
        }
        
        private void OnClickItemList(ItemSlotObject slot)
        {
            var itemId = slot.ItemViewData.ItemId;
            var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
            _onClickItem.OnNext(itemRecipes);
        }
        
        private void OnInventoryItemChange(int slot)
        {
            var enableItem = CheckAllItemCraftable();
            foreach (var itemUI in _itemListObjects)
            {
                var isGrayOut = !enableItem.Contains(itemUI.ItemViewData.ItemId);
                itemUI.SetGrayOut(isGrayOut);
            }
            
            #region Internal
            
            HashSet<ItemId> CheckAllItemCraftable()
            {
                var itemPerCount = new Dictionary<ItemId, int>();
                foreach (var item in _localPlayerInventory)
                {
                    if (item.Id == ItemMaster.EmptyItemId) continue;
                    if (itemPerCount.ContainsKey(item.Id))
                        itemPerCount[item.Id] += item.Count;
                    else
                        itemPerCount.Add(item.Id, item.Count);
                }
                
                var result = new HashSet<ItemId>();
                
                foreach (var craftMaster in MasterHolder.CraftRecipeMaster.GetAllCraftRecipes())
                {
                    var resultItemId = MasterHolder.ItemMaster.GetItemId(craftMaster.CraftResultItemGuid);
                    if (result.Contains(resultItemId)) continue; //すでにクラフト可能なアイテムならスキップ
                    var isCraftable = true;
                    foreach (var requiredItem in craftMaster.RequiredItems)
                    {
                        var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                        if (!itemPerCount.ContainsKey(requiredItemId) || itemPerCount[requiredItemId] < requiredItem.Count)
                        {
                            isCraftable = false;
                            break;
                        }
                    }
                    
                    if (isCraftable) result.Add(resultItemId);
                }
                
                return result;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestElectricGenerator.cs
```cs
using Game.Block.Interface;
using Game.EnergySystem;

namespace Tests.Module
{
    //デバック用で無限に電力を供給できる
    public class TestElectricGenerator : IElectricGenerator
    {
        private readonly ElectricPower _power;
        
        public TestElectricGenerator(ElectricPower power, BlockInstanceId blockInstanceId)
        {
            _power = power;
            BlockInstanceId = blockInstanceId;
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        
        public ElectricPower OutputEnergy()
        {
            return _power;
        }
        
        public bool IsDestroy { get; }
        
        public void Destroy()
        {
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/BlockGameObjectContainer.cs
```cs
using System.Collections.Generic;
using Client.Common.Asset;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;


namespace Client.Game.InGame.Context
{
    /// <summary>
    ///     Unityに表示されるブロックの実際のGameObjectを管理するクラス
    ///     最初にブロックを生成しておき、必要なブロックを複製するためのクラス
    /// </summary>
    public class BlockGameObjectContainer
    {
        public IReadOnlyDictionary<BlockId, BlockObjectInfo> BlockObjects => _blockObjects;
        private readonly Dictionary<BlockId, BlockObjectInfo> _blockObjects;
        private readonly BlockGameObject _missingBlockIdObject;
        
        public BlockGameObjectContainer(BlockGameObject missingBlockIdObject, Dictionary<BlockId, BlockObjectInfo> blockObjects)
        {
            _missingBlockIdObject = missingBlockIdObject;
            _blockObjects = blockObjects;
        }
        
        public static async UniTask<BlockGameObjectContainer> CreateAndLoadBlockGameObjectContainer(BlockGameObject missingBlockIdObject)
        {
            var blocks = new Dictionary<BlockId, BlockObjectInfo>();
            var tasks = new List<UniTask<BlockObjectInfo>>();
            foreach (var blockId in MasterHolder.BlockMaster.GetBlockIds())
            {
                tasks.Add(LoadBlockGameObject(blockId));
            }
            
            var results = await UniTask.WhenAll(tasks);
            foreach (var result in results)
            {
                if (result == null) continue;
                blocks.Add(result.BlockId, result);
            }
            
            return new BlockGameObjectContainer(missingBlockIdObject, blocks);
        }
        
        private static async UniTask<BlockObjectInfo> LoadBlockGameObject(BlockId blockId)
        {
            var masterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            if (masterElement.BlockPrefabAddressablesPath == null)
            {
                Debug.LogWarning($"ブロックのパスの設定がありません。 Name:{masterElement.Name} GUID:{masterElement.BlockGuid}");
                return null;
            }
            
            var blockAsset = await AddressableLoader.LoadAsync<GameObject>(masterElement.BlockPrefabAddressablesPath);
            if (blockAsset == null)
            {
                //TODO ログ基盤に入れる
                Debug.LogError($"ブロックのアセットが見つかりません。Name:{masterElement.Name} Path:{masterElement.BlockPrefabAddressablesPath} GUID:{masterElement.BlockGuid} ");
                return null;
            }
            
            return new BlockObjectInfo(blockId, blockAsset.Asset, masterElement);
        }
        
        public BlockGameObject CreateBlock(BlockId blockId, Vector3 position, Quaternion rotation, Transform parent, Vector3Int blockPosition, BlockDirection direction)
        {
            if (!_blockObjects.TryGetValue(blockId, out var blockObjectInfo))
            {
                //ブロックIDがないのでない時用のブロックを作る
                return CreateMissingIdBlock();
            }
            
            //ブロックの作成とセットアップをして返す
            return CreateBlockObject();
            
            #region Internal
            
            BlockGameObject CreateMissingIdBlock()
            {
                var missingIdBlock = Object.Instantiate(_missingBlockIdObject, position, rotation, parent);
                var missingPosInfo = new BlockPositionInfo(blockPosition, direction, Vector3Int.one);
                
                //TODO nullのblock masterを入れる
                //missingIdBlock.Initialize(blockConfig, missingPosInfo, new NullBlockStateChangeProcessor());
                
                return missingIdBlock.GetComponent<BlockGameObject>();
            }
            
            BlockGameObject CreateBlockObject()
            {
                //ブロックIDは1から始まるので、オブジェクトのリストインデックスマイナス１する
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                
                //ブロックの作成とセットアップをして返す
                var block = Object.Instantiate(blockObjectInfo.BlockObjectPrefab, position, rotation, parent);
                
                //コンポーネントの設定
                if (!block.TryGetComponent(out BlockGameObject blockObj))
                {
                    blockObj = block.AddComponent<BlockGameObject>();
                }
                
                //子要素のコンポーネントの設定
                foreach (var mesh in blockObj.GetComponentsInChildren<MeshRenderer>())
                {
                    mesh.gameObject.AddComponent<BlockGameObjectChild>();
                    mesh.gameObject.AddComponent<MeshCollider>();
                }
                
                blockObj.gameObject.SetActive(true);
                var blockType = blockMasterElement.BlockType;
                //ブロックが開けるものの場合はそのコンポーネントを付与する
                if (IsOpenableInventory(blockType)) block.gameObject.AddComponent<OpenableInventoryBlock>();
                // 機械の場合はそのプロセッサを付与する
                if (IsCommonMachine(blockType)) block.gameObject.AddComponent<CommonMachineBlockStateChangeProcessor>();
                
                // 初期化
                var posInfo = new BlockPositionInfo(blockPosition, direction, blockMasterElement.BlockSize);
                blockObj.Initialize(blockMasterElement, posInfo);
                
                return blockObj;
            }
            
            
            // todo ブロックコンフィグのロードのdynamicを辞める時に一緒にこれに対応したシステムを構築する
            bool IsOpenableInventory(string type)
            {
                return type is
                    BlockTypeConst.Chest or
                    BlockTypeConst.ElectricGenerator or
                    BlockTypeConst.ElectricMiner or
                    BlockTypeConst.ElectricMachine or
                    BlockTypeConst.GearMachine or
                    BlockTypeConst.GearMiner;
            }
            
            bool IsCommonMachine(string type)
            {
                return type is
                    BlockTypeConst.ElectricGenerator or
                    BlockTypeConst.ElectricMiner or
                    BlockTypeConst.ElectricMachine or
                    BlockTypeConst.GearMachine or
                    BlockTypeConst.GearMiner;
            }
            
            #endregion
        }
        
        public BlockPreviewObject CreatePreviewBlock(BlockId blockId)
        {
            if (!_blockObjects.TryGetValue(blockId, out var blockObjectInfo))
            {
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                throw new System.Exception($"ブロックの登録がありません。Name:{blockMasterElement.Name} GUID:{blockMasterElement.BlockGuid}");
            }
            
            //ブロックの作成とセットアップをして返す
            var block = Object.Instantiate(blockObjectInfo.BlockObjectPrefab, Vector3.zero, Quaternion.identity);
            block.SetActive(true);
            
            var previewGameObject = block.AddComponent<BlockPreviewObject>();
            previewGameObject.SetTriggerCollider(true);
            previewGameObject.Initialize(blockId);
            
            return previewGameObject;
        }
    }
    
    public class BlockObjectInfo
    {
        public readonly BlockId BlockId;
        public readonly BlockMasterElement BlockMasterElement;
        public readonly GameObject BlockObjectPrefab;
        
        public BlockObjectInfo(BlockId blockId, GameObject blockObjectPrefab, BlockMasterElement blockMasterElement)
        {
            BlockObjectPrefab = blockObjectPrefab;
            BlockMasterElement = blockMasterElement;
            BlockId = blockId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaBeltConveyorTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaBeltConveyorTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            //TODo UP bletからの入力を受付?
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var beltParam = blockMasterElement.BlockParam as BeltConveyorBlockParam;
            
            var slopeType = beltParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            var connectorComponent = BlockTemplateUtil.CreateInventoryConnector(beltParam.InventoryConnectors, blockPositionInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(connectorComponent);
            var itemCount = beltParam.BeltConveyorItemCount;
            var time = beltParam.TimeOfItemEnterToExit;
            
            var beltComponent = componentStates == null ? 
                new VanillaBeltConveyorComponent(itemCount, time, beltConveyorConnector, slopeType) : 
                new VanillaBeltConveyorComponent(componentStates, itemCount, time, beltConveyorConnector, slopeType);
            
            
            var components = new List<IBlockComponent>
            {
                beltComponent,
                connectorComponent
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ItemShooterSaveLoadTest.cs
```cs
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.ItemShooter;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ItemShooterSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var itemShooter = blockFactory.Create(ForUnitTestModBlockId.StraightItemShooter, new BlockInstanceId(1), posInfo);
            
            var shooter = itemShooter.GetComponent<ItemShooterComponent>();
            //リフレクションで_inventoryItemsを取得
            var inventoryItemsField = typeof(ItemShooterComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (ShooterInventoryItem[])inventoryItemsField.GetValue(shooter);
            
            //アイテムを設定
            var item1Speed = 1.5f;
            var item2Speed = 2.2f;
            var item3Speed = 5f;
            var item1RemainingPercent = 0.5f;
            var item2RemainingPercent = 0.3f;
            var item3RemainingPercent = 0.0f;
            inventoryItems[0] = new ShooterInventoryItem(new ItemId(1), new ItemInstanceId(0), item1Speed);
            inventoryItems[0].RemainingPercent = item1RemainingPercent;
            inventoryItems[2] = new ShooterInventoryItem(new ItemId(2), new ItemInstanceId(0), item2Speed);
            inventoryItems[2].RemainingPercent = item2RemainingPercent;
            inventoryItems[3] = new ShooterInventoryItem(new ItemId(5), new ItemInstanceId(0), item3Speed);
            inventoryItems[3].RemainingPercent = item3RemainingPercent;
            
            
            //セーブデータ取得
            var str = shooter.GetSaveState();
            var states = new Dictionary<string, string>() { { shooter.SaveKey, str } };
            Debug.Log(str);
            
            //セーブデータをロード
            var newShooter = blockFactory.Load(itemShooter.BlockMasterElement.BlockGuid, new BlockInstanceId(0), states, posInfo).GetComponent<ItemShooterComponent>();
            var newInventoryItems = (ShooterInventoryItem[])inventoryItemsField.GetValue(newShooter);
            
            //アイテムが一致するかチェック
            Assert.AreEqual(inventoryItems.Length, newInventoryItems.Length);
            
            Assert.AreEqual(1, newInventoryItems[0].ItemId.AsPrimitive());
            Assert.AreEqual(item1Speed, newInventoryItems[0].CurrentSpeed);
            Assert.AreEqual(item1RemainingPercent, newInventoryItems[0].RemainingPercent);
            
            Assert.IsTrue(newInventoryItems[1] == null);
            
            Assert.AreEqual(2, newInventoryItems[2].ItemId.AsPrimitive());
            Assert.AreEqual(item2Speed, newInventoryItems[2].CurrentSpeed);
            Assert.AreEqual(item2RemainingPercent, newInventoryItems[2].RemainingPercent);
            
            Assert.AreEqual(5, newInventoryItems[3].ItemId.AsPrimitive());
            Assert.AreEqual(item3Speed, newInventoryItems[3].CurrentSpeed);
            Assert.AreEqual(item3RemainingPercent, newInventoryItems[3].RemainingPercent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearNetwork.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface;
using UnityEngine;

namespace Game.Gear.Common
{
    public class GearNetwork
    {
        public IReadOnlyList<IGearEnergyTransformer> GearTransformers => _gearTransformers;
        public IReadOnlyList<IGearGenerator> GearGenerators => _gearGenerators;
        
        private readonly Dictionary<BlockInstanceId, GearRotationInfo> _checkedGearComponents = new();
        private readonly List<IGearGenerator> _gearGenerators = new();
        private readonly List<IGearEnergyTransformer> _gearTransformers = new();
        public readonly GearNetworkId NetworkId;
        
        public GearNetwork(GearNetworkId networkId)
        {
            NetworkId = networkId;
        }
        
        public void AddGear(IGearEnergyTransformer gear)
        {
            switch (gear)
            {
                case IGearGenerator generator:
                    _gearGenerators.Add(generator);
                    break;
                default:
                    _gearTransformers.Add(gear);
                    break;
            }
        }
        
        public void RemoveGear(IGearEnergyTransformer gear)
        {
            switch (gear)
            {
                case IGearGenerator generator:
                    _gearGenerators.Remove(generator);
                    break;
                default:
                    _gearTransformers.Remove(gear);
                    break;
            }
        }
        
        public void ManualUpdate()
        {
            //もっとも早いジェネレーターを選定し、そのジェネレーターを起点として、各歯車コンポーネントのRPMと回転方向を計算していく
            IGearGenerator fastestOriginGenerator = null;
            foreach (var gearGenerator in GearGenerators)
            {
                if (fastestOriginGenerator == null)
                {
                    fastestOriginGenerator = gearGenerator;
                    continue;
                }
                
                if (gearGenerator.GenerateRpm > fastestOriginGenerator.GenerateRpm) fastestOriginGenerator = gearGenerator;
            }
            
            if (fastestOriginGenerator == null)
            {
                //ジェネレーターがない場合はすべてにゼロを供給して終了
                foreach (var transformer in GearTransformers) transformer.SupplyPower(new RPM(0), new Torque(0), true);
                return;
            }
            
            //そのジェネレータと接続している各歯車コンポーネントを深さ優先度探索でたどり、RPMと回転方向を計算していく
            _checkedGearComponents.Clear();
            var generatorGearRotationInfo = new GearRotationInfo(fastestOriginGenerator.GenerateRpm, fastestOriginGenerator.GenerateIsClockwise, fastestOriginGenerator);
            _checkedGearComponents.Add(fastestOriginGenerator.BlockInstanceId, generatorGearRotationInfo);
            var rocked = false;
            foreach (var connect in fastestOriginGenerator.GetGearConnects())
            {
                rocked = CalcGearInfo(connect, generatorGearRotationInfo);
                //ロックを検知したので処理を終了
                if (rocked) break;
            }
            
            if (rocked)
            {
                SetRocked();
                return;
            }
            
            //すべてのジェネレーターから生成GPを取得し、合算する
            DistributeGearPower();
            
            #region Internal
            
            bool CalcGearInfo(GearConnect gearConnect, GearRotationInfo connectGearRotationInfo)
            {
                var transformer = gearConnect.Transformer;
                
                //RPMと回転方向を計算する
                var isReverseRotation = IsReverseRotation(gearConnect);
                var isClockwise = isReverseRotation ? !connectGearRotationInfo.IsClockwise : connectGearRotationInfo.IsClockwise;
                RPM rpm;
                if (transformer is IGear gear &&
                    connectGearRotationInfo.EnergyTransformer is IGear connectGear &&
                    isReverseRotation)
                {
                    var gearRate = (float)connectGear.TeethCount / gear.TeethCount;
                    rpm = connectGearRotationInfo.Rpm * gearRate;
                }
                else
                {
                    rpm = connectGearRotationInfo.Rpm;
                }
                
                // もし既に計算済みの場合、新たな計算と一致するかを計算し、一致しない場合はロックフラグを立てる
                if (_checkedGearComponents.TryGetValue(transformer.BlockInstanceId, out var info))
                {
                    if (info.IsClockwise != isClockwise || // 回転方向が一致しない場合
                        Math.Abs((info.Rpm - rpm).AsPrimitive()) > 0.1f) // RPMが一致しない場合
                        return true;
                    
                    // 深さ優先度探索でループになったのでこの探索は終了
                    return false;
                }
                
                if (transformer is IGearGenerator generator
                    && generator.GenerateIsClockwise != isClockwise // もしこれがジェネレーターである場合、回転方向が合っているかを確認
                    && fastestOriginGenerator.BlockInstanceId != transformer.BlockInstanceId // 上記が一番早い起点となるジェネレーターでない場合はロックをする
                   )
                    return true;
                
                // 計算済みとして登録
                var gearRotationInfo = new GearRotationInfo(rpm, isClockwise, transformer);
                _checkedGearComponents.Add(transformer.BlockInstanceId, gearRotationInfo);
                
                // この歯車が接続している歯車を再帰的に計算する
                foreach (var connect in transformer.GetGearConnects())
                {
                    var isRocked = CalcGearInfo(connect, gearRotationInfo);
                    //ロックを検知したので処理を終了
                    if (isRocked) return true;
                }
                
                return false;
            }
            
            bool IsReverseRotation(GearConnect connect)
            {
                return connect.Self.IsReverse && connect.Target.IsReverse;
            }
            
            void SetRocked()
            {
                foreach (var transformer in GearTransformers) transformer.Rocked();
                foreach (var generator in GearGenerators) generator.Rocked();
            }
            
            void DistributeGearPower()
            {
                var totalGenerateTorque = new Torque(0);
                foreach (var gearGenerator in GearGenerators) totalGenerateTorque += gearGenerator.GenerateTorque;
                
                // 起点となるジェネレーターのRPM
                var originRpm = fastestOriginGenerator.GenerateRpm;
                //すべてのコンシューマーの必要トルクを取得し、生成トルクから割って分配率を計算する
                var totalRequiredTorquePerOriginRpm = 0f;
                
                foreach (var gearConsumer in GearTransformers)
                {
                    var info = _checkedGearComponents[gearConsumer.BlockInstanceId];
                    
                    var rpm = info.Rpm;
                    var isClockwise = info.IsClockwise;
                    
                    // このコンシューマーに供給できる最大のトルク
                    // このコンシューマーが要求するトルク
                    var requiredTorque = gearConsumer.GetRequiredTorque(rpm, isClockwise);
                    info.RequiredTorque = requiredTorque;
                    
                    // RPMの比によって供給するトルクを調整する
                    // RPMが倍であれば、その歯車に必要なトルクは倍になるし、RPMが半分であれば、その歯車に必要なトルクは半分になる
                    var distributeTorque = rpm.AsPrimitive() / originRpm.AsPrimitive() * requiredTorque.AsPrimitive();
                    totalRequiredTorquePerOriginRpm += distributeTorque;
                }
                
                // 分配率をもとに、供給するGPを算出し、RPMから供給トルクを計算する
                // 歯車とトルク両方に分配するため、平方根を取る
                var distributeGearPowerRate = Mathf.Sqrt(Mathf.Min(1, totalGenerateTorque.AsPrimitive() / totalRequiredTorquePerOriginRpm));
                
                foreach (var gearConsumer in GearTransformers)
                {
                    var info = _checkedGearComponents[gearConsumer.BlockInstanceId];
                    
                    var ratedDistributeTorque = new Torque(info.RequiredTorque.AsPrimitive() * distributeGearPowerRate * (originRpm / info.Rpm).AsPrimitive());
                    var ratedDistributionRpm = info.Rpm * distributeGearPowerRate;
                    
                    gearConsumer.SupplyPower(ratedDistributionRpm, ratedDistributeTorque, info.IsClockwise);
                }
                
                foreach (var generator in _gearGenerators)
                {
                    var info = _checkedGearComponents[generator.BlockInstanceId];
                    
                    var ratedDistributeTorque = new Torque(info.RequiredTorque.AsPrimitive() * distributeGearPowerRate);
                    var ratedDistributionRpm = info.Rpm * distributeGearPowerRate;
                    
                    generator.SupplyPower(ratedDistributionRpm, ratedDistributeTorque, info.IsClockwise);
                }
            }
            
            #endregion
        }
    }
    
    public class GearRotationInfo
    {
        public readonly IGearEnergyTransformer EnergyTransformer;
        public readonly bool IsClockwise;
        public readonly RPM Rpm;
        
        public GearRotationInfo(RPM rpm, bool isClockwise, IGearEnergyTransformer energyTransformer)
        {
            Rpm = rpm;
            IsClockwise = isClockwise;
            EnergyTransformer = energyTransformer;
        }
        
        public Torque RequiredTorque { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/InventoryItemInsertServiceTest.cs
```cs
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util.InventoryService;
using Tests.Module.TestMod;

namespace Tests.CombinedTest.Game
{
    public class InventoryItemInsertServiceTest
    {
        /// <summary>
        ///     通常のinsert処理
        /// </summary>
        [Test]
        public void InsertTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).MainOpenableInventory;
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            
            //インベントリの設定
            mainInventory.SetItem(PlayerInventoryConst.HotBarSlotToInventorySlot(0), new ItemId(1), 10);
            grabInventory.SetItem(0, new ItemId(1), 10);
            
            //グラブからメインにid 1のアイテムを移す
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 5);
            
            Assert.AreEqual(15, mainInventory.GetItem(PlayerInventoryConst.HotBarSlotToInventorySlot(0)).Count);
            Assert.AreEqual(5, grabInventory.GetItem(0).Count);
        }
        
        
        /// <summary>
        ///     アイテムがいっぱいの時はinsertされないテスト
        /// </summary>
        [Test]
        public void FullItemInsert()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).MainOpenableInventory;
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            
            var id1MaxStack = MasterHolder.ItemMaster.GetItemMaster(new ItemId(1)).MaxStack;
            
            //インベントリをアイテムで満たす
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++) mainInventory.SetItem(i, new ItemId(1), id1MaxStack);
            //グラブインベントリの設定
            grabInventory.SetItem(0, new ItemId(1), 10);
            
            //グラブからメインにid 1のアイテムを移す
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 5);
            //挿入されてないことをテスト
            Assert.AreEqual(10, grabInventory.GetItem(0).Count);
            
            
            //挿入した一部が帰ってくるテスト
            //下準備としてスロットのアイテム数を5引く
            mainInventory.SetItem(0, new ItemId(1), id1MaxStack - 5);
            //グラブからメインにid 1のアイテムを全て移す
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 10);
            //挿入されていることをテスト
            Assert.AreEqual(5, grabInventory.GetItem(0).Count);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ConnectingInventoryListPriorityInsertItemServiceTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks.Service;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Other
{
    public class ConnectingInventoryListPriorityInsertItemServiceTest
    {
        /// <summary>
        ///     アイテムを挿入の優先度がループしてるかテストする
        /// </summary>
        [Test]
        public void Test()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var inventoryList = new List<IBlockInventory>();
            
            //インベントリ1はインベントリのサイズを1にして、インベントリ2に入るか確認する
            var inventory1 = new DummyBlockInventory(1, 1);
            var inventory2 = new DummyBlockInventory();
            var inventory3 = new DummyBlockInventory();
            inventoryList.Add(inventory1);
            inventoryList.Add(inventory2);
            inventoryList.Add(inventory3);
            
            var componentPos = new BlockPositionInfo(Vector3Int.zero, BlockDirection.North, Vector3Int.one);
            var inputConnectorComponent = new BlockConnectorComponent<IBlockInventory>(null, null, componentPos);
            
            var targets = (Dictionary<IBlockInventory, ConnectedInfo>)inputConnectorComponent.ConnectedTargets;
            
            foreach (var inventory in inventoryList) targets.Add(inventory, new ConnectedInfo());
            
            var service = new ConnectingInventoryListPriorityInsertItemService(inputConnectorComponent);
            
            service.InsertItem(itemStackFactory.Create(new ItemId(1), 4));
            service.InsertItem(itemStackFactory.Create(new ItemId(2), 3));
            service.InsertItem(itemStackFactory.Create(new ItemId(3), 2));
            service.InsertItem(itemStackFactory.Create(new ItemId(4), 1));
            
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 4), inventory1.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 3), inventory2.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), inventory3.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(4), 1), inventory2.InsertedItems[1]);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapObjectFactory.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using UnityEngine;

namespace Game.Map
{
    public class MapObjectFactory : IMapObjectFactory
    {
        public IMapObject Create(int instanceId, Guid mapObjectGuid, int currentHp, bool isDestroyed, Vector3 position)
        {
            return new VanillaStaticMapObject(instanceId, mapObjectGuid, isDestroyed, currentHp, position);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Train/TrainCar.cs
```cs
namespace Game.Train.Train
{
    public class TrainCar
    {
        // 駆動力 (動力車での推進力、貨車では0)
        public int TractionForce { get; private set; }

        // インベントリスロット数 (貨車での容量、動力車では0?)
        public int InventorySlots { get; private set; }

        public TrainCar(int tractionForce, int inventorySlots)
        {
            TractionForce = tractionForce;
            InventorySlots = inventorySlots;
        }

    }

}

```

moorestech_server/Assets/Scripts/Core.Item.Interface/IItemStack.cs
```cs
using Core.Master;

namespace Core.Item.Interface
{
    public interface IItemStack
    {
        ItemId Id { get; }
        int Count { get; }
        
        /// <summary>
        ///     アイテムを識別するID
        ///     新しいインスタンスが生成されるたびにかわる
        ///     基本的にメモリ上でアイテムをエンティティとして扱うために使われるID、「今のところ」保存しなくてよい
        /// </summary>
        ItemInstanceId ItemInstanceId { get; }
        
        ItemProcessResult AddItem(IItemStack receiveItemStack);
        IItemStack SubItem(int subCount);
        
        /// <summary>
        ///     アイテムを追加できるときtrueを返す
        ///     あまりがある時はfalceを返す
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        bool IsAllowedToAdd(IItemStack item);
        
        /// <summary>
        ///     アイテムを追加できるが、余りが発生する場合trueを返します
        ///     あまりが発生しない場合でも追加ができるならtrueを返します
        ///     IDが違うことで追加ができない場合はfalseを返します
        /// </summary>
        /// <returns>あまりが出ても追加できるときはtrue</returns>
        bool IsAllowedToAddWithRemain(IItemStack item);
        
        // ひとまず追加はしたが、用途がないので放置。 moddingとかに使うかもしれないので取っておいてはいるが、動作はサポートしていないです。
        // I added it for the time being, but left it alone because I have no use for it. I'm keeping it because I might use it for modding or something, but I don't support its operation.
        public ItemStackMetaData GetMeta(string key);
        public bool TryGetMeta(string key, out ItemStackMetaData value); 
        public IItemStack SetMeta(string key, ItemStackMetaData value);
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/OpenableBlockInventoryUpdateEventPacket.cs
```cs
using System;
using Core.Item.Interface;
using Game.Block.Interface.Event;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Event.EventReceive
{
    /// <summary>
    ///     TODO これいる？どうせステートの変更を送るんだから、そこに入れたらいいんじゃないの？
    /// </summary>
    public class OpenableBlockInventoryUpdateEventPacket
    {
        public const string EventTag = "va:event:blockInvUpdate";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        private readonly IBlockInventoryOpenStateDataStore _inventoryOpenStateDataStore;
        
        private DateTime _now = DateTime.Now;
        
        public OpenableBlockInventoryUpdateEventPacket(EventProtocolProvider eventProtocolProvider, IBlockInventoryOpenStateDataStore inventoryOpenStateDataStore)
        {
            _eventProtocolProvider = eventProtocolProvider;
            _inventoryOpenStateDataStore = inventoryOpenStateDataStore;
            ServerContext.BlockOpenableInventoryUpdateEvent.Subscribe(InventoryUpdateEvent);
        }
        
        
        private void InventoryUpdateEvent(BlockOpenableInventoryUpdateEventProperties properties)
        {
            //そのブロックを開いているプレイヤーをリストアップ
            var playerIds = _inventoryOpenStateDataStore.GetBlockInventoryOpenPlayers(properties.BlockInstanceId);
            if (playerIds.Count == 0) return;
            
            var pos = ServerContext.WorldBlockDatastore.GetBlockPosition(properties.BlockInstanceId);
            var messagePack = new OpenableBlockInventoryUpdateEventMessagePack(pos, properties.Slot, properties.ItemStack);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            //プレイヤーごとにイベントを送信
            foreach (var id in playerIds) _eventProtocolProvider.AddEvent(id, EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class OpenableBlockInventoryUpdateEventMessagePack
    {
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public OpenableBlockInventoryUpdateEventMessagePack()
        {
        }
        
        public OpenableBlockInventoryUpdateEventMessagePack(Vector3Int pos, int slot, IItemStack item)
        {
            Position = new Vector3IntMessagePack(pos);
            Slot = slot;
            Item = new ItemMessagePack(item.Id, item.Count);
        }
        
        [Key(0)] public Vector3IntMessagePack Position { get; set; }
        
        [Key(1)] public int Slot { get; set; }
        
        [Key(2)] public ItemMessagePack Item { get; set; }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningIdleState.cs
```cs

using Client.Game.InGame.UI.Util;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningIdleState : IMapObjectMiningState
    {
        public MapObjectMiningIdleState()
        {
            MouseCursorExplainer.Instance.Hide();
        }
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            return
                context.CurrentFocusMapObjectGameObject != null 
                    ? new MapObjectMiningFocusState() 
                    : this;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapVeinDatastore.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Map.Interface.Json;
using Game.Map.Interface.Vein;
using UnityEngine;

namespace Game.Map
{
    public class MapVeinDatastore : IMapVeinDatastore
    {
        private readonly List<IMapVein> _mapVeins = new();
        
        public MapVeinDatastore(MapInfoJson mapInfoJson)
        {
            //configからmap obejctを生成
            foreach (var veinJson in mapInfoJson.MapVeins)
            {
                var itemId = MasterHolder.ItemMaster.GetItemId(veinJson.VeinItemGuid);
                var vein = new MapVein(itemId, veinJson.MinPosition, veinJson.MaxPosition);
                _mapVeins.Add(vein);
            }
        }
        
        public List<IMapVein> GetOverVeins(Vector3Int pos)
        {
            var veins = new List<IMapVein>();
            foreach (var vein in _mapVeins)
                if (vein.VeinRangeMin.x <= pos.x && pos.x <= vein.VeinRangeMax.x &&
                    vein.VeinRangeMin.y <= pos.y && pos.y <= vein.VeinRangeMax.y)
                    veins.Add(vein);
            
            return veins;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/BeltConveyorTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;
using Random = System.Random;

namespace Tests.CombinedTest.Core
{
    /// <summary>
    ///     コンフィグが変わったらこのテストを変更に応じて変更してください
    /// </summary>
    public class BeltConveyorTest
    {
        //一定個数以上アイテムが入らないテストした後、正しく次に出力されるかのテスト
        [Test]
        public void FullInsertAndChangeConnectorBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //あまり深い意味はないが取りあえずテストは2回実行する
            {
                var id = new ItemId(random.Next(0, 10));
                
                var item = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount + 1);
                var beltConveyor = ServerContext.BlockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var endTime = DateTime.Now.AddSeconds(beltConveyorParam.TimeOfItemEnterToExit);
                
                while (DateTime.Now < endTime.AddSeconds(0.1))
                {
                    item = beltConveyorComponent.InsertItem(item);
                    GameUpdater.UpdateWithWait();
                }
                
                Assert.AreEqual(item.Count, 1);
                
                var dummy = new DummyBlockInventory();
                
                var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
                connectInventory.Add(dummy, new ConnectedInfo());
                GameUpdater.UpdateWithWait();
                
                Assert.AreEqual(itemStackFactory.Create(id, 1).ToString(), dummy.InsertedItems[0].ToString());
            }
        }
        
        //一個のアイテムが入って正しく搬出されるかのテスト
        [Test]
        public void InsertBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            
            var id = new ItemId(2);
            const int count = 3;
            var item = itemStackFactory.Create(id, count);
            var dummy = new DummyBlockInventory();
            
            // アイテムを挿入
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            connectInventory.Add(dummy, new ConnectedInfo());
            
            var expectedEndTime = DateTime.Now.AddSeconds(beltConveyorParam.TimeOfItemEnterToExit);
            var outputItem = beltConveyorComponent.InsertItem(item);
            
            //5秒以上経過したらループを抜ける 
            while (!dummy.IsItemExists) GameUpdater.UpdateWithWait();
            
            
            //チェック
            Assert.True(DateTime.Now <= expectedEndTime.AddSeconds(0.1));
            Assert.True(expectedEndTime.AddSeconds(-0.1) <= DateTime.Now);
            
            Debug.Log($"{(DateTime.Now - expectedEndTime).TotalSeconds}");
            
            Assert.True(outputItem.Equals(itemStackFactory.Create(id, count - 1)));
            var tmp = itemStackFactory.Create(id, 1);
            Debug.Log($"{tmp} {dummy.InsertedItems[0]}");
            Assert.AreEqual(tmp.ToString(), dummy.InsertedItems[0].ToString());
        }
        
        //ベルトコンベアのインベントリをフルにするテスト
        [Test]
        public void FullInsertBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //あまり深い意味はないが取りあえずテストは2回実行する
            {
                var id = new ItemId(random.Next(1, 11));
                var item = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount + 1);
                var dummy = new DummyBlockInventory(beltConveyorParam.BeltConveyorItemCount);
                var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
                connectInventory.Add(dummy, new ConnectedInfo());
                
                while (!dummy.IsItemExists)
                {
                    item = beltConveyorComponent.InsertItem(item);
                    GameUpdater.UpdateWithWait();
                }
                
                Assert.True(item.Equals(itemStackFactory.Create(id, 0)));
                var tmp = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount);
                Assert.True(dummy.InsertedItems[0].Equals(tmp));
            }
        }
        
        //二つのアイテムが入ったとき、一方しか入らないテスト
        [Test]
        public void Insert2ItemBeltConveyorTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //あまり深い意味はないが取りあえずテストは2回実行する
            {
                //必要な変数を作成
                var item1 = itemStackFactory.Create(new ItemId(random.Next(1, 11)), random.Next(1, 10));
                var item2 = itemStackFactory.Create(new ItemId(random.Next(1, 11)), random.Next(1, 10));
                
                var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId , new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var item1Out = beltConveyorComponent.InsertItem(item1);
                var item2Out = beltConveyorComponent.InsertItem(item2);
                
                Assert.True(item1Out.Equals(item1.SubItem(1)));
                Assert.True(item2Out.Equals(item2));
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObjectFactory.cs
```cs
using System;
using UnityEngine;

namespace Game.Map.Interface.MapObject
{
    public interface IMapObjectFactory
    {
        public IMapObject Create(int instanceId, Guid mapObjectGuid, int currentHp, bool isDestroyed, Vector3 position);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/ChestBlockInventoryView.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class ChestBlockInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            
            // アイテムリストを初期化
            // Initialize item list
            var itemList = new List<IItemStack>();
            
            var param = blockGameObject.BlockMasterElement.BlockParam;
            var slotSize =  param switch
            {
                ChestBlockParam blockParam => blockParam.ChestItemSlotCount, // TODO master interfaceブロックインベントリの整理箇所
                CraftChainerProviderChestBlockParam blockParam => blockParam.ItemSlotCount,
                CraftChainerMainComputerBlockParam blockParam => blockParam.ItemSlotCount,
                _ => 0
            };
            for (var i = 0; i < slotSize; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            UpdateItemList(itemList);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Inventory/OpenableInventoryItemDataStoreService.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Item.Interface;
using Core.Master;

namespace Core.Inventory
{
    /// <summary>
    ///     開くことができるインベントリ（プレイヤーインベントリやチェストのインベントリ）の処理を統合的に行うクラスです
    /// </summary>
    public class OpenableInventoryItemDataStoreService : IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems => _inventory;
        private readonly List<IItemStack> _inventory;
        
        public delegate void InventoryUpdate(int slot, IItemStack itemStack);
        
        private readonly IItemStackFactory _itemStackFactory;
        private readonly InventoryUpdate _onInventoryUpdate;
        
        public OpenableInventoryItemDataStoreService(InventoryUpdate onInventoryUpdate, IItemStackFactory itemStackFactory, int slotNumber)
        {
            _itemStackFactory = itemStackFactory;
            _onInventoryUpdate = onInventoryUpdate;
            
            _inventory = new List<IItemStack>();
            for (var i = 0; i < slotNumber; i++) _inventory.Add(_itemStackFactory.CreatEmpty());
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            //インベントリのアイテムをコピー
            var inventoryCopy = new List<IItemStack>(_inventory);
            //挿入を実行する
            var result = InventoryInsertItem.InsertItem(itemStacks, inventoryCopy, _itemStackFactory);
            //結果のアイテム数が0だったら挿入可能
            return result.Count == 0;
        }
        
        public int GetSlotSize()
        {
            return _inventory.Count;
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            return new(_inventory);
        }
        
        public IItemStack GetItem(int slot)
        {
            return _inventory[slot];
        }
        
        private void InvokeEvent(int slot)
        {
            _onInventoryUpdate(slot, _inventory[slot]);
        }
        
        #region Set
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            if (!_inventory[slot].Equals(itemStack))
            {
                _inventory[slot] = itemStack;
                InvokeEvent(slot);
            }
        }
        
        public void SetItemWithoutEvent(int slot, IItemStack itemStack)
        {
            _inventory[slot] = itemStack;
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            SetItem(slot, _itemStackFactory.Create(itemId, count));
        }
        
        #endregion
        
        
        #region Replace
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            //アイテムIDが同じの時はスタックして余ったものを返す
            var item = _inventory[slot];
            if (item.Id == itemStack.Id)
            {
                var result = item.AddItem(itemStack);
                _inventory[slot] = result.ProcessResultItemStack;
                InvokeEvent(slot);
                return result.RemainderItemStack;
            }
            
            //違う場合はそのまま入れ替える
            _inventory[slot] = itemStack;
            InvokeEvent(slot);
            return item;
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            return ReplaceItem(slot, _itemStackFactory.Create(itemId, count));
        }
        
        #endregion
        
        
        #region Insert
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return InventoryInsertItem.InsertItem(itemStack, _inventory, _itemStackFactory, InvokeEvent);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            return InsertItem(_itemStackFactory.Create(itemId, count));
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return InventoryInsertItem.InsertItem(itemStacks, _inventory, _itemStackFactory, InvokeEvent);
        }
        
        /// <summary>
        ///     もしそのスロットに入れられるのであれば、まずはそれらのスロットに入れてから、余ったものを返す
        /// </summary>
        public IItemStack InsertItemWithPrioritySlot(IItemStack itemStack, int[] prioritySlots)
        {
            return InventoryInsertItem.InsertItemWithPrioritySlot(itemStack, _inventory, _itemStackFactory, prioritySlots, InvokeEvent);
        }
        
        public IItemStack InsertItemWithPrioritySlot(ItemId itemId, int count, int[] prioritySlots)
        {
            return InsertItemWithPrioritySlot(_itemStackFactory.Create(itemId, count), prioritySlots);
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/PowerGenerator/VanillaElectricGeneratorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Core.Const;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Event;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json;

namespace Game.Block.Blocks.PowerGenerator
{
    public class VanillaElectricGeneratorComponent : IElectricGenerator, IBlockInventory, IOpenableInventory, IBlockSaveState, IUpdatableBlockComponent
    {
        private readonly BlockComponentManager _blockComponentManager = new();
        private readonly Dictionary<ItemId, FuelItemsElement> _fuelSettings;
        
        private readonly ElectricPower _infinityPower;
        private readonly bool _isInfinityPower;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        private ItemId _currentFuelItemId = ItemMaster.EmptyItemId;
        private double _remainingFuelTime;
        
        public VanillaElectricGeneratorComponent(VanillaPowerGeneratorProperties data)
        {
            BlockPositionInfo = data.BlockPositionInfo;
            BlockInstanceId = data.BlockInstanceId;
            _fuelSettings = data.FuelSettings;
            _isInfinityPower = data.IsInfinityPower;
            _infinityPower = data.InfinityPower;
            
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, data.FuelItemSlot);
            
            _blockComponentManager.AddComponent(data.InventoryInputConnectorComponent);
        }
        
        public VanillaElectricGeneratorComponent(Dictionary<string, string> componentStates, VanillaPowerGeneratorProperties data) : this(data)
        {
            var saveData = JsonConvert.DeserializeObject<VanillaElectricGeneratorSaveJsonObject>(componentStates[SaveKey]);
            
            var itemId = MasterHolder.ItemMaster.GetItemId(saveData.CurrentFuelItemGuid);
            _currentFuelItemId = itemId;
            _remainingFuelTime = saveData.RemainingFuelTime;
            
            for (var i = 0; i < saveData.Items.Count; i++)
            {
                _itemDataStoreService.SetItem(i, saveData.Items[i].ToItemStack());
            }
        }
        public BlockPositionInfo BlockPositionInfo { get; }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemStack);
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _itemDataStoreService.GetSlotSize();
        }
        
        public string SaveKey { get; } = typeof(VanillaElectricGeneratorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var itemGuid = MasterHolder.ItemMaster.GetItemMaster(_currentFuelItemId).ItemGuid;
            var saveData = new VanillaElectricGeneratorSaveJsonObject
            {
                CurrentFuelItemGuidStr = itemGuid.ToString(),
                RemainingFuelTime = _remainingFuelTime,
                Items = _itemDataStoreService.InventoryItems.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
            };
            
            return JsonConvert.SerializeObject(saveData);
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        
        public bool IsDestroy { get; private set; }
        
        public ElectricPower OutputEnergy()
        {
            BlockException.CheckDestroy(this);
            
            if (_isInfinityPower) return _infinityPower;
            if (_fuelSettings.TryGetValue(_currentFuelItemId, out var fuelSetting))
            {
                return (ElectricPower)fuelSetting.Power;
            }
            
            return new ElectricPower(0);
        }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        public IReadOnlyList<IItemStack> InventoryItems => _itemDataStoreService.InventoryItems;
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            return _itemDataStoreService.CreateCopiedItems();
        }
        
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.ReplaceItem(slot, itemId, count);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemId, count);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertionCheck(itemStacks);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            _itemDataStoreService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.ReplaceItem(slot, itemStack);
        }
        
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            //現在燃料を消費しているか判定
            //燃料が在る場合は燃料残り時間をUpdate時間分減らす
            if (_currentFuelItemId != ItemMaster.EmptyItemId)
            {
                _remainingFuelTime -= GameUpdater.UpdateSecondTime;
                
                //残り時間が0以下の時は燃料の設定をNullItemIdにする
                if (_remainingFuelTime <= 0) _currentFuelItemId = ItemMaster.EmptyItemId;
                
                return;
            }
            
            //燃料がない場合はスロットに燃料が在るか判定する
            //スロットに燃料がある場合は燃料の設定し、アイテムを1個減らす
            for (var i = 0; i < _itemDataStoreService.GetSlotSize(); i++)
            {
                //スロットに燃料がある場合
                var slotItemId = _itemDataStoreService.InventoryItems[i].Id;
                if (!_fuelSettings.ContainsKey(slotItemId)) continue;
                
                //ID、残り時間を設定
                _currentFuelItemId = MasterHolder.ItemMaster.GetItemId(_fuelSettings[slotItemId].ItemGuid);
                _remainingFuelTime = _fuelSettings[slotItemId].Time;
                
                //アイテムを1個減らす
                _itemDataStoreService.SetItem(i, _itemDataStoreService.InventoryItems[i].SubItem(1));
                return;
            }
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            var blockInventoryUpdate = (BlockOpenableInventoryUpdateEvent)ServerContext.BlockOpenableInventoryUpdateEvent;
            var properties = new BlockOpenableInventoryUpdateEventProperties(BlockInstanceId, slot, itemStack);
            blockInventoryUpdate.OnInventoryUpdateInvoke(properties);
        }
    }
    
    public class VanillaElectricGeneratorSaveJsonObject
    {
        [JsonProperty("currentFuelItemGuid")]
        public string CurrentFuelItemGuidStr;
        [JsonIgnore] public Guid CurrentFuelItemGuid => Guid.Parse(CurrentFuelItemGuidStr);
        
        [JsonProperty("inventory")]
        public List<ItemStackSaveJsonObject> Items;
        
        [JsonProperty("remainingFuelTime")]
        public double RemainingFuelTime;
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/ProviderChest/CraftChainerProviderChestBlockInventoryInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.Context;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent.ProviderChest
{
    /// <summary>
    /// CraftChainerネットワークへのアイテムの供給リクエストを受け、InsertItemがそれに合致しているアイテムをCraftChainerネットワークに供給する
    /// InsertItemメソッドはチェスト等から毎フレーム叩かれているため、明示的にInsertを呼び出すと言ったことはしない。
    ///
    /// Receive a request to supply an item to the CraftChainer network, and InsertItem will supply the matching item to the CraftChainer network.
    /// The InsertItem method is hit every frame from the chest, etc., so it does not explicitly call Insert.
    /// </summary>
    public class CraftChainerProviderChestBlockInventoryInserter : IBlockInventoryInserter
    {
        private readonly CraftChainerNodeId _providerChestNodeId;
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        public CraftChainerProviderChestBlockInventoryInserter(CraftChainerNodeId providerChestNodeId, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _providerChestNodeId = providerChestNodeId;
            _blockConnectorComponent = blockConnectorComponent;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var context = CraftChainerMainComputerManager.Instance.GetChainerNetworkContext(_providerChestNodeId);
            if (context == null)
            {
                return itemStack;
            }
            
            // 1個ずつアイテムを挿入し、それを返すため、1個分のアイテムを作成
            // Insert items one by one and return them, so create an item for one item
            var oneItem = ServerContext.ItemStackFactory.Create(itemStack.Id, 1);
            
            var insertResult = context.InsertNodeNetworkNextBlock(oneItem, _providerChestNodeId, _blockConnectorComponent);
            
            // アイテムが消失しないように、1個ひいたアイテムと、挿入結果のアイテムを合成して返す
            // To prevent the item from disappearing, return a composite of the item with one item subtracted and the inserted item
            var subOneItem = itemStack.SubItem(1);
            return insertResult.AddItem(subOneItem).ProcessResultItemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Transporter/CraftChainerTransporterInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent
{
    /// <summary>
    /// そのアイテムがどのクラフトノードに挿入されるべきかを判断し、挿入するためのクラス
    /// Class for determining which craft node the item should be inserted into and inserting it
    /// </summary>
    public class CraftChainerTransporterInserter : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        private readonly CraftChainerNodeId _startChainerNodeId;
        
        public CraftChainerTransporterInserter(BlockConnectorComponent<IBlockInventory> blockConnectorComponent, CraftChainerNodeId startChainerNodeId)
        {
            _blockConnectorComponent = blockConnectorComponent;
            _startChainerNodeId = startChainerNodeId;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var context = CraftChainerMainComputerManager.Instance.GetChainerNetworkContext(_startChainerNodeId);
            if (context == null)
            {
                return itemStack;
            }
            
            // transporterの場合は既に1個になっているアイテムを挿入する想定
            // In the case of a transporter, it is assumed that the item has already been reduced to one
            return context.InsertNodeNetworkNextBlock(itemStack, _startChainerNodeId, _blockConnectorComponent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/CollectBeltConveyorItems.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Entity.Interface;
using Game.Entity.Interface.EntityInstance;
using Game.World.Interface.DataStore;
using UnityEngine;


namespace Server.Protocol.PacketResponse.Util
{
    /// <summary>
    ///     ベルトコンベアにあるアイテムを収集し、エンティティに変換して返す
    /// </summary>
    public static class CollectBeltConveyorItems
    {
        public const float DefaultBeltConveyorHeight = 0.3f;
        
        public static List<IEntity> CollectItem(IEntityFactory entityFactory)
        {
            var result = new List<IEntity>();
            result.AddRange(CollectItemFromWorld(entityFactory));
            
            return result;
        }
        
        public static List<IEntity> CollectItemFromWorld(IEntityFactory entityFactory)
        {
            var result = new List<IEntity>();
            
            //TODO 個々のパフォーマンス問題を何とかする
            foreach (KeyValuePair<BlockInstanceId, WorldBlockData> blockMaster in ServerContext.WorldBlockDatastore.BlockMasterDictionary)
            {
                var block = blockMaster.Value.Block;
                var pos = blockMaster.Value.BlockPositionInfo.OriginalPos;
                // TODO 重かったら考える
                if (!block.TryGetComponent<IItemCollectableBeltConveyor>(out var component))
                {
                    continue;
                }
                
                var direction = ServerContext.WorldBlockDatastore.GetBlockDirection(pos);
                result.AddRange(CollectItemFromBeltConveyor(entityFactory, component, pos, direction));
            }
            
            return result;
        }
        
        static Dictionary<ItemInstanceId,float> _itemInstanceIdToPercent = new Dictionary<ItemInstanceId, float>();
        
        private static List<IEntity> CollectItemFromBeltConveyor(IEntityFactory entityFactory, IItemCollectableBeltConveyor beltConveyor, Vector3Int pos, BlockDirection blockDirection)
        {
            var result = new List<IEntity>();
            for (var i = 0; i < beltConveyor.BeltConveyorItems.Count; i++)
            {
                var beltConveyorItem = beltConveyor.BeltConveyorItems[i];
                if (beltConveyorItem == null) continue;
                if (beltConveyorItem.ItemId == ItemMaster.EmptyItemId) continue;
                
                //残り時間をどこまで進んだかに変換するために 1- する
                var percent = 1f - (float)beltConveyorItem.RemainingPercent;
                
                var last = _itemInstanceIdToPercent.GetValueOrDefault(beltConveyorItem.ItemInstanceId);
                _itemInstanceIdToPercent[beltConveyorItem.ItemInstanceId] = percent;
                
                var diff = percent - last;
                var instanceId = beltConveyorItem.ItemInstanceId;
                UnityEngine.Debug.Log($"CollectItemFrom Last:{last:F3} Current:{percent:F3} Diff:{diff:F3} {instanceId}");
                
                float entityX = pos.x;
                float entityZ = pos.z;
                switch (blockDirection)
                {
                    case BlockDirection.North:
                        entityX += 0.5f; //ベルトコンベアの基準座標は中心なので0.5を他してアイテムを中心に持ってくる
                        entityZ += percent;
                        break;
                    case BlockDirection.South:
                        entityX += 0.5f;
                        entityZ += 1 - percent; //北とは逆向きなので1を引いて逆向きにする
                        break;
                    case BlockDirection.East:
                        entityX += percent;
                        entityZ += 0.5f;
                        break;
                    case BlockDirection.West:
                        entityX += 1 - percent;
                        entityZ += 0.5f;
                        break;
                }
                
                //この0.3という値は仮
                var y = pos.y + DefaultBeltConveyorHeight;
                
                if (beltConveyor.SlopeType == BeltConveyorSlopeType.Up)
                {
                    y += percent;
                    y += 0.1f;
                }
                else if (beltConveyor.SlopeType == BeltConveyorSlopeType.Down)
                {
                    y -= percent;
                    y += 0.1f;
                    y++;
                }
                
                var position = new Vector3(entityX, y, entityZ);
                var itemEntity = (ItemEntity)entityFactory.CreateEntity(VanillaEntityType.VanillaItem, new EntityInstanceId(beltConveyorItem.ItemInstanceId.AsPrimitive()), position);
                itemEntity.SetState(beltConveyorItem.ItemId, 1);
                
                result.Add(itemEntity);
            }
            
            return result;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/ConnectMachineToElectricSegment.cs
```cs
using Core.Master;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     電力を生産もしくは消費するブロックが設置されたときに、そのブロックを電柱に接続する
    /// </summary>
    public class ConnectMachineToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        private readonly int _maxMachineConnectionRange;
        private readonly IWorldEnergySegmentDatastore<TSegment> _worldEnergySegmentDatastore;
        
        
        public ConnectMachineToElectricSegment(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore, MaxElectricPoleMachineConnectionRange maxElectricPoleMachineConnectionRange)
        {
            _worldEnergySegmentDatastore = worldEnergySegmentDatastore;
            _maxMachineConnectionRange = maxElectricPoleMachineConnectionRange.Get();
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlace);
        }
        
        private void OnBlockPlace(BlockUpdateProperties updateProperties)
        {
            //設置されたブロックが電柱だった時の処理
            var pos = updateProperties.Pos;
            var x = updateProperties.Pos.x;
            var y = updateProperties.Pos.y;
            
            //設置されたブロックが発電機か機械以外はスルー処理
            if (!IsElectricMachine(pos)) return;
            
            //最大の電柱の接続範囲を取得探索して接続する
            var startMachineX = x - _maxMachineConnectionRange / 2;
            var startMachineY = y - _maxMachineConnectionRange / 2;
            for (var i = startMachineX; i < startMachineX + _maxMachineConnectionRange; i++)
            for (var j = startMachineY; j < startMachineY + _maxMachineConnectionRange; j++)
            {
                var polePos = new Vector3Int(i, j);
                if (!ServerContext.WorldBlockDatastore.ExistsComponent<IElectricTransformer>(polePos)) continue;
                
                //範囲内に電柱がある場合
                //電柱に接続
                ConnectToElectricPole(polePos, pos);
            }
        }
        
        private bool IsElectricMachine(Vector3Int pos)
        {
            return ServerContext.WorldBlockDatastore.ExistsComponent<TGenerator>(pos) ||
                   ServerContext.WorldBlockDatastore.ExistsComponent<TConsumer>(pos);
        }
        
        
        /// <summary>
        ///     電柱のセグメントに機械を接続する
        /// </summary>
        private void ConnectToElectricPole(Vector3Int polePos, Vector3Int machinePos)
        {
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            
            //電柱を取得
            var block = ServerContext.WorldBlockDatastore.GetBlock(polePos);
            var pole = block.GetComponent<TTransformer>();
            //その電柱のコンフィグを取得
            var configParam = block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            var range = configParam.MachineConnectionRange;
            
            //その電柱から見て機械が範囲内に存在するか確認
            var poleX = polePos.x;
            var poleY = polePos.y;
            if (poleX - range / 2 > poleX || poleX > poleX + range / 2 || poleY - range / 2 > poleY ||
                poleY > poleY + range / 2) return;
            
            //在る場合は発電機か機械かを判定して接続
            //発電機を電力セグメントに追加
            var segment = _worldEnergySegmentDatastore.GetEnergySegment(pole);
            if (worldBlockDatastore.ExistsComponent<TGenerator>(machinePos))
                segment.AddGenerator(worldBlockDatastore.GetBlock<TGenerator>(machinePos));
            else if (worldBlockDatastore.ExistsComponent<TConsumer>(machinePos))
                segment.AddEnergyConsumer(worldBlockDatastore.GetBlock<TConsumer>(machinePos));
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/OpenableInventoryBlock.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.BlockSystem
{
    //todo これをオミットしてIDからチェックできるようにする
    public class OpenableInventoryBlock : MonoBehaviour
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerMainComputerInventoryView.cs
```cs
using System.Collections.Generic;
using System.Threading;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class CraftChainerMainComputerInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        
        [SerializeField] private Button requestButton;
        [SerializeField] private CraftChainerMainComputerSelectRequestItemModal selectRequestItemModal;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            selectRequestItemModal.Initialize();
            requestButton.onClick.AddListener(() => OnClickRequestButton().Forget());
            
            // アイテムリストを初期化
            // Initialize item list
            InitializeItemList();
            
            #region Internal
            
            void InitializeItemList()
            {
                var itemList = new List<IItemStack>();
                var param = (CraftChainerMainComputerBlockParam)blockGameObject.BlockMasterElement.BlockParam;
                for (var i = 0; i < param.ItemSlotCount; i++)
                {
                    var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                    _blockItemSlotObjects.Add(slotObject);
                    itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
                }
                UpdateItemList(itemList);
            }
            
  #endregion
        }
        
        private async UniTask OnClickRequestButton()
        {
            var (itemId, count) = await selectRequestItemModal.GetRequestItem();
            if (itemId == ItemMaster.EmptyItemId) return;
            
            var pos = _blockGameObject.BlockPosInfo.OriginalPos;
            ClientContext.VanillaApi.SendOnly.SetCraftChainerMainComputerRequestItem(pos, itemId, count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/PlayerInventoryViewController.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using ClassLibrary;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Input;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Main
{
    /// <summary>
    ///     TODO フラグ管理をステートベースに変換する
    /// </summary>
    public class PlayerInventoryViewController : MonoBehaviour
    {
        [SerializeField] private GameObject mainInventoryObject;
        
        [SerializeField] private List<ItemSlotObject> mainInventorySlotObjects;
        [SerializeField] private ItemSlotObject grabInventorySlotObject;
        
        public Transform SubInventoryParent => subInventoryParent.transform;
        [SerializeField] private Transform subInventoryParent;
        
        //現在スプリットドラッグしているスロットのリスト
        private readonly List<ItemSplitDragSlot> _itemSplitDraggedSlots = new();
        
        private readonly List<IDisposable> _subInventorySlotUIEventUnsubscriber = new();
        
        //ドラッグ中のアイテムをドラッグする前のGrabインベントリ
        private IItemStack _grabInventoryBeforeDrag;
        private bool _isItemOneDragging;
        private bool _isItemSplitDragging;
        
        private LocalPlayerInventoryController _playerInventory;
        
        private ISubInventory _subInventory;
        
        private bool IsGrabItem => _playerInventory.GrabInventory.Id != ItemMaster.EmptyItemId;
        
        private void Awake()
        {
            foreach (var mainInventorySlotObject in mainInventorySlotObjects) mainInventorySlotObject.OnPointerEvent.Subscribe(ItemSlotUIEvent);
        }
        
        
        private void Update()
        {
            InventoryViewUpdate();
        }
        
        [Inject]
        public void Construct(LocalPlayerInventoryController playerInventory)
        {
            _playerInventory = playerInventory;
        }
        
        public void SetSubInventory(ISubInventory subInventory)
        {
            foreach (var disposable in _subInventorySlotUIEventUnsubscriber) disposable.Dispose();
            
            _subInventorySlotUIEventUnsubscriber.Clear();
            _subInventory = subInventory;
            _playerInventory.SetSubInventory(subInventory);
            foreach (var sub in _subInventory.SubInventorySlotObjects) _subInventorySlotUIEventUnsubscriber.Add(sub.OnPointerEvent.Subscribe(ItemSlotUIEvent));
        }
        
        private void ItemSlotUIEvent((ItemSlotObject slotObject, ItemUIEventType itemUIEvent) eventProperty)
        {
            var (slotObject, itemUIEvent) = eventProperty;
            var index = mainInventorySlotObjects.IndexOf(slotObject);
            if (index == -1)
                index = mainInventorySlotObjects.Count + _subInventory.SubInventorySlotObjects.IndexOf(slotObject);
            
            if (index == -1) throw new Exception("slot index not found");
            switch (itemUIEvent)
            {
                case ItemUIEventType.LeftClickDown:
                    LeftClickDown(index);
                    break;
                case ItemUIEventType.RightClickDown:
                    RightClickDown(index);
                    break;
                case ItemUIEventType.LeftClickUp:
                    LeftClickUp(index);
                    break;
                case ItemUIEventType.RightClickUp:
                    RightClickUp(index);
                    break;
                case ItemUIEventType.CursorEnter:
                    CursorEnter(index);
                    break;
                case ItemUIEventType.DoubleClick:
                    DoubleClick(index);
                    break;
                case ItemUIEventType.CursorExit: break;
                case ItemUIEventType.CursorMove: break;
                default: throw new ArgumentOutOfRangeException(nameof(itemUIEvent), itemUIEvent, null);
            }
        }
        
        
        private void DoubleClick(int slotIndex)
        {
            if (_isItemSplitDragging || _isItemOneDragging) return;
            
            
            IItemStack collectTargetItem;
            LocalMoveInventoryType fromType;
            int fromSlot;
            if (IsGrabItem)
            {
                collectTargetItem = _playerInventory.GrabInventory;
                fromType = LocalMoveInventoryType.Grab;
                fromSlot = 0;
            }
            else
            {
                collectTargetItem = _playerInventory.LocalPlayerInventory[slotIndex];
                fromType = LocalMoveInventoryType.MainOrSub;
                fromSlot = slotIndex;
            }
            
            var collectTargetSotIndex = _playerInventory.LocalPlayerInventory.Select((item, index) => new { item, index }).Where(i => i.item.Id == collectTargetItem.Id).OrderBy(i => i.item.Count).Select(i => i.index).ToList();
            
            //一つのスロットに集める場合は集める先のスロットのインデックスをターゲットから除外する
            if (!IsGrabItem) collectTargetSotIndex.Remove(slotIndex);
            
            foreach (var index in collectTargetSotIndex)
            {
                var added = collectTargetItem.AddItem(_playerInventory.LocalPlayerInventory[index]);
                
                //アイテムを何個移したのかを計算
                var collectItemCount = _playerInventory.LocalPlayerInventory[index].Count - added.RemainderItemStack.Count;
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, index, fromType, fromSlot, collectItemCount);
                
                collectTargetItem = added.ProcessResultItemStack;
                
                //足したあまりがあるということはスロットにそれ以上入らないということなので、ここで処理を終了する
                if (added.RemainderItemStack.Count != 0) break;
            }
        }
        
        private void CursorEnter(int slotIndex)
        {
            if (_isItemSplitDragging)
                SplitDraggingItem(slotIndex, false);
            else if (_isItemOneDragging)
                //ドラッグ中の時はマウスカーソルが乗ったスロットをドラッグされたと判定する
                PlaceOneItem(slotIndex);
        }
        
        private void RightClickUp(int slotIndex)
        {
            if (_isItemOneDragging) _isItemOneDragging = false;
        }
        
        private void LeftClickUp(int slotIndex)
        {
            //左クリックを離したときはドラッグ中のスロットを解除する
            if (_isItemSplitDragging)
            {
                SplitDraggingItem(slotIndex, true);
                _itemSplitDraggedSlots.Clear();
                _isItemSplitDragging = false;
            }
        }
        
        
        private void RightClickDown(int slotIndex)
        {
            if (IsGrabItem)
            {
                //アイテムを持っている時に右クリックするとアイテム1個だけ置く処理
                PlaceOneItem(slotIndex);
                _isItemOneDragging = true;
            }
            else
            {
                //アイテムを持ってない時に右クリックするとアイテムを半分とる処理
                
                //空スロットの時はアイテムを持たない
                var item = _playerInventory.LocalPlayerInventory[slotIndex];
                if (item.Id == ItemMaster.EmptyItemId) return;
                
                var halfItemCount = item.Count / 2;
                
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.Grab, 0, halfItemCount);
            }
        }
        
        private void LeftClickDown(int slotIndex)
        {
            if (IsGrabItem)
            {
                var isSlotEmpty = _playerInventory.LocalPlayerInventory[slotIndex].Id == ItemMaster.EmptyItemId;
                
                if (isSlotEmpty)
                {
                    //アイテムを持っている時に左クリックするとアイテムを置くもしくは置き換える処理
                    _isItemSplitDragging = true;
                    _grabInventoryBeforeDrag = _playerInventory.GrabInventory;
                    SplitDraggingItem(slotIndex, false);
                }
                else
                {
                    _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, slotIndex, _playerInventory.GrabInventory.Count);
                }
                
                return;
            }
            
            if (InputManager.UI.ItemDirectMove.GetKey)
            {
                //シフト（デフォルト）＋クリックでメイン、サブのアイテム移動を直接やる処理
                DirectMove(slotIndex);
            }
            else
            {
                var slotItemCount = _playerInventory.LocalPlayerInventory[slotIndex].Count;
                //アイテムを持ってない時に左クリックするとアイテムを取る処理
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.Grab, 0, slotItemCount);
            }
        }
        
        
        private void PlaceOneItem(int slotIndex)
        {
            var oneItem = ServerContext.ItemStackFactory.Create(_playerInventory.GrabInventory.Id, 1);
            var currentItem = _playerInventory.LocalPlayerInventory[slotIndex];
            
            //追加できない場合はスキップ
            if (!currentItem.IsAllowedToAdd(oneItem)) return;
            
            //アイテムを追加する
            _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, slotIndex, 1);
            
            //Grabインベントリがなくなったらドラッグを終了する
            if (_playerInventory.GrabInventory.Count == 0)
                _isItemOneDragging = false;
        }
        
        private void SplitDraggingItem(int slotIndex, bool isMoveSendData)
        {
            if (!_playerInventory.LocalPlayerInventory[slotIndex].IsAllowedToAddWithRemain(_playerInventory.GrabInventory)) return;
            
            // まだスロットをドラッグしてない時
            var doNotDragging = !_itemSplitDraggedSlots.Exists(i => i.Slot == slotIndex);
            // アイテムがない時か、同じアイテムがあるとき
            var isNotSlotOrSameItem = _playerInventory.LocalPlayerInventory[slotIndex].Id == ItemMaster.EmptyItemId || _playerInventory.LocalPlayerInventory[slotIndex].Id == _grabInventoryBeforeDrag.Id;
            
            // まだスロットをドラッグしてない時 か アイテムがない時か、同じアイテムがあるとき
            if (doNotDragging && isNotSlotOrSameItem)
            {
                //ドラッグ中のアイテムに設定
                _itemSplitDraggedSlots.Add(new ItemSplitDragSlot(slotIndex, _playerInventory.LocalPlayerInventory[slotIndex]));
            }
            
            //一度Grabインベントリをリセットする
            _playerInventory.SetGrabItem(_grabInventoryBeforeDrag);
            foreach (var itemSplit in _itemSplitDraggedSlots) _playerInventory.SetMainItem(itemSplit.Slot, itemSplit.BeforeDragItem);
            
            //1スロットあたりのアイテム数
            var grabItem = _playerInventory.GrabInventory;
            var dragItemCount = grabItem.Count / _itemSplitDraggedSlots.Count;
            //余っているアイテム数
            var remainItemNum = grabItem.Count - dragItemCount * _itemSplitDraggedSlots.Count;
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            foreach (var dragSlot in _itemSplitDraggedSlots)
            {
                //ドラッグ中のスロットにアイテムを加算する
                var addedItem = dragSlot.BeforeDragItem.AddItem(itemStackFactory.Create(grabItem.Id, dragItemCount));
                var moveItemCount = addedItem.ProcessResultItemStack.Count - dragSlot.BeforeDragItem.Count;
                
                _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, dragSlot.Slot, moveItemCount, isMoveSendData);
                //余ったアイテムを加算する
                remainItemNum += addedItem.RemainderItemStack.Count;
            }
            
            //あまりのアイテムをGrabインベントリに設定する
            _playerInventory.SetGrabItem(itemStackFactory.Create(grabItem.Id, remainItemNum));
        }
        
        
        private void DirectMove(int slotIndex)
        {
            //そのスロットがメインインベントリかサブインベントリを判定する
            var isMain = slotIndex < PlayerInventoryConst.MainInventorySize;
            
            var startIndex = isMain ? 0 : PlayerInventoryConst.MainInventorySize;
            var endIndex = isMain ? PlayerInventoryConst.MainInventorySize : PlayerInventoryConst.MainInventorySize + _subInventory.Count;
            for (var i = startIndex; i < endIndex; i++)
            {
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.MainOrSub, i, _playerInventory.LocalPlayerInventory[slotIndex].Count);
                //アイテムがなくなったら終了する
                if (_playerInventory.LocalPlayerInventory[slotIndex].Count == 0) break;
            }
        }
        
        public void SetActive(bool isActive)
        {
            mainInventoryObject.SetActive(isActive);
        }
        
        private void InventoryViewUpdate()
        {
            for (var i = 0; i < _playerInventory.LocalPlayerInventory.Count; i++)
            {
                var item = _playerInventory.LocalPlayerInventory[i];
                var itemView = ClientContext.ItemImageContainer.GetItemView(item.Id);
                
                if (i < mainInventorySlotObjects.Count)
                {
                    mainInventorySlotObjects[i].SetItem(itemView, item.Count);
                }
                else
                {
                    var subIndex = i - mainInventorySlotObjects.Count;
                    _subInventory.SubInventorySlotObjects[subIndex].SetItem(itemView, item.Count);
                }
            }
            
            grabInventorySlotObject.SetActive(IsGrabItem);
            var garbItemView = ClientContext.ItemImageContainer.GetItemView(_playerInventory.GrabInventory.Id);
            grabInventorySlotObject.SetItem(garbItemView, _playerInventory.GrabInventory.Count);
        }
    }
    
    public class ItemSplitDragSlot
    {
        public ItemSplitDragSlot(int slot, IItemStack beforeDragItem)
        {
            Slot = slot;
            BeforeDragItem = beforeDragItem;
        }
        
        public int Slot { get; }
        public IItemStack BeforeDragItem { get; }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/BlockPlaceToConnectionBlockTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    /// <summary>
    ///     ブロックが設置された時ブロック同士が接続するテスト
    /// </summary>
    public class BlockPlaceToConnectionBlockTest
    {
        /// <summary>
        ///     機械にベルトコンベアが自動でつながるかをテストする
        ///     機械にアイテムを入れる向きでベルトコンベアのテストを行う
        /// </summary>
        [Test]
        public void BeltConveyorConnectMachineTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            //北向きにベルトコンベアを設置した時、機械とつながるかをテスト
            BlockPlaceToGetMachineIdAndConnectorId(
                0, 10,
                0, 9, BlockDirection.North, blockFactory, world);
            
            //東向きにベルトコンベアを設置した時、機械とつながるかをテスト
            BlockPlaceToGetMachineIdAndConnectorId(
                10, 0,
                9, 0, BlockDirection.East, blockFactory, world);
            
            //南向きにベルトコンベアを設置した時、機械とつながるかをテスト
            BlockPlaceToGetMachineIdAndConnectorId(
                0, -10,
                0, -9, BlockDirection.South, blockFactory, world);
            
            //西向きにベルトコンベアを設置した時、機械とつながるかをテスト
            BlockPlaceToGetMachineIdAndConnectorId(
                -10, 0,
                -9, 0, BlockDirection.West, blockFactory, world);
        }
        
        private void BlockPlaceToGetMachineIdAndConnectorId(
            int machineX, int machineZ,
            int conveyorX, int conveyorZ,
            BlockDirection direction, IBlockFactory blockFactory, IWorldBlockDatastore world)
        {
            //機械の設置
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(machineX, 0, machineZ), direction, out var vanillaMachine);
            
            //ベルトコンベアの設置
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(conveyorX, 0, conveyorZ), direction, out var beltConveyor);
            
            //繋がっているコネクターを取得
            var connectedMachine = (VanillaMachineBlockInventoryComponent)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets.First().Key;
            
            //繋がっているかを検証
            var machineInventory = vanillaMachine.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            Assert.IsTrue(connectedMachine == machineInventory);
        }
        
        /// <summary>
        ///     機械がベルトコンベアに自動でつながるかをテストする
        ///     機械をあらかじめ設置しておき、後に機械からアイテムが出る方向でベルトコンベアをおく
        ///     ブロックが削除されたらつながるベルトコンベアが消えるので、それをテストする
        /// </summary>
        [Test]
        public void MachineConnectToBeltConveyorTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            //機械の設置
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var vanillaMachine);
            
            //機械から4方向にベルトコンベアが出るように配置
            var beltConveyorTransforms = new List<(Vector3Int, BlockDirection)>
            {
                (new Vector3Int(1, 0, 0), BlockDirection.North),
                (new Vector3Int(0, 0, 1), BlockDirection.East),
                (new Vector3Int(-1, 0, 0), BlockDirection.South),
                (new Vector3Int(0, 0, -1), BlockDirection.West),
            };
            foreach (var (position, direction) in beltConveyorTransforms) world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, position, direction, out _);
            
            //繋がっているコネクターを取得
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)vanillaMachine.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            Assert.AreEqual(4, connectInventory.Count);
            
            //ベルトコンベアを削除する
            world.RemoveBlock(new Vector3Int(1, 0, 0));
            world.RemoveBlock(new Vector3Int(-1, 0, 0));
            //接続しているコネクターが消えているか確認
            Assert.AreEqual(2, connectInventory.Count);
            world.RemoveBlock(new Vector3Int(0, 0, 1));
            world.RemoveBlock(new Vector3Int(0, 0, -1));
            
            //接続しているコネクターが消えているか確認
            Assert.AreEqual(0, connectInventory.Count);
        }
        
        
        /// <summary>
        ///     ベルトコンベアを設置した後チェストを設置する
        ///     ベルトコンベアのコネクターが正しく設定されているかをチェックする
        /// </summary>
        [Test]
        public void BeltConveyorToChestConnectTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            //チェストの設置
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 0), BlockDirection.North, out var vanillaChest);
            
            
            //北向きにベルトコンベアを設置してチェック
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(0, 0, -1), BlockDirection.North, vanillaChest);
            
            //東向きにベルトコンベアを設置してチェック
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(-1, 0, 0), BlockDirection.East, vanillaChest);
            
            //南向きにベルトコンベアを設置してチェック
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(0, 0, 1), BlockDirection.South, vanillaChest);
            
            //西向きにベルトコンベアを設置してチェック
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(1, 0, 0), BlockDirection.West, vanillaChest);
        }
        
        private void BeltConveyorPlaceAndCheckConnector(Vector3Int beltConveyorPos, BlockDirection direction, IBlock targetChest)
        {
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, beltConveyorPos, direction, out var northBeltConveyor);
            
            var connector = (VanillaChestComponent)northBeltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets.First().Key;
            
            Assert.AreEqual(targetChest.BlockInstanceId, connector.BlockInstanceId);
        }
        
        /// <summary>
        ///     接続できないブロック(機械とチェスト)同士が接続していないテスト
        /// </summary>
        [Test]
        public void NotConnectableBlockTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            
            //機械とチェストを設置
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var machine);
            world.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 1), BlockDirection.North, out var chest);
            
            //機械のコネクターを取得
            var machineConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)machine.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            //接続されていないことをチェック
            Assert.AreEqual(0, machineConnectInventory.Count);
            
            //チェストのコネクターを取得
            var chestConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)chest.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            //接続されていないことをチェック
            Assert.AreEqual(0, chestConnectInventory.Count);
        }
        
        
        /// <summary>
        ///     大きさが1x1x1以上のブロックで複数のコネクターがある場合、正しく接続されるかをテスト
        /// </summary>
        [Test]
        public void MultiBlockConnectTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            
            //ベルトコンベアを設置
            
            //接続するベルトコンベア
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(2, 0, 3), BlockDirection.North, out _);
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(2, 0, -1), BlockDirection.South, out _);
            
            //接続されないベルトコンベア
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(3, 0, 3), BlockDirection.North, out _);
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(1, 0, -1), BlockDirection.South, out _);
            
            //マルチブロックを設置
            world.TryAddBlock(ForUnitTestModBlockId.MultiBlockGeneratorId, new Vector3Int(0, 0), BlockDirection.North, out var multiBlock);
            
            // マルチブロックのコネクターを取得
            var connector = (Dictionary<IBlockInventory, ConnectedInfo>)multiBlock.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            // ベルトコンベアが正しく接続されているかをチェック
            Assert.AreEqual(2, connector.Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/MachineRecipeView.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Sub;
using Core.Master;
using Game.CraftChainer.Util;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class MachineRecipeView : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform inputParent;
        [SerializeField] private RectTransform outputParent;
        
        [SerializeField] private Button nextRecipeButton;
        [SerializeField] private Button prevRecipeButton;
        
        [SerializeField] private TMP_Text itemNameText;
        [SerializeField] private TMP_Text recipeCountText;
        [SerializeField] private ItemSlotObject machineObject;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private readonly List<ItemSlotObject> _inputSlotList = new();
        private readonly List<ItemSlotObject> _outputSlotList = new();
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        
        private int MachineRecipeCount => _currentItemRecipes.MachineRecipes[_currentBlockId].Count;
        private RecipeViewerItemRecipes _currentItemRecipes;
        private BlockId _currentBlockId;
        private int _currentIndex;
        

        [Inject]
        public void Construct(ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            machineObject.SetFrame(ItemSlotFrameType.MachineSlot);
            machineObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;

            
            nextRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex++;
                if (MachineRecipeCount <= _currentIndex) _currentIndex = 0;
                DisplayRecipe(_currentIndex);
            });
            
            prevRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex--;
                if (_currentIndex < 0) _currentIndex = MachineRecipeCount - 1;
                DisplayRecipe(_currentIndex);
            });
        }
        
        public void SetRecipes(RecipeViewerItemRecipes recipeViewerItemRecipes)
        {
            _currentItemRecipes = recipeViewerItemRecipes;
            _currentIndex = 0;
            if (recipeViewerItemRecipes.MachineRecipes.Count != 0)
            {
                _currentBlockId = recipeViewerItemRecipes.MachineRecipes.First().Key;
            }
        }
        
        public void SetBlockId(BlockId blockId)
        {
            _currentBlockId = blockId;
            _currentIndex = 0;
            DisplayRecipe(_currentIndex);
        }
        
        public void DisplayRecipe(int index)
        {
            var machineRecipes = _currentItemRecipes.MachineRecipes[_currentBlockId][index];
            
            ClearSlotObject();
            
            SetInputSlot();
            SetOutputSlot();
            SetMachineSlot();
            
            UpdateButtonAndText();
            
            #region InternalMethod
            
            void ClearSlotObject()
            {
                foreach (var materialSlot in _inputSlotList) Destroy(materialSlot.gameObject);
                _inputSlotList.Clear();
                foreach (var resultSlot in _outputSlotList) Destroy(resultSlot.gameObject);
                _outputSlotList.Clear();
            }
            
            void SetInputSlot()
            {
                foreach (var requiredItem in machineRecipes.InputItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, inputParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _inputSlotList.Add(itemSlotObject);
                    
                    // 原材料をクリックしたときにそのレシピを表示するようにする
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetOutputSlot()
            {
                foreach (var requiredItem in machineRecipes.OutputItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, outputParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _outputSlotList.Add(itemSlotObject);
                    
                    // 原材料をクリックしたときにそのレシピを表示するようにする
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetMachineSlot()
            {
                var blockItemId = MasterHolder.BlockMaster.GetItemId(_currentBlockId);
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(blockItemId);
                machineObject.SetItem(itemViewData, 0);
            }
            
            void UpdateButtonAndText()
            {
                prevRecipeButton.interactable = MachineRecipeCount != 1;
                nextRecipeButton.interactable = MachineRecipeCount != 1;
                recipeCountText.text = $"{_currentIndex + 1} / {MachineRecipeCount}";
                
                var itemName = MasterHolder.ItemMaster.GetItemMaster(_currentItemRecipes.ResultItemId).Name;
                itemNameText.text = itemName;
            }
            
            #endregion
        }
        
        private void OnClickMaterialItem(ItemSlotObject itemSlotObject)
        {
            var itemId = itemSlotObject.ItemViewData.ItemId;
            var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
            _onClickItem.OnNext(itemRecipes);
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerNetworkContext.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.BlockComponent.ProviderChest;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using UnityEngine;

namespace Game.CraftChainer.BlockComponent.Computer
{
    public class CraftChainerNetworkContext
    {
        // チェインネットワークに関する情報
        // Information about the chain network
        public IReadOnlyList<CraftChainerProviderChestComponent> ProviderChests => _providerChests;
        private readonly List<CraftChainerProviderChestComponent> _providerChests = new();
        public IReadOnlyList<CraftCraftChainerCrafterComponent> CrafterComponents => _crafterComponents;
        private readonly List<CraftCraftChainerCrafterComponent> _crafterComponents = new();
        private readonly Dictionary<CraftChainerNodeId, ICraftChainerNode> _nodes = new();
        
        // このコンテキストを保持するメインコンピューターの情報
        // Information about the main computer that holds this context
        private readonly BlockConnectorComponent<IBlockInventory> _mainComputerConnector; 
        private readonly ICraftChainerNode _mainComputerNode;
        
        // 現在クラフト中のアイテム情報
        // Information about the item currently being crafted
        private readonly Dictionary<ItemInstanceId,CraftChainerNodeId> _requestedMoveItems = new();
        // アイテムごとにどのノードに何個アイテムを入れなければならないか
        // How many items of each item type must be placed in each node?
        private Dictionary<ItemId,Dictionary<CraftChainerNodeId,int>> _craftChainRecipeQue = new();
        
        public CraftChainerNetworkContext(BlockConnectorComponent<IBlockInventory> mainComputerConnector, ICraftChainerNode mainComputerNode)
        {
            _mainComputerConnector = mainComputerConnector;
            _mainComputerNode = mainComputerNode;
        }
        
        public bool IsExistNode(CraftChainerNodeId nodeId)
        {
            return _nodes.ContainsKey(nodeId);
        }
        
        public void SetCraftChainRecipeQue(Dictionary<CraftingSolverRecipeId, int> solvedResults, CraftingSolverItem targetItem)
        {
            var craftRecipeIdMap = GetCraftRecipeIdMap();
            
            _craftChainRecipeQue = CreateRecipeQue(solvedResults, craftRecipeIdMap);
            // ターゲットのアイテムをコンピューターに移動するようにリクエストを追加しておく
            _craftChainRecipeQue.Add(targetItem.ItemId, new Dictionary<CraftChainerNodeId, int> {{_mainComputerNode.NodeId, targetItem.Count}});
            
            #region Internal
            
            Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent> GetCraftRecipeIdMap()
            {
                var map = new Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent>();
                foreach (var crafter in _crafterComponents)
                {
                    var recipeId = crafter.CraftingSolverRecipe.CraftingSolverRecipeId;
                    if (recipeId != CraftingSolverRecipeId.InvalidId)
                    {
                        map[recipeId] = crafter;
                    }
                }
                return map;
            }
            
            Dictionary<ItemId, Dictionary<CraftChainerNodeId,int>> CreateRecipeQue(Dictionary<CraftingSolverRecipeId, int> solved, Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent> recipes)
            {
                var result = new Dictionary<ItemId, Dictionary<CraftChainerNodeId,int>>();
                foreach (var solvedResult in solved)
                {
                    var crafter = recipes[solvedResult.Key];
                    var recipe = crafter.CraftingSolverRecipe;
                    foreach (var inputItems in recipe.Inputs)
                    {
                        var count = inputItems.Count * solvedResult.Value;
                        if (result.TryGetValue(inputItems.ItemId, out var que))
                        {
                            if (!que.TryAdd(crafter.NodeId,count))
                            {
                                que[crafter.NodeId] += count;
                            }
                        }
                        else
                        {
                            result[inputItems.ItemId] = new Dictionary<CraftChainerNodeId, int>()
                            {
                                { crafter.NodeId, count }
                            };
                        }
                    }
                }
                
                return result;
            }
            
            #endregion
        }
        
        /// <summary>
        /// クラフトチェインのネットワークを再検索する
        /// Re-search the network of the craft chain
        /// </summary>
        public void ReSearchNetwork()
        {
            _providerChests.Clear();
            _crafterComponents.Clear();
            _nodes.Clear();
            
            _nodes.Add(_mainComputerNode.NodeId, _mainComputerNode);
            
            // 単純に深さ優先探索で探索し、途中にあったチェストをリストに追加
            // Simply search by depth-first search and add the chests found on the way to the list
            Search(_mainComputerConnector);
            
            #region Internal
            
            void Search(BlockConnectorComponent<IBlockInventory> connector)
            {
                foreach (var connectedTarget in connector.ConnectedTargets)
                {
                    var targetBlock = connectedTarget.Value.TargetBlock;
                    if (!targetBlock.TryGetComponent<ICraftChainerNode>(out var node))
                    {
                        continue;
                    }
                    if (!_nodes.TryAdd(node.NodeId, node))
                    {
                        continue;
                    }
                    
                    if (targetBlock.TryGetComponent<CraftChainerProviderChestComponent>(out var chest))
                    {
                        _providerChests.Add(chest);
                    }
                    if (targetBlock.TryGetComponent<CraftCraftChainerCrafterComponent>(out var crafter))
                    {
                        _crafterComponents.Add(crafter);
                    }
                    if (targetBlock.TryGetComponent<BlockConnectorComponent<IBlockInventory>>(out var nextConnector))
                    {
                        Search(nextConnector);
                    }
                }
            }
            
            #endregion
        }
        
        /// <summary>
        /// アイテムのIDとつながっているコネクターから、次にインサートすべきブロックを取得し、インサート出来る場合はインサートする
        /// Get the next block to insert from the item ID and connected connector, and insert it if possible
        /// </summary>
        public IItemStack InsertNodeNetworkNextBlock(IItemStack item, CraftChainerNodeId startChainerNodeId, BlockConnectorComponent<IBlockInventory> blockConnector)
        {
            if (item.Id == ItemMaster.EmptyItemId) return item;
            
            // ターゲットとなるノードがあるか
            var targetNodeId = GetTargetNodeId(item);
            if (targetNodeId == CraftChainerNodeId.Invalid)
            {
                return item;
            }
            
            // たどり着けるか
            var result = ExecuteBfs(targetNodeId);
            if (result == null || result.Count == 0)
            {
                return item;
            }
            
            // 次のインベントリにアイテムを入れられるか
            var nextInventory = result[0].Item2;
            if (!nextInventory.InsertionCheck(new List<IItemStack> {item}))
            {
                return item;
            }
            
            // アイテムを入れられるのでキューの情報を更新する
            DebugExportCraftChainRecipeQueLog();
            UpdateCraftQue();
            
            // 次のインベントリにアイテムを入れる
            return nextInventory.InsertItem(item);
            
            #region Internal
            
            CraftChainerNodeId GetTargetNodeId(IItemStack item)
            {
                // 移動先が既に指定されている場合はそのまま返す
                // If the destination is already specified, return it as it is
                if (_requestedMoveItems.TryGetValue(item.ItemInstanceId, out var nodeId))
                {
                    return nodeId;
                }
                
                // 現在のアイテムがクラフト対象の材料かどうかをチェック
                // Check if the current item is a crafting target material
                if (!_craftChainRecipeQue.TryGetValue(item.Id, out var craftQue))
                {
                    return CraftChainerNodeId.Invalid;
                }
                
                // クラフト対象の材料なのでそのうちの一つを取得
                // It is a crafting target material, so get one of them
                foreach (var nodeReminder in craftQue)
                {
                    return nodeReminder.Key;
                }
                
                // 移動先が特に指定されていない場合はInvalidを返す
                // If no destination is specified, return Invalid
                return CraftChainerNodeId.Invalid;
            }
            
            List<(CraftChainerNodeId,IBlockInventory)> ExecuteBfs(CraftChainerNodeId targetNode)
            {
                var idToConnector = new Dictionary<CraftChainerNodeId, (BlockConnectorComponent<IBlockInventory> connector, IBlockInventory blockInventory)>();
                var searchQueue = new Queue<CraftChainerNodeId>();
                var searched = new HashSet<CraftChainerNodeId>();
                var reverseSearch = new Dictionary<CraftChainerNodeId, CraftChainerNodeId>();
                var stepLog = new Dictionary<CraftChainerNodeId, int>();
                var isFound = false;
                
                searchQueue.Enqueue(startChainerNodeId);
                searched.Add(startChainerNodeId);
                idToConnector[startChainerNodeId] = (blockConnector, null);
                stepLog[startChainerNodeId] = 0;
                
                // キューがなくなるまでループ
                // Loop until the queue is empty
                while (0 < searchQueue.Count)
                {
                    var searchingId = searchQueue.Dequeue();
                    if (searchingId == targetNode)
                    {
                        isFound = true;
                        break;
                    }
                    
                    var step = stepLog[searchingId] + 1;
                    foreach (var connectedTarget in idToConnector[searchingId].connector.ConnectedTargets)
                    {
                        var targetBlock = connectedTarget.Value.TargetBlock;
                        var next = GetNext(targetBlock);
                        
                        // 接続先がChainerNodeではないので無視
                        // Ignore if the connection destination is not a ChainerNode
                        if (!next.HasValue) continue;
                        
                        var (nodeId, nextConnector, blockInventory) = next.Value;
                        
                        // すでに探索済みの場合は無視
                        // Ignore if already searched
                        if (searched.Contains(nodeId)) continue;
                        
                        searched.Add(nodeId); // Mark as searched before enqueuing
                        reverseSearch[nodeId] = searchingId;
                        idToConnector[nodeId] = (nextConnector, blockInventory);
                        stepLog[nodeId] = step;
                        searchQueue.Enqueue(nodeId);
                    }
                }
                
                if (!isFound)
                {
                    return null;
                }
                
                // 経路をたどっていく
                // Follow the path
                var result = new List<(CraftChainerNodeId,IBlockInventory)>();
                var current = targetNode;
                while (current != startChainerNodeId)
                {
                    result.Add((current,idToConnector[current].blockInventory));
                    current = reverseSearch[current];
                }
                
                result.Reverse();
                return result;
            }
            
            (CraftChainerNodeId nodeId, BlockConnectorComponent<IBlockInventory> connector, IBlockInventory blockInventory)? GetNext(IBlock block)
            {
                if (!block.TryGetComponent<ICraftChainerNode>(out var node)) return null;
                if (node.NodeId == startChainerNodeId) return null;
                if (!block.TryGetComponent<BlockConnectorComponent<IBlockInventory>>(out var connector)) return null;
                if (!block.TryGetComponent<IBlockInventory>(out var inventory)) return null;
                
                return (node.NodeId, connector, inventory);
            }
            
            void UpdateCraftQue()
            {
                // 新しく挿入されたアイテムのみ更新を行うので、既に移動先が指定されているアイテムは無視
                // Only newly inserted items are updated, so items that already have a destination specified are ignored
                if (_requestedMoveItems.ContainsKey(item.ItemInstanceId))
                {
                    return;
                }
                
                // クラフトキューの情報をアップデート
                // Update the craft queue information
                var craftQue = _craftChainRecipeQue[item.Id];
                var reminder = craftQue[targetNodeId];
                reminder--;
                if (reminder <= 0)
                {
                    craftQue.Remove(targetNodeId);
                }
                else
                {
                    craftQue[targetNodeId] = reminder;
                }
                
                // 計算したアイテムの移動先を保持
                // Keep the destination of the calculated item
                _requestedMoveItems[item.ItemInstanceId] = targetNodeId;
            }
            
            void DebugExportCraftChainRecipeQueLog()
            {
                // 使う場合はこのreturnを取る
                // If you want to use it, remove this return
                return;
                
                var str = "";
                
                foreach (var ques in _craftChainRecipeQue)
                {
                    foreach (var que in ques.Value)
                    {
                        var crafter = _crafterComponents.Find(c => c.NodeId == que.Key);
                        if (crafter != null)
                        {
                            var outputId = crafter.CraftingSolverRecipe.Outputs[0].ItemId;
                            var outItemName = MasterHolder.ItemMaster.GetItemMaster(outputId).Name;
                            var itemName = MasterHolder.ItemMaster.GetItemMaster(ques.Key).Name;
                            
                            str += $"Id {itemName} Count {que.Value} Output {outItemName},  ";
                        }
                    }
                }
                
                Debug.Log(str);
            }
            #endregion
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CommonBlockInventoryViewBase.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    /// <summary>
    /// インベントリを持つ基本的なブロックのクラスです。通常のインベントリを持つようなブロックであればこれを継承して実装してください。
    /// クラスの肥大化防止の為、専用処理を書かないといけなくなったときは<see cref="IBlockInventoryView"/>を実装した新たなクラスを作成してください。
    /// This is the class of the basic block with inventory. If you have a block that has a normal inventory, you can implement it by inheriting from this class.
    /// If you need to write dedicated processing to prevent class bloat, create a new class that implements <see cref="IBlockInventoryView"/>.
    /// </summary>
    public abstract class CommonBlockInventoryViewBase : MonoBehaviour, IBlockInventoryView
    {
        public IReadOnlyList<ItemSlotObject> SubInventorySlotObjects => _blockItemSlotObjects;
        public int Count => _blockItemSlotObjects.Count;
        protected readonly List<ItemSlotObject> _blockItemSlotObjects = new();
        public List<IItemStack> SubInventory { get; } = new();
        public ItemMoveInventoryInfo ItemMoveInventoryInfo { get; protected set; }
        
        public virtual void Initialize(BlockGameObject blockGameObject)
        {
            ItemMoveInventoryInfo = new ItemMoveInventoryInfo(ItemMoveInventoryType.BlockInventory, blockGameObject.BlockPosInfo.OriginalPos);
        }
        
        public void UpdateItemList(List<IItemStack> response)
        {
            SubInventory.Clear();
            SubInventory.AddRange(response);
        }
        public void UpdateInventorySlot(int slot, IItemStack item)
        {
            if (SubInventory.Count <= slot)
            {
                //TODO ログ基盤にいれる
                Debug.LogError($"インベントリのサイズを超えています。item:{item} slot:{slot}");
                return;
            }
            
            SubInventory[slot] = item;
        }
        public void DestroyUI()
        {
            Destroy(gameObject);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaMachineProcessorComponent.cs
```cs
using System;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Blocks.Util;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.EnergySystem;
using MessagePack;
using Mooresmaster.Model.MachineRecipesModule;
using UniRx;

namespace Game.Block.Blocks.Machine
{
    public class VanillaMachineProcessorComponent : IBlockStateObservable, IUpdatableBlockComponent
    {
        public ProcessState CurrentState { get; private set; } = ProcessState.Idle;
        
        public double RemainingSecond { get; private set; }
        
        public Guid RecipeGuid => _processingRecipe?.MachineRecipeGuid ?? Guid.Empty;
        public IObservable<Unit> OnChangeBlockState => _changeState;
        private readonly Subject<Unit> _changeState = new();
        
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        
        public readonly ElectricPower RequestPower;
        
        private ElectricPower _currentPower;
        private ProcessState _lastState = ProcessState.Idle;
        private MachineRecipeMasterElement _processingRecipe;
        
        
        public VanillaMachineProcessorComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            MachineRecipeMasterElement machineRecipe, ElectricPower requestPower)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            _processingRecipe = machineRecipe;
            RequestPower = requestPower;
            
            //TODO コンポーネント化する
        }
        
        public VanillaMachineProcessorComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            ProcessState currentState, double remainingSecond, MachineRecipeMasterElement processingRecipe,
            ElectricPower requestPower)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            
            _processingRecipe = processingRecipe;
            RequestPower = requestPower;
            RemainingSecond = remainingSecond;
            
            CurrentState = currentState;
        }
        
        
        public BlockStateDetail GetBlockStateDetail()
        {
            BlockException.CheckDestroy(this);
            
            var processingRate = _processingRecipe != null ? 1 - (float)RemainingSecond / _processingRecipe.Time : 0;
            var stateDetail = new CommonMachineBlockStateDetail(_currentPower.AsPrimitive(), RequestPower.AsPrimitive(), processingRate, CurrentState.ToStr(), _lastState.ToStr());
            var currentState = MessagePackSerializer.Serialize(stateDetail);
            return new BlockStateDetail(CommonMachineBlockStateDetail.BlockStateDetailKey, currentState);
        }
        
        public void SupplyPower(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            _currentPower = power;
        }
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            switch (CurrentState)
            {
                case ProcessState.Idle:
                    Idle();
                    break;
                case ProcessState.Processing:
                    Processing();
                    break;
            }
            
            //ステートの変化を検知した時か、ステートが処理中の時はイベントを発火させる
            if (_lastState != CurrentState || CurrentState == ProcessState.Processing)
            {
                _changeState.OnNext(Unit.Default);
                _lastState = CurrentState;
            }
        }
        
        private void Idle()
        {
            var isGetRecipe = _vanillaMachineInputInventory.TryGetRecipeElement(out var recipe);
            var isStartProcess = CurrentState == ProcessState.Idle && isGetRecipe &&
                   _vanillaMachineInputInventory.IsAllowedToStartProcess() &&
                   _vanillaMachineOutputInventory.IsAllowedToOutputItem(recipe);
            
            if (isStartProcess)
            {
                CurrentState = ProcessState.Processing;
                _processingRecipe = recipe;
                _vanillaMachineInputInventory.ReduceInputSlot(_processingRecipe);
                RemainingSecond = _processingRecipe.Time;
            }
        }
        
        private void Processing()
        {
            RemainingSecond -= MachineCurrentPowerToSubSecond.GetSubSecond(_currentPower, RequestPower);
            if (RemainingSecond <= 0)
            {
                CurrentState = ProcessState.Idle;
                _vanillaMachineOutputInventory.InsertOutputSlot(_processingRecipe);
            }
            
            //電力を消費する
            _currentPower = new ElectricPower(0);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
    
    public static class ProcessStateExtension
    {
        /// <summary>
        ///     <see cref="ProcessState" />をStringに変換します。
        ///     EnumのToStringを使わない理由はアロケーションによる速度低下をなくすためです。
        /// </summary>
        public static string ToStr(this ProcessState state)
        {
            return state switch
            {
                ProcessState.Idle => VanillaMachineBlockStateConst.IdleState,
                ProcessState.Processing => VanillaMachineBlockStateConst.ProcessingState,
                _ => throw new ArgumentOutOfRangeException(nameof(state), state, null),
            };
        }
    }
    
    public enum ProcessState
    {
        Idle,
        Processing,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Electric/DisplayEnergizedRange.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.UIState;
using Core.Master;
using Game.PlayerInventory.Interface;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using VContainer;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Client.Game.InGame.Electric
{
    /// <summary>
    ///     TODO 各データにアクセスしやすいようなアクセッサを作ってそっちに乗り換える
    /// </summary>
    public class DisplayEnergizedRange : MonoBehaviour
    {
        [SerializeField] private EnergizedRangeObject rangePrefab;
        private readonly List<EnergizedRangeObject> rangeObjects = new();
        
        private BlockGameObjectDataStore _blockGameObjectDataStore;
        private HotBarView _hotBarView;
        private ILocalPlayerInventory _localPlayerInventory;
        
        private bool isBlockPlaceState;
        
        [Inject]
        public void Construct(HotBarView hotBarView, UIStateControl uiStateControl, BlockGameObjectDataStore blockGameObjectDataStore, ILocalPlayerInventory localPlayerInventory)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            
            _localPlayerInventory = localPlayerInventory;
            _hotBarView = hotBarView;
            
            hotBarView.OnSelectHotBar += OnSelectHotBar;
            uiStateControl.OnStateChanged += OnStateChanged;
            blockGameObjectDataStore.OnPlaceBlock += OnPlaceBlock;
        }
        
        private void OnSelectHotBar(int index)
        {
            ResetRangeObject();
            CreateRangeObject();
        }
        
        private void OnStateChanged(UIStateEnum state)
        {
            if (isBlockPlaceState && state != UIStateEnum.GameScreen)
            {
                isBlockPlaceState = false;
                ResetRangeObject();
                return;
            }
            
            if (state != UIStateEnum.GameScreen) return;
            isBlockPlaceState = true;
            
            CreateRangeObject();
        }
        
        private void OnPlaceBlock(BlockGameObject blockGameObject)
        {
            if (!isBlockPlaceState) return;
            
            ResetRangeObject();
            CreateRangeObject();
        }
        
        
        private void ResetRangeObject()
        {
            foreach (var rangeObject in rangeObjects) Destroy(rangeObject.gameObject);
            rangeObjects.Clear();
        }
        
        
        private void CreateRangeObject()
        {
            var (isElectricalBlock, isPole) = IsDisplay();
            //電気ブロックでも電柱でもない
            if (!isElectricalBlock && !isPole) return;
            
            //電気系のブロックなので電柱の範囲を表示する
            foreach (var electricalPole in GetElectricalPoles())
            {
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(electricalPole.BlockId);
                var electricPoleParam = (ElectricPoleBlockParam)blockMasterElement.BlockParam;
                var range = isElectricalBlock ? electricPoleParam.MachineConnectionRange : electricPoleParam.PoleConnectionRange;
                
                var rangeObject = Instantiate(rangePrefab, electricalPole.transform.position, Quaternion.identity, transform);
                rangeObject.SetRange(range);
                rangeObjects.Add(rangeObject);
            }
            
            #region Internal
            
            (bool isElectricalBlock, bool isPole) IsDisplay()
            {
                var hotBarSlot = _hotBarView.SelectIndex;
                var id = _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(hotBarSlot)].Id;
                
                if (id == ItemMaster.EmptyItemId) return (false, false);
                

                if (!MasterHolder.BlockMaster.IsBlock(id)) return (false, false);
                
                var blockId = MasterHolder.BlockMaster.GetBlockId(id);
                var blockMaster = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                
                return (IsElectricalBlock(blockMaster.BlockType), IsPole(blockMaster.BlockType));
            }
            
            List<BlockGameObject> GetElectricalPoles()
            {
                var resultBlocks = new List<BlockGameObject>();
                foreach (var blocks in _blockGameObjectDataStore.BlockGameObjectDictionary)
                {
                    var blockMaster = MasterHolder.BlockMaster.GetBlockMaster(blocks.Value.BlockId);
                    if (blockMaster.BlockType != BlockTypeConst.ElectricPole) continue;
                    
                    resultBlocks.Add(blocks.Value);
                }
                
                return resultBlocks;
            }
            
            //TODO 電気系のブロックかどうか判定するロジック
            bool IsElectricalBlock(string type)
            {
                return type is BlockTypeConst.ElectricGenerator or BlockTypeConst.ElectricMachine or BlockTypeConst.ElectricMiner;
            }
            
            bool IsPole(string type)
            {
                return type is BlockTypeConst.ElectricPole;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/RequestBlockInventoryTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.BlockInventoryRequestProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class RequestBlockInventoryTest
    {
        private const int InputSlotNum = 2;
        private const int OutPutSlotNum = 3;
        
        //通常の機械のテスト
        [Test]
        public void MachineInventoryRequest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(5, 10), BlockDirection.North, out var machineBlock);
            var machineComponent = machineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            machineComponent.SetItem(0, itemStackFactory.Create(new ItemId(1), 2));
            machineComponent.SetItem(2, itemStackFactory.Create(new ItemId(4), 5));
            
            //レスポンスの取得
            var data = MessagePackSerializer.Deserialize<BlockInventoryResponseProtocolMessagePack>(packet.GetPacketResponse(RequestBlock(new Vector3Int(5, 10)))[0].ToArray());
            
            Assert.AreEqual(InputSlotNum + OutPutSlotNum, data.Items.Length); // slot num
            
            
            Assert.AreEqual(ForUnitTestModBlockId.MachineId, data.BlockId); // block id
            
            Assert.AreEqual(1, data.Items[0].Id.AsPrimitive()); // item id
            Assert.AreEqual(2, data.Items[0].Count); // item count
            
            Assert.AreEqual(0, data.Items[1].Id.AsPrimitive());
            Assert.AreEqual(0, data.Items[1].Count);
            
            Assert.AreEqual(4, data.Items[2].Id.AsPrimitive());
            Assert.AreEqual(5, data.Items[2].Count);
        }
        
        private List<byte> RequestBlock(Vector3Int pos)
        {
            return MessagePackSerializer.Serialize(new RequestBlockInventoryRequestProtocolMessagePack(pos)).ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/CommonMachineBlockStateChangeProcessor.cs
```cs
using System;
using Game.Block.Blocks.Machine;
using Game.Block.Interface.State;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    /// <summary>
    /// TODO マシーン系は自動でつけるみたいなシステムが欲しいな、、、
    /// </summary>
    public class CommonMachineBlockStateChangeProcessor : MonoBehaviour, IBlockStateChangeProcessor
    {
        public CommonMachineBlockStateDetail CurrentMachineState { get; private set; }
        
        
        private void Awake()
        {
        }
        
        private void Start()
        {

        }
        
        
        public void OnChangeState(BlockStateMessagePack blockState)
        {
            CurrentMachineState = blockState.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            var currentState = CurrentMachineState.CurrentStateType;
            var previousState = CurrentMachineState.PreviousStateType;
            
            switch (currentState)
            {
                case VanillaMachineBlockStateConst.ProcessingState:
                    if (previousState == VanillaMachineBlockStateConst.IdleState)
                    {
                    }
                    
                    break;
                case VanillaMachineBlockStateConst.IdleState:
                    break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;

namespace Game.CraftChainer.BlockComponent.Computer
{
    /// <summary>
    /// メインコンピューターはアイテムを外に出さないので、そのためのクラス
    /// The main computer does not take items out, so this class is for that
    /// </summary>
    public class CraftChainerMainComputerInserter : IBlockInventoryInserter
    {
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return itemStack;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Define/ItemObjectContainer.cs
```cs
using System;
using Client.Common;
using Core.Const;
using Core.Master;
using UnityEngine;

namespace Client.Game.InGame.Define
{
    /// <summary>
    ///     TODO このコードはalpha2.0以降で消す
    /// </summary>
    [Obsolete("Alpha2.0用のコンテナ")]
    [CreateAssetMenu(fileName = "ItemObjectContainer", menuName = "moorestech/ItemObjectContainer", order = 0)]
    public class ItemObjectContainer : ScriptableObject
    {
        [SerializeField] private ItemObjectData[] itemObjects;
        
        public ItemObjectData GetItemPrefab(ItemId itemId)
        {
            var itemGuid = MasterHolder.ItemMaster.GetItemMaster(itemId).ItemGuid;
            foreach (var itemObject in itemObjects)
            {
                if (itemObject.ItemGuid == itemGuid)
                {
                    return itemObject;
                }
            }
            
            return null;
        }
    }
    
    [Serializable]
    public class ItemObjectData
    {
        public Guid ItemGuid => Guid.Parse(itemGuid);
        public GameObject ItemPrefab => itemPrefab;
        public Vector3 Position => position;
        public Vector3 Rotation => rotation;
        
        [SerializeField] private string itemGuid;
        [SerializeField] private GameObject itemPrefab;
        [SerializeField] private Vector3 position;
        [SerializeField] private Vector3 rotation;
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/ItemShooterTest.cs
```cs
using System;
using Core.Const;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.ItemShooter;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    public class ItemShooterTest
    {
        [Test]
        public void ShooterTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemFactory = ServerContext.ItemStackFactory;
            
            // アイテムシューターのテストは、以下のように、一度下がり、再び上がるような構造になっている
            // Item shooter tests are structured to drop once and then rise again as follows
            // ↓ チェスト Chest
            // □ ＿ 
            //     ＼         ＿ ＿ → アイテムの流れ Item flow
            //        ＼ ＿ ／
            //   ↑  ↑ アイテムシューター ItemShooter
            var chestPosition = new Vector3Int(0, 0, 0);
            var horizonShooter1 = new Vector3Int(0, 0, 1);
            var downShooter1 = new Vector3Int(0, -1, 2);
            var downShooter2 = new Vector3Int(0, -2, 3);
            var horizonShooter2 = new Vector3Int(0, -2, 4);
            var upShooter = new Vector3Int(0, -2, 5);
            var horizonShooter3 = new Vector3Int(0, -1, 6);
            var horizonShooter4 = new Vector3Int(0, -1, 7);
            
            var chest = AddBlock(ForUnitTestModBlockId.ChestId, chestPosition).GetComponent<VanillaChestComponent>();
            var shooter1 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter1).GetComponent<ItemShooterComponent>();
            var down1 = AddBlock(ForUnitTestModBlockId.DownItemShooter, downShooter1).GetComponent<ItemShooterComponent>();
            var down2 = AddBlock(ForUnitTestModBlockId.DownItemShooter, downShooter2).GetComponent<ItemShooterComponent>();
            var shooter2 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter2).GetComponent<ItemShooterComponent>();
            var up = AddBlock(ForUnitTestModBlockId.UpItemShooter, upShooter).GetComponent<ItemShooterComponent>();
            var shooter3 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter3).GetComponent<ItemShooterComponent>();
            var shooter4 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter4).GetComponent<ItemShooterComponent>();
            
            chest.InsertItem(itemFactory.Create(new ItemId(1), 1));
            
            // チェストのUpdateを呼び出し
            // Call the Update of the chest
            chest.Update();
            
            // デフォルトでインサートされる速度の検証
            // Verification of the speed inserted by default
            var shooterItem1 = GetShooterItem(shooter1);
            Assert.AreEqual(1, shooterItem1.ItemId.AsPrimitive());
            Assert.AreEqual(1, shooterItem1.CurrentSpeed);
            Assert.AreEqual(1, shooterItem1.RemainingPercent);
            
            // 個々の値は実際の値をみて検証し、極端にかわってなければOKとする
            // Verify each value by looking at the actual value and OK if it is not extremely different
            var shootedItem = WaitInsertItem(down1, "1");
            Assert.IsTrue(0.7f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 0.8f);
            
            shootedItem = WaitInsertItem(down2, "Down1");
            Assert.IsTrue(1.2f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.5f);
            
            shootedItem = WaitInsertItem(shooter2, "Down2");
            Assert.IsTrue(1.7f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 2.0f);
            
            shootedItem = WaitInsertItem(up, "2");
            Assert.IsTrue(1.4f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.8f);
            
            shootedItem = WaitInsertItem(shooter3, "Up", up);
            Assert.IsTrue(0.9f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.3f);
            
            shootedItem = WaitInsertItem(shooter4, "3");
            Assert.IsTrue(0.6f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.1f);
        }
        
        private ShooterInventoryItem WaitInsertItem(ItemShooterComponent waitTarget, string tag, ItemShooterComponent waitFrom = null)
        {
            var currentTime = DateTime.Now;
            while (true)
            {
                var item = waitTarget.GetItem(0);
                if (item.Id != ItemMaster.EmptyItemId)
                {
                    // アイテム挿入時間を出力
                    var shooterItem = GetShooterItem(waitTarget);
                    var totalSeconds = (DateTime.Now - currentTime).TotalSeconds;
                    var currentSpeed = shooterItem.CurrentSpeed;
                    // 下2桁表示
                    Debug.Log($"{tag} Time: {totalSeconds:F2} Speed: {currentSpeed:F2}");
                    return shooterItem;
                }
                GameUpdater.Update();
                
                // 5秒経過したら失敗
                if ((DateTime.Now - currentTime).TotalSeconds > 5)
                {
                    Assert.Fail("インサートができていません");
                }
            }
        }
        
        private ShooterInventoryItem GetShooterItem(ItemShooterComponent target)
        {
            var item = target.BeltConveyorItems[0];
            return item as ShooterInventoryItem;
        }
        
        private IBlock AddBlock(BlockId blockId, Vector3Int position)
        {
            var world = ServerContext.WorldBlockDatastore;
            
            world.TryAddBlock(blockId, position, BlockDirection.North, out var block);
            
            return block;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Player/PlayerObjectController.cs
```cs
using Client.Game.InGame.BlockSystem;
using Client.Network.API;
using StarterAssets;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Player
{
    public interface IPlayerObjectController
    {
        public Vector3 Position { get; }
        public Vector2 Position2d { get; }
        public void SetPlayerPosition(Vector2 playerPos);
        public void SetActive(bool active);
        
        public void SetAnimationState(string state);
    }
    
    public class PlayerAnimationState
    {
        public const string IdleWalkRunBlend = "Idle Walk Run Blend";
        public const string JumpStart = "JumpStart";
        public const string JumpInAir = "JumpInAir";
        public const string JumpLand = "JumpLand";
        public const string Axe = "Axe";
    }
    
    public class PlayerObjectController : MonoBehaviour, IPlayerObjectController
    {
        public Vector3 Position => transform.position;
        public Vector2 Position2d => new(transform.position.x, transform.position.z);
        
        [SerializeField] private ThirdPersonController controller;
        [SerializeField] private Animator animator;
        
        [Inject]
        public void Construct(InitialHandshakeResponse initialHandshakeResponse)
        {
            controller.Initialize();
            SetPlayerPosition(initialHandshakeResponse.PlayerPos);
        }
        
        private void LateUpdate()
        {
            if (transform.localPosition.y < -10) SetPlayerPosition(new Vector2(transform.localPosition.x, transform.localPosition.z));
        }
        
        /// <summary>
        ///     注意：アップデートのタイミングによってはThirdPersonController.csによる戻しが発生する可能性がある
        ///     セットしても位置が変わらなかった時はThirdPersonController.csをオフにして位置がセットできているか試してください
        /// </summary>
        /// <param name="playerPos"></param>
        public void SetPlayerPosition(Vector2 playerPos)
        {
            var height = SlopeBlockPlaceSystem.GetGroundPoint(playerPos).y;
            controller.Warp(new Vector3(playerPos.x, height, playerPos.y));
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        public void SetAnimationState(string state)
        {
            animator.Play(state);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/GearMachineSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Game.PlayerInventory;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class GearMachineSaveLoadTest
    {
        //ギア機械のインベントリのあるブロックを追加した時のテスト
        //レシピやブロックが変わった時はテストコードを修正してください
        [Test]
        public void InventoryBlockTest()
        {
            //機械の追加
            var (blockFactory, worldBlockDatastore, _, assembleSaveJsonText, _) = CreateBlockTestModule();
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GearMachine, new Vector3Int(0, 0), BlockDirection.North, out var gearMachineBlock);
            var machineInventory = gearMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            
            //レシピ用のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(1), 3));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 1));
            
            //処理を開始
            gearMachineBlock.GetComponent<GearEnergyTransformer>().SupplyPower(new RPM(1000), new Torque(1000), true);
            GameUpdater.UpdateWithWait();
            //別のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(5), 6));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 4));
            
            //リフレクションで機械の状態を設定
            //機械のレシピの残り時間設定
            var vanillaMachineProcessor = gearMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            //ステータスをセット
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("RemainingSecond")
                .SetValue(vanillaMachineProcessor, 0.3);
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("CurrentState")
                .SetValue(vanillaMachineProcessor, ProcessState.Processing);
            
            //機械のアウトプットスロットの設定
            var outputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(machineInventory);
            
            outputInventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            outputInventory.SetItem(2, itemStackFactory.Create(new ItemId(3), 2));
            
            //レシピIDを取得
            var recipeId = vanillaMachineProcessor.RecipeGuid;
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            //配置したブロックを削除
            worldBlockDatastore.RemoveBlock(new Vector3Int(0, 0));
            
            
            //ロードした時に機械の状態が正しいことを確認
            var (_, loadWorldBlockDatastore, _, _, loadJsonFile) = CreateBlockTestModule();
            
            loadJsonFile.Load(json);
            
            var loadMachineBlock = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            
            //ブロックID、intIDが同じであることを確認
            Assert.AreEqual(gearMachineBlock.BlockId, loadMachineBlock.BlockId);
            Assert.AreEqual(gearMachineBlock.BlockInstanceId, loadMachineBlock.BlockInstanceId);
            
            
            //機械のレシピの残り時間のチェック
            var machineProcessor = loadMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            Assert.AreEqual(0.3, machineProcessor.RemainingSecond);
            //レシピIDのチェック
            Assert.AreEqual(recipeId, machineProcessor.RecipeGuid);
            //機械のステータスのチェック
            Assert.AreEqual(ProcessState.Processing, machineProcessor.CurrentState);
            
            
            var loadMachineInventory = loadMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            //インプットスロットのチェック
            var inputInventoryField = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(5), 6), inputInventoryField.InputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 4), inputInventoryField.InputSlot[1]);
            
            //アウトプットスロットのチェック
            var outputInventoryField = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.CreatEmpty(), outputInventoryField.OutputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 1), outputInventoryField.OutputSlot[1]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), outputInventoryField.OutputSlot[2]);
        }
        
        private (IBlockFactory, IWorldBlockDatastore, PlayerInventoryDataStore, AssembleSaveJsonText, WorldLoaderFromJson)
            CreateBlockTestModule()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var playerInventoryDataStore = serviceProvider.GetService<PlayerInventoryDataStore>();
            var loadJsonFile = serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson;
            
            return (blockFactory, worldBlockDatastore, playerInventoryDataStore, assembleSaveJsonText, loadJsonFile);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearMachineTemplate.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearMachineTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdateEvent;
        
        public VanillaGearMachineTemplate(BlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            _blockInventoryUpdateEvent = blockInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var machineParam = blockMasterElement.BlockParam as GearMachineBlockParam;
            var inventoryConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(machineParam.InventoryConnectors, blockPositionInfo);
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            var (input, output) = BlockTemplateUtil.GetMachineIOInventory(blockId, blockInstanceId, machineParam, inventoryConnectorComponent, _blockInventoryUpdateEvent);
            
            var connectSetting = machineParam.Gear.GearConnects;
            var gearConnector = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var requiredTorque = new Torque(machineParam.RequireTorque);
            var gearEnergyTransformer = new GearEnergyTransformer(requiredTorque, blockInstanceId, gearConnector);
            
            var requirePower = new ElectricPower(machineParam.RequireTorque * machineParam.RequiredRpm);
            
            // パラメーターをロードするか、新規作成する
            // Load the parameters or create new ones
            var processor = componentStates == null ? 
                new VanillaMachineProcessorComponent(input, output, null, requirePower) :
                BlockTemplateUtil.MachineLoadState(componentStates, input, output, requirePower);
            
            var blockInventory = new VanillaMachineBlockInventoryComponent(input, output);
            var machineSave = new VanillaMachineSaveComponent(input, output, processor);
            
            var machineComponent = new VanillaGearMachineComponent(processor, gearEnergyTransformer, machineParam);
            
            var components = new List<IBlockComponent>
            {
                blockInventory,
                machineSave,
                processor,
                machineComponent,
                inventoryConnectorComponent,
                gearConnector,
                gearEnergyTransformer,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerComponent.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using Newtonsoft.Json;

namespace Game.CraftChainer.BlockComponent.Computer
{
    public class CraftChainerMainComputerComponent : ICraftChainerNode
    {
        public readonly CraftChainerNetworkContext CraftChainerNetworkContext;
        
        public CraftChainerNodeId NodeId { get; } = CraftChainerNodeId.Create();
        
        public CraftChainerMainComputerComponent(BlockConnectorComponent<IBlockInventory> mainComputerConnector)
        {
            CraftChainerNetworkContext = new CraftChainerNetworkContext(mainComputerConnector, this);
        }
        
        public CraftChainerMainComputerComponent(Dictionary<string, string> componentStates, BlockConnectorComponent<IBlockInventory> mainComputerConnector) : this(mainComputerConnector)
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerMainComputerComponentJsonObject>(state);
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        /// <summary>
        /// アイテムのクラフトをリクエストする
        /// Request to create an item
        /// </summary>
        /// <returns>
        /// クラフトリクエストが成功したかどうか
        /// Whether the craft request was successful
        /// </returns>
        public bool StartCreateItem(ItemId itemId, int count)
        {
            var (recipes, initialInventory, targetItem) = CreateInitialData();
            
            var solverResult = CraftChainerCraftingSolver.Solve(recipes, initialInventory, targetItem);
            
            // アイテムは作成できなかった
            // The item could not be created
            if (solverResult == null)
            {
                return false;
            }
            
            CraftChainerNetworkContext.SetCraftChainRecipeQue(solverResult, targetItem);
            return true;
            
            #region Internal
            
            (List<CraftingSolverRecipe> recipes, Dictionary<ItemId, int> initialInventory, CraftingSolverItem targetItem) CreateInitialData()
            {
                var recipeResults = new List<CraftingSolverRecipe>();
                foreach (var crafterComponent in CraftChainerNetworkContext.CrafterComponents)
                {
                    recipeResults.Add(crafterComponent.CraftingSolverRecipe);
                }
                
                var initialInventoryResults = new Dictionary<ItemId, int>();
                foreach (var chest in CraftChainerNetworkContext.ProviderChests)
                {
                    foreach (var item in chest.Inventory)
                    {
                        if (initialInventoryResults.ContainsKey(item.Id))
                        {
                            initialInventoryResults[item.Id] += item.Count;
                        }
                        else
                        {
                            initialInventoryResults[item.Id] = item.Count;
                        }
                    }
                }
                
                var target = new CraftingSolverItem(itemId, count);
                
                return (recipeResults, initialInventoryResults, target);
            }
            
  #endregion
        }
        
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        public string SaveKey { get; } = typeof(CraftChainerMainComputerComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerMainComputerComponentJsonObject(this));
        }
    }
    
    public class ChainerMainComputerComponentJsonObject
    {
        [JsonProperty("nodeId")] public int NodeId { get; set; }
        
        public ChainerMainComputerComponentJsonObject(){}
        public ChainerMainComputerComponentJsonObject(CraftChainerMainComputerComponent component)
        {
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/CollectBeltConveyorItemsTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Entity.Interface;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Server
{
    public class CollectBeltConveyorItemsTest
    {
        //4秒で入って出るベルトコンベアで残り1秒で出る時の座標が正しいかどうかをテストする
        private const double RemainingTime = 0.5;
        private const int ItemInstanceId = 100;
        
        private readonly List<Vector2Int> _plusPlayerCoordinate = new() { new Vector2Int(0, 0) };
        
        /// <summary>
        ///     各方向に向いたベルトコンベア内のアイテムの位置が正しいかどうかをチェックする
        /// </summary>
        [Test]
        public void BlockDirectionItemPositionTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldDataStore = ServerContext.WorldBlockDatastore;
            var entityFactory = serviceProvider.GetService<IEntityFactory>();
            
            //x,yがともにプラスの時のテスト 
            
            //北向きに設置
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.North, worldDataStore);
            
            //エンティティを取得
            var itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            const float defaultY = CollectBeltConveyorItems.DefaultBeltConveyorHeight;
            Assert.AreEqual(0.5, itemEntity.Position.x); //0,0に設置してベルトコンベアの中心にアイテムがあるため、Z座標は0.5となる 
            Assert.AreEqual(defaultY, itemEntity.Position.y); //2次元座標から3次元座標に変換されているため、Y座標は0となる
            Assert.AreEqual(0.75, itemEntity.Position.z); //4秒のベルトコンベアで残り1秒の時の座標のため、1の3/4の位置にある
            //エンティティを検証
            Assert.AreEqual(ItemInstanceId, itemEntity.InstanceId.AsPrimitive());
            Assert.AreEqual(VanillaEntityType.VanillaItem, itemEntity.EntityType);
            
            
            //東向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.East, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(0.75, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.5, itemEntity.Position.z);
            
            
            //ブロックを削除し南向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.South, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.25, itemEntity.Position.z);
            
            
            //ブロックを削除し西向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.West, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //ブロックを削除し座標を検証
            Assert.AreEqual(0.25, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.5, itemEntity.Position.z);
            
            
            //x、yがマイナスであるときのテスト
            //北向きに設
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.North, worldDataStore);
            
            //エンティティを取得
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(-0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.25, itemEntity.Position.z); //ブロックの座標がマイナスなので-1を原点として3/4の値である-0.25となる
            
            
            //東向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.East, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(-0.25, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.5, itemEntity.Position.z);
            
            
            //ブロックを削除し南向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.South, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(-0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.75, itemEntity.Position.z);
            
            
            //ブロックを削除し西向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.West, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //ブロックを削除し座標を検証
            Assert.AreEqual(-0.75, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.5, itemEntity.Position.z);
        }
        
        
        /// <summary>
        ///     ベルトコンベアから別のベルトコンベアに移ってもInstanceIdは変化しないことをテスト
        /// </summary>
        [Test]
        public void ItemInstanceIdTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldDataStore = ServerContext.WorldBlockDatastore;
            
            worldDataStore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(0, 0, 1), BlockDirection.North, out var belt2);
            //二つのベルトコンベアを繋がるように設置
            
            var belt1 = CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.North, worldDataStore);
            
            //4秒間アップデートする
            var now = DateTime.Now;
            while (DateTime.Now - now < TimeSpan.FromSeconds(RemainingTime * 1.1)) GameUpdater.UpdateWithWait();
            
            //ベルトコンベアからアイテムを取得
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventory2Items = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(belt2.GetComponent<VanillaBeltConveyorComponent>());
            
            //InstanceIdが変化していないことを検証
            Assert.AreEqual(ItemInstanceId, inventory2Items[3].ItemInstanceId.AsPrimitive());
        }
        
        
        private IBlock CreateOneItemInsertedItem(Vector3Int pos, BlockDirection blockDirection, IWorldBlockDatastore datastore)
        {
            datastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, pos, blockDirection, out var beltConveyor);
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            //リフレクションで_inventoryItemsを取得
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(beltConveyorComponent);
            
            inventoryItems[0] = new VanillaBeltConveyorInventoryItem(new ItemId(1), new ItemInstanceId(ItemInstanceId));
            inventoryItems[1] = null;
            inventoryItems[2] = null;
            inventoryItems[3] = null;
            
            inventoryItems[0].RemainingPercent = 0.25f;
            
            return beltConveyor;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlaceSystem.cs
```cs
using System.Collections.Generic;
using ClassLibrary;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Player;
using Client.Game.InGame.SoundEffect;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.UIState;
using Client.Input;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.PlayerInventory.Interface;
using Server.Protocol.PacketResponse;
using UnityEngine;
using UnityEngine.EventSystems;
using VContainer.Unity;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    /// <summary>
    ///     マウスで地面をクリックしたときに発生するイベント
    /// </summary>
    public class BlockPlaceSystem : IPostTickable
    {
        public static BlockPlaceSystem Instance;
        
        private const float PlaceableMaxDistance = 100f;
        private readonly IBlockPlacePreview _blockPlacePreview;
        private readonly HotBarView _hotBarView;
        private readonly ILocalPlayerInventory _localPlayerInventory;
        private readonly Camera _mainCamera;
        private readonly PlayerObjectController _playerObjectController;
        private readonly BlockPlacePointCalculator _blockPlacePointCalculator;
        
        private BlockDirection _currentBlockDirection = BlockDirection.North;
        private Vector3Int? _clickStartPosition;
        private int _clickStartHeightOffset;
        private bool? _isStartZDirection;
        private List<PlaceInfo> _currentPlaceInfos = new();
        
        private bool _enableBlockPlace;
        
        private int _heightOffset;
        
        public BlockPlaceSystem(
            Camera mainCamera,
            HotBarView hotBarView,
            IBlockPlacePreview blockPlacePreview,
            ILocalPlayerInventory localPlayerInventory,
            BlockGameObjectDataStore blockGameObjectDataStore,
            PlayerObjectController playerObjectController
        )
        {
            Instance = this;
            _hotBarView = hotBarView;
            _mainCamera = mainCamera;
            _blockPlacePreview = blockPlacePreview;
            _localPlayerInventory = localPlayerInventory;
            _playerObjectController = playerObjectController;
            _blockPlacePointCalculator = new BlockPlacePointCalculator(blockGameObjectDataStore);
        }
        
        public static void SetEnableBlockPlace(bool enable)
        {
            if (Instance == null) return;
            
            Instance._enableBlockPlace = enable;
            if (!enable)
            {
                Instance._blockPlacePreview.SetActive(false);
            }
        }
        
        public void PostTick()
        {
            if (!_enableBlockPlace) return;
            
            UpdateHeightOffset();
            BlockDirectionControl();
            GroundClickControl();
            
            #region Internal
            
            void UpdateHeightOffset()
            {
                if (UnityEngine.Input.GetKeyDown(KeyCode.Q)) //TODO InputManagerに移す
                    _heightOffset--;
                else if (UnityEngine.Input.GetKeyDown(KeyCode.E)) _heightOffset++;
            }
            
            void BlockDirectionControl()
            {
                if (InputManager.Playable.BlockPlaceRotation.GetKeyDown)
                    // 東西南北の向きを変更する
                    _currentBlockDirection = _currentBlockDirection.HorizonRotation();
                
                //TODo シフトはインプットマネージャーに入れる
                if (UnityEngine.Input.GetKey(KeyCode.LeftShift) && InputManager.Playable.BlockPlaceRotation.GetKeyDown)
                    _currentBlockDirection = _currentBlockDirection.VerticalRotation();
            }
            
            #endregion
        }
        
        private int _lastSelectedIndex = -1;
        
        private void GroundClickControl()
        {
            var selectIndex = _hotBarView.SelectIndex;
            if (selectIndex != _lastSelectedIndex)
            {
                _clickStartPosition = null;
                _lastSelectedIndex = selectIndex;
                _clickStartHeightOffset = _heightOffset;
            }
            
            var itemId = _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(selectIndex)].Id;
            var hitPoint = Vector3.zero;
            
            //基本はプレビュー非表示
            _blockPlacePreview.SetActive(false);
            
            if (!MasterHolder.BlockMaster.IsBlock(itemId)) return; // 置けるブロックかどうか
            if (!TryGetRayHitPosition(out hitPoint)) return; // ブロック設置用のrayが当たっているか
            
            //設置座標計算 calculate place point
            var blockId = MasterHolder.BlockMaster.GetBlockId(itemId);
            var holdingBlockMaster = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            var placePoint = CalcPlacePoint();
            
            if (!IsBlockPlaceableDistance(PlaceableMaxDistance)) return; // 設置可能な距離かどうか
            
            _blockPlacePreview.SetActive(true);
            
            //クリックされてたらUIがゲームスクリーンの時にホットバーにあるブロックの設置
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && !EventSystem.current.IsPointerOverGameObject())
            {
                _clickStartPosition = placePoint;
                _clickStartHeightOffset = _heightOffset;
            }
            
            //プレビュー表示と地面との接触を取得する
            //display preview and get collision with ground
            var groundDetects = new List<bool>();
            if (_clickStartPosition.HasValue)
            {
                if (_clickStartPosition.Value == placePoint)
                {
                    _isStartZDirection = null;
                }
                else if (!_isStartZDirection.HasValue)
                {
                    _isStartZDirection = Mathf.Abs(placePoint.z - _clickStartPosition.Value.z) > Mathf.Abs(placePoint.x - _clickStartPosition.Value.x);
                }
                
                _currentPlaceInfos = _blockPlacePointCalculator.CalculatePoint(_clickStartPosition.Value, placePoint, _isStartZDirection ?? true, _currentBlockDirection, holdingBlockMaster);
                groundDetects = _blockPlacePreview.SetPreviewAndGroundDetect(_currentPlaceInfos, holdingBlockMaster);
            }
            else
            {
                _isStartZDirection = null;
                _currentPlaceInfos = _blockPlacePointCalculator.CalculatePoint(placePoint, placePoint, true, _currentBlockDirection, holdingBlockMaster);
                groundDetects = _blockPlacePreview.SetPreviewAndGroundDetect(_currentPlaceInfos, holdingBlockMaster);
            }
            
            // Placeableの更新
            // update placeable
            for (var i = 0; i < groundDetects.Count; i++)
            {
                // 地面と接触していたら設置不可
                // if collision with ground, cannot place
                if (groundDetects[i])
                {
                    _currentPlaceInfos[i].Placeable = false;
                }
            }
            
            // 設置するブロックをサーバーに送信
            // send block place info to server
            if (InputManager.Playable.ScreenLeftClick.GetKeyUp)
            {
                _heightOffset = _clickStartHeightOffset;
                _clickStartPosition = null;
                ClientContext.VanillaApi.SendOnly.PlaceHotBarBlock(_currentPlaceInfos, selectIndex);
                SoundEffectManager.Instance.PlaySoundEffect(SoundEffectType.PlaceBlock);
            }
            
            #region Internal
            
            bool IsBlockPlaceableDistance(float maxDistance)
            {
                var placePosition = (Vector3)placePoint;
                var playerPosition = _playerObjectController.transform.position;
                
                return Vector3.Distance(playerPosition, placePosition) <= maxDistance;
            }
            
            Vector3Int CalcPlacePoint()
            {
                var rotateAction = _currentBlockDirection.GetCoordinateConvertAction();
                var rotatedSize = rotateAction(holdingBlockMaster.BlockSize).Abs();
                
                var point = Vector3Int.zero;
                point.x = Mathf.FloorToInt(hitPoint.x + (rotatedSize.x % 2 == 0 ? 0.5f : 0));
                point.z = Mathf.FloorToInt(hitPoint.z + (rotatedSize.z % 2 == 0 ? 0.5f : 0));
                point.y = Mathf.FloorToInt(hitPoint.y);
                
                point += new Vector3Int(0, _heightOffset, 0);
                point -= new Vector3Int(rotatedSize.x, 0, rotatedSize.z) / 2;
                
                return point;
            }
            
            #endregion
        }
        
        
        private bool TryGetRayHitPosition(out Vector3 pos)
        {
            pos = Vector3Int.zero;
            var ray = _mainCamera.ScreenPointToRay(UnityEngine.Input.mousePosition);
            
            //画面からのrayが何かにヒットしているか
            if (!Physics.Raycast(ray, out var hit, float.PositiveInfinity, LayerConst.WithoutMapObjectAndPlayerLayerMask)) return false;
            //そのrayが地面のオブジェクトかブロックにヒットしてるか
            if (!hit.transform.TryGetComponent<GroundGameObject>(out _) && !hit.transform.TryGetComponent<BlockGameObjectChild>(out _)) return false;
            
            //基本的にブロックの原点は0,0なので、rayがヒットした座標を基準にブロックの原点を計算する
            pos = hit.point;
            
            return true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.Json;

namespace Game.Map.Interface.MapObject
{
    public interface IMapObjectDatastore
    {
        public IReadOnlyList<IMapObject> MapObjects { get; }
        
        /// <summary>
        ///     オブジェクトをロードするか生成する
        ///     既に存在するオブジェクトはデータを適応し、存在しないオブジェクトは生成する
        /// </summary>
        public void LoadMapObject(List<MapObjectJsonObject> savedMapObjects);
        
        public void Add(IMapObject mapObject);
        public IMapObject Get(int instanceId);
        
        public List<MapObjectJsonObject> GetSaveJsonObject();
        
        public event Action<IMapObject> OnDestroyMapObject;
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/MachineSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Assert = UnityEngine.Assertions.Assert;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class MachineSaveLoadTest
    {
        //インベントリのあるブロックを追加した時のテスト
        //レシピやブロックが変わった時はテストコードを修正してください
        [Test]
        public void InventoryBlockTest()
        {
            //機械の追加
            var (blockFactory, worldBlockDatastore, _, assembleSaveJsonText, _) = CreateBlockTestModule();
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId , new Vector3Int(0, 0), BlockDirection.North, out var machineBlock);
            var machineInventory = machineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            
            //レシピ用のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(1), 3));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 1));
            //処理を開始
            GameUpdater.UpdateWithWait();
            //別のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(5), 6));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 4));
            
            //リフレクションで機械の状態を設定
            //機械のレシピの残り時間設定
            var vanillaMachineProcessor = machineBlock.GetComponent<VanillaMachineProcessorComponent>();
            //ステータスをセット
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("RemainingSecond")
                .SetValue(vanillaMachineProcessor, 0.3);
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("CurrentState")
                .SetValue(vanillaMachineProcessor, ProcessState.Processing);
            
            //機械のアウトプットスロットの設定
            var outputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(machineInventory);
            
            outputInventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            outputInventory.SetItem(2, itemStackFactory.Create(new ItemId(3), 2));
            
            //レシピIDを取得
            var recipeId = vanillaMachineProcessor.RecipeGuid;
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            //配置したブロックを削除
            worldBlockDatastore.RemoveBlock(new Vector3Int(0, 0));
            
            
            //ロードした時に機械の状態が正しいことを確認
            var (_, loadWorldBlockDatastore, _, _, loadJsonFile) = CreateBlockTestModule();
            
            loadJsonFile.Load(json);
            
            var loadMachineBlock = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            
            //ブロックID、intIDが同じであることを確認
            Assert.AreEqual(machineBlock.BlockId, loadMachineBlock.BlockId);
            Assert.AreEqual(machineBlock.BlockInstanceId, loadMachineBlock.BlockInstanceId);
            
            
            //機械のレシピの残り時間のチェック
            var machineProcessor = loadMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            Assert.AreEqual(0.3, machineProcessor.RemainingSecond);
            //レシピIDのチェック
            Assert.AreEqual(recipeId, machineProcessor.RecipeGuid);
            //機械のステータスのチェック
            Assert.AreEqual(ProcessState.Processing, machineProcessor.CurrentState);
            
            
            var loadMachineInventory = loadMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            //インプットスロットのチェック
            var inputInventoryField = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(5), 6), inputInventoryField.InputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 4), inputInventoryField.InputSlot[1]);
            
            //アウトプットスロットのチェック
            var outputInventoryField = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.CreatEmpty(), outputInventoryField.OutputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 1), outputInventoryField.OutputSlot[1]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), outputInventoryField.OutputSlot[2]);
        }
        
        private (IBlockFactory, IWorldBlockDatastore, PlayerInventoryDataStore, AssembleSaveJsonText, WorldLoaderFromJson)
            CreateBlockTestModule()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var playerInventoryDataStore = serviceProvider.GetService<PlayerInventoryDataStore>();
            var loadJsonFile = serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson;
            
            return (blockFactory, worldBlockDatastore, playerInventoryDataStore, assembleSaveJsonText, loadJsonFile);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/State/CommonMachineBlockStateDetail.cs
```cs
using System;
using MessagePack;

namespace Game.Block.Interface.State
{
    /// <summary>
    ///     機械、採掘機など基本的な機械のステートの詳細なデータ
    /// </summary>
    [Serializable]
    [MessagePackObject]
    public class CommonMachineBlockStateDetail
    {
        public const string BlockStateDetailKey = "CommonMachine";
        
        /// <summary>
        ///     現在のステートの種類
        /// </summary>
        [Key(0)] public string CurrentStateType;
        
        /// <summary>
        ///     以前のステートの種類
        /// </summary>
        [Key(1)] public string PreviousStateType;
        
        /// <summary>
        ///     必要な電力に対してどの程度電力が来ているかを表す
        ///     アニメーションを再生する速度に利用する
        /// </summary>
        [Key(2)] public float PowerRate;
        
        /// <summary>
        ///     アイテムの作成がどれくらい進んでいるかを表す
        /// </summary>
        [Key(3)] public float ProcessingRate;
        
        public CommonMachineBlockStateDetail(float currentPower, float requestPower, float processingRate, string currentStateType, string previousStateType)
        {
            PowerRate = requestPower == 0 ? 1.0f : currentPower / requestPower;
            this.ProcessingRate = processingRate;
            CurrentStateType = currentStateType;
            PreviousStateType = previousStateType;
        }
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public CommonMachineBlockStateDetail()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Json/MapObjectJsonObject.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Map.Interface.Json
{
    [Serializable]
    public class MapObjectJsonObject
    {
        [JsonProperty("instanceId")] public int instanceId;
        [JsonProperty("isDestroyed")] public bool isDestroyed;
        [JsonProperty("hp")] public int hp;
        [JsonProperty("guid")] public string guidStr;
        [JsonIgnore] public Guid MapObjectGuid => new(guidStr);
        
        [JsonProperty("x")] public float x;
        [JsonProperty("y")] public float y;
        [JsonProperty("z")] public float z;
        
        [Obsolete("Json用にのみ使用してください。")]
        public MapObjectJsonObject()
        {
        }
        
        public MapObjectJsonObject(IMapObject mapObject)
        {
            instanceId = mapObject.InstanceId;
            isDestroyed = mapObject.IsDestroyed;
            guidStr = mapObject.MapObjectGuid.ToString();
            hp = mapObject.CurrentHp;
            x = mapObject.Position.x;
            y = mapObject.Position.y;
            z = mapObject.Position.z;
        }
        
        [JsonIgnore] public Vector3 Position => new(x, y, z);
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockInventory.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Block.Interface.ComponentAttribute;

namespace Game.Block.Interface.Component
{
    /// <summary>
    ///     ベルトコンベアに乗っているアイテムを機械に入れたり、機械からベルトコンベアにアイテムを載せるなどの処理をするための共通インターフェース
    ///     ブロック同士でアイテムをやり取りしたいときに使う
    /// </summary>
    [DisallowMultiple]
    public interface IBlockInventory : IBlockComponent
    {
        public IItemStack InsertItem(IItemStack itemStack);
        public bool InsertionCheck(List<IItemStack> itemStacks);
        
        public IItemStack GetItem(int slot);
        void SetItem(int slot, IItemStack itemStack);
        public int GetSlotSize();
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/VanillaBeltConveyorComponent.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Connector;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Newtonsoft.Json;

namespace Game.Block.Blocks.BeltConveyor
{
    /// <summary>
    ///     アイテムの搬出入とインベントリの管理を行う
    /// </summary>
    public class VanillaBeltConveyorComponent : IBlockInventory, IBlockSaveState, IItemCollectableBeltConveyor, IUpdatableBlockComponent
    {
        public BeltConveyorSlopeType SlopeType { get; }
        public IReadOnlyList<IOnBeltConveyorItem> BeltConveyorItems => _inventoryItems;
        private readonly VanillaBeltConveyorInventoryItem[] _inventoryItems;
        
        private readonly IBlockInventoryInserter _blockInventoryInserter;
        private readonly int _inventoryItemNum;
        
        private double _timeOfItemEnterToExit; //ベルトコンベアにアイテムが入って出るまでの時間
        
        public VanillaBeltConveyorComponent(int inventoryItemNum, float timeOfItemEnterToExit, IBlockInventoryInserter blockInventoryInserter, BeltConveyorSlopeType slopeType)
        {
            SlopeType = slopeType;
            _inventoryItemNum = inventoryItemNum;
            _timeOfItemEnterToExit = timeOfItemEnterToExit;
            _blockInventoryInserter = blockInventoryInserter;
            
            _inventoryItems = new VanillaBeltConveyorInventoryItem[inventoryItemNum];
        }
        
        public VanillaBeltConveyorComponent(Dictionary<string, string> componentStates, int inventoryItemNum, float timeOfItemEnterToExit, IBlockInventoryInserter blockInventoryInserter, BeltConveyorSlopeType slopeType) :
            this(inventoryItemNum, timeOfItemEnterToExit, blockInventoryInserter, slopeType)
        {
            var itemJsons = JsonConvert.DeserializeObject<List<string>>(componentStates[SaveKey]);
            for (var i = 0; i < itemJsons.Count; i++)
            {
                if (itemJsons[i] != null)
                {
                    _inventoryItems[i] = VanillaBeltConveyorInventoryItem.LoadItem(itemJsons[i]);
                }
            }
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //新しく挿入可能か
            if (_inventoryItems[^1] != null)
                //挿入可能でない
                return itemStack;
            
            _inventoryItems[^1] = new VanillaBeltConveyorInventoryItem(itemStack.Id, itemStack.ItemInstanceId);
            
            //挿入したのでアイテムを減らして返す
            return itemStack.SubItem(1);
        }
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            // 空きスロットがない
            if (_inventoryItems[^1] != null) return false;
            
            // 挿入スロットが1個かどうか
            if (itemStacks.Count == 1 && itemStacks[0].Count == 1) return true;
            
            return false;
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            
            return _inventoryItems.Length;
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            if (_inventoryItems[slot] == null) return itemStackFactory.CreatEmpty();
            return itemStackFactory.Create(_inventoryItems[slot].ItemId, 1);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //TODO lockすべき？？
            _inventoryItems[slot] = new VanillaBeltConveyorInventoryItem(itemStack.Id, itemStack.ItemInstanceId);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public string SaveKey { get; } = typeof(VanillaBeltConveyorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var saveItems = new List<string>();
            foreach (var t in _inventoryItems)
            {
                saveItems.Add(t?.GetSaveJsonString());
            }
            
            return JsonConvert.SerializeObject(saveItems);
        }
        
        /// <summary>
        ///     アイテムの搬出判定を行う
        ///     判定はUpdateで毎フレーム行われる
        ///     TODO 個々のマルチスレッド対応もいい感じにやりたい
        /// </summary>
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            //TODO lockすべき？？
            var count = _inventoryItems.Length;
            
            for (var i = 0; i < count; i++)
            {
                var item = _inventoryItems[i];
                if (item == null) continue;
                
                //次のインデックスに入れる時間かどうかをチェックする
                var nextIndexStartTime = i * (1f / _inventoryItemNum);
                var isNextInsertable = item.RemainingPercent <= nextIndexStartTime;
                
                //次に空きがあれば次に移動する
                if (isNextInsertable && i != 0)
                {
                    if (_inventoryItems[i - 1] == null)
                    {
                        _inventoryItems[i - 1] = item;
                        _inventoryItems[i] = null;
                    }
                }
                
                //最後のアイテムの場合は接続先に渡す
                if (i == 0 && item.RemainingPercent <= 0)
                {
                    var insertItem = ServerContext.ItemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
                    
                    var output = _blockInventoryInserter.InsertItem(insertItem);
                    
                    //渡した結果がnullItemだったらそのアイテムを消す
                    if (output.Id == ItemMaster.EmptyItemId) _inventoryItems[i] = null;
                    
                    continue;
                }
                
                //時間を減らす 
                var diff = (float)(GameUpdater.UpdateSecondTime * (1f / (float)_timeOfItemEnterToExit));
                var last = item.RemainingPercent;
                item.RemainingPercent -= diff;
                var current = item.RemainingPercent;
                
                if (item.ItemInstanceId.AsPrimitive() != 0)
                {
                    UnityEngine.Debug.Log($"Belt Last:{last:F3} Current:{current:F3} Diff:{diff:F3} {item.ItemInstanceId}");
                }
            }
        }
        
        public void SetTimeOfItemEnterToExit(double time)
        {
            _timeOfItemEnterToExit = time;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Blocks/StationComponent.cs
```cs
using Game.Block.Interface.Component;
using Game.Train.Train;
namespace Game.Train.Blocks
{
    public class StationComponent : IBlockComponent
    {
        public string StationName { get; }

        // 駅の長さ（何両分か）
        private int _stationLength;

        // 現在使用中の列車単位
        private TrainUnit _currentTrain;

        // IBlockComponentからのメンバ
        public bool IsDestroy { get; private set; }

        public StationComponent(int stationLength, string stationName = "DefaultStation")
        {
            _stationLength = stationLength;
            _currentTrain = null;
            IsDestroy = false;
            StationName = stationName;
        }


        // 列車が駅に到着したときの処理
        public bool TrainArrived(TrainUnit train)
        {
            // すでに列車がいる場合は何もしない
            if (_currentTrain != null)
            {
                return false;
            }

            // 列車が駅に入る
            _currentTrain = train;
            return true;
        }

        // 列車が駅から出発したときの処理
        public bool TrainDeparted(TrainUnit train)
        {
            // 列車がいない場合は何もしない
            if (_currentTrain == null)
            {
                return false;
            }

            // 列車が駅から出る
            _currentTrain = null;
            return true;
        }


        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearMachineIoTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.MachineRecipesModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class GearMachineIoTest
    {
        public int GearMachineRecipeIndex = 3;
        
        //アイテムが通常通り処理されるかのテスト
        [Test]
        public void ItemProcessingOutputTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[GearMachineRecipeIndex];
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var block = blockFactory.Create(blockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var blockInventory = block.GetComponent<VanillaMachineBlockInventoryComponent>();
            foreach (var inputItem in recipe.InputItems)
            {
                blockInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var gearEnergyTransformer = block.GetComponent<GearEnergyTransformer>();
            var gearMachineParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearMachine).BlockParam as GearMachineBlockParam;
            var machineProcessor = block.GetComponent<VanillaMachineProcessorComponent>();
            
            //最大クラフト時間を超過するまでクラフトする
            var craftTime = DateTime.Now.AddSeconds(recipe.Time);
            while (craftTime.AddSeconds(0.4).CompareTo(DateTime.Now) == 1)
            {
                var requiredRpm = new RPM(gearMachineParam.RequiredRpm);
                var requiredTorque = new Torque(gearMachineParam.RequireTorque);
                gearEnergyTransformer.SupplyPower(requiredRpm, requiredTorque, true);
                machineProcessor.Update();
                GameUpdater.Wait();
                GameUpdater.UpdateDeltaTime();
            }
            
            //検証
            AssertInventory(blockInventory, recipe);
        }
        
        
        [Test]
        // RPM、トルクが足りないときに処理に時間がかかるテスト
        public void NotEnoughTorqueOrRpmTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[GearMachineRecipeIndex];
            
            var recipeBlockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var lackRpmBlock = blockFactory.Create(recipeBlockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var lackTorqueBlock = blockFactory.Create(recipeBlockId, new BlockInstanceId(2), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.zero));
            
            var lackRpmInventory = lackRpmBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            var lackTorqueInventory = lackTorqueBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            foreach (var inputItem in recipe.InputItems)
            {
                lackRpmInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
                lackTorqueInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var lackRpmGearMachine = lackRpmBlock.GetComponent<GearEnergyTransformer>();
            var lackTorqueGearMachine = lackTorqueBlock.GetComponent<GearEnergyTransformer>();
            var gearMachineParam = lackRpmBlock.BlockMasterElement.BlockParam as GearMachineBlockParam;
            
            var lackRpmProcessor = lackRpmBlock.GetComponent<VanillaMachineProcessorComponent>();
            var lackTorqueProcessor = lackTorqueBlock.GetComponent<VanillaMachineProcessorComponent>();
            
            //最大クラフト時間を超過するまでクラフトする
            var craftTime = DateTime.Now.AddSeconds(recipe.Time * 2);
            while (craftTime.AddSeconds(0.3).CompareTo(DateTime.Now) == 1)
            {
                var rpm = new RPM(gearMachineParam.RequiredRpm / 2f);
                lackRpmGearMachine.SupplyPower(rpm, new Torque(gearMachineParam.RequireTorque), true);
                lackTorqueGearMachine.SupplyPower(new RPM(gearMachineParam.RequiredRpm), (Torque)gearMachineParam.RequireTorque / 2f, true);
                
                lackRpmProcessor.Update();
                lackTorqueProcessor.Update();
                
                GameUpdater.Wait();
                GameUpdater.UpdateDeltaTime();
            }
            
            //検証
            AssertInventory(lackRpmInventory, recipe);
            AssertInventory(lackTorqueInventory, recipe);
        }
        
        private void AssertInventory(VanillaMachineBlockInventoryComponent inventory, MachineRecipeMasterElement recipe)
        {
            (List<IItemStack> input, List<IItemStack> output) = GetInputOutputSlot(inventory);
            
            Assert.AreEqual(0, input.Count);
            foreach (var inputItem in input) Assert.AreEqual(ItemMaster.EmptyItemId, inputItem.Id);
            
            Assert.AreNotEqual(0, output.Count);
            for (var i = 0; i < output.Count; i++)
            {
                var outputItemId = MasterHolder.ItemMaster.GetItemId(recipe.OutputItems[i].ItemGuid);
                Assert.AreEqual(outputItemId, output[i].Id);
                Assert.AreEqual(recipe.OutputItems[i].Count, output[i].Count);
            }
        }
        
        private (List<IItemStack>, List<IItemStack>) GetInputOutputSlot(VanillaMachineBlockInventoryComponent vanillaMachineInventory)
        {
            var vanillaMachineInputInventory = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            var vanillaMachineOutputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            
            var inputSlot = vanillaMachineInputInventory.InputSlot.Where(i => i.Count != 0).ToList();
            inputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            var outputSlot = vanillaMachineOutputInventory.OutputSlot.Where(i => i.Count != 0).ToList();
            outputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            return (inputSlot, outputSlot);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaGearMachineComponent.cs
```cs
using Game.Block.Blocks.Gear;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.Block.Blocks.Machine
{
    /// <summary>
    ///     歯車機械を表すクラス
    /// </summary>
    public class VanillaGearMachineComponent : IBlockComponent
    {
        private readonly GearEnergyTransformer _gearEnergyTransformer;
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        private readonly GearMachineBlockParam _gearMachineBlockParam;
        
        public VanillaGearMachineComponent(VanillaMachineProcessorComponent vanillaMachineProcessorComponent, GearEnergyTransformer gearEnergyTransformer, GearMachineBlockParam gearMachineBlockParam)
        {
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
            _gearEnergyTransformer = gearEnergyTransformer;
            _gearMachineBlockParam = gearMachineBlockParam;
            
            _gearEnergyTransformer.OnGearUpdate.Subscribe(OnGearUpdate);
        }
        
        private void OnGearUpdate(GearUpdateType gearUpdateType)
        {
            var requiredRpm = new RPM(_gearMachineBlockParam.RequiredRpm);
            var requireTorque = new Torque(_gearMachineBlockParam.RequireTorque);
            
            var currentElectricPower = _gearEnergyTransformer.CalcMachineSupplyPower(requiredRpm, requireTorque);
            _vanillaMachineProcessorComponent.SupplyPower(currentElectricPower);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            BlockException.CheckDestroy(this);
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineOutputInventory.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Service;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Context;
using Mooresmaster.Model.MachineRecipesModule;
using UniRx;

namespace Game.Block.Blocks.Machine.Inventory
{
    public class VanillaMachineOutputInventory
    {
        public IReadOnlyList<IItemStack> OutputSlot => _itemDataStoreService.InventoryItems;
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly ConnectingInventoryListPriorityInsertItemService _connectInventoryService;
        private readonly BlockInstanceId _blockInstanceId;
        
        private readonly int _inputSlotSize;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        public VanillaMachineOutputInventory(int outputSlot, IItemStackFactory itemStackFactory,
            BlockOpenableInventoryUpdateEvent blockInventoryUpdate, BlockInstanceId blockInstanceId, int inputSlotSize, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockInventoryUpdate = blockInventoryUpdate;
            _blockInstanceId = blockInstanceId;
            _inputSlotSize = inputSlotSize;
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, itemStackFactory, outputSlot);
            _connectInventoryService = new ConnectingInventoryListPriorityInsertItemService(blockConnectorComponent);
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        private void Update()
        {
            InsertConnectInventory();
        }
        
        /// <summary>
        ///     アウトプットスロットにアイテムを入れれるかチェック
        /// </summary>
        /// <param name="machineRecipe"></param>
        /// <returns>スロットに空きがあったらtrue</returns>
        public bool IsAllowedToOutputItem(MachineRecipeMasterElement machineRecipe)
        {
            foreach (var itemOutput in machineRecipe.OutputItems)
            {
                var outputItemId = MasterHolder.ItemMaster.GetItemId(itemOutput.ItemGuid);
                var outputItemStack = ServerContext.ItemStackFactory.Create(outputItemId, itemOutput.Count);
                
                var isAllowed = OutputSlot.Aggregate(false, (current, slot) => slot.IsAllowedToAdd(outputItemStack) || current);
                
                if (!isAllowed) return false;
            }
            
            return true;
        }
        
        public void InsertOutputSlot(MachineRecipeMasterElement machineRecipe)
        {
            //アウトプットスロットにアイテムを格納する
            foreach (var itemOutput in machineRecipe.OutputItems)
                for (var i = 0; i < OutputSlot.Count; i++)
                {
                    var outputItemId = MasterHolder.ItemMaster.GetItemId(itemOutput.ItemGuid);
                    var outputItemStack = ServerContext.ItemStackFactory.Create(outputItemId, itemOutput.Count);
                    
                    if (!OutputSlot[i].IsAllowedToAdd(outputItemStack)) continue;
                    
                    var item = OutputSlot[i].AddItem(outputItemStack).ProcessResultItemStack;
                    _itemDataStoreService.SetItem(i, item);
                    break;
                }
        }
        
        private void InsertConnectInventory()
        {
            for (var i = 0; i < OutputSlot.Count; i++)
                _itemDataStoreService.SetItem(i, _connectInventoryService.InsertItem(OutputSlot[i]));
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(
                _blockInstanceId, slot + _inputSlotSize, itemStack));
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/GetMapObjectInfoProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     map objectの破壊状況を送信するプロトコル
    /// </summary>
    public class GetMapObjectInfoProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:mapObjectInfo";
        
        private readonly IMapObjectDatastore _mapObjectDatastore;
        
        public GetMapObjectInfoProtocol(ServiceProvider serviceProvider)
        {
            _mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var sendMapObjects = new List<MapObjectsInfoMessagePack>();
            foreach (var mapObject in _mapObjectDatastore.MapObjects)
                sendMapObjects.Add(new MapObjectsInfoMessagePack(mapObject.InstanceId, mapObject.IsDestroyed));
            
            var response = new ResponseMapObjectInfosMessagePack(sendMapObjects);
            
            return response;
        }
        
        
        
        [MessagePackObject]
        public class RequestMapObjectInfosMessagePack : ProtocolMessagePackBase
        {
            public RequestMapObjectInfosMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
        
        [MessagePackObject]
        public class ResponseMapObjectInfosMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<MapObjectsInfoMessagePack> MapObjects { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseMapObjectInfosMessagePack() { }
            
            public ResponseMapObjectInfosMessagePack(List<MapObjectsInfoMessagePack> mapObjects)
            {
                Tag = ProtocolTag;
                MapObjects = mapObjects;
            }
        }
        
        [MessagePackObject]
        public class MapObjectsInfoMessagePack
        {
            [Key(0)] public int InstanceId { get; set; }
            [Key(1)] public bool IsDestroyed { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public MapObjectsInfoMessagePack() { }
            public MapObjectsInfoMessagePack(int instanceId, bool isDestroyed)
            {
                InstanceId = instanceId;
                IsDestroyed = isDestroyed;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Entity/EntityObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Network.API;
using Core.Master;
using Game.Entity.Interface;
using UnityEngine;

namespace Client.Game.InGame.Entity
{
    public class EntityObjectDatastore : MonoBehaviour
    {
        [SerializeField] private ItemEntityObject itemPrefab;
        
        private readonly Dictionary<long, (DateTime lastUpdate, IEntityObject objectEntity)> _entities = new();
        
        /// <summary>
        ///     エンティティ最終更新時間をチェックし、一定時間経過していたら削除する
        /// </summary>
        private void Update()
        {
            //1秒以上経過していたら削除
            var removeEntities = new List<long>();
            foreach (var entity in _entities)
                if ((DateTime.Now - entity.Value.lastUpdate).TotalSeconds > 1)
                    removeEntities.Add(entity.Key);
            foreach (var removeEntity in removeEntities)
            {
                _entities[removeEntity].objectEntity.Destroy();
                _entities.Remove(removeEntity);
            }
        }
        
        /// <summary>
        ///     エンティティの生成、更新を行う
        /// </summary>
        public void OnEntitiesUpdate(List<EntityResponse> entities)
        {
            foreach (var entity in entities)
                if (_entities.ContainsKey(entity.InstanceId))
                {
                    _entities[entity.InstanceId].objectEntity.SetInterpolationPosition(entity.Position);
                    _entities[entity.InstanceId] = (DateTime.Now, _entities[entity.InstanceId].objectEntity);
                }
                else
                {
                    var entityObject = CreateEntity(entity);
                    _entities.Add(entity.InstanceId, (DateTime.Now, entityObject));
                }
        }
        
        /// <summary>
        ///     タイプに応じたエンティティの作成
        /// </summary>
        private IEntityObject CreateEntity(EntityResponse entity)
        {
            if (entity.Type == VanillaEntityType.VanillaItem)
            {
                var item = Instantiate(itemPrefab, entity.Position, Quaternion.identity, transform);
                
                var id = new ItemId(int.Parse(entity.State.Split(',')[0]));
                var viewData = ClientContext.ItemImageContainer.GetItemView(id);
                Texture texture = null;
                if (viewData == null)
                {
                    Debug.LogError("ItemTexture Not Found  ItemId:" + id);
                }
                else
                {
                    texture = viewData.ItemTexture;
                }
                item.SetTexture(texture);
                return item;
            }
            
            throw new ArgumentException("エンティティタイプがありません");
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/MapObjectDestructionInformationTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.GetMapObjectInfoProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class MapObjectDestructionInformationTest
    {
        [Test]
        public void GetMapObjectTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            
            
            //一個だけマップオブジェクトを破壊
            mapObjectDatastore.Get(mapObjectDatastore.MapObjects[0].InstanceId).Destroy();
            
            
            var responseArray = packet.GetPacketResponse(MapObjectDestructionInformationProtocol())[0];
            var response = MessagePackSerializer.Deserialize<ResponseMapObjectInfosMessagePack>(responseArray.ToArray());
            
            foreach (var mapObject in mapObjectDatastore.MapObjects)
            {
                var responseObject =
                    response.MapObjects.Find(m => m.InstanceId == mapObject.InstanceId);
                Assert.AreEqual(mapObject.IsDestroyed, responseObject.IsDestroyed);
            }
        }
        
        // Packet
        private List<byte> MapObjectDestructionInformationProtocol()
        {
            return MessagePackSerializer.Serialize(new RequestMapObjectInfosMessagePack()).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaMachineSaveComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Newtonsoft.Json;

namespace Game.Block.Blocks.Machine
{
    public class VanillaMachineSaveComponent : IBlockSaveState
    {
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        
        public VanillaMachineSaveComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            VanillaMachineProcessorComponent vanillaMachineProcessorComponent)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
        }
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        [Obsolete("機械のセーブ周りのリファクタをしたい")] // TODO 機械のセーブ、保存周りのリファクタ
        public static string SaveKeyStatic => typeof(VanillaMachineSaveComponent).FullName;
        public string SaveKey { get; } = typeof(VanillaMachineSaveComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            // JsonObjectにリファクタ
            var jsonObject = new VanillaMachineJsonObject
            {
                InputSlot = _vanillaMachineInputInventory.InputSlot.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
                OutputSlot = _vanillaMachineOutputInventory.OutputSlot.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
                State = (int)_vanillaMachineProcessorComponent.CurrentState,
                RemainingTime = _vanillaMachineProcessorComponent.RemainingSecond,
                RecipeGuidStr = _vanillaMachineProcessorComponent.RecipeGuid.ToString(),
            };
            
            return JsonConvert.SerializeObject(jsonObject);
        }
    }
    
    public class VanillaMachineJsonObject
    {
        [JsonProperty("inputSlot")]
        public List<ItemStackSaveJsonObject> InputSlot;
        [JsonProperty("outputSlot")]
        public List<ItemStackSaveJsonObject> OutputSlot;
        [JsonProperty("recipeGuid")]
        public string RecipeGuidStr;
        [JsonIgnore]
        public Guid RecipeGuid => Guid.Parse(RecipeGuidStr);
        
        [JsonProperty("remainingTime")]
        public double RemainingTime;
        
        [JsonProperty("state")]
        public int State;
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/MapObjectUpdateEventPacketTest.cs
```cs
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class MapObjectUpdateEventPacketTest
    {
        private const int PlayerId = 1;
        
        [Test]
        public void MapObjectDestroyToEventTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            
            var response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(PlayerId));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            //イベントがないことを確認する
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            
            //MapObjectを一つ破壊する
            var mapObject = mapObjectDatastore.MapObjects[0];
            mapObject.Destroy();
            
            //map objectが破壊されたことを確かめる
            response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(1, eventMessagePack.Events.Count);
            
            var data = MessagePackSerializer.Deserialize<MapObjectUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(MapObjectUpdateEventMessagePack.DestroyEventType, data.EventType);
            Assert.AreEqual(mapObject.InstanceId, data.InstanceId);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/MapObjectPin.cs
```cs
using System;
using System.Linq;
using Client.Game.InGame.Control;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Mooresmaster.Model.ChallengesModule;
using TMPro;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Tutorial
{
    public class MapObjectPin : MonoBehaviour, ITutorialView, ITutorialViewManager
    {
        public const string TutorialType = "mapObjectPin";
        
        [SerializeField] private TMP_Text pinText;
        
        private InGameCameraController _inGameCameraController;
        private MapObjectGameObjectDatastore _mapObjectGameObjectDatastore;
        private IPlayerObjectController _playerObjectController;
        
        private MapObjectPinTutorialParam _currentTutorialParam;
        private IDisposable _mapObjectOnDestroy;
        
        [Inject]
        public void Construct(InGameCameraController inGameCameraController, MapObjectGameObjectDatastore mapObjectGameObjectDatastore, IPlayerObjectController playerObjectController)
        {
            _inGameCameraController = inGameCameraController;
            _mapObjectGameObjectDatastore = mapObjectGameObjectDatastore;
            _playerObjectController = playerObjectController;
        }
        
        private void Update()
        {
            // Y軸を常にカメラに向ける
            transform.LookAt(_inGameCameraController.Position);
            transform.rotation = Quaternion.Euler(0, transform.rotation.eulerAngles.y, 0);
        }
        
        public ITutorialView ApplyTutorial(ITutorialParam param)
        {
            _currentTutorialParam = (MapObjectPinTutorialParam)param;
            
            _mapObjectOnDestroy?.Dispose();
            
            // 近くのMapObjectを探してピンを表示
            var mapObjects = _mapObjectGameObjectDatastore.CreateMapObjectList(_currentTutorialParam.MapObjectGuid);
            var playerPos = _playerObjectController.Position;
            var sortedMapObjects = mapObjects.OrderBy(x => (playerPos - x.GetPosition()).sqrMagnitude).ToList();
            if (sortedMapObjects.Count == 0)
            {
                Debug.LogWarning($"未破壊のMapObject {_currentTutorialParam.MapObjectGuid} が存在しません");
                return null;
            }
            
            var nearMapObject = sortedMapObjects.First();
            transform.position = nearMapObject.GetPosition();
            
            // そのMapObjectが破壊されたら別のmapObjectを探す
            _mapObjectOnDestroy = nearMapObject.OnDestroyMapObject.Subscribe(_ =>
            {
                ApplyTutorial(_currentTutorialParam);
            }).AddTo(this);
            
            // ピンのテキストを設定
            pinText.text = _currentTutorialParam.PinText;
            
            SetActive(true);
            
            return this;
        }
        
        public void CompleteTutorial()
        {
            SetActive(false);
            _currentTutorialParam = null;
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/BlockTemplateUtil.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.InventoryConnectsModule;
using Newtonsoft.Json;

namespace Game.Block.Factory.BlockTemplate
{
    public class BlockTemplateUtil
    {
        public static BlockConnectorComponent<IBlockInventory> CreateInventoryConnector(InventoryConnects inventoryConnects, BlockPositionInfo blockPositionInfo)
        {
            return new BlockConnectorComponent<IBlockInventory>(inventoryConnects.InputConnects, inventoryConnects.OutputConnects, blockPositionInfo);
        }
        
        // TODO 保存ステートを誰でも持てるようになったので、このあたりも各自でセーブ、ロードできるように簡略化したい
        public static (VanillaMachineInputInventory, VanillaMachineOutputInventory) GetMachineIOInventory(
            BlockId blockId,BlockInstanceId blockInstanceId,
            IMachineParam machineParam, 
            BlockConnectorComponent<IBlockInventory> blockConnectorComponent,
            BlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            var inputSlotCount = machineParam.InputSlotCount;
            var outputSlotCount = machineParam.OutputSlotCount;
            
            var input = new VanillaMachineInputInventory(
                blockId, inputSlotCount,
                blockInventoryUpdateEvent, blockInstanceId);
            
            var output = new VanillaMachineOutputInventory(
                outputSlotCount, ServerContext.ItemStackFactory, blockInventoryUpdateEvent, blockInstanceId,
                inputSlotCount, blockConnectorComponent);
            
            return (input, output);
        }
        
        public static VanillaMachineProcessorComponent MachineLoadState(
            Dictionary<string, string> componentStates,
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            ElectricPower requestPower)
        {
            var state = componentStates[VanillaMachineSaveComponent.SaveKeyStatic];
            var jsonObject = JsonConvert.DeserializeObject<VanillaMachineJsonObject>(state);
            
            var inputItems = jsonObject.InputSlot.Select(item => item.ToItemStack()).ToList();
            for (var i = 0; i < inputItems.Count; i++)
            {
                vanillaMachineInputInventory.SetItem(i, inputItems[i]);
            }
            
            var outputItems = jsonObject.OutputSlot.Select(item => item.ToItemStack()).ToList();
            for (var i = 0; i < outputItems.Count; i++)
            {
                vanillaMachineOutputInventory.SetItem(i, outputItems[i]);
            }
            
            var recipe = jsonObject.RecipeGuid == Guid.Empty ?
                null :
                MasterHolder.MachineRecipesMaster.GetRecipeElement(jsonObject.RecipeGuid);
            
            var processor = new VanillaMachineProcessorComponent(
                vanillaMachineInputInventory,
                vanillaMachineOutputInventory,
                (ProcessState)jsonObject.State,
                jsonObject.RemainingTime,
                recipe,
                requestPower);
            
            return processor;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Element/ItemSlotObject.cs
```cs
using System;
using Client.Game.InGame.UI.Util;
using Client.Mod.Texture;
using Core.Const;
using Core.Master;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Element
{
    public class ItemSlotObject : MonoBehaviour, IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerClickHandler, IPointerExitHandler, IPointerMoveHandler
    {
        [SerializeField] private Image itemImage;
        
        [SerializeField] private GameObject normalFrame;
        [SerializeField] private GameObject machineSlotFrame;
        [SerializeField] private GameObject craftRecipeFrame;
        
        [SerializeField] private GameObject hotBarSelect;
        
        [SerializeField] private GameObject grayOutImage;
        [SerializeField] private GameObject hoverImage; // TODO 後で対応
        [SerializeField] private GameObject clickImage; // TODO 後で対応
        
        [SerializeField] private GameObject normalItemSlotObject;
        [SerializeField] private GameObject noneCrossObject;
        
        [SerializeField] private TMP_Text countText;
        [SerializeField] private UIEnterExplainerController uiEnterExplainerController;
        
        private bool _onPointing;
        
        public ItemViewData ItemViewData { get; private set; }
        public int Count { get; private set; }
        
        private void Awake()
        {
            OnPointerEvent.Subscribe(OnInvokeOtherEvent).AddTo(this);
            SubscribeHover();
            SubscribeClick();
        }
        
        private void SubscribeHover()
        {
            _onCursorEnter.Subscribe(_ => hoverImage.SetActive(true)).AddTo(this);
            _onCursorExit.Subscribe(_ => hoverImage.SetActive(false)).AddTo(this);
        }
        
        private void SubscribeClick()
        {
            _onLeftClickDown.Subscribe(_ => clickImage.SetActive(true)).AddTo(this);
            _onLeftClickUp.Subscribe(_ => clickImage.SetActive(false)).AddTo(this);
        }
        
        
        public void SetItem(ItemViewData itemView, int count)
        {
            ItemViewData = itemView;
            
            Count = count;
            countText.text = count != 0 ? count.ToString() : string.Empty;
            
            if (itemView == null || itemView.ItemId == ItemMaster.EmptyItemId)
            {
                itemImage.gameObject.SetActive(false);
                
                uiEnterExplainerController.DisplayEnable(false);
            }
            else
            {
                itemImage.gameObject.SetActive(true);
                itemImage.sprite = itemView.ItemImage;
                
                uiEnterExplainerController.SetText($"{itemView.ItemName}\n<size=25>ID:{itemView.ItemId}</size>", false);
                uiEnterExplainerController.DisplayEnable(true);
            }
        }
        
        public void SetGrayOut(bool active)
        {
            grayOutImage.SetActive(active);
        }
        
        public void SetFrame(ItemSlotFrameType frameType)
        {
            normalFrame.SetActive(frameType == ItemSlotFrameType.Normal);
            machineSlotFrame.SetActive(frameType == ItemSlotFrameType.MachineSlot);
            craftRecipeFrame.SetActive(frameType == ItemSlotFrameType.CraftRecipe);
        }
        
        public void SetItemSlotType(ItemSlotType slotType)
        {
            normalItemSlotObject.SetActive(slotType == ItemSlotType.Normal);
            noneCrossObject.SetActive(slotType == ItemSlotType.NoneCross);
        }
        
        public void SetHotBarSelect(bool active)
        {
            hotBarSelect.SetActive(active);
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        
        #region PointerEvents
        
        public IObservable<(ItemSlotObject, ItemUIEventType)> OnPointerEvent => _onPointerEvent;
        private readonly Subject<(ItemSlotObject, ItemUIEventType)> _onPointerEvent = new();
        
        public IObservable<ItemSlotObject> OnRightClickDown => _onRightClickDown;
        private readonly Subject<ItemSlotObject> _onRightClickDown = new();
        public IObservable<ItemSlotObject> OnLeftClickDown => _onLeftClickDown;
        private readonly Subject<ItemSlotObject> _onLeftClickDown = new();
        public IObservable<ItemSlotObject> OnRightClickUp => _onRightClickUp;
        private readonly Subject<ItemSlotObject> _onRightClickUp = new();
        public IObservable<ItemSlotObject> OnLeftClickUp => _onLeftClickUp;
        private readonly Subject<ItemSlotObject> _onLeftClickUp = new();
        public IObservable<ItemSlotObject> OnCursorEnter => _onCursorEnter;
        private readonly Subject<ItemSlotObject> _onCursorEnter = new();
        public IObservable<ItemSlotObject> OnCursorExit => _onCursorExit;
        private readonly Subject<ItemSlotObject> _onCursorExit = new();
        public IObservable<ItemSlotObject> OnCursorMove => _onCursorMove;
        private readonly Subject<ItemSlotObject> _onCursorMove = new();
        public IObservable<ItemSlotObject> OnDoubleClick => _onDoubleClick;
        private readonly Subject<ItemSlotObject> _onDoubleClick = new();
        
        private void OnInvokeOtherEvent((ItemSlotObject, ItemUIEventType) data)
        {
            var type = data.Item2;
            var slot = data.Item1;
            switch (type)
            {
                case ItemUIEventType.RightClickDown:
                    _onRightClickDown.OnNext(slot);
                    break;
                case ItemUIEventType.LeftClickDown:
                    _onLeftClickDown.OnNext(slot);
                    break;
                case ItemUIEventType.RightClickUp:
                    _onRightClickUp.OnNext(slot);
                    break;
                case ItemUIEventType.LeftClickUp:
                    _onLeftClickUp.OnNext(slot);
                    break;
                case ItemUIEventType.CursorEnter:
                    _onCursorEnter.OnNext(slot);
                    break;
                case ItemUIEventType.CursorExit:
                    _onCursorExit.OnNext(slot);
                    break;
                case ItemUIEventType.CursorMove:
                    _onCursorMove.OnNext(slot);
                    break;
                case ItemUIEventType.DoubleClick:
                    _onDoubleClick.OnNext(slot);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
        
        public void OnPointerClick(PointerEventData eventData)
        {
            if (2 == eventData.clickCount && eventData.button == PointerEventData.InputButton.Left) _onPointerEvent.OnNext((this, ItemUIEventType.DoubleClick));
        }
        
        public void OnPointerDown(PointerEventData eventData)
        {
            switch (eventData.button)
            {
                case PointerEventData.InputButton.Left:
                    _onPointerEvent.OnNext((this, ItemUIEventType.LeftClickDown));
                    break;
                case PointerEventData.InputButton.Right:
                    _onPointerEvent.OnNext((this, ItemUIEventType.RightClickDown));
                    break;
            }
        }
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            _onPointing = true;
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorEnter));
        }
        
        public void OnPointerExit(PointerEventData eventData)
        {
            _onPointing = false;
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorExit));
        }
        
        public void OnPointerMove(PointerEventData eventData)
        {
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorMove));
        }
        
        public void OnPointerUp(PointerEventData eventData)
        {
            switch (eventData.button)
            {
                case PointerEventData.InputButton.Left:
                    _onPointerEvent.OnNext((this, ItemUIEventType.LeftClickUp));
                    break;
                case PointerEventData.InputButton.Right:
                    _onPointerEvent.OnNext((this, ItemUIEventType.RightClickUp));
                    break;
            }
        }
        
        #endregion
    }
    
    public enum ItemUIEventType
    {
        RightClickDown,
        LeftClickDown,
        RightClickUp,
        LeftClickUp,
        
        CursorEnter,
        CursorExit,
        CursorMove,
        
        DoubleClick,
    }
    
    public enum ItemSlotType
    {
        Normal, // 通常のアイテム表示
        NoneCross, // アイテムが何もないクロス表示
    }
    
    public enum ItemSlotFrameType
    {
        Normal,
        MachineSlot,
        CraftRecipe,
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/ItemShooter/ItemShooterComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Block.Blocks.ItemShooter
{
    public class ItemShooterComponent : IItemCollectableBeltConveyor, IBlockInventory, IBlockSaveState, IUpdatableBlockComponent
    {
        public BeltConveyorSlopeType SlopeType { get; }
        public IReadOnlyList<IOnBeltConveyorItem> BeltConveyorItems => _inventoryItems;
        private readonly ShooterInventoryItem[] _inventoryItems;
        
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        private readonly ItemShooterBlockParam _itemShooterBlockParam;
        private const float InsertItemInterval = 1f; // TODO to master
        
        private float _lastInsertElapsedTime = float.MaxValue;
        
        public ItemShooterComponent(BlockConnectorComponent<IBlockInventory> blockConnectorComponent, ItemShooterBlockParam itemShooterBlockParam)
        {
            _blockConnectorComponent = blockConnectorComponent;
            _itemShooterBlockParam = itemShooterBlockParam;
            SlopeType = itemShooterBlockParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            
            _inventoryItems = new ShooterInventoryItem[_itemShooterBlockParam.InventoryItemNum];
        }
        
        public ItemShooterComponent(Dictionary<string, string> componentStates, BlockConnectorComponent<IBlockInventory> blockConnectorComponent, ItemShooterBlockParam itemShooterBlockParam) :
            this(blockConnectorComponent, itemShooterBlockParam)
        {
            var items = JsonConvert.DeserializeObject<List<ItemShooterItemJsonObject>>(componentStates[SaveKey]);
            for (var i = 0; i < items.Count; i++)
            {
                var item = items[i];
                if (item.ItemStackSave == null) continue;
                
                var id = MasterHolder.ItemMaster.GetItemId(item.ItemStackSave.ItemGuid);
                _inventoryItems[i] = new ShooterInventoryItem(id, ItemInstanceId.Create(), (float)item.CurrentSpeed)
                {
                    RemainingPercent = (float)items[i].RemainingPercent
                };
            }
        }
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            _lastInsertElapsedTime += (float)GameUpdater.UpdateSecondTime;
            var count = _inventoryItems.Length;
            
            for (var i = 0; i < count; i++)
            {
                var item = _inventoryItems[i];
                if (item == null) continue;
                
                if (item.RemainingPercent <= 0)
                {
                    var insertItem = ServerContext.ItemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
                    
                    if (_blockConnectorComponent.ConnectedTargets.Count == 0) continue;
                    
                    var connector = _blockConnectorComponent.ConnectedTargets.First();
                    var target = connector.Key;
                    if (target is ItemShooterComponent shooter)
                    {
                        _inventoryItems[i] = shooter.InsertItemFromShooter(item);
                    }
                    else
                    {
                        var output = connector.Key.InsertItem(insertItem);
                        
                        //渡した結果がnullItemだったらそのアイテムを消す
                        if (output.Id == ItemMaster.EmptyItemId) _inventoryItems[i] = null;
                    }
                    
                    continue;
                }
                
                //時間を減らす
                var deltaTime = (float)GameUpdater.UpdateSecondTime; // floatとdobuleが混在しているの気持ち悪いから改善したい
                item.RemainingPercent -= deltaTime * _itemShooterBlockParam.ItemShootSpeed * item.CurrentSpeed;
                item.RemainingPercent = Math.Clamp(item.RemainingPercent, 0, 1);
                
                // velocityを更新する
                item.CurrentSpeed += _itemShooterBlockParam.Acceleration * deltaTime;
                item.CurrentSpeed = Mathf.Clamp(item.CurrentSpeed, 0, float.MaxValue);
            }
        }
        
        private ShooterInventoryItem InsertItemFromShooter(ShooterInventoryItem inventoryItem)
        {
            BlockException.CheckDestroy(this);
            
            for (var i = 0; i < _inventoryItems.Length; i++)
            {
                if (_inventoryItems[i] != null) continue;
                
                _inventoryItems[i] = inventoryItem;
                _inventoryItems[i].RemainingPercent = 1;
                return null;
            }
            
            return inventoryItem;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            // インサート間隔をチェック
            if (_lastInsertElapsedTime < InsertItemInterval) return itemStack;
            
            // インサート可能なスロットに挿入
            for (var i = 0; i < _inventoryItems.Length; i++)
            {
                if (_inventoryItems[i] != null) continue;
                
                _inventoryItems[i] = new ShooterInventoryItem(itemStack.Id, itemStack.ItemInstanceId, _itemShooterBlockParam.InitialShootSpeed);
                //挿入したのでアイテムを減らして返す
                _lastInsertElapsedTime = 0;
                return itemStack.SubItem(1);
            }
            
            return itemStack;
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            // 空きスロットがあるかどうか
            var nullCount = 0;
            foreach (var inventoryItem in _inventoryItems)
            {
                if (inventoryItem == null) nullCount++;
            }
            // 挿入可能スロットがない
            if (nullCount == 0) return false;
            
            // 挿入スロットが1個かどうか
            if (itemStacks.Count == 1 && itemStacks[0].Count == 1) return true;
            
            return false;
        }
        
        public IItemStack GetItem(int slot)
        {
            var itemStackFactory = ServerContext.ItemStackFactory;
            var item = _inventoryItems[slot];
            return item == null ? itemStackFactory.CreatEmpty() : itemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            _inventoryItems[slot] = new ShooterInventoryItem(itemStack.Id, itemStack.ItemInstanceId, _itemShooterBlockParam.InitialShootSpeed);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _inventoryItems.Length;
        }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public string SaveKey { get; } = typeof(ItemShooterComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            var items = _inventoryItems.Select(item => new ItemShooterItemJsonObject(item)).ToList();
            return JsonConvert.SerializeObject(items);
        }
    }
    
    public class ItemShooterItemJsonObject
    {
        [JsonProperty("itemStack")] public ItemStackSaveJsonObject ItemStackSave;
        
        [JsonProperty("remainingTime")] public double RemainingPercent;
        
        [JsonProperty("currentSpeed")] public double CurrentSpeed;
        
        public ItemShooterItemJsonObject(ShooterInventoryItem shooterInventoryItem)
        {
            if (shooterInventoryItem == null)
            {
                ItemStackSave = null;
                RemainingPercent = 0;
                CurrentSpeed = 0;
                return;
            }
            
            var item = ServerContext.ItemStackFactory.Create(shooterInventoryItem.ItemId, 1);
            ItemStackSave = new ItemStackSaveJsonObject(item);
            RemainingPercent = shooterInventoryItem.RemainingPercent;
            CurrentSpeed = shooterInventoryItem.CurrentSpeed;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineInputInventory.cs
```cs
using System.Collections.Generic;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Event;
using Game.Context;
using Mooresmaster.Model.MachineRecipesModule;

namespace Game.Block.Blocks.Machine.Inventory
{
    /// <summary>
    ///     インプットのインベントリとアウトプットのインベントリを同じように扱う
    ///     Insertなどの処理は基本的にInputのインベントリにのみ行う
    /// </summary>
    public class VanillaMachineInputInventory
    {
        private readonly BlockId _blockId;
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly BlockInstanceId _blockInstanceId;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        public VanillaMachineInputInventory(BlockId blockId, int inputSlot, BlockOpenableInventoryUpdateEvent blockInventoryUpdate, BlockInstanceId blockInstanceId)
        {
            _blockId = blockId;
            _blockInventoryUpdate = blockInventoryUpdate;
            _blockInstanceId = blockInstanceId;
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, inputSlot);
        }
        
        public IReadOnlyList<IItemStack> InputSlot => _itemDataStoreService.InventoryItems;
        
        public bool IsAllowedToStartProcess()
        {
            //ブロックIDと現在のインプットスロットからレシピを検索する
            if (TryGetRecipeElement(out var recipe))
            {
                //実行できるレシピかどうか
                return recipe.RecipeConfirmation(_blockId, InputSlot);
            }
            return false;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return _itemDataStoreService.InsertItem(itemStack);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return _itemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool TryGetRecipeElement(out MachineRecipeMasterElement recipe)
        {
            return MachineRecipeMasterUtil.TryGetRecipeElement(_blockId, InputSlot, out recipe);
        }
        
        public void ReduceInputSlot(MachineRecipeMasterElement recipe)
        {
            //inputスロットからアイテムを減らす
            foreach (var item in recipe.InputItems)
                for (var i = 0; i < InputSlot.Count; i++)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(item.ItemGuid);
                    
                    if (_itemDataStoreService.InventoryItems[i].Id != itemId || item.Count > InputSlot[i].Count) continue;
                    //アイテムを減らす
                    _itemDataStoreService.SetItem(i, InputSlot[i].SubItem(item.Count));
                    break;
                }
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return _itemDataStoreService.InsertionCheck(itemStacks);
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(
                _blockInstanceId, slot, itemStack));
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/MapObjectAcquisitionProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     MapObjectを取得するときのプロトコル
    /// </summary>
    public class MapObjectAcquisitionProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:mapObjectInfoAcquisition";
        
        
        private readonly IMapObjectDatastore _mapObjectDatastore;
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public MapObjectAcquisitionProtocol(ServiceProvider serviceProvider)
        {
            _mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<GetMapObjectProtocolProtocolMessagePack>(payload.ToArray());
            
            var mapObject = _mapObjectDatastore.Get(data.InstanceId);
            var playerMainInventory = _playerInventoryDataStore.GetInventoryData(data.PlayerId).MainOpenableInventory;
            
            var earnedItem = mapObject.Attack(data.AttackDamage); // ダメージを与える
            
            foreach (var earnItem in earnedItem) playerMainInventory.InsertItem(earnItem);
            
            return null;
        }
        
        [MessagePackObject]
        public class GetMapObjectProtocolProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public int InstanceId { get; set; }
            [Key(4)] public int AttackDamage { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public GetMapObjectProtocolProtocolMessagePack() { }
            
            public GetMapObjectProtocolProtocolMessagePack(int playerId, int instanceId, int attackDamage)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                InstanceId = instanceId;
                AttackDamage = attackDamage;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/IMapObjectMiningState.cs
```cs
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Cysharp.Threading.Tasks;

namespace Client.Game.InGame.Mining
{
    public interface IMapObjectMiningState
    {
        IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt);
    }
    
    public class MapObjectMiningControllerContext
    {
        public MapObjectGameObject CurrentFocusMapObjectGameObject { get; private set; }
        
        
        public readonly HotBarView HotBarView;
        public readonly ILocalPlayerInventory LocalPlayerInventory;
        public readonly IPlayerObjectController PlayerObjectController;
        
        public MapObjectMiningControllerContext(HotBarView hotBarView, ILocalPlayerInventory localPlayerInventory, IPlayerObjectController playerObjectController)
        {
            HotBarView = hotBarView;
            LocalPlayerInventory = localPlayerInventory;
            PlayerObjectController = playerObjectController;
        }
        
        
        
        public void SetFocusMapObjectGameObject(MapObjectGameObject mapObjectGameObject)
        {
            if (mapObjectGameObject != CurrentFocusMapObjectGameObject)
            {
                CurrentFocusMapObjectGameObject?.OutlineEnable(false);
                mapObjectGameObject?.OutlineEnable(true);
            }
            
            CurrentFocusMapObjectGameObject = mapObjectGameObject;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/MachineIOTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Core.Const;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class MachineIOTest
    {
        //アイテムが通常通り処理されるかのテスト
        [Test]
        public void ItemProcessingOutputTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[0];
            
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var block = blockFactory.Create(blockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var blockInventory = block.GetComponent<VanillaMachineBlockInventoryComponent>();
            foreach (var inputItem in recipe.InputItems)
            {
                blockInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var blockMachineComponent = block.GetComponent<VanillaElectricMachineComponent>();
            
            var craftTime = DateTime.Now.AddSeconds(recipe.Time);
            //最大クラフト時間を超過するまでクラフトする
            while (craftTime.AddSeconds(0.2).CompareTo(DateTime.Now) == 1)
            {
                blockMachineComponent.SupplyEnergy(new ElectricPower(10000));
                GameUpdater.UpdateWithWait();
            }
            
            //検証
            (List<IItemStack> input, List<IItemStack> output) = GetInputOutputSlot(blockInventory);
            
            Assert.AreEqual(0, input.Count);
            foreach (var inputItem in input) Assert.AreEqual(ItemMaster.EmptyItemId, inputItem.Id);
            
            Assert.AreNotEqual(0, output.Count);
            for (var i = 0; i < output.Count; i++)
            {
                var expectedOutputId = MasterHolder.ItemMaster.GetItemId(recipe.OutputItems[i].ItemGuid);
                Assert.AreEqual(expectedOutputId, output[i].Id);
                Assert.AreEqual(recipe.OutputItems[i].Count, output[i].Count);
            }
        }
        
        public (List<IItemStack>, List<IItemStack>) GetInputOutputSlot(VanillaMachineBlockInventoryComponent vanillaMachineInventory)
        {
            var vanillaMachineInputInventory = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            var vanillaMachineOutputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            
            var inputSlot = vanillaMachineInputInventory.InputSlot.Where(i => i.Count != 0).ToList();
            inputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            var outputSlot = vanillaMachineOutputInventory.OutputSlot.Where(i => i.Count != 0).ToList();
            outputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            return (inputSlot, outputSlot);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaElectricMachineComponent.cs
```cs
using Game.Block.Interface;
using Game.EnergySystem;

namespace Game.Block.Blocks.Machine
{
    /// <summary>
    ///     機械を表すクラス
    /// </summary>
    public class VanillaElectricMachineComponent : IElectricConsumer
    {
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        
        public VanillaElectricMachineComponent(BlockInstanceId blockInstanceId, VanillaMachineProcessorComponent vanillaMachineProcessorComponent)
        {
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
            BlockInstanceId = blockInstanceId;
        }
        public BlockInstanceId BlockInstanceId { get; }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        #region IBlockElectric implementation
        
        public ElectricPower RequestEnergy => _vanillaMachineProcessorComponent.RequestPower;
        
        public void SupplyEnergy(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            
            _vanillaMachineProcessorComponent.SupplyPower(power);
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/MapObjectUpdateEventPacket.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using MessagePack;

namespace Server.Event.EventReceive
{
    /// <summary>
    ///     Mapオブジェクトが破壊など、更新されたらその情報を伝えるためのパケット
    /// </summary>
    public class MapObjectUpdateEventPacket
    {
        public const string EventTag = "va:event:mapObjectUpdate";
        private readonly EventProtocolProvider _eventProtocolProvider;
        private readonly IMapObjectDatastore _mapObjectDatastore;
        
        public MapObjectUpdateEventPacket(IMapObjectDatastore mapObjectDatastore,
            EventProtocolProvider eventProtocolProvider)
        {
            _mapObjectDatastore = mapObjectDatastore;
            _eventProtocolProvider = eventProtocolProvider;
            
            _mapObjectDatastore.OnDestroyMapObject += OnDestroyMapObject;
        }
        
        private void OnDestroyMapObject(IMapObject mapObject)
        {
            var messagePack = new MapObjectUpdateEventMessagePack(MapObjectUpdateEventMessagePack.DestroyEventType, mapObject.InstanceId);
            var data = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, data);
        }
    }
    
    [MessagePackObject]
    public class MapObjectUpdateEventMessagePack
    {
        public const string DestroyEventType = "destroy";
        
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public MapObjectUpdateEventMessagePack()
        {
        }
        
        public MapObjectUpdateEventMessagePack(string eventType, int instanceId)
        {
            EventType = eventType;
            InstanceId = instanceId;
        }
        
        [Key(0)] public string EventType { get; set; }
        
        [Key(1)] public int InstanceId { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Miner/VanillaMinerProcessorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.Service;
using Game.Block.Blocks.Util;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Block.Interface.State;
using Game.Context;
using Game.EnergySystem;
using Game.Map.Interface.Vein;
using MessagePack;
using Mooresmaster.Model.MineSettingsModule;
using Newtonsoft.Json;
using UniRx;

namespace Game.Block.Blocks.Miner
{
    public class VanillaMinerProcessorComponent : IOpenableBlockInventoryComponent, IBlockSaveState, IBlockStateObservable, IBlockStateDetail, IUpdatableBlockComponent
    {
        public bool IsDestroy { get; private set; }
        public ElectricPower RequestEnergy { get; }
        public IObservable<Unit> OnChangeBlockState => _blockStateChangeSubject;
        private Subject<Unit> _blockStateChangeSubject = new();
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly ConnectingInventoryListPriorityInsertItemService _connectInventoryService;
        private readonly List<IItemStack> _miningItems = new();
        
        private readonly OpenableInventoryItemDataStoreService _openableInventoryItemDataStoreService;
        private readonly BlockInstanceId _blockInstanceId;
        
        private ElectricPower _currentPower;
        
        private float _defaultMiningTime = float.MaxValue;
        private double _remainingSecond = double.MaxValue;
        
        private VanillaMinerState _lastMinerState;
        private VanillaMinerState _currentState = VanillaMinerState.Idle;
        
        public VanillaMinerProcessorComponent(BlockInstanceId blockInstanceId, ElectricPower requestPower, int outputSlotCount, BlockOpenableInventoryUpdateEvent openableInventoryUpdateEvent, BlockConnectorComponent<IBlockInventory> inputConnectorComponent, BlockPositionInfo blockPositionInfo, MineSettings mineSettings)
        {
            _blockInstanceId = blockInstanceId;
            RequestEnergy = requestPower;
            
            _blockInventoryUpdate = openableInventoryUpdateEvent;
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            _openableInventoryItemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, itemStackFactory, outputSlotCount);
            _connectInventoryService = new ConnectingInventoryListPriorityInsertItemService(inputConnectorComponent);
            
            SetMiningItem();
            
            #region Internal
            
            void SetMiningItem()
            {
                List<IMapVein> veins = ServerContext.MapVeinDatastore.GetOverVeins(blockPositionInfo.OriginalPos);
                foreach (var vein in veins) _miningItems.Add(itemStackFactory.Create(vein.VeinItemId, 1));
                if (veins.Count == 0) return;
                
                foreach (var miningSetting in mineSettings.items)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(miningSetting.ItemGuid);
                    if (itemId != veins[0].VeinItemId) continue;
                    _defaultMiningTime = miningSetting.Time;
                    _remainingSecond = _defaultMiningTime;
                    break;
                }
            }
            
            #endregion
        }
        
        public VanillaMinerProcessorComponent(Dictionary<string, string> componentStates, BlockInstanceId blockInstanceId, ElectricPower requestPower, int outputSlotCount, BlockOpenableInventoryUpdateEvent openableInventoryUpdateEvent, BlockConnectorComponent<IBlockInventory> inputConnectorComponent, BlockPositionInfo blockPositionInfo, MineSettings mineSettings)
            : this(blockInstanceId, requestPower, outputSlotCount, openableInventoryUpdateEvent, inputConnectorComponent, blockPositionInfo, mineSettings)
        {
            var saveJsonObject = JsonConvert.DeserializeObject<VanillaElectricMinerSaveJsonObject>(componentStates[SaveKey]);
            for (var i = 0; i < saveJsonObject.Items.Count; i++)
            {
                var itemStack = saveJsonObject.Items[i].ToItemStack();
                _openableInventoryItemDataStoreService.SetItem(i, itemStack);
            }
            
            _remainingSecond = saveJsonObject.RemainingSecond;
        }
        
        public void SupplyPower(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            
            _currentPower = power;
        }
        
        public string SaveKey { get; } = typeof(VanillaMinerProcessorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var saveData = new VanillaElectricMinerSaveJsonObject
            {
                RemainingSecond = _remainingSecond,
                Items = _openableInventoryItemDataStoreService.InventoryItems.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
            };
            
            return JsonConvert.SerializeObject(saveData);
        }
        
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            MinerProgressUpdate();
            CheckStateAndInvokeEventUpdate();
            
            #region Internal
            
            void MinerProgressUpdate()
            {
                var subTime = MachineCurrentPowerToSubSecond.GetSubSecond(_currentPower, RequestEnergy);
                if (subTime <= 0)
                {
                    //電力の都合で処理を進められないのでreturn
                    _currentState = VanillaMinerState.Idle;
                    return;
                }
                
                //insertできるかチェック
                if (!_openableInventoryItemDataStoreService.InsertionCheck(_miningItems))
                {
                    //挿入できないのでreturn
                    _currentState = VanillaMinerState.Idle;
                    return;
                }
                
                _currentState = VanillaMinerState.Mining;
                
                _remainingSecond -= subTime;
                
                if (_remainingSecond <= 0)
                {
                    _remainingSecond = _defaultMiningTime;
                    
                    //空きスロットを探索し、あるならアイテムを挿入
                    _openableInventoryItemDataStoreService.InsertItem(_miningItems);
                }
                
                _currentPower = new ElectricPower(0);
                InsertConnectInventory();
            }
            
            void CheckStateAndInvokeEventUpdate()
            {
                if (_lastMinerState == VanillaMinerState.Mining && _currentState == VanillaMinerState.Idle)
                {
                    //Miningからidleに切り替わったのでイベントを発火
                    InvokeChangeStateEvent();
                    _lastMinerState = _currentState;
                    return;
                }
                
                if (_currentState == VanillaMinerState.Idle)
                    //Idle中は発火しない
                    return;
                
                //マイニング中 この時は常にイベントを発火
                InvokeChangeStateEvent();
            }
            
            void InvokeChangeStateEvent()
            {
                BlockException.CheckDestroy(this);
                
                _blockStateChangeSubject.OnNext(Unit.Default);
            }
            
            
            void InsertConnectInventory()
            {
                BlockException.CheckDestroy(this);
                
                for (var i = 0; i < _openableInventoryItemDataStoreService.InventoryItems.Count; i++)
                {
                    var insertedItem = _connectInventoryService.InsertItem(_openableInventoryItemDataStoreService.InventoryItems[i]);
                    _openableInventoryItemDataStoreService.SetItem(i, insertedItem);
                }
            }
            
            #endregion
        }
        
        
        public BlockStateDetail GetBlockStateDetail()
        {
            var processingRate = 1 - (float)_remainingSecond / _defaultMiningTime;
            var stateDetail = new CommonMachineBlockStateDetail(_currentPower.AsPrimitive(), RequestEnergy.AsPrimitive(), processingRate, _currentState.ToStr(), _lastMinerState.ToStr());
            var stateDetailBytes = MessagePackSerializer.Serialize(stateDetail);
            return new BlockStateDetail(CommonMachineBlockStateDetail.BlockStateDetailKey, stateDetailBytes);
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(_blockInstanceId, slot, itemStack));
        }
        
        #region Implimantion IOpenableInventory
        
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _openableInventoryItemDataStoreService.SetItem(slot, itemStack);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _openableInventoryItemDataStoreService.GetSlotSize();
        }
        
        
        public IReadOnlyList<IItemStack> InventoryItems => _openableInventoryItemDataStoreService.InventoryItems;
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.ReplaceItem(slot, itemId, count);
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemStack);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemId, count);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertionCheck(itemStacks);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            _openableInventoryItemDataStoreService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.ReplaceItem(slot, itemStack);
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            return _openableInventoryItemDataStoreService.CreateCopiedItems();
        }
        
        #endregion
        
        public void Destroy()
        {
            IsDestroy = true;
            _blockStateChangeSubject.Dispose();
            _blockStateChangeSubject = null;
        }
    }
    
    public enum VanillaMinerState
    {
        Idle,
        Mining,
    }
    
    public static class ProcessStateExtension
    {
        /// <summary>
        ///     <see cref="ProcessState" />をStringに変換します。
        ///     EnumのToStringを使わない理由はアロケーションによる速度低下をなくすためです。
        /// </summary>
        public static string ToStr(this VanillaMinerState state)
        {
            return state switch
            {
                VanillaMinerState.Idle => "idle",
                VanillaMinerState.Mining =>"mining",
                _ => throw new ArgumentOutOfRangeException(nameof(state), state, null),
            };
        }
    }
    
    public class VanillaElectricMinerSaveJsonObject
    {
        [JsonProperty("items")]
        public List<ItemStackSaveJsonObject> Items;
        [JsonProperty("remainingSecond")]
        public double RemainingSecond;
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.Map.Interface.Json;
using Game.Map.Interface.MapObject;
using Game.SaveLoad.Json;

namespace Game.Map
{
    public class MapObjectDatastore : IMapObjectDatastore
    {
        private readonly IMapObjectFactory _mapObjectFactory;
        
        /// <summary>
        ///     このデータが空になる場合はワールドのロードか初期化ができていない状態である可能性が高いです。
        ///     単純にmapObjectがない場合もありますが、、
        ///     <see cref="WorldLoaderFromJson" />でロードもしくは初期化を行ってください。
        /// </summary>
        private readonly Dictionary<int, IMapObject> _mapObjects = new();
        
        public MapObjectDatastore(IMapObjectFactory mapObjectFactory, MapInfoJson mapInfoJson)
        {
            _mapObjectFactory = mapObjectFactory;
            
            foreach (var mapObjectInfo in mapInfoJson.MapObjects)
            {
                var mapObjectConfig = MasterHolder.MapObjectMaster.GetMapObjectElement(mapObjectInfo.MapObjectGuid);
                var hp = mapObjectConfig.Hp;
                
                var mapObject = _mapObjectFactory.Create(mapObjectInfo.InstanceId, mapObjectInfo.MapObjectGuid, hp, false, mapObjectInfo.Position);
                _mapObjects.Add(mapObject.InstanceId, mapObject);
                mapObject.OnDestroy += () => OnDestroyMapObject?.Invoke(mapObject);
            }
        }
        
        public event Action<IMapObject> OnDestroyMapObject;
        
        public IReadOnlyList<IMapObject> MapObjects => _mapObjects.Values.ToList();
        
        public void Add(IMapObject mapObject)
        {
            _mapObjects.Add(mapObject.InstanceId, mapObject);
            mapObject.OnDestroy += () => OnDestroyMapObject?.Invoke(mapObject);
        }
        
        public IMapObject Get(int instanceId)
        {
            return _mapObjects[instanceId];
        }
        
        public void LoadMapObject(List<MapObjectJsonObject> savedMapObjects)
        {
            foreach (var savedMapObject in savedMapObjects)
            {
                if (!_mapObjects.TryGetValue(savedMapObject.instanceId, out var loadedMapObject)) throw new KeyNotFoundException($"セーブデータ内にあるインスタンスID: {savedMapObject.instanceId} のmapObjectが実際のマップに存在しません。");
                
                //破壊状況をロード
                if (savedMapObject.isDestroyed) loadedMapObject.Destroy();
                if (savedMapObject.hp != loadedMapObject.CurrentHp) loadedMapObject.Attack(loadedMapObject.CurrentHp - savedMapObject.hp);
            }
        }
        
        public List<MapObjectJsonObject> GetSaveJsonObject()
        {
            return _mapObjects.Select(m => new MapObjectJsonObject(m.Value)).ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Entity/ItemEntityObject.cs
```cs
using Client.Common.Server;
using UnityEngine;

namespace Client.Game.InGame.Entity
{
    public class ItemEntityObject : MonoBehaviour, IEntityObject
    {
        [SerializeField] private MeshRenderer meshRenderer;
        [SerializeField] private Material itemMaterial;
        private float _linerTime;
        private Vector3 _previousPosition;
        
        private Vector3 _targetPosition;
        
        private void Awake()
        {
            _targetPosition = transform.position;
            _previousPosition = transform.position;
        }
        
        //Linerでポジションを補完させる
        private void Update()
        {
            //補完する
            var rate = _linerTime / NetworkConst.UpdateIntervalSeconds;
            rate = Mathf.Clamp01(rate);
            transform.position = Vector3.Lerp(_previousPosition, _targetPosition, rate);
            _linerTime += Time.deltaTime;
        }
        
        public void SetDirectPosition(Vector3 position)
        {
            _targetPosition = position;
            _previousPosition = position;
            transform.position = position;
        }
        
        public void SetInterpolationPosition(Vector3 position)
        {
            _previousPosition = transform.position;
            _targetPosition = position;
            _linerTime = 0;
        }
        
        public void Destroy()
        {
            Destroy(gameObject);
        }
        
        public void SetTexture(Texture texture)
        {
            var material = new Material(itemMaterial) { mainTexture = texture };
            meshRenderer.material = material;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/MinerMiningTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Update;
using Game.Block.Blocks.Miner;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using Game.Map.Interface.Vein;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class MinerMiningTest
    {
        //一定時間たったら鉱石が出るテスト
        [Test]
        public void MiningTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //手動で鉱石の設定を行う
            var (mapVein, pos) = GetMapVein();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricMinerId, pos, BlockDirection.North, out _);
            var miner = worldBlockDatastore.GetBlock(pos);
            var minerComponent = miner.GetComponent<VanillaMinerProcessorComponent>();
            
            var miningItems = (List<IItemStack>)typeof(VanillaMinerProcessorComponent).GetField("_miningItems", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(minerComponent);
            var miningItemId = miningItems[0].Id;
            var miningTime = (float)typeof(VanillaMinerProcessorComponent).GetField("_defaultMiningTime", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(minerComponent);
            
            
            var dummyInventory = new DummyBlockInventory();
            //接続先ブロックの設定
            //本当はダメなことしているけどテストだから許してヒヤシンス
            var minerConnectors = (Dictionary<IBlockInventory, ConnectedInfo>)miner.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            minerConnectors.Add(dummyInventory, new ConnectedInfo());
            
            //電力の設定
            var segment = new EnergySegment();
            segment.AddEnergyConsumer(miner.GetComponent<IElectricConsumer>());
            segment.AddGenerator(new TestElectricGenerator(new ElectricPower(10000), new BlockInstanceId(10)));
            
            var mineEndTime = DateTime.Now.AddSeconds(miningTime);
            
            
            //テストコードの準備完了
            //鉱石1個分の採掘時間待機
            while (mineEndTime.AddSeconds(0.05).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //鉱石1個が出力されているかチェック
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id);
            Assert.AreEqual(1, dummyInventory.InsertedItems[0].Count);
            
            //コネクターを外す
            minerConnectors.Remove(dummyInventory);
            
            //鉱石2個分の採掘時間待機
            mineEndTime = DateTime.Now.AddSeconds(miningTime * 2);
            while (mineEndTime.AddSeconds(0.05).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //鉱石2個が残っているかチェック
            var outputSlot = miner.GetComponent<VanillaMinerProcessorComponent>().InventoryItems[0];
            Assert.AreEqual(miningItemId, outputSlot.Id);
            Assert.AreEqual(2, outputSlot.Count);
            
            //またコネクターをつなげる
            minerConnectors.Add(dummyInventory, new ConnectedInfo());
            
            //コネクターにアイテムを入れるためのアップデート
            GameUpdater.UpdateWithWait();
            
            //アイテムがさらに2個追加で入っているかチェック
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id);
            Assert.AreEqual(3, dummyInventory.InsertedItems[0].Count);
        }
        
        public static (IMapVein mapVein, Vector3Int pos) GetMapVein()
        {
            var pos = new Vector3Int(0, 0);
            for (var i = 0; i < 500; i++)
            for (var j = 0; j < 500; j++)
            {
                List<IMapVein> veins = ServerContext.MapVeinDatastore.GetOverVeins(new Vector3Int(i, j));
                if (veins.Count == 0) continue;
                
                return (veins[0], new Vector3Int(i, j));
            }
            
            return (null, pos);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/GetMapObjectProtocolTest.cs
```cs
using System.Linq;
using Game.Context;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.MapObjectAcquisitionProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class GetMapObjectProtocolTest
    {
        private const int PlayerId = 0;
        
        [Test]
        public void GetMapObjectProtocol_DestroyAndAddToInventory_Test()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
            var worldMapObjectDataStore = serviceProvider.GetService<IMapObjectDatastore>();
            var itemFactory = ServerContext.ItemStackFactory;
            
            var mapObject = worldMapObjectDataStore.MapObjects[0];
            
            var playerInventory = playerInventoryDataStore.GetInventoryData(PlayerId).MainOpenableInventory;
            var itemSlot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            
            
            // 少ないダメージでアイテムが入手できないことのテスト
            var messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 5);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            Assert.AreEqual(itemFactory.CreatEmpty(), playerInventory.GetItem(itemSlot));
            
            
            // アイテムがもらえるだけのダメージを与えてアイテムを入手できることのテスト
            messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 5);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            var earnItem = mapObject.EarnItems[0];
            Assert.AreEqual(earnItem, playerInventory.GetItem(itemSlot));
            playerInventory.SetItem(itemSlot, itemFactory.CreatEmpty()); // アイテムをリセット
            
            
            //大きくダメージを与えて2倍のアイテムを入手できることのテスト
            messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 20);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            Assert.AreEqual(earnItem.Id, playerInventory.GetItem(itemSlot).Id);
            Assert.AreEqual(earnItem.Count * 2, playerInventory.GetItem(itemSlot).Count);
            
            //破壊されていることのテスト
            Assert.IsTrue(mapObject.IsDestroyed);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/MachineBlockInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class MachineBlockInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform machineInputItemParent;
        [SerializeField] private RectTransform machineOutputItemParent;
        [SerializeField] private TMP_Text machineBlockNameText;
        
        [SerializeField] private ProgressArrowView machineProgressArrow;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            
            var itemList = new List<IItemStack>();
            
            // GearMachineParamとElectricMachineParamを共通して使える
            var param = blockGameObject.BlockMasterElement.BlockParam as IMachineParam;
            
            
            for (var i = 0; i < param.InputSlotCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, machineInputItemParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            for (var i = 0; i < param.OutputSlotCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, machineOutputItemParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            machineBlockNameText.text = blockGameObject.BlockMasterElement.Name;
            UpdateItemList(itemList);
        }
        
        private void Update()
        {
            // ここが重かったら検討
            var commonProcessor = (CommonMachineBlockStateChangeProcessor)_blockGameObject.BlockStateChangeProcessors.FirstOrDefault(x => x as CommonMachineBlockStateChangeProcessor);
            if (commonProcessor == null) return;
            
            machineProgressArrow.SetProgress(commonProcessor.CurrentMachineState?.ProcessingRate ?? 0.0f);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineBlockInventoryComponent.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;

namespace Game.Block.Blocks.Machine.Inventory
{
    public class VanillaMachineBlockInventoryComponent : IOpenableBlockInventoryComponent
    {
        public IReadOnlyList<IItemStack> InventoryItems
        {
            get
            {
                BlockException.CheckDestroy(this);
                var items = new List<IItemStack>();
                items.AddRange(_vanillaMachineInputInventory.InputSlot);
                items.AddRange(_vanillaMachineOutputInventory.OutputSlot);
                return items;
            }
        }
        
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        
        public VanillaMachineBlockInventoryComponent(VanillaMachineInputInventory vanillaMachineInputInventory, VanillaMachineOutputInventory vanillaMachineOutputInventory)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            return ReplaceItem(slot, item);
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //アイテムをインプットスロットに入れた後、プロセス開始できるなら開始
            var item = _vanillaMachineInputInventory.InsertItem(itemStack);
            return item;
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            return _vanillaMachineInputInventory.InsertItem(item);
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
                return _vanillaMachineInputInventory.InputSlot[slot];
            
            slot -= _vanillaMachineInputInventory.InputSlot.Count;
            return _vanillaMachineOutputInventory.OutputSlot[slot];
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
            {
                _vanillaMachineInputInventory.SetItem(slot, itemStack);
            }
            else
            {
                slot -= _vanillaMachineInputInventory.InputSlot.Count;
                _vanillaMachineOutputInventory.SetItem(slot, itemStack);
            }
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            SetItem(slot, item);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            
            return _vanillaMachineInputInventory.InputSlot.Count + _vanillaMachineOutputInventory.OutputSlot.Count;
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            
            var items = new List<IItemStack>();
            items.AddRange(_vanillaMachineInputInventory.InputSlot);
            items.AddRange(_vanillaMachineOutputInventory.OutputSlot);
            return new ReadOnlyCollection<IItemStack>(items);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            //アイテムをインプットスロットに入れた後、プロセス開始できるなら開始
            return _vanillaMachineInputInventory.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _vanillaMachineInputInventory.InsertionCheck(itemStacks);
        }
        
        /// <summary>
        ///     アイテムの置き換えを実行しますが、同じアイテムIDの場合はそのまま現在のアイテムにスタックされ、スタックしきらなかったらその分を返します。
        /// </summary>
        /// <param name="slot"></param>
        /// <param name="itemStack"></param>
        /// <returns></returns>
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            ItemProcessResult result;
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
            {
                //アイテムIDが同じの時はスタックして余ったものを返す
                var item = _vanillaMachineInputInventory.InputSlot[slot];
                if (item.Id == itemStack.Id)
                {
                    result = item.AddItem(itemStack);
                    _vanillaMachineInputInventory.SetItem(slot, result.ProcessResultItemStack);
                    return result.RemainderItemStack;
                }
                
                //違う場合はそのまま入れ替える
                _vanillaMachineInputInventory.SetItem(slot, itemStack);
                return item;
            }
            else
            {
                //アウトプットスロットのインデックスに変換する
                slot -= _vanillaMachineInputInventory.InputSlot.Count;
                
                var item = _vanillaMachineOutputInventory.OutputSlot[slot];
                
                if (item.Id == itemStack.Id)
                {
                    result = item.AddItem(itemStack);
                    _vanillaMachineOutputInventory.SetItem(slot, result.ProcessResultItemStack);
                    return result.RemainderItemStack;
                }
                
                _vanillaMachineOutputInventory.SetItem(slot, itemStack);
                return item;
            }
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/MinerBlockInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class MinerBlockInventoryView : CommonBlockInventoryViewBase 
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private ItemSlotObject minerResourceSlot;
        [SerializeField] private RectTransform minerResultsParent;
        
        [SerializeField] private ProgressArrowView minerProgressArrow;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            
            var itemList = new List<IItemStack>();
            var param = blockGameObject.BlockMasterElement.BlockParam;
            var outputCount = param switch
            {
                ElectricMinerBlockParam blockParam => blockParam.OutputItemSlotCount, // TODO master interfaceブロックインベントリの整理箇所
                GearMinerBlockParam blockParam => blockParam.OutputItemSlotCount,
                _ => 0
            };
            
            for (var i = 0; i < outputCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, minerResultsParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            UpdateItemList(itemList);
        }
        
        private void Update()
        {
            // ここが重かったら検討
            var commonProcessor = (CommonMachineBlockStateChangeProcessor)_blockGameObject.BlockStateChangeProcessors.FirstOrDefault(x => x as CommonMachineBlockStateChangeProcessor);
            if (commonProcessor == null) return;
            
            minerProgressArrow.SetProgress(commonProcessor.CurrentMachineState?.ProcessingRate ?? 0.0f);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Map/MapObject/MapObjectGameObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Context;
using Client.Network.API;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Map.MapObject
{
    /// <summary>
    ///     TODO 静的なオブジェクトになってるので、サーバーからコンフィグを取得して動的に生成するようにしたい
    /// </summary>
    public class MapObjectGameObjectDatastore : MonoBehaviour
    {
        [SerializeField] private List<MapObjectGameObject> mapObjects;
        private readonly Dictionary<int, MapObjectGameObject> _allMapObjects = new();
        
        
        [Inject]
        public void Construct(InitialHandshakeResponse handshakeResponse)
        {
            //イベント登録
            ClientContext.VanillaApi.Event.SubscribeEventResponse(MapObjectUpdateEventPacket.EventTag, OnUpdateMapObject);
            
            // mapObjectの破壊状況の初期設定
            foreach (var mapObject in mapObjects) _allMapObjects.Add(mapObject.InstanceId, mapObject);
            
            foreach (var mapObjectInfo in handshakeResponse.MapObjects)
            {
                var mapObject = _allMapObjects[mapObjectInfo.InstanceId];
                if (mapObjectInfo.IsDestroyed) mapObject.DestroyMapObject();
            }
        }
        
        private void OnUpdateMapObject(byte[] payLoad)
        {
            var data = MessagePackSerializer.Deserialize<MapObjectUpdateEventMessagePack>(payLoad);
            
            switch (data.EventType)
            {
                case MapObjectUpdateEventMessagePack.DestroyEventType:
                    _allMapObjects[data.InstanceId].DestroyMapObject();
                    break;
                default:
                    throw new Exception("MapObjectUpdateEventProtocol: EventTypeが不正か実装されていません");
            }
        }
        
        public List<MapObjectGameObject> CreateMapObjectList(Guid mapObjectGuid)
        {
            return mapObjects.Where(x => x.MapObjectGuid == mapObjectGuid && !x.IsDestroyed).ToList();
        }
        
#if UNITY_EDITOR
        public List<MapObjectGameObject> MapObjects => mapObjects;
        
        public void FindMapObjects()
        {
            mapObjects = FindObjectsOfType<MapObjectGameObject>().ToList();
            mapObjects.Sort((a, b) => string.Compare(a.gameObject.name, b.gameObject.name, StringComparison.Ordinal));
        }
#endif
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Map/MapObject/MapObjectGameObject.cs
```cs
using System;
using Core.Master;
using Mooresmaster.Model.MapObjectsModule;
using UniRx;
using UnityEditor;
using UnityEngine;

namespace Client.Game.InGame.Map.MapObject
{
    /// <summary>
    ///     MapObjectのGameObjectを表すクラス
    ///     TODO 今はUnity上に直接おいているので、今後はちゃんとサーバーからデータを受け取って生成するようにする
    /// </summary>
    public class MapObjectGameObject : MonoBehaviour
    {
        public int InstanceId => instanceId;
        public Guid MapObjectGuid => new(mapObjectGuid);
        public MapObjectMasterElement MapObjectMasterElement => MasterHolder.MapObjectMaster.GetMapObjectElement(MapObjectGuid);
        
        [SerializeField] private GameObject outlineObject;
        [SerializeField] private int instanceId;
        [SerializeField] private string mapObjectGuid;
        
        public bool IsDestroyed { get; private set; }
        
        public IObservable<Unit> OnDestroyMapObject => _onDestroyMapObject;
        private readonly Subject<Unit> _onDestroyMapObject = new();
        
        public void OutlineEnable(bool enable)
        {
            if (outlineObject != null)
            {
                outlineObject.SetActive(enable);
            }
        }
        
        public void DestroyMapObject()
        {
            IsDestroyed = true;
            //自分を含む全ての子のコライダーとレンダラーを無効化する
            foreach (var child in GetComponentsInChildren<Transform>())
            {
                var collider = child.GetComponent<Collider>();
                if (collider != null) collider.enabled = false;
                var renderer = child.GetComponent<Renderer>();
                if (renderer != null) renderer.enabled = false;
            }
            
            _onDestroyMapObject.OnNext(Unit.Default);
        }
        
        public Vector3 GetPosition()
        {
            return transform.position;
        }
        
#if UNITY_EDITOR
        public void SetMapObjectData(int instanceId)
        {
            Undo.RecordObject(this, "SetMapObjectData");
            
            this.instanceId = instanceId;
            
            //Dirtyフラグを立てる
            EditorUtility.SetDirty(this);
        }
        
#endif
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningFocusState.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.UI.Util;
using Client.Input;
using Core.Master;
using Game.PlayerInventory.Interface;
using Mooresmaster.Model.MapObjectsModule;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningFocusState : IMapObjectMiningState
    {
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            // フォーカスが外れたのであればIdleに遷移
            // If the focus is lost, transition to Idle
            if (context.CurrentFocusMapObjectGameObject == null)
            {
                return new MapObjectMiningIdleState();
            }
            
            var currentMapObjectMaster = context.CurrentFocusMapObjectGameObject.MapObjectMasterElement;
            var miningType = currentMapObjectMaster.MiningType;
            
            if (miningType == MapObjectMasterElement.MiningTypeConst.PickUp)
            {
                return PickUpProcess(context);
            }
            if (miningType == MapObjectMasterElement.MiningTypeConst.Mining)
            {
                return MiningProcess(currentMapObjectMaster, context);
            }
            
            throw new System.Exception("MiningType is not defined");
        }
        
        private IMapObjectMiningState PickUpProcess(MapObjectMiningControllerContext context)
        {
            if (InputManager.Playable.ScreenLeftClick.GetKey)
            {
                MouseCursorExplainer.Instance.Hide();
                return new MapObjectMiningMiningCompleteState(context.CurrentFocusMapObjectGameObject, int.MaxValue);
            }
            
            // 左クリックがされていなければ現状を維持
            // If left click is not pressed, maintain the current state
            MouseCursorExplainer.Instance.Show("左クリックで取得", isLocalize: false);
            return this;
        }
        
        private IMapObjectMiningState MiningProcess(MapObjectMasterElement masterElement,MapObjectMiningControllerContext context)
        {
            // 今持っているアイテムがマイニングツールとして登録されているかどうかをチェック
            // Check if the item you are currently holding is registered as a mining tool
            var hotBarInventoryIndex = PlayerInventoryConst.HotBarSlotToInventorySlot(context.HotBarView.SelectIndex);
            var inventoryItem = context.LocalPlayerInventory[hotBarInventoryIndex];
                
            
            // 何も選択していない場合はフォーカスを維持
            // If nothing is selected, maintain focus
            var miningTools = ((MiningMiningParam)masterElement.MiningParam).MiningTools;
            if (inventoryItem.Id == ItemMaster.EmptyItemId)
            {
                ShowRecommendMiningTools(miningTools);
                return this;
            }
            
            
            // マイニングツールとして登録されているかどうかをチェック
            // Check if it is registered as a mining tool
            MiningToolsElement usableMiningTool = null; 
            var currentItemGuid = MasterHolder.ItemMaster.GetItemMaster(inventoryItem.Id).ItemGuid;
            foreach (var miningTool in miningTools)
            {
                if (miningTool.ToolItemGuid != currentItemGuid) continue;
                
                usableMiningTool = miningTool;
                break;
            }
            
            // マイニングツールとして登録されていない場合はフォーカスを維持
            // If it is not registered as a mining tool, maintain focus
            if (usableMiningTool == null)
            {
                ShowRecommendMiningTools(miningTools);
                return this;
            }
            
            // クリックしていあない場合はフォーカスを維持
            // If not clicked, maintain focus
            if (!InputManager.Playable.ScreenLeftClick.GetKey)
            {
                MouseCursorExplainer.Instance.Show("左クリック長押しで取得", isLocalize: false);
                return this;
            }
            
            // マイニング状態に遷移
            // Transition to mining state
            MouseCursorExplainer.Instance.Hide();
            return new MapObjectMiningMiningState(usableMiningTool, context.PlayerObjectController);
        }
        
        
        private void ShowRecommendMiningTools(MiningToolsElement[] miningTools)
        {
            var result = new List<string>();
            
            foreach (var tool in miningTools)
            {
                var itemMaster = MasterHolder.ItemMaster.GetItemMaster(tool.ToolItemGuid);
                result.Add(itemMaster.Name);
            }
            
            var text = "このアイテムが必要です:" + string.Join(", ",result);
            
            MouseCursorExplainer.Instance.Show(text, isLocalize: false);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningMiningState.cs
```cs
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.ProgressBar;
using Client.Input;
using Mooresmaster.Model.MapObjectsModule;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningMiningState : IMapObjectMiningState
    {
        private readonly MiningToolsElement _miningToolsElement;
        
        private float _currentMiningProgressTime;
        
        public MapObjectMiningMiningState(MiningToolsElement miningToolsElement, IPlayerObjectController playerObjectController)
        {
            _miningToolsElement = miningToolsElement;
            _currentMiningProgressTime = 0;
            
            playerObjectController.SetAnimationState(PlayerAnimationState.Axe);
            ProgressBarView.Instance.Show();
        }
        
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            var next = GetNextUpdateInternal(context, dt);
            if (next != this)
            {
                context.PlayerObjectController.SetAnimationState(PlayerAnimationState.IdleWalkRunBlend);
                ProgressBarView.Instance.Hide();
            }
            return next;
        }
        
        private IMapObjectMiningState GetNextUpdateInternal(MapObjectMiningControllerContext context, float dt)
        {
            // フォーカスが外れた場合はidleに遷移
            // if focus is lost, transition to idle
            if (context.CurrentFocusMapObjectGameObject == null)
            {
                return new MapObjectMiningFocusState();
            }
            
            // 左クリックされていない場合はフォーカス状態に遷移
            // If left click is not pressed, transition to focus state
            if (!InputManager.Playable.ScreenLeftClick.GetKey)
            {
                return new MapObjectMiningFocusState();
            }
            
            _currentMiningProgressTime += dt;
            ProgressBarView.Instance.SetProgress(_currentMiningProgressTime / _miningToolsElement.AttackSpeed);
            
            // マイニングが完了した場合はマイニング完了状態に遷移
            // If mining is complete, transition to mining complete state
            if (_miningToolsElement.AttackSpeed <= _currentMiningProgressTime)
            {
                var attackDamage = _miningToolsElement.Damage;
                return new MapObjectMiningMiningCompleteState(context.CurrentFocusMapObjectGameObject, attackDamage);
            }
            
            return this;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningMiningCompleteState.cs
```cs
using Client.Game.InGame.Context;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.SoundEffect;
using Mooresmaster.Model.MapObjectsModule;
using UnityEngine;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningMiningCompleteState : IMapObjectMiningState
    {
        private readonly MapObjectGameObject _completedMapObjectGameObject;
        private readonly int _attackDamage;
        
        public MapObjectMiningMiningCompleteState(MapObjectGameObject completedMapObjectGameObject, int attackDamage)
        {
            _completedMapObjectGameObject = completedMapObjectGameObject;
            _attackDamage = attackDamage;
        }
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            var masterElement = _completedMapObjectGameObject.MapObjectMasterElement;
            
            PlaySoundEffect(masterElement);
            
            var instanceId = _completedMapObjectGameObject.InstanceId;
            ClientContext.VanillaApi.SendOnly.AttackMapObject(instanceId, _attackDamage);
            
            return context.CurrentFocusMapObjectGameObject == null
                ? new MapObjectMiningIdleState()
                : new MapObjectMiningFocusState();
        }
        
        
        void PlaySoundEffect(MapObjectMasterElement masterElement)
        {
            SoundEffectType soundEffectType;
            switch (masterElement.SoundEffectType)
            {
                case MapObjectMasterElement.SoundEffectTypeConst.stone:
                    soundEffectType = SoundEffectType.DestroyStone;
                    break;
                case MapObjectMasterElement.SoundEffectTypeConst.tree:
                    soundEffectType = SoundEffectType.DestroyTree;
                    break;
                default:
                    soundEffectType = SoundEffectType.DestroyStone;
                    Debug.LogError("採掘音が設定されていません");
                    break;
            }
            
            SoundEffectManager.Instance.PlaySoundEffect(soundEffectType);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningController.cs
```cs
using Client.Common;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.UIState;
using UnityEngine;
using UnityEngine.EventSystems;
using VContainer;

namespace Client.Game.InGame.Mining
{
    /// <summary>
    ///     マップオブジェクトのUIの表示や削除の判定を担当する
    /// </summary>
    public class MapObjectMiningController : MonoBehaviour
    {
        [SerializeField] private HotBarView hotBarView;
        [SerializeField] private float miningDistance = 1.5f;
        
        private IMapObjectMiningState _currentState;
        private MapObjectMiningControllerContext _context;
        
        [Inject]
        public void Constructor(UIStateControl uiStateControl, ILocalPlayerInventory localPlayerInventory, IPlayerObjectController playerObjectController)
        {
            _currentState = new MapObjectMiningIdleState();
            _context = new MapObjectMiningControllerContext(hotBarView, localPlayerInventory, playerObjectController);
        }
        
        
        private void Update()
        {
            // update focus map object
            var currentMapObject = GetCurrentMapObject();
            _context.SetFocusMapObjectGameObject(currentMapObject);
            
            // update state
            _currentState = _currentState.GetNextUpdate(_context, Time.deltaTime);
            
            #region Internal
            
            MapObjectGameObject GetCurrentMapObject()
            {
                if (Camera.main == null) return null;
                
                var ray = Camera.main.ScreenPointToRay(new Vector2(Screen.width / 2.0f, Screen.height / 2.0f));
                if (!Physics.Raycast(ray, out var hit, 10, LayerConst.MapObjectOnlyLayerMask)) return null;
                if (EventSystem.current.IsPointerOverGameObject()) return null;
                if (!hit.collider.gameObject.TryGetComponent(out MapObjectGameObject mapObject)) return null;
                
                var playerPos = _context.PlayerObjectController.Position;
                var mapObjectPos = mapObject.transform.position;
                if (miningDistance < Vector3.Distance(playerPos, mapObjectPos)) return null;
                
                return mapObject;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObject.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using UnityEngine;

namespace Game.Map.Interface.MapObject
{
    /// <summary>
    ///     小石や木など、マップ上にもとから配置されている静的なオブジェクトです。
    /// </summary>
    public interface IMapObject
    {
        /// <summary>
        ///     マップオブジェクト自体の固有ID
        ///     オブジェクトごとに異なる
        /// </summary>
        public int InstanceId { get; }
        
        /// <summary>
        ///     そのオブジェクトのID
        /// </summary>
        public Guid MapObjectGuid { get; }
        
        /// <summary>
        ///     オブジェクトがすでに獲得などされていればtrue
        /// </summary>
        public bool IsDestroyed { get; }
        
        /// <summary>
        ///     オブジェクトが存在する座標
        /// </summary>
        Vector3 Position { get; }
        
        /// <summary>
        ///     MapObjectが破壊されるまでのHP
        /// </summary>
        public int CurrentHp { get; }
        
        /// <summary>
        ///     獲得したとき入手できるアイテム
        /// </summary>
        public List<IItemStack> EarnItems { get; }
        
        public event Action OnDestroy;
        
        /// <summary>
        ///     HPを減らして、入手できるアイテムを返す
        ///     0以下になったらDestroyをする
        /// </summary>
        public List<IItemStack> Attack(int damage);
        
        /// <summary>
        ///     オブジェクトを破壊する
        /// </summary>
        public void Destroy();
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/VanillaStaticMapObject.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.Map.Interface.MapObject;
using UnityEngine;
using Random = System.Random;

namespace Game.Map
{
    /// <summary>
    ///     木や小石など基本的に動かないマップオブジェクト
    /// </summary>
    public class VanillaStaticMapObject : IMapObject
    {
        public int InstanceId { get; }
        public Guid MapObjectGuid { get; }
        public bool IsDestroyed { get; private set; }
        public Vector3 Position { get; }
        public int CurrentHp { get; private set; }
        
        public List<IItemStack> EarnItems { get; }
        
        public event Action OnDestroy;
        
        private readonly int[] _earnItemHps;
        
        public VanillaStaticMapObject(int instanceId, Guid mapObjectGuid, bool isDestroyed, int currentHp, Vector3 position)
        {
            var mapObjectConfig = MasterHolder.MapObjectMaster.GetMapObjectElement(mapObjectGuid);
            InstanceId = instanceId;
            MapObjectGuid = mapObjectGuid;
            IsDestroyed = isDestroyed;
            Position = position;
            CurrentHp = currentHp;
            
            
            _earnItemHps = mapObjectConfig.EarnItemHps;
            
            var random = new Random(instanceId);
            EarnItems = new List<IItemStack>();
            foreach (var earnItemConfig in mapObjectConfig.EarnItems)
            {
                var itemCount = random.Next(earnItemConfig.MinCount, earnItemConfig.MaxCount + 1);
                var itemStack = ServerContext.ItemStackFactory.Create(earnItemConfig.ItemGuid, itemCount);
                
                EarnItems.Add(itemStack);
            }
        }
        
        public List<IItemStack> Attack(int damage)
        {
            var lastHp = CurrentHp;
            CurrentHp -= damage;
            if (CurrentHp <= 0) Destroy();
            
            var earnedCount = _earnItemHps.Count(hp => lastHp > hp && CurrentHp <= hp);
            if (earnedCount == 0) return new List<IItemStack>();
            
            var earnedItems = new List<IItemStack>();
            foreach (var item in EarnItems)
            {
                var id = item.Id;
                var count = item.Count * earnedCount;
                
                earnedItems.Add(ServerContext.ItemStackFactory.Create(id, count));
            }
            
            return earnedItems;
        }
        
        public void Destroy()
        {
            CurrentHp = 0;
            IsDestroyed = true;
            OnDestroy?.Invoke();
        }
    }
}
```

コードを書く場合はコメント、空白、タブ、改行は本のコードと全く同じにしてください。適切な差分を維持するため、必要箇所以外は編集しないでください。
# Instructions

以下の機能を実装するコンポーネントとテストコードは何ですか？また、それを実装してください。

**MapObject採掘機**

### 概要
MapObject採掘機(以下、本機)は、設置型のマシンであり、その周囲に存在する特定のMapObject(例：木、石など)を自動で採掘し、採掘結果となるアイテムを自身のインベントリに格納します。

### 目的
- プレイヤーが近接操作や手動採掘を行わずとも、自動的にMapObject資源を獲得できる仕組みを提供する。
- 生産ラインや自動化構築において、原材料となるMapObject由来アイテムを安定的かつ継続的に供給する。

### 詳細機能
1. **採掘範囲検出**
   - 本機は設置地点を中心とした一定範囲(パラメータで定義可能)内に存在するMapObjectを検知する。
   - 検出にはクライアント側で定期的に当たり判定(コライダー)によるスキャンを行うことで、範囲内にあるMapObjectを特定する。

2. **ダメージ付与とMapObject破壊**
   - 採掘対象となったMapObjectには一定時間ごと、または一定周期でダメージを与える処理を行う。
   - MapObjectごとのHPが0以下になると、そのMapObjectは破壊されたと見なされ、該当MapObjectは今後採掘対象から除外される。
   - 本機によるダメージはクライアント側で検知され、サーバーにダメージ情報が送られることで正式に反映される。

3. **アイテム化およびインベントリ格納**
   - MapObjectが破壊されると、それに対応する採掘結果(アイテム)がサーバー側で生成され、本機のインベントリへと挿入される。
   - インベントリ容量が満杯の場合、アイテムは採掘機内でスタックされず、あふれたアイテムは挿入失敗や別の処理(排出口への排出など)を考慮する必要がある。

4. **クライアント-サーバー間通信フロー**
   - クライアント側：
     - コライダーを用いて採掘範囲内のMapObjectを特定。
   - サーバー側：
     - クライアントから送られてくる破壊対象となるMapObjectを保持
     - 一定間隔でMapObjectのHPを減算。
     - HPが0以下になったMapObjectは破壊状態とし、対応する報酬アイテムを生成、本機のインベントリへ挿入する。

### パラメータおよびチューニングポイント
- 採掘範囲半径(または直方体範囲)：MapObject探索を行う範囲サイズ
- ダメージ間隔：どれぐらいの頻度でMapObjectへダメージを与えるか
- ダメージ量：1回の処理あたりのダメージ量
- インベントリ容量：本機が保持できるアイテムスタック数
- クールダウンタイム：MapObject破壊後、新たなMapObjectを対象とするまでのインターバル(必要に応じて)

### 想定ユースケース
- プレイヤーがMapObjectが多い場所に本機を設置し、自動的に資源を収集する。
- 資源が枯渇した場所では、新たなMapObjectが生成されない限り生産が止まるため、プレイヤーは別エリアへの移動や本機の再配置を検討する。

### エラーハンドリング・特記事項
- サーバーとの同期不整合があった場合、クライアント側の検知対象MapObjectリストを再取得するなどのリカバリ処理が必要。
- インベントリが満杯の場合の挙動(採掘結果の破棄、停止、外部排出など)は別途決定。
- 本機の耐久値や動力源などがある場合は、動力切れまたは耐久切れで動作が停止する仕様も考慮可能。
