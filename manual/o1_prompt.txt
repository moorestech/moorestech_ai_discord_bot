moorestech_server/Assets/Scripts/Game.Paths/CalcFileHash.cs
```cs
using System;
using System.IO;
using System.Security.Cryptography;

namespace Game.Paths
{
    public static class CalcFileHash
    {
        public static string GetSha1Hash(string filePath)
        {
            using var sha1 = new SHA1Managed();
            using var stream = File.OpenRead(filePath);
            var hash = sha1.ComputeHash(stream);
            return BitConverter.ToString(hash).Replace("-", string.Empty);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/GameObjectExtension.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public static class GameObjectExtension
    {
        public static string GetFullPath(this GameObject obj)
        {
            return GetFullPath(obj.transform);
        }
        
        public static string GetFullPath(this Transform t)
        {
            var path = t.name;
            var parent = t.parent;
            while (parent)
            {
                path = $"{parent.name}/{path}";
                parent = parent.parent;
            }
            
            return path;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Paths/StringExtension.cs
```cs
namespace Game.Paths
{
    public static class StringExtension
    {
        public static string ReplaceFileNotAvailableCharacter(this string fileName, string replace)
        {
            fileName = fileName.Replace("/", replace);
            fileName = fileName.Replace("\\", replace);
            fileName = fileName.Replace(" ", replace);
            fileName = fileName.Replace(":", replace);
            fileName = fileName.Replace("*", replace);
            fileName = fileName.Replace("?", replace);
            fileName = fileName.Replace("\"", replace);
            fileName = fileName.Replace("<", replace);
            fileName = fileName.Replace(">", replace);
            fileName = fileName.Replace("|", replace);
            fileName = fileName.Replace(".", replace);
            return fileName;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/EventTestUtil.cs
```cs
using System.Collections.Generic;
using System.Linq;
using MessagePack;
using Server.Protocol.PacketResponse;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class EventTestUtil
    {
        public static List<byte> EventRequestData(int playerID)
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(playerID)).ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/PlayerPrefsKeys.cs
```cs
namespace Client.Common
{
    public class PlayerPrefsKeys
    {
        public const string PlayerIdKey = "PlayerId";
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/QuitGame.cs
```cs
using UnityEngine;
using UnityEngine.UI;

namespace Client.MainMenu
{
    public class QuitGame : MonoBehaviour
    {
        [SerializeField] private Button quitButton;
        
        private void Awake()
        {
            quitButton.onClick.AddListener(Application.Quit);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/IPacketResponse.cs
```cs
using System.Collections.Generic;

namespace Server.Protocol.PacketResponse
{
    public interface IPacketResponse
    {
        public ProtocolMessagePackBase GetResponse(List<byte> payload);
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/UI/SelectionButton.cs
```cs
using System.Threading;
using Cysharp.Threading.Tasks;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Skit.UI
{
    public class SelectionButton : MonoBehaviour
    {
        [SerializeField] private Button button;
        [SerializeField] private TMP_Text buttonText;
        
        private int _index;
        
        public void SetButton(string text, int index)
        {
            buttonText.text = text;
            _index = index;
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
        
        public async UniTask<int> WaitClick(CancellationToken ct)
        {
            await button.OnClickAsync(ct);
            return _index;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/Asset/AddressableLoader.cs
```cs
using System;
using System.Linq;
using Cysharp.Threading.Tasks;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

namespace Client.Common.Asset
{
    public class AddressableLoader
    {
        public static async UniTask<LoadedAsset<T>> LoadAsync<T>(string address) where T : UnityEngine.Object
        {
            if (string.IsNullOrEmpty(address))
            {
                return null;
            }
            
            var handle = Addressables.LoadAssetAsync<T>(address);
            await handle.Task;
            
            return handle.Status == AsyncOperationStatus.Succeeded ? new LoadedAsset<T>(handle.Result) : null;
        }
        
        public static async UniTask<T> LoadAsyncDefault<T>(string address) where T : UnityEngine.Object
        {
            var loadedAsset = await LoadAsync<T>(address);
            return loadedAsset?.Asset;
        }
    }
    
    public class LoadedAsset<T> : IDisposable where T : UnityEngine.Object
    {
        public T Asset { get; }
        
        public LoadedAsset(T asset)
        {
            Asset = asset;
        }
        
        public void Dispose()
        {
            Addressables.Release(Asset);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/PauseMenu/SaveButton.cs
```cs
using Client.Game.InGame.Context;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.Presenter.PauseMenu
{
    public class SaveButton : MonoBehaviour
    {
        [SerializeField] private Button saveButton;
        
        private void Start()
        {
            saveButton.onClick.AddListener(ClientContext.VanillaApi.SendOnly.Save);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/EmotionType.cs
```cs
namespace Client.Skit.SkitTrack
{
    public enum EmotionType
    {
        Normal,
        Happy,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/PauseMenu/NetworkDisconnectPresenter.cs
```cs
using Client.Common;
using Client.Game.InGame.Context;
using UniRx;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace Client.Game.InGame.Presenter.PauseMenu
{
    public class NetworkDisconnectPresenter : MonoBehaviour
    {
        [SerializeField] private GameObject disconnectPanel;
        
        [SerializeField] private Button goToMainMenuButton;
        
        private void Start()
        {
            ClientContext.VanillaApi.OnDisconnect.Subscribe(_ => { disconnectPanel.gameObject.SetActive(true); }).AddTo(this);
            goToMainMenuButton.onClick.AddListener(() => { SceneManager.LoadScene(SceneConstant.MainMenuSceneName); });
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/RPM.cs
```cs
// ReSharper disable InconsistentNaming

using UnitGenerator;

namespace Game.Gear.Common
{
    [UnitOf(typeof(float), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable)]
    public partial struct RPM
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Skit/Starter/StartSkitUI.cs
```cs
using UnityEngine;

namespace Client.Game.Skit.Starter
{
    public class StartSkitUI : MonoBehaviour
    {
        [SerializeField] private GameObject startStoryPanel;
        
        public void ShowStartStoryUI(bool enable)
        {
            startStoryPanel.SetActive(enable);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/SceneConstant.cs
```cs
namespace Client.Common
{
    public class SceneConstant
    {
        public const string MainMenuSceneName = "MainMenu";
        public const string GameInitializerSceneName = "GameInitialaizer";
        public const string MainGameSceneName = "MainGame";
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/Settings/PlayerConnectionSetting.cs
```cs
namespace Client.Network.Settings
{
    public class PlayerConnectionSetting
    {
        public readonly int PlayerId;
        
        public PlayerConnectionSetting(int playerId)
        {
            PlayerId = playerId;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/ResetStoryButton.cs
```cs
using Client.Game.Sequence;
using UnityEngine;
using UnityEngine.UI;

namespace Client.MainMenu
{
    public class ResetStoryButton : MonoBehaviour
    {
        [SerializeField] private Button resetStoryButton;
        
        private void Start()
        {
            resetStoryButton.onClick.AddListener(() =>
            {
                PlayerPrefs.DeleteKey(S1InitialMovie.S1InitialMoviePlayerPrefsKey);
                PlayerPrefs.Save();
            });
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Skit/Starter/PlayerSkitStarterDetector.cs
```cs
using UnityEngine;

namespace Client.Game.Skit.Starter
{
    public class PlayerSkitStarterDetector : MonoBehaviour
    {
        [SerializeField] private StartSkitUI startSkitUI;
        
        public bool IsStartReady => CurrentSkitStarterObject != null;
        public SkitStarterObject CurrentSkitStarterObject { get; private set; }
        
        private void OnDisable()
        {
            startSkitUI.ShowStartStoryUI(false);
        }
        
        private void OnTriggerEnter(Collider other)
        {
            if (other.TryGetComponent<SkitStarterObject>(out var storyStarterObject))
            {
                CurrentSkitStarterObject = storyStarterObject;
                startSkitUI.ShowStartStoryUI(true);
            }
        }
        
        private void OnTriggerExit(Collider other)
        {
            if (other.TryGetComponent<SkitStarterObject>(out var _))
            {
                CurrentSkitStarterObject = null;
                startSkitUI.ShowStartStoryUI(false);
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/BlockConstant.cs
```cs
using Core.Master;

namespace Client.Common
{
    public static class BlockConstant
    {
        public static readonly BlockId NullBlockId = new(0);
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/LanguageSetting.cs
```cs
using Client.Localization;
using TMPro;
using UnityEngine;

namespace Client.MainMenu
{
    public class LanguageSetting : MonoBehaviour
    {
        [SerializeField] private TMP_Dropdown tmpDropdown;
        
        private void Start()
        {
            tmpDropdown.ClearOptions();
            tmpDropdown.AddOptions(Localize.LanguageCodes);
            tmpDropdown.value = Localize.LanguageCodes.IndexOf(Localize.CurrentLanguageCode);
            tmpDropdown.onValueChanged.AddListener(OnValueChanged);
        }
        
        private void OnValueChanged(int index)
        {
            Localize.SetLanguage(Localize.LanguageCodes[index]);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/Event/GrabInventoryUpdateEvent.cs
```cs
using Game.PlayerInventory.Interface.Event;
using static Game.PlayerInventory.Interface.Event.IGrabInventoryUpdateEvent;

namespace Game.PlayerInventory.Event
{
    public class GrabInventoryUpdateEvent : IGrabInventoryUpdateEvent
    {
        public void Subscribe(UpdateInventoryEvent updateInventoryEvent)
        {
            OnPlayerInventoryUpdate += updateInventoryEvent;
        }
        
        public event UpdateInventoryEvent OnPlayerInventoryUpdate;
        
        public void OnInventoryUpdateInvoke(
            PlayerInventoryUpdateEventProperties properties)
        {
            OnPlayerInventoryUpdate?.Invoke(properties);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/StoryTrackDefine.cs
```cs
namespace Client.Skit.SkitTrack
{
    public class StoryTrackDefine
    {
        public static IStoryTrack GetStoryTrack(string key)
        {
            return key switch
            {
                "Camerawork" => new CameraworkTrack(),
                "CameraWarp" => new CameraWarpTrack(),
                "Text" => new TextTrack(),
                "CharacterTransform" => new CharacterTransformTrack(),
                "CharacterMotion" => new CharacterMotionTrack(),
                "CharacterEmotion" => new CharacterEmotionTrack(),
                "WaitTime" => new WaitTimeTrack(),
                "Transition" => new TransitionTrack(),
                "SelectionTrack" => new SelectionTrack(),
                "Jump" => new JumpTrack(),
                _ => null,
            };
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/Event/IGrabInventoryUpdateEvent.cs
```cs
namespace Game.PlayerInventory.Interface.Event
{
    public interface IGrabInventoryUpdateEvent
    {
        public delegate void UpdateInventoryEvent(
            PlayerInventoryUpdateEventProperties playerInventoryUpdateEventProperties);
        
        public void Subscribe(UpdateInventoryEvent updateInventoryEvent);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/PauseMenuState.cs
```cs
using Client.Game.InGame.UI.UIState.UIObject;
using Client.Input;

namespace Client.Game.InGame.UI.UIState
{
    public class PauseMenuState : IUIState
    {
        private readonly PauseMenuObject _pauseMenu;
        
        public PauseMenuState(PauseMenuObject pauseMenu)
        {
            _pauseMenu = pauseMenu;
            pauseMenu.gameObject.SetActive(false);
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.CloseUI.GetKeyDown) return UIStateEnum.GameScreen;
            
            return UIStateEnum.Current;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            _pauseMenu.gameObject.SetActive(true);
            InputManager.MouseCursorVisible(true);
        }
        
        public void OnExit()
        {
            _pauseMenu.gameObject.SetActive(false);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIStateEnum.cs
```cs
namespace Client.Game.InGame.UI.UIState
{
    public enum UIStateEnum
    {
        Current,
        
        GameScreen,
        PlayerInventory,
        BlockInventory,
        PauseMenu,
        DeleteBar,
        Story,
        PlaceBlock,
        BlockDebug,
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/Settings/ConnectionServerConfig.cs
```cs
namespace Client.Network.Settings
{
    public class ConnectionServerConfig
    {
        public readonly string IP;
        public readonly int Port;
        
        public ConnectionServerConfig(string ip, int port)
        {
            IP = ip;
            Port = port;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Util/ToByteList.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Server.Util
{
    public static class ToByteList
    {
        public static List<byte> Convert(int sendData)
        {
            var result = BitConverter.GetBytes(sendData);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(result);
            return result.ToList();
        }
        
        public static List<byte> Convert(short sendData)
        {
            var result = BitConverter.GetBytes(sendData);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(result);
            return result.ToList();
        }
        
        public static List<byte> Convert(float sendData)
        {
            var result = BitConverter.GetBytes(sendData);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(result);
            return result.ToList();
        }
        
        public static List<byte> Convert(string sendData)
        {
            return Encoding.UTF8.GetBytes(sendData).ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/StartLocal.cs
```cs
using System.Diagnostics;
using Client.Common;
using Client.Starter;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using Debug = UnityEngine.Debug;

namespace Client.MainMenu
{
    public class StartLocal : MonoBehaviour
    {
        [SerializeField] private Button startLocalButton;
        
        private Process _serverProcess;
        
        
        private void Start()
        {
            startLocalButton.onClick.AddListener(() => ConnectLocalServer().Forget());
        }
        
        private async UniTask ConnectLocalServer()
        {
            Debug.Log("Server started");
            
            SceneManager.sceneLoaded += OnMainGameSceneLoaded;
            SceneManager.LoadScene(SceneConstant.GameInitializerSceneName);
        }
        
        private void OnMainGameSceneLoaded(Scene scene, LoadSceneMode mode)
        {
            SceneManager.sceneLoaded -= OnMainGameSceneLoaded;
            var starter = FindObjectOfType<InitializeScenePipeline>();
            
            starter.SetProperty(new InitializeProprieties(
                true, _serverProcess,
                ServerConst.LocalServerIp,
                ServerConst.LocalServerPort,
                PlayerPrefs.GetInt(PlayerPrefsKeys.PlayerIdKey)));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/Event/MainInventoryUpdateEvent.cs
```cs
using Game.PlayerInventory.Interface.Event;
using static Game.PlayerInventory.Interface.Event.IMainInventoryUpdateEvent;

namespace Game.PlayerInventory.Event
{
    public class MainInventoryUpdateEvent : IMainInventoryUpdateEvent
    {
        public void Subscribe(UpdateInventoryEvent updateInventoryEvent)
        {
            OnPlayerInventoryUpdate += updateInventoryEvent;
        }
        
        public event UpdateInventoryEvent OnPlayerInventoryUpdate;
        
        public void OnInventoryUpdateInvoke(
            PlayerInventoryUpdateEventProperties properties)
        {
            OnPlayerInventoryUpdate?.Invoke(properties);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/JumpTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class JumpTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            return parameters[0];
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/Event/IMainInventoryUpdateEvent.cs
```cs
namespace Game.PlayerInventory.Interface.Event
{
    public interface IMainInventoryUpdateEvent
    {
        public delegate void UpdateInventoryEvent(
            PlayerInventoryUpdateEventProperties playerInventoryUpdateEventProperties);
        
        public void Subscribe(UpdateInventoryEvent updateInventoryEvent);
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/VanillaMapObjectType.cs
```cs
namespace Game.Map.Interface.MapObject
{
    public static class VanillaMapObjectType
    {
        public const string VanillaPebble = "vanilla:Pebble";
        public const string VanillaTree = "vanilla:Tree";
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockInstanceId.cs
```cs
using System;
using UnitGenerator;

namespace Game.Block.Interface
{
    [UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter | UnitGenerateOptions.Comparable)]
    public readonly partial struct BlockInstanceId
    {
        private static readonly Random Random = new();
        
        public static BlockInstanceId Create()
        {
            return new BlockInstanceId(Random.Next(int.MinValue, int.MaxValue));
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/HotBarSlotToInventorySlotTest.cs
```cs
using Game.PlayerInventory.Interface;
using NUnit.Framework;

namespace Tests.UnitTest.Game
{
    public class HotBarSlotToInventorySlotTest
    {
        [TestCase(0, 36)]
        [TestCase(1, 37)]
        [TestCase(8, 44)]
        public void Test(int hotBarSlot, int inventorySlot)
        {
            Assert.AreEqual(inventorySlot, PlayerInventoryConst.HotBarSlotToInventorySlot(hotBarSlot));
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/IUIState.cs
```cs
namespace Client.Game.InGame.UI.UIState
{
    public interface IUIState
    {
        public void OnEnter(UIStateEnum lastStateEnum);
        public UIStateEnum GetNextUpdate();
        public void OnExit();
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/UIHighlight/UIHighlightTutorialTargetObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Tutorial.UIHighlight
{
    [RequireComponent(typeof(RectTransform))]
    public class UIHighlightTutorialTargetObject : MonoBehaviour
    {
        public bool ActiveSelf => gameObject.activeInHierarchy;
        
        public string HighlightObjectId => highlightObjectId;
        [SerializeField] private string highlightObjectId;
        
        public RectTransform RectTransform => rectTransform;
        [SerializeField] private RectTransform rectTransform;
        
        public void Initialize(string uiObjectId)
        {
            highlightObjectId = uiObjectId;
            rectTransform = GetComponent<RectTransform>();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/TestModDirectory.cs
```cs
using System;
using System.IO;

namespace Tests.Module.TestMod
{
    public class TestModDirectory
    {
        private static string FolderDirectory => Path.Combine(Environment.CurrentDirectory, "../", "moorestech_server", "Assets", "Scripts", "", "Tests.Module", "TestMod");
        
        public static string ConfigOnlyDirectory => Path.Combine(FolderDirectory, "ConfigOnly");
        public static string ForUnitTestModDirectory => Path.Combine(FolderDirectory, "ForUnitTest");
        
        public static string MoorestechAlphaModDirectory => Path.Combine(Environment.CurrentDirectory, "../", "moorestech_client", "Server");
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/Event/PlayerInventoryUpdateEventProperties.cs
```cs
using Core.Item.Interface;

namespace Game.PlayerInventory.Interface.Event
{
    public class PlayerInventoryUpdateEventProperties
    {
        public readonly int PlayerId;
        public readonly int InventorySlot;
        public readonly IItemStack ItemStack;
        
        public PlayerInventoryUpdateEventProperties(int playerId, int inventorySlot, IItemStack itemStack)
        {
            PlayerId = playerId;
            InventorySlot = inventorySlot;
            ItemStack = itemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Extension/BlockPositionInfoExtension.cs
```cs
using UnityEngine;

namespace Game.Block.Interface.Extension
{
    public static class BlockPositionInfoExtension
    {
        public static bool IsContainPos(this BlockPositionInfo self, Vector3Int pos)
        {
            return self.MinPos.x <= pos.x && pos.x <= self.MaxPos.x &&
                   self.MinPos.y <= pos.y && pos.y <= self.MaxPos.y &&
                   self.MinPos.z <= pos.z && pos.z <= self.MaxPos.z;
        }
        
        public static bool IsOverlap(this BlockPositionInfo self, BlockPositionInfo other)
        {
            return self.MinPos.x <= other.MaxPos.x && other.MinPos.x <= self.MaxPos.x &&
                   self.MinPos.y <= other.MaxPos.y && other.MinPos.y <= self.MaxPos.y &&
                   self.MinPos.z <= other.MaxPos.z && other.MinPos.z <= self.MaxPos.z;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/Command/CommandUIInput.cs
```cs
using Client.Game.InGame.Context;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.Presenter.Command
{
    public class CommandUIInput : MonoBehaviour
    {
        [SerializeField] private TMP_InputField commandInputField;
        [SerializeField] private Button submitButton;
        
        
        private void Start()
        {
            submitButton.onClick.AddListener(SubmitCommand);
        }
        
        private void SubmitCommand()
        {
            ClientContext.VanillaApi.SendOnly.SendCommand(commandInputField.text);
            commandInputField.text = string.Empty;
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/MapVeinGameObjectInspector.cs
```cs
using System;
using Client.Game.InGame.Map.MapVein;
using UnityEditor;
using UnityEditor.IMGUI.Controls;
using UnityEngine;

[CustomEditor(typeof(MapVeinGameObject))]
public class MapVeinGameObjectInspector : Editor
{
    private readonly BoxBoundsHandle _boxBoundsHandle = new();
    
    private void OnSceneGUI()
    {
        var mapVein = target as MapVeinGameObject;
        if (mapVein == null)
        {
            return;
        }
        
        EditorGUI.BeginChangeCheck();
        
        _boxBoundsHandle.center = mapVein.Bounds.center + mapVein.transform.position;
        _boxBoundsHandle.size = mapVein.Bounds.size;
        
        _boxBoundsHandle.SetColor(Color.red);
        _boxBoundsHandle.DrawHandle();
        
        if (EditorGUI.EndChangeCheck())
        {
            
            var bounds = new Bounds(_boxBoundsHandle.center, _boxBoundsHandle.size);
            mapVein.SetBounds(bounds);
            Undo.RecordObject(mapVein, "Change Bounds");
            EditorUtility.SetDirty(mapVein);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Skit/SkitCamera.cs
```cs
using DG.Tweening;
using UnityEngine;

namespace Client.Skit.Skit
{
    public interface ISkitCamera
    {
        public void TweenCamera(Vector3 fromPos, Vector3 fromRot, Vector3 toPos, Vector3 toRot, float duration, Ease easing);
        
        public void SetTransform(Vector3 pos, Vector3 rot);
        
        public void SetActive(bool enabled);
    }
    
    public class SkitCamera : MonoBehaviour, ISkitCamera
    {
        [SerializeField] private Camera camera;
        
        public void TweenCamera(Vector3 fromPos, Vector3 fromRot, Vector3 toPos, Vector3 toRot, float duration, Ease easing)
        {
            camera.transform.position = fromPos;
            camera.transform.eulerAngles = fromRot;
            
            camera.transform.DOMove(toPos, duration).SetEase(easing);
            camera.transform.DORotate(toRot, duration).SetEase(easing);
        }
        
        public void SetTransform(Vector3 pos, Vector3 rot)
        {
            camera.transform.position = pos;
            camera.transform.eulerAngles = rot;
        }
        
        public void SetActive(bool enabled)
        {
            gameObject.SetActive(enabled);
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/SchemaWatcher.cs
```cs

```

moorestech_client/Assets/Scripts/Client.Common/LayerConst.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public class LayerConst
    {
        public static readonly int PlayerLayer = LayerMask.NameToLayer("Player");
        public static readonly int BlockLayer = LayerMask.NameToLayer("Block");
        public static readonly int BlockBoundingBoxLayer = LayerMask.NameToLayer("BlockBoundingBox");
        public static readonly int MapObjectLayer = LayerMask.NameToLayer("MapObject");
        
        public static readonly int BlockOnlyLayerMask = 1 << BlockLayer;
        public static readonly int MapObjectOnlyLayerMask = 1 << MapObjectLayer;
        public static readonly int PlayerOnlyLayerMask = 1 << PlayerLayer;
        
        public static readonly int Without_Player_MapObject_Block_LayerMask = ~MapObjectOnlyLayerMask & ~PlayerOnlyLayerMask & ~BlockOnlyLayerMask;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/SkitState.cs
```cs
using Client.Game.Skit;

namespace Client.Game.InGame.UI.UIState
{
    public class SkitState : IUIState
    {
        private readonly SkitManager _skitManager;
        
        public SkitState(SkitManager skitManager)
        {
            _skitManager = skitManager;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (_skitManager.IsPlayingSkit) return UIStateEnum.Current;
            return UIStateEnum.GameScreen;
        }
        
        public void OnExit()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeJsonObject.cs
```cs
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Game.Challenge
{
    public class ChallengeJsonObject
    {
        [JsonProperty("completedGuids")] public List<string> CompletedGuids;
        [JsonProperty("playerId")] public int PlayerId;
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/PopUp/ServerConnectPopup.cs
```cs
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Client.MainMenu.PopUp
{
    public class ServerConnectPopup : MonoBehaviour
    {
        [SerializeField] private TMP_Text logText;
        [SerializeField] private Button closeButton;
        
        private void Start()
        {
            closeButton.onClick.AddListener(() =>
                gameObject.SetActive(false)
            );
        }
        
        public void SetText(string text)
        {
            gameObject.SetActive(true);
            logText.text = text;
        }
    }
}
```

schema/challenges.json
```cs
{
  "$id": "challenges",
  "type": "object",
  "isDefaultOpen": true,

  "properties": {
    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "ChallengeMasterElement",

      "items": {
        "type": "object",
        "properties": {

          "challengeGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "prevChallengeGuid": {
            "type": "string",
            "format": "uuid",
            "foreignKey": "challenges:challengeGuid:title",
            "optional": true
          },

          "title": {
            "type": "string",
            "default": "New Challenge"
          },

          "summary": {
            "type": "string",
            "default": "New Challenge summary"
          },

          "playSkitType": {
            "type": "string",
            "default": "createItem",
            "enum": ["None", "BackgroundSkit"]
          },

          "playSkitParam": {
            "oneOf": [
              {
                "if": {
                  "properties": {
                    "playSkitType": { "const": "None" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "playSkitType": { "const": "BackgroundSkit" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "fireSkitName": {
                      "type": "string"
                    }
                  }
                }
              }
            ]
          },


          "taskCompletionType": {
            "type": "string",
            "default": "createItem",
            "enum": ["createItem", "inInventoryItem","blockPlace"]
          },

          "taskParam": {
            "oneOf": [
              {
                "if": {
                  "properties": {
                    "taskCompletionType": { "const": "createItem" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "itemGuid": {
                      "type": "string",
                      "format": "uuid",
                      "foreignKey": "items:itemGuid:name"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "taskCompletionType": { "const": "inInventoryItem" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "itemGuid": {
                      "type": "string",
                      "format": "uuid",
                      "foreignKey": "items:itemGuid:name"
                    },
                    "itemCount": {
                      "type": "integer",
                        "default": 1
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "taskCompletionType": { "const": "blockPlace" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "blockGuid": {
                      "type": "string",
                      "format": "uuid",
                      "foreignKey": "blocks:blockGuid:name"
                    },
                    "itemCount": {
                      "type": "integer",
                        "default": 1
                    }

                  }
                }
              }
            ]
          },


          "tutorials": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {

                "tutorialType": {
                  "type": "string",
                  "default": "uiHighLight",
                  "enum": ["mapObjectPin", "keyControl", "uiHighLight"]
                },

                "tutorialParam": {
                  "oneOf": [
                    {
                      "if": {
                        "properties": {
                          "tutorialType": { "const": "mapObjectPin" }
                        }
                      },
                      "then": {
                        "type": "object",
                        "properties": {
                          "mapObjectGuid": {
                            "type": "string",
                            "format": "uuid",
                            "foreignKey": "mapObjects:mapObjectGuid:mapObjectName"
                          },
                          "pinText": {
                            "type": "string",
                            "default": "pin text"
                          }
                        }
                      }
                    },
                    {
                      "if": {
                        "properties": {
                          "tutorialType": { "const": "keyControl" }
                        }
                      },
                      "then": {
                        "type": "object",
                        "properties": {
                          "uiState": {
                            "type": "string",
                            "enum" : ["GameScreen","PlayerInventory", "BlockInventory", "PauseMenu","DeleteBar","Story","PlaceBlock"],
                            "default": "GameScreen"
                          },
                          "controlText": {
                            "type": "string",
                            "default": "control text"
                          }
                        }
                      }
                    },
                    {
                      "if": {
                        "properties": {
                          "tutorialType": { "const": "uiHighLight" }
                        }
                      },
                      "then": {
                        "type": "object",
                        "properties": {
                          "highLightUIObjectId": {
                            "type": "string",
                            "default": "ui object id"
                          },
                          "highLightText": {
                            "type": "string",
                            "default": "highlight text"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    }
  }
}

```

moorestech_client/Assets/Scripts/Client.Skit/UI/SkitUI.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using TMPro;
using UnityEngine;

namespace Client.Skit.UI
{
    public class SkitUI : MonoBehaviour
    {
        [SerializeField] private GameObject storyPanel;
        
        [SerializeField] private TMP_Text characterNameText;
        [SerializeField] private TMP_Text storyText;
        
        [SerializeField] private CanvasGroup transitionImage;
        
        [SerializeField] private GameObject selectionPanel;
        [SerializeField] private List<SelectionButton> selectionButtons;
        
        public void SetText(string characterName, string text)
        {
            storyPanel.SetActive(true);
            characterNameText.text = characterName;
            storyText.text = text.Replace("\\n", "\n");
        }
        
        public void ShowTransition(bool isShow, float duration)
        {
            transitionImage.alpha = isShow ? 0 : 1;
            transitionImage.DOFade(isShow ? 1 : 0, duration);
        }
        
        public void ShowSelectionUI(bool enable)
        {
            selectionPanel.SetActive(enable);
        }
        
        public async UniTask<int> WaitSelectText(List<string> texts)
        {
            for (var i = 0; i < selectionButtons.Count; i++)
                if (i < texts.Count)
                {
                    selectionButtons[i].SetButton(texts[i], i);
                    selectionButtons[i].SetActive(true);
                }
                else
                {
                    selectionButtons[i].SetActive(false);
                }
            
            var cancelToken = this.GetCancellationTokenOnDestroy();
            
            var (_, resultIndex) = await UniTask.WhenAny(selectionButtons.Select(button => button.WaitClick(cancelToken)));
            
            return resultIndex;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIStateDictionary.cs
```cs
using System.Collections.Generic;

namespace Client.Game.InGame.UI.UIState
{
    public class UIStateDictionary
    {
        private readonly Dictionary<UIStateEnum, IUIState> _stateDictionary = new();
        
        public UIStateDictionary(
            GameScreenState gameScreenState,
            PlayerInventoryState playerInventoryState,
            BlockInventoryState blockInventoryState,
            PauseMenuState pauseMenuState,
            DeleteBlockState deleteBlockState,
            SkitState skitState,
            PlaceBlockState placeBlockState)
        {
            _stateDictionary.Add(UIStateEnum.GameScreen, gameScreenState);
            _stateDictionary.Add(UIStateEnum.PlayerInventory, playerInventoryState);
            _stateDictionary.Add(UIStateEnum.BlockInventory, blockInventoryState);
            _stateDictionary.Add(UIStateEnum.PauseMenu, pauseMenuState);
            _stateDictionary.Add(UIStateEnum.DeleteBar, deleteBlockState);
            _stateDictionary.Add(UIStateEnum.Story, skitState);
            _stateDictionary.Add(UIStateEnum.PlaceBlock, placeBlockState);
        }
        
        public IUIState GetState(UIStateEnum state)
        {
            return _stateDictionary[state];
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Common/GameStateController.cs
```cs
using Client.Game.InGame.Control;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory;
using Client.Input;
using Client.Skit.Skit;
using UnityEngine;

namespace Client.Game.Common
{
    public class GameStateController : MonoBehaviour
    {
        private static GameStateController _instance;
        [SerializeField] private SkitCamera skitCamera;
        [SerializeField] private InGameCameraController inGameCameraController;
        
        [SerializeField] private PlayerObjectController playerObjectController;
        
        [SerializeField] private HotBarView hotBarView;
        [SerializeField] private GameObject challengeText;
        
        private void Awake()
        {
            _instance = this;
        }
        
        public void Start()
        {
            ChangeState(GameStateType.InGame);
        }
        
        public static void ChangeState(GameStateType gameStateType)
        {
            switch (gameStateType)
            {
                case GameStateType.InGame:
                    _instance.SetInGameState();
                    break;
                case GameStateType.Skit:
                    _instance.SetSkitState();
                    break;
                case GameStateType.CutScene:
                    _instance.SetCutSceneState();
                    break;
            }
        }
        
        private void SetInGameState()
        {
            skitCamera.SetActive(false);
            inGameCameraController.SetActive(true);
            
            playerObjectController.SetActive(true);
            
            hotBarView.SetActive(true);
            challengeText.SetActive(true);
            
            InputManager.MouseCursorVisible(false);
        }
        
        private void SetSkitState()
        {
            skitCamera.SetActive(true);
            inGameCameraController.SetActive(false);
            
            playerObjectController.SetActive(false);
            
            hotBarView.SetActive(false);
            challengeText.SetActive(false);
            
            InputManager.MouseCursorVisible(true);
        }
        
        private void SetCutSceneState()
        {
            skitCamera.SetActive(false);
            inGameCameraController.SetActive(false);
            
            playerObjectController.SetActive(false);
            
            hotBarView.SetActive(false);
            challengeText.SetActive(false);
            
            InputManager.MouseCursorVisible(false);
        }
    }
    
    public enum GameStateType
    {
        InGame,
        Skit,
        CutScene,
    }
}
```

moorestech_server/Assets/Scripts/Game.Paths/GameSystemPaths.cs
```cs
using System;
using System.IO;
using System.Runtime.InteropServices;

namespace Game.Paths
{
    public static class GameSystemPaths
    {
        public static string GameSystemDirectory
        {
            get
            {
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                    return DirectoryCreator("C:\\Users", Environment.UserName, "AppData", "Roaming", ".moorestech");
                if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                    return DirectoryCreator("/Users", Environment.UserName, "Library", "Application Support",
                        "moorestech");
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    return DirectoryCreator("/home", Environment.UserName, ".moorestech");
                throw new Exception("Unsupported OS");
            }
        }
        
        public static string TmpFileDirectory => DirectoryCreator(GameSystemDirectory, "Tmp");
        public static string ExtractedModDirectory => DirectoryCreator(TmpFileDirectory, "ExtractedMods");
        public static string SaveFileDirectory => DirectoryCreator(GameSystemDirectory, "Saves");
        
        public static string GetExtractedModDirectory(string folderName)
        {
            return Path.Combine(ExtractedModDirectory, folderName);
        }
        
        public static string CreateExtractedModDirectory(string folderName)
        {
            return DirectoryCreator(ExtractedModDirectory, folderName);
        }

        
        public static string GetSaveFilePath(string fileName)
        {
            return Path.Combine(SaveFileDirectory, fileName);
        }
        
        
        private static string DirectoryCreator(params string[] paths)
        {
            var directory = Path.Combine(paths);
            if (!Directory.Exists(directory)) Directory.CreateDirectory(directory);
            return directory;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/DebugSheet/DebugSheetControllerExtension.cs
```cs
using System;
using Client.Game.GameDebug;
using UnityDebugSheet.Runtime.Core.Scripts;

namespace Client.DebugSystem
{
    public static class DebugSheetControllerExtension
    {
        public static void AddEnumPickerWithSave<TEnum>(this DebugPage debugPage, TEnum defaultValue, string label, string key, Action<TEnum> valueChangedOrInitialize) where TEnum : Enum
        {
            var value = (TEnum)Enum.ToObject(typeof(TEnum), DebugParameters.GetInt(key, Convert.ToInt32(defaultValue)));
            valueChangedOrInitialize(value);
            
            debugPage.AddEnumPicker(value, label, activeValueChanged: d =>
            {
                DebugParameters.SaveInt(key, Convert.ToInt32(d));
                valueChangedOrInitialize((TEnum)d);
            });
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.CutScene/TimelinePlayer.cs
```cs
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Playables;

namespace Client.CutScene
{
    public class TimelinePlayer : MonoBehaviour
    {
        [SerializeField] private PlayableDirector playableDirector;
        
        public async UniTask Play(PlayableAsset playableAsset)
        {
            playableDirector.playableAsset = playableAsset;
            playableDirector.Play();
            
            await UniTask.WaitUntil(() => playableDirector.state != PlayState.Playing);
            
            playableDirector.playableAsset = null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/TextureExtension.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public static class TextureExtension
    {
        public static Sprite ToSprite(this Texture2D texture2D)
        {
            return texture2D == null ? null : Sprite.Create(texture2D, new Rect(0, 0, texture2D.width, texture2D.height), Vector2.zero);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Electric/EnergizedRangeObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Electric
{
    public class EnergizedRangeObject : MonoBehaviour
    {
        public void SetRange(int range)
        {
            var y = transform.localScale.y;
            transform.localScale = new Vector3(range, y, range);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CameraWarpTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Skit.SkitTrack
{
    public class CameraWarpTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var pos = new Vector3(float.Parse(parameters[1]), float.Parse(parameters[2]), float.Parse(parameters[3]));
            var rot = new Vector3(float.Parse(parameters[5]), float.Parse(parameters[6]), float.Parse(parameters[7]));
            
            storyContext.SkitCamera.SetTransform(pos, rot);
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Const/BlockConst.cs
```cs
using Core.Master;

namespace Core.Const
{
    public static class BlockConst
    {
        public static readonly BlockId EmptyBlockId = new(0);
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/IStoryTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public interface IStoryTrack
    {
        public UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIObject/PauseMenuObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.UI.UIState.UIObject
{
    public class PauseMenuObject : MonoBehaviour
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CameraworkTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;
using static System.Enum;

namespace Client.Skit.SkitTrack
{
    public class CameraworkTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var duration = float.Parse(parameters[0]);
            var easing = (Ease)Parse(typeof(Ease), parameters[1]);
            
            var fromPos = new Vector3(float.Parse(parameters[3]), float.Parse(parameters[4]), float.Parse(parameters[5]));
            var fromRot = new Vector3(float.Parse(parameters[7]), float.Parse(parameters[8]), float.Parse(parameters[9]));
            
            var toPos = new Vector3(float.Parse(parameters[11]), float.Parse(parameters[12]), float.Parse(parameters[13]));
            var toRot = new Vector3(float.Parse(parameters[15]), float.Parse(parameters[16]), float.Parse(parameters[17]));
            
            storyContext.SkitCamera.TweenCamera(fromPos, fromRot, toPos, toRot, duration, easing);
            
            return null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/VanillaApiEvent.cs
```cs
using System;
using System.Collections.Generic;
using System.Threading;
using Client.Network.Settings;
using Cysharp.Threading.Tasks;
using Server.Protocol;
using UniRx;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Client.Network.API
{
    public class VanillaApiEvent
    {
        private readonly Dictionary<string, Subject<byte[]>> _eventResponseSubjects = new();
        private readonly PacketExchangeManager _packetExchangeManager;
        private readonly PlayerConnectionSetting _playerConnectionSetting;
        
        public VanillaApiEvent(PacketExchangeManager packetExchangeManager, PlayerConnectionSetting playerConnectionSetting)
        {
            _packetExchangeManager = packetExchangeManager;
            _playerConnectionSetting = playerConnectionSetting;
            CollectEvent().Forget();
        }
        
        private async UniTask CollectEvent()
        {
            while (true)
            {
                var ct = new CancellationTokenSource().Token;
                
                try
                {
                    await RequestAndParse(ct);
                }
                catch (Exception e)
                {
                    Debug.LogError($"Event Protocol Error:{e.Message}\n{e.StackTrace}");
                }
                
                await UniTask.Delay(ServerConst.PollingRateMillSec, cancellationToken: ct);
            }
            
            #region Internal
            
            async UniTask RequestAndParse(CancellationToken ct)
            {
                var request = new EventProtocolMessagePack(_playerConnectionSetting.PlayerId);
                
                var response = await _packetExchangeManager.GetPacketResponse<ResponseEventProtocolMessagePack>(request, ct);
                
                foreach (var eventMessagePack in response.Events)
                {
                    if (!_eventResponseSubjects.TryGetValue(eventMessagePack.Tag, out var subjects)) continue;
                    
                    subjects.OnNext(eventMessagePack.Payload);
                }
            }
            
            #endregion
        }
        
        public IDisposable SubscribeEventResponse(string tag, Action<byte[]> responseAction)
        {
            if (!_eventResponseSubjects.TryGetValue(tag, out var subject))
            {
                subject = new Subject<byte[]>();
                _eventResponseSubjects.Add(tag, subject);
            }
            
            return subject.Subscribe(responseAction);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Control/UICursorFollowControl.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Control
{
    public class UICursorFollowControl : MonoBehaviour
    {
        [SerializeField] private Vector3 offSet = Vector3.zero;
        private RectTransform _canvasRect;
        
        private void Start()
        {
            _canvasRect = transform.root.GetComponentsInChildren<RectTransform>()[0];
        }
        
        private void Update()
        {
            var magnification = _canvasRect.sizeDelta.x / Screen.width;
            
            var itemPos = new Vector3();
            
            itemPos.x = UnityEngine.Input.mousePosition.x * magnification - _canvasRect.sizeDelta.x / 2;
            itemPos.y = UnityEngine.Input.mousePosition.y * magnification - _canvasRect.sizeDelta.y / 2;
            itemPos.z = transform.localPosition.z;
            
            transform.localPosition = itemPos + offSet;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/MaterialConst.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public class MaterialConst
    {
        public const string PlaceBlockAnimationMaterial = "PlaceBlockAnimation";
        
        public const string PreviewPlaceBlockMaterial = "PreviewPlaceBlock";
        
        public const string PreviewColorPropertyName = "_PreviewColor";
        public static readonly Color PlaceableColor = new(0.41f,0.59f,0.86f,1f);
        public static readonly Color NotPlaceableColor = new(0.9f,0.25f,0.16f,1);
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/Responses.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Interface;
using Game.Challenge;
using Mooresmaster.Model.ChallengesModule;
using Server.Event.EventReceive;
using Server.Util.MessagePack;
using UnityEngine;
using static Server.Protocol.PacketResponse.GetMapObjectInfoProtocol;
using static Server.Protocol.PacketResponse.InitialHandshakeProtocol;

namespace Client.Network.API
{
    public class InitialHandshakeResponse
    {
        public Vector3 PlayerPos { get; }
        public WorldDataResponse WorldData { get; }
        public List<MapObjectsInfoMessagePack> MapObjects { get; }
        public PlayerInventoryResponse Inventory { get; }
        public ChallengeResponse Challenge { get; }
        public List<BlockStateMessagePack> BlockStates { get; }
        
        public InitialHandshakeResponse(ResponseInitialHandshakeMessagePack response, WorldDataResponse worldData, List<MapObjectsInfoMessagePack> mapObjects, PlayerInventoryResponse inventory, ChallengeResponse challenge, List<BlockStateMessagePack> blockStates)
        {
            PlayerPos = response.PlayerPos;
            WorldData = worldData;
            MapObjects = mapObjects;
            Inventory = inventory;
            Challenge = challenge;
            BlockStates = blockStates;
        }
    }
    
    public class PlayerInventoryResponse
    {
        public PlayerInventoryResponse(List<IItemStack> mainInventory, IItemStack grabItem)
        {
            MainInventory = mainInventory;
            GrabItem = grabItem;
        }
        
        public List<IItemStack> MainInventory { get; }
        public IItemStack GrabItem { get; }
    }
    
    public class WorldDataResponse
    {
        public readonly List<BlockInfo> Blocks;
        public readonly List<EntityResponse> Entities;
        
        public WorldDataResponse(List<BlockInfo> blocks, List<EntityResponse> entities)
        {
            Blocks = blocks;
            Entities = entities;
        }
    }
    
    public class BlockInfo
    {
        public readonly BlockDirection BlockDirection;
        public readonly BlockId BlockId;
        public readonly Vector3Int BlockPos;
        
        public BlockInfo(BlockDataMessagePack blockDataMessagePack)
        {
            BlockPos = blockDataMessagePack.BlockPos;
            BlockId = blockDataMessagePack.BlockId;
            BlockDirection = blockDataMessagePack.BlockDirection;
        }
    }
    
    public class EntityResponse
    {
        public readonly long InstanceId;
        public readonly Vector3 Position;
        public readonly string State;
        public readonly string Type;
        
        public EntityResponse(EntityMessagePack entityMessagePack)
        {
            InstanceId = entityMessagePack.InstanceId;
            Type = entityMessagePack.Type;
            Position = entityMessagePack.Position;
            State = entityMessagePack.State;
        }
    }
    
    public class ChallengeResponse
    {
        public readonly List<ChallengeMasterElement> CompletedChallenges;
        public readonly List<ChallengeMasterElement> CurrentChallenges;
        
        public ChallengeResponse(List<ChallengeMasterElement> currentChallenges, List<ChallengeMasterElement> completedChallenges)
        {
            CurrentChallenges = currentChallenges;
            CompletedChallenges = completedChallenges;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/BlockDebugState.cs
```cs
using System.Threading;
using Client.Game.GameDebug;
using Client.Game.InGame.Control;
using Client.Game.InGame.UI.UIState.Input;
using Client.Game.Skit;
using Client.Input;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class BlockDebugState : IUIState
    {
        private readonly SkitManager _skitManager;
        private readonly ScreenClickableCameraController _screenClickableCameraController;
        
        private CancellationTokenSource _startTweenCameraCancellationTokenSource;
        
        public BlockDebugState(SkitManager skitManager, InGameCameraController inGameCameraController)
        {
            _screenClickableCameraController = new ScreenClickableCameraController(inGameCameraController);
            _skitManager = skitManager;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            _screenClickableCameraController.OnEnter();
            _screenClickableCameraController.StartTweenFromTop();
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.PlayerInventory;
            if (_skitManager.IsPlayingSkit) return UIStateEnum.Story;
            if (DebugInfoStore.EnableBlockDebugMode) return UIStateEnum.GameScreen;
            
            _screenClickableCameraController.GetNextUpdate();
            
            if (BlockClickDetect.TryGetCursorOnBlock(out var block))
            {
                DebugInfoStore.InvokeClickBlock(block);
            }
            
            return UIStateEnum.Current;
        }
        
        public void OnExit()
        {
            _screenClickableCameraController.OnExit();
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/ItemStackMetaData.cs
```cs
using MessagePack;

namespace Core.Item.Interface
{
    [MessagePackObject]
    public abstract class ItemStackMetaData
    {
        public abstract bool Equals(ItemStackMetaData target);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningIdleState.cs
```cs

using Client.Game.InGame.UI.Util;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningIdleState : IMapObjectMiningState
    {
        public MapObjectMiningIdleState()
        {
            MouseCursorExplainer.Instance.Hide();
        }
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            return
                context.CurrentFocusMapObjectGameObject != null 
                    ? new MapObjectMiningFocusState() 
                    : this;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Extension/BlockExtension.cs
```cs
using Game.Block.Interface.Component;

namespace Game.Block.Interface.Extension
{
    public static class BlockExtension
    {
        public static T GetComponent<T>(this IBlock block) where T : IBlockComponent
        {
            return block.ComponentManager.GetComponent<T>();
        }
        
        public static bool ExistsComponent<T>(this IBlock block) where T : IBlockComponent
        {
            return block.ComponentManager.ExistsComponent<T>();
        }
        
        public static bool TryGetComponent<T>(this IBlock block, out T component) where T : IBlockComponent
        {
            return block.ComponentManager.TryGetComponent(out component);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/items.json
```cs
{
  "data": [
    {
      "maxStack": 100,
      "name": "Test1",
      "itemGuid": "00000000-0000-0000-1234-000000000001",
      "imagePath": "Test1",
      "sortPriority": 100
    },
    {
      "maxStack": 50,
      "name": "Test2",
      "itemGuid": "00000000-0000-0000-1234-000000000002",
      "imagePath": "Test2"
    },
    {
      "maxStack": 300,
      "name": "Test3",
      "itemGuid": "00000000-0000-0000-1234-000000000003",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test4",
      "itemGuid": "00000000-0000-0000-1234-000000000004",
      "imagePath": "Test1"
    },
    {
      "maxStack": 200,
      "name": "Test5",
      "itemGuid": "00000000-0000-0000-1234-000000000005",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test6",
      "itemGuid": "00000000-0000-0000-1234-000000000006",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test7",
      "itemGuid": "00000000-0000-0000-1234-000000000007",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test8",
      "itemGuid": "00000000-0000-0000-1234-000000000008",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test9",
      "itemGuid": "00000000-0000-0000-1234-000000000009",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test10",
      "itemGuid": "00000000-0000-0000-1234-000000000010",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test11",
      "itemGuid": "00000000-0000-0000-1234-000000000011",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "tree",
      "itemGuid": "00000000-0000-0000-1234-000000000012",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "stone",
      "itemGuid": "00000000-0000-0000-1234-000000000013",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "SmallTestGear",
      "itemGuid": "00000000-0000-0000-1234-000000000014",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "BigTestGear",
      "itemGuid": "16000000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestShaft",
      "itemGuid": "17000000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestGearMachine",
      "itemGuid": "18000000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestSimpleGearGenerator",
      "itemGuid": "19000000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestFastSimpleGearGenerator",
      "itemGuid": "11100000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "SmallRequireTorqueTestGear",
      "itemGuid": "11200000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "BigRequireTorqueTestGear",
      "itemGuid": "11300000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "InfinityTestSimpleGearGenerator",
      "itemGuid": "11400000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "StraightTestItemShooter",
      "itemGuid": "11500000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "DownTestItemShooter",
      "itemGuid": "11600000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "UpTestItemShooter",
      "itemGuid": "11700000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "GearBeltConveyor",
      "itemGuid": "11800000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestElectricMachine1",
      "itemGuid": "11900000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestElectricMachine2",
      "itemGuid": "12010000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestElectricMachine3",
      "itemGuid": "12102000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "GearMiner",
      "imagePath": "Test1",
      "itemGuid": "ca6225bf-41ea-466d-89ef-98334f8c628f"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerTransporter",
      "itemGuid": "db52f4b0-c28c-4f18-a6c8-0b054e460006"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerCrafter",
      "itemGuid": "b76d00ed-72c9-436d-af80-11739a4f3e14"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerProviderChest",
      "itemGuid": "35be2026-4730-46d3-9821-5d5f88ac3326"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMainComputer",
      "itemGuid": "59ca039e-7b91-41d9-b387-9bbfa73b74e5"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerBeltConveyor",
      "itemGuid": "9ba04edc-1fe0-4528-91a8-80155a51bfe0"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMachine1",
      "itemGuid": "0b9e2f8f-b53f-440f-8913-0664f51e6856"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMachine2",
      "itemGuid": "7dd72da1-e030-494e-a650-a651f7826648"
    },
    {
      "maxStack": 100,
      "name": "Chainer - A",
      "itemGuid": "189672cb-6811-4080-bde1-1f9ff0ec63ff"
    },
    {
      "maxStack": 100,
      "name": "Chainer - B",
      "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
    },
    {
      "maxStack": 100,
      "name": "Chainer - C",
      "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "blockType": "TrainRail",
      "maxStack": 100,
      "name": "TestTrainRail",
      "itemGuid": "1b72541e-0896-43bb-91fa-0b3fef137dcf"
    },
    {
      "maxStack": 100,
      "name": "TestTrainStation",
      "itemGuid": "9bdfa843-d4ee-4033-a61c-538bb9aaa21d"
    },
    {
      "maxStack": 100,
      "name": "TestTrainCargoPlatform",
      "itemGuid": "4a2cd701-ecd0-45f1-ae00-1e43adcadd84"
    }
  ]
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/ITutorialView.cs
```cs
namespace Client.Game.InGame.Tutorial
{
    public interface ITutorialView
    {
        public void CompleteTutorial();
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ConfigOnly/mods/testConfigOnlyMod2/modMeta.json
```cs
{
  "id": "testMod2",
  "name": "Test Mod 2",
  "version": "2.0",
  "author": "Test Author 2",
  "description": "This is a test mod."
}
```

moorestech_server/Assets/Scripts/Core.Master/MapObjectMaster.cs
```cs
using System;
using Mooresmaster.Loader.MapObjectsModule;
using Mooresmaster.Model.MapObjectsModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class MapObjectMaster
    {
        public readonly MapObjects MapObjects;
        
        public MapObjectMaster(JToken jToken)
        {
            MapObjects = MapObjectsLoader.Load(jToken);
        }
        
        public MapObjectMasterElement GetMapObjectElement(Guid guid)
        {
            return Array.Find(MapObjects.Data, x => x.MapObjectGuid == guid);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/EntityInstanceId.cs
```cs
using UnitGenerator;

namespace Game.Entity.Interface
{
    [UnitOf(typeof(long))]
    public partial struct EntityInstanceId
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/WaitTimeTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class WaitTimeTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var time = float.Parse(parameters[0]);
            await UniTask.Delay((int)(time * 1000));
            
            return null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Player/PlayerGrabItemManager.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Player
{
    public class PlayerGrabItemManager : MonoBehaviour
    {
        [SerializeField] private Transform leftHandParent;
        [SerializeField] private Transform rightHandParent;
        
        public void SetItem(GameObject item, bool isLeft, Vector3 position = default, Quaternion rotation = default)
        {
            var parent = isLeft ? leftHandParent : rightHandParent;
            item.transform.SetParent(parent);
            item.transform.localPosition = position;
            item.transform.localRotation = rotation;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Extension/BlockMasterExtension.cs
```cs
using System;
using Core.Master;

namespace Game.Block.Interface.Extension
{
    public static class BlockMasterExtension
    {
        public static BlockId GetVerticalOverrideBlockId(this BlockId blockId,BlockVerticalDirection verticalDirection)
        {
            var blockElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            var overrideBlock = blockElement.OverrideVerticalBlock;
            if (overrideBlock == null)
            {
                return blockId;
            }
            
            if (verticalDirection is BlockVerticalDirection.Up && overrideBlock.UpBlockGuid != Guid.Empty)
            {
                return MasterHolder.BlockMaster.GetBlockId(overrideBlock.UpBlockGuid);
            }
            if (verticalDirection is BlockVerticalDirection.Horizontal && overrideBlock.HorizontalBlockGuid != Guid.Empty)
            {
                return MasterHolder.BlockMaster.GetBlockId(overrideBlock.HorizontalBlockGuid);
            }
            if (verticalDirection is  BlockVerticalDirection.Down && overrideBlock.DownBlockGuid != Guid.Empty)
            {
                return MasterHolder.BlockMaster.GetBlockId(overrideBlock.DownBlockGuid);
            }
            
            return blockId;
        }
        
        public static BlockId GetVerticalOverrideBlockId(this Guid blockGuid,BlockVerticalDirection verticalDirection)
        {
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockGuid);
            return blockId.GetVerticalOverrideBlockId(verticalDirection);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/mapObjects.json
```cs
{
  "data": [
    {
      "earnItemHps": [
        0,
        10,
        20
      ],
      "hp": 30,
      "mapObjectName": "vanilla:Tree",
      "miningTools": [
        {
          "attackSpeed": 1.6,
          "damage": 1,
          "toolItemGuid": "00000000-0000-0000-1234-000000000001"
        }
      ],
      "earnItems": [
        {
          "maxCount": 5,
          "minCount": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        }
      ],
      "mapObjectGuid": "8c0e1339-be75-4690-99cd-58b5385a17cd",
      "soundEffectType": "tree",
      "miningType": "PickUp",
      "miningParam": {}
    }
  ]
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/MinHeap.cs
```cs
//generated by Chat GPT 4o
using System;
using System.Collections.Generic;

namespace Game.Train.RailGraph
{
    public class MinHeap<T> where T : IComparable<T>
    {
        private List<T> _elements;

        public MinHeap()
        {
            _elements = new List<T>();
        }

        public int Count => _elements.Count;

        public bool IsEmpty => Count == 0;

        // Insert a new element into the heap
        public void Insert(T item)
        {
            _elements.Add(item);
            HeapifyUp(_elements.Count - 1);
        }

        // Get the minimum element without removing it
        public T Peek()
        {
            if (IsEmpty)
            {
                throw new InvalidOperationException("Heap is empty.");
            }
            return _elements[0];
        }

        // Remove and return the minimum element
        public T RemoveMin()
        {
            if (IsEmpty)
            {
                throw new InvalidOperationException("Heap is empty.");
            }

            T root = _elements[0];
            _elements[0] = _elements[Count - 1];
            _elements.RemoveAt(Count - 1);

            if (!IsEmpty)
            {
                HeapifyDown(0);
            }

            return root;
        }

        private void HeapifyUp(int index)
        {
            while (index > 0)
            {
                int parentIndex = (index - 1) / 2;

                if (_elements[index].CompareTo(_elements[parentIndex]) >= 0)
                {
                    break;
                }

                Swap(index, parentIndex);
                index = parentIndex;
            }
        }

        private void HeapifyDown(int index)
        {
            while (index < Count)
            {
                int leftChildIndex = 2 * index + 1;
                int rightChildIndex = 2 * index + 2;
                int smallestIndex = index;

                if (leftChildIndex < Count && _elements[leftChildIndex].CompareTo(_elements[smallestIndex]) < 0)
                {
                    smallestIndex = leftChildIndex;
                }

                if (rightChildIndex < Count && _elements[rightChildIndex].CompareTo(_elements[smallestIndex]) < 0)
                {
                    smallestIndex = rightChildIndex;
                }

                if (smallestIndex == index)
                {
                    break;
                }

                Swap(index, smallestIndex);
                index = smallestIndex;
            }
        }

        private void Swap(int index1, int index2)
        {
            T temp = _elements[index1];
            _elements[index1] = _elements[index2];
            _elements[index2] = temp;
        }
    }

}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/DeleteBlockState.cs
```cs
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Control;
using Client.Game.InGame.UI.UIState.Input;
using Client.Game.InGame.UI.UIState.UIObject;
using Client.Input;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class DeleteBlockState : IUIState
    {
        private readonly DeleteBarObject _deleteBarObject;
        
        private readonly ScreenClickableCameraController _screenClickableCameraController;
        
        private BlockGameObject _removeTargetBlock;
        
        public DeleteBlockState(DeleteBarObject deleteBarObject, InGameCameraController inGameCameraController)
        {
            _screenClickableCameraController = new ScreenClickableCameraController(inGameCameraController);
            _deleteBarObject = deleteBarObject;
            deleteBarObject.gameObject.SetActive(false);
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            _screenClickableCameraController.OnEnter();
            _deleteBarObject.gameObject.SetActive(true);
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.CloseUI.GetKeyDown || InputManager.UI.BlockDelete.GetKeyDown) return UIStateEnum.GameScreen;
            
            if (InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.PlayerInventory;
            if (InputManager.UI.OpenMenu.GetKeyDown) return UIStateEnum.PauseMenu;
            
            if (BlockClickDetect.TryGetCursorOnBlock(out var blockGameObject))
            {
                if (_removeTargetBlock == null || _removeTargetBlock != blockGameObject)
                {
                    if (_removeTargetBlock != null) _removeTargetBlock.ResetMaterial();
                    
                    _removeTargetBlock = blockGameObject;
                    _removeTargetBlock.SetRemovePreviewing();
                }
            }
            else if (_removeTargetBlock != null)
            {
                _removeTargetBlock.ResetMaterial();
                _removeTargetBlock = null;
            }
            
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && _removeTargetBlock != null)
            {
                var blockPosition = _removeTargetBlock.BlockPosInfo.OriginalPos;
                ClientContext.VanillaApi.SendOnly.BlockRemove(blockPosition);
            }
            
            _screenClickableCameraController.GetNextUpdate();
            
            return UIStateEnum.Current;
        }
        
        
        public void OnExit()
        {
            if (_removeTargetBlock != null) _removeTargetBlock.ResetMaterial();
            _deleteBarObject.gameObject.SetActive(false);
            
            _screenClickableCameraController.OnExit();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/ItemManaged/GrabInventoryData.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Event;
using Game.PlayerInventory.Interface.Event;

namespace Game.PlayerInventory.ItemManaged
{
    public class GrabInventoryData : IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems => _openableInventoryService.InventoryItems;
        
        private readonly GrabInventoryUpdateEvent _grabInventoryUpdateEvent;
        private readonly OpenableInventoryItemDataStoreService _openableInventoryService;
        private readonly int _playerId;
        
        public GrabInventoryData(int playerId, GrabInventoryUpdateEvent grabInventoryUpdateEvent)
        {
            _playerId = playerId;
            _grabInventoryUpdateEvent = grabInventoryUpdateEvent;
            _openableInventoryService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, 1);
        }
        
        public GrabInventoryData(int playerId, GrabInventoryUpdateEvent grabInventoryUpdateEvent, IItemStack itemStacks) : this(playerId, grabInventoryUpdateEvent)
        {
            _openableInventoryService.SetItemWithoutEvent(0, itemStacks);
        }
        
        public IItemStack GetItem(int slot)
        {
            return _openableInventoryService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _openableInventoryService.SetItem(slot, itemStack);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            _openableInventoryService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            return _openableInventoryService.ReplaceItem(slot, itemStack);
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            return _openableInventoryService.ReplaceItem(slot, itemId, count);
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return _openableInventoryService.InsertItem(itemStack);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            return _openableInventoryService.InsertItem(itemId, count);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return _openableInventoryService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return _openableInventoryService.InsertionCheck(itemStacks);
        }
        
        public int GetSlotSize()
        {
            return _openableInventoryService.GetSlotSize();
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            return _openableInventoryService.CreateCopiedItems();
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _grabInventoryUpdateEvent.OnInventoryUpdateInvoke(new PlayerInventoryUpdateEventProperties(
                _playerId, slot, itemStack));
        }
    }
}
```

schema/items.json
```cs
{
  "$id": "items",
  "type": "object",
  "isDefaultOpen": true,

  "properties": {
    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "ItemMasterElement",
      
      "items": {
        "type": "object",
        "thumbnail": "imagePath",

        "properties": {
          "itemGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "imagePath": {
            "type": "string",
            "pattern": "@imagePath",
            "thumbnail": true,
            "optional": true
          },

          "name": {
            "type": "string"
          },

          "maxStack": {
            "type": "integer",
            "default" : 100
          },

          "sortPriority": {
            "type": "number",
            "default" : 100,
            "optional": true
          }
        }
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/Factory/ChallengeFactory.cs
```cs
using System.Collections.Generic;
using Mooresmaster.Model.ChallengesModule;

namespace Game.Challenge.Task.Factory
{
    public class ChallengeFactory
    {
        public delegate IChallengeTask ChallengeTaskCreator(int playerId, ChallengeMasterElement challengeElement);
        
        private readonly Dictionary<string,ChallengeTaskCreator> _taskCreators = new();
        
        public ChallengeFactory()
        {
            _taskCreators.Add(VanillaChallengeType.CreateItemTask,CreateItemChallengeTask.Create);
            _taskCreators.Add(VanillaChallengeType.InInventoryItemTask,InInventoryItemChallengeTask.Create);
            _taskCreators.Add(VanillaChallengeType.BlockPlaceTask,BlockPlaceChallengeTask.Create);
        }
        
        public IChallengeTask CreateChallengeTask(int playerId, ChallengeMasterElement challengeElement)
        {
            var creator = _taskCreators[challengeElement.TaskCompletionType];
            return creator(playerId, challengeElement);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockException.cs
```cs
using System;
using Game.Block.Interface.Component;

namespace Game.Block.Interface
{
    public static class BlockException
    {
        private const string IsDestroyed = "This component is already destroyed";
        private static readonly InvalidOperationException IsDestroyedException = new(IsDestroyed);
        
        public static void CheckDestroy(IBlockComponent blockComponent)
        {
            if (blockComponent.IsDestroy)
            {
                throw IsDestroyedException;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/ProgressBar/ProgressBarView.cs
```cs
using System;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.ProgressBar
{
    public class ProgressBarView : MonoBehaviour
    {
        [SerializeField] private GameObject viewRoot;
        [SerializeField] private Scrollbar scrollbar;
        
        public static ProgressBarView Instance;
        
        private void Awake()
        {
            Instance = this;
            Hide();
        }
        
        public void Show()
        {
            viewRoot.SetActive(true);
        }
        
        public void Hide()
        {
            viewRoot.SetActive(false);
        }
        
        public void SetProgress(float progress)
        {
            scrollbar.size = progress;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/IgnoreRendererMaterialReplacer.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class IgnoreRendererMaterialReplacer : MonoBehaviour
    {
        
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/Util/CreateEmptyItemStacksArray.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Context;

namespace Core.Item.Util
{
    public static class CreateEmptyItemStacksList
    {
        public static List<IItemStack> Create(int count)
        {
            var a = new List<IItemStack>();
            for (var i = 0; i < count; i++) a.Add(ServerContext.ItemStackFactory.CreatEmpty());
            
            return a;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Input/HotBarKeyBoardComposite.cs
```cs
using UnityEditor;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Layouts;
using UnityEngine.InputSystem.Utilities;
#if UNITY_EDITOR
#endif

namespace Client.Input
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    [DisplayStringFormat("{select0}/{select1}/{select2}/{select3}/{select4}/{select5}/{select6}/{select7}/{select8}")]
    public class HotBarKeyBoardComposite : InputBindingComposite<int>
    {
        [InputControl(layout = "Button")] public int select0 = 1;
        [InputControl(layout = "Button")] public int select1 = 2;
        [InputControl(layout = "Button")] public int select2 = 3;
        [InputControl(layout = "Button")] public int select3 = 4;
        [InputControl(layout = "Button")] public int select4 = 5;
        [InputControl(layout = "Button")] public int select5 = 6;
        [InputControl(layout = "Button")] public int select6 = 7;
        [InputControl(layout = "Button")] public int select7 = 8;
        [InputControl(layout = "Button")] public int select8 = 9;
#if UNITY_EDITOR
        static HotBarKeyBoardComposite()
        {
            Initialize();
        }
#endif
        
        [RuntimeInitializeOnLoadMethod]
        private static void Initialize()
        {
            InputSystem.RegisterBindingComposite<HotBarKeyBoardComposite>();
        }
        
        public override int ReadValue(ref InputBindingCompositeContext context)
        {
            if (context.ReadValueAsButton(select0)) return select0;
            if (context.ReadValueAsButton(select1)) return select1;
            if (context.ReadValueAsButton(select2)) return select2;
            if (context.ReadValueAsButton(select3)) return select3;
            if (context.ReadValueAsButton(select4)) return select4;
            if (context.ReadValueAsButton(select5)) return select5;
            if (context.ReadValueAsButton(select6)) return select6;
            if (context.ReadValueAsButton(select7)) return select7;
            if (context.ReadValueAsButton(select8)) return select8;
            
            return 0;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/UIHighlight/UIHighlightTutorialManager.cs
```cs
using Mooresmaster.Model.ChallengesModule;
using UnityEngine;

namespace Client.Game.InGame.Tutorial.UIHighlight
{
    public class UIHighlightTutorialManager : MonoBehaviour, ITutorialViewManager
    {
        public const string TutorialType = "uiHighLight";
        
        [SerializeField] private UIHighlightTutorialView highlightTutorialViewPrefab;
        [SerializeField] private RectTransform highlightParent;
        
        public ITutorialView ApplyTutorial(ITutorialParam param)
        {
            var highlightParam = (UiHighLightTutorialParam)param;
            
            var highlightTargetObjects = FindObjectsOfType<UIHighlightTutorialTargetObject>(true);
            foreach (var targetObject in highlightTargetObjects)
            {
                if (targetObject.HighlightObjectId != highlightParam.HighLightUIObjectId) continue;
                
                var highlightView = Instantiate(highlightTutorialViewPrefab, transform);
                highlightView.SetTargetObject(targetObject, highlightParam.HighLightText);
                return highlightView;
            }
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/EntityInstance/PlayerEntity.cs
```cs
using UnityEngine;

namespace Game.Entity.Interface.EntityInstance
{
    public class PlayerEntity : IEntity
    {
        public PlayerEntity(EntityInstanceId instanceId, Vector3 position)
        {
            InstanceId = instanceId;
            Position = position;
        }
        
        public Vector3 Position { get; private set; }
        
        public EntityInstanceId InstanceId { get; }
        public string EntityType => VanillaEntityType.VanillaPlayer;
        public string State => string.Empty;
        
        public void SetPosition(Vector3 serverVector3)
        {
            Position = serverVector3;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BackgroundSkit/BackgroundSkitUI.cs
```cs
using Cysharp.Threading.Tasks;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.BackgroundSkit
{
    public class BackgroundSkitUI : MonoBehaviour
    {
        [SerializeField] private TMP_Text characterName;
        [SerializeField] private TMP_Text line;
        
        [SerializeField] private AudioSource voiceSource;
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
        
        public async UniTask SetText(string name, string sentence, AudioClip voice = null)
        {
            characterName.text = name;
            line.text = sentence;
            
            if (voice == null)
            {
                await UniTask.Delay(3000);
                return;
            }
            
            voiceSource.clip = voice;
            voiceSource.Play();
            
            await UniTask.Delay((int)(voiceSource.clip.length * 1000));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearPower.cs
```cs
using UnitGenerator;

namespace Game.Gear.Common
{
    [UnitOf(typeof(float), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable)]
    public partial struct GearPower
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CharacterEmotionTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using static System.Enum;

namespace Client.Skit.SkitTrack
{
    public class CharacterEmotionTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var characterKey = parameters[0];
            var emotion = (EmotionType)Parse(typeof(EmotionType), parameters[1]);
            var duration = float.Parse(parameters[2]);
            
            var character = storyContext.GetCharacter(characterKey);
            character.SetEmotion(emotion, duration);
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/Factory/VanillaChallengeType.cs
```cs
namespace Game.Challenge.Task.Factory
{
    public class VanillaChallengeType
    {
        public const string CreateItemTask = "createItem";
        public const string InInventoryItemTask = "inInventoryItem";
        public const string BlockPlaceTask = "blockPlace";
    }
}
```

moorestech_client/Assets/Scripts/Client.Localization/TextMeshProLocalize.cs
```cs
using System;
using TMPro;
using UniRx;
using UnityEngine;

namespace Client.Localization
{
    [RequireComponent(typeof(TextMeshProUGUI))]
    public class TextMeshProLocalize : MonoBehaviour
    {
        [SerializeField] private string key;
        
        private TMP_Text _text;
        
        private void Awake()
        {
            _text = GetComponent<TextMeshProUGUI>();
            _text.text = Localize.Get(key);
            
            Localize.OnLanguageChanged.Subscribe(_ => GetComponent<TextMeshProUGUI>().text = Localize.Get(key))
                .AddTo(this);
        }
        
        public void SetKey(string key, params string[] addContents)
        {
            this.key = key;
            
            var text = string.Empty;
            try
            {
                text = string.Format(Localize.Get(key), addContents);
            }
            catch (FormatException e)
            {
                text = "[Localize] Format Error : " + key;
            }
            catch (Exception e)
            {
                text = $"[Localize] Other Error : {key} : {e.Message}";
            }
            
            if (_text == null) _text = GetComponent<TextMeshProUGUI>();
            _text.text = text;
            _text.ForceMeshUpdate();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Input/InputManager.cs
```cs
using System;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Client.Input
{
    public static class InputManager
    {
        private static PayerInputManager player;
        private static PlayableInputManager playable;
        private static UIInputManager ui;
        private static MoorestechInputSettings _instance;
        public static PayerInputManager Player => player ??= new PayerInputManager(Instance);
        
        public static PlayableInputManager Playable => playable ??= new PlayableInputManager(Instance);
        
        public static UIInputManager UI => ui ??= new UIInputManager(Instance);
        
        
        private static MoorestechInputSettings Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new MoorestechInputSettings();
                    _instance.Enable();
                }
                
                return _instance;
            }
        }
        
        public static void MouseCursorVisible(bool isVisible)
        {
            Cursor.lockState = isVisible ? CursorLockMode.None : CursorLockMode.Locked;
        }
    }
    
    public class PayerInputManager
    {
        public readonly InputKey Jump;
        public readonly InputKey Look;
        public readonly InputKey Move;
        public readonly InputKey Sprint;
        
        public PayerInputManager(MoorestechInputSettings settings)
        {
            Move = new InputKey(settings.Player.Move);
            Look = new InputKey(settings.Player.Look);
            Jump = new InputKey(settings.Player.Jump);
            Sprint = new InputKey(settings.Player.Sprint);
        }
    }
    
    public class PlayableInputManager
    {
        public readonly InputKey BlockPlaceRotation;
        public readonly InputKey ClickPosition;
        public readonly InputKey ScreenLeftClick;
        public readonly InputKey ScreenRightClick;
        
        public PlayableInputManager(MoorestechInputSettings settings)
        {
            ScreenLeftClick = new InputKey(settings.Playable.ScreenLeftClick);
            ScreenRightClick = new InputKey(settings.Playable.ScreenRightClick);
            ClickPosition = new InputKey(settings.Playable.ClickPosition);
            BlockPlaceRotation = new InputKey(settings.Playable.BlockPlaceRotation);
        }
    }
    
    public class UIInputManager
    {
        public readonly InputKey AllCraft;
        public readonly InputKey BlockDelete;
        public readonly InputKey CloseUI;
        public readonly InputKey HotBar;
        public readonly InputKey InventoryItemHalve;
        public readonly InputKey InventoryItemOnePut;
        public readonly InputKey ItemDirectMove;
        public readonly InputKey OneStackCraft;
        public readonly InputKey OpenInventory;
        public readonly InputKey OpenMenu;
        public readonly InputKey QuestUI;
        public readonly InputKey SwitchHotBar;
        
        public UIInputManager(MoorestechInputSettings settings)
        {
            OpenMenu = new InputKey(settings.UI.OpenMenu);
            CloseUI = new InputKey(settings.UI.CloseUI);
            OpenInventory = new InputKey(settings.UI.OpenInventory);
            InventoryItemOnePut = new InputKey(settings.UI.InventoryItemOnePut);
            InventoryItemHalve = new InputKey(settings.UI.InventoryItemHalve);
            HotBar = new InputKey(settings.UI.HotBar);
            SwitchHotBar = new InputKey(settings.UI.SwitchHotBar);
            BlockDelete = new InputKey(settings.UI.BlockDelete);
            AllCraft = new InputKey(settings.UI.AllCraft);
            OneStackCraft = new InputKey(settings.UI.OneStackCraft);
            QuestUI = new InputKey(settings.UI.QuestUI);
            ItemDirectMove = new InputKey(settings.UI.ItemDirectMove);
        }
    }
    
    public class InputKey
    {
        private readonly InputAction _inputAction;
        
        
        public InputKey(InputAction key)
        {
            _inputAction = key;
            key.started += _ => { OnGetKeyDown?.Invoke(); };
            key.performed += _ => { OnGetKey?.Invoke(); };
            key.canceled += _ => { OnGetKeyUp?.Invoke(); };
        }
        
        public bool GetKeyDown => _inputAction.WasPressedThisFrame();
        public bool GetKey => _inputAction.IsPressed();
        public bool GetKeyUp => _inputAction.WasReleasedThisFrame();
        
        public event Action OnGetKeyDown;
        public event Action OnGetKey;
        public event Action OnGetKeyUp;
        
        public TValue ReadValue<TValue>() where TValue : struct
        {
            return _inputAction.ReadValue<TValue>();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/GameDebug/DebugInfoStore.cs
```cs
using System;
using Client.Game.InGame.Block;
using UniRx;

namespace Client.Game.GameDebug
{
    public class DebugInfoStore
    {
        public static bool EnableBlockDebugMode { get; set; }
        
        public static IObservable<BlockGameObject> OnClickBlock => _onClickBlock;
        private static readonly Subject<BlockGameObject> _onClickBlock = new();
        
        public static void InvokeClickBlock(BlockGameObject block)
        {
            _onClickBlock.OnNext(block);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CharacterTransformTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Skit.SkitTrack
{
    public class CharacterTransformTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var characterKey = parameters[0];
            
            var posX = float.Parse(parameters[2]);
            var posY = float.Parse(parameters[3]);
            var posZ = float.Parse(parameters[4]);
            var pos = new Vector3(posX, posY, posZ);
            
            var rotX = float.Parse(parameters[6]);
            var rotY = float.Parse(parameters[7]);
            var rotZ = float.Parse(parameters[8]);
            var rot = new Vector3(rotX, rotY, rotZ);
            
            var character = storyContext.GetCharacter(characterKey);
            
            character.SetTransform(pos, rot);
            
            return null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/InitializeProprieties.cs
```cs
using System.Diagnostics;

namespace Client.Starter
{
    public class InitializeProprieties
    {
        public readonly bool IsLocal;
        public readonly Process LocalServerProcess;
        public readonly int PlayerId;
        public readonly string ServerIp;
        public readonly int ServerPort;
        
        public InitializeProprieties(bool isLocal, Process localServerProcess, string serverIp, int serverPort, int playerId)
        {
            IsLocal = isLocal;
            LocalServerProcess = localServerProcess;
            ServerIp = serverIp;
            ServerPort = serverPort;
            PlayerId = playerId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeEvent.cs
```cs
using System;
using Game.Challenge.Task;
using UniRx;

namespace Game.Challenge
{
    public class ChallengeEvent
    {
        private readonly Subject<IChallengeTask> _onCompleteChallenge = new();
        public IObservable<IChallengeTask> OnCompleteChallenge => _onCompleteChallenge;
        
        public void InvokeCompleteChallenge(IChallengeTask craftConfig)
        {
            _onCompleteChallenge.OnNext(craftConfig);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/EntityProperties.cs
```cs
using Server.Util.MessagePack;
using UnityEngine;

namespace Client.Common
{
    public class EntityProperties
    {
        public readonly long InstanceId;
        public readonly Vector3 Position;
        public readonly string State;
        public readonly string Type;
        
        public EntityProperties(EntityMessagePack entityMessagePack)
        {
            InstanceId = entityMessagePack.InstanceId;
            Type = entityMessagePack.Type;
            var x = entityMessagePack.Position.X;
            var y = entityMessagePack.Position.Y;
            var z = entityMessagePack.Position.Z;
            Position = new Vector3(x, y, z);
            State = entityMessagePack.State;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapObjectFactory.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using UnityEngine;

namespace Game.Map
{
    public class MapObjectFactory : IMapObjectFactory
    {
        public IMapObject Create(int instanceId, Guid mapObjectGuid, int currentHp, bool isDestroyed, Vector3 position)
        {
            return new VanillaStaticMapObject(instanceId, mapObjectGuid, isDestroyed, currentHp, position);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CharacterMotionTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class CharacterMotionTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var characterKey = parameters[0];
            var animationName = parameters[1];
            
            var character = storyContext.GetCharacter(characterKey);
            character.PlayAnimation(animationName);
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity/EntityFactory.cs
```cs
using System.Collections.Generic;
using Game.Entity.Interface;
using Game.Entity.Interface.EntityInstance;
using UnityEngine;

namespace Game.Entity
{
    public class EntityFactory : IEntityFactory
    {
        public IEntity CreateEntity(string entityType, EntityInstanceId instanceId, Vector3 position = default)
        {
            if (entityType == VanillaEntityType.VanillaPlayer) return new PlayerEntity(instanceId, position);
            
            if (entityType == VanillaEntityType.VanillaItem) return new ItemEntity(instanceId, position);
            
            throw new KeyNotFoundException("Entity type not found : " + entityType);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockDebugInfo.cs
```cs
using MessagePack;

namespace Game.Block.Interface.Component
{
    public interface IBlockDebugInfo : IBlockComponent
    {
        public BlockDebugInfo GetDebugInfo();
    }
    
    
    [MessagePackObject]
    public struct BlockDebugInfo
    {
        [Key(0)] public string ComponentName;
        [Key(1)] public string Value;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockGameObjectChild.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class BlockGameObjectChild : MonoBehaviour
    {
        public BlockGameObject BlockGameObject { get; private set; }
        
        public void Init(BlockGameObject blockGameObject)
        {
            BlockGameObject = blockGameObject;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/StoryContext.cs
```cs
using System.Collections.Generic;
using Client.Skit.Define;
using Client.Skit.Skit;
using Client.Skit.UI;
using UnityEngine;

namespace Client.Skit.SkitTrack
{
    public class StoryContext
    {
        private readonly Dictionary<string, SkitCharacter> _characters;
        public readonly ISkitCamera SkitCamera;
        public readonly SkitUI SkitUI;
        public readonly VoiceDefine VoiceDefine;
        
        public StoryContext(SkitUI skitUI, Dictionary<string, SkitCharacter> characters, SkitCamera skitCamera, VoiceDefine voiceDefine)
        {
            SkitUI = skitUI;
            _characters = characters;
            SkitCamera = skitCamera;
            VoiceDefine = voiceDefine;
        }
        
        public SkitCharacter GetCharacter(string characterKey)
        {
            return _characters[characterKey];
        }
        
        public void DestroyCharacter()
        {
            foreach (var character in _characters) Object.Destroy(character.Value.gameObject);
        }
    }
}
```

schema/ref/mineSettings.json
```cs
{
  "$id": "mineSettings",

  "type": "array",
  "overrideCodeGeneratePropertyName": "MineSettingsMasterElement",
  
  "items": {
    "type": "object",
    "properties": {
      "itemGuid": {
        "type": "string",
        "format": "uuid",
        "foreignKey": "items:itemGuid:name"
      },

      "time": {
        "type": "number",
        "default": 1
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Game.Gear/Common/IGearGenerator.cs
```cs
namespace Game.Gear.Common
{
    public interface IGearGenerator : IGear
    {
        public RPM GenerateRpm { get; }
        public Torque GenerateTorque { get; }
        
        public bool GenerateIsClockwise { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Vein/IMapVeinDatastore.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Game.Map.Interface.Vein
{
    public interface IMapVeinDatastore
    {
        public List<IMapVein> GetOverVeins(Vector3Int pos);
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/IWorldEnergySegmentDatastore.cs
```cs
using Game.EnergySystem;

namespace Game.World.Interface.DataStore
{
    public interface IWorldEnergySegmentDatastore<TSegment> where TSegment : EnergySegment, new()
    {
        public TSegment GetEnergySegment(IElectricTransformer transformer);
        public TSegment GetEnergySegment(int index);
        public TSegment CreateEnergySegment();
        public void SetEnergySegment(TSegment energySegment);
        public void RemoveEnergySegment(TSegment energySegment);
        public int GetEnergySegmentListCount();
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Element/ProgressArrowView.cs
```cs
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Element
{
    public class ProgressArrowView : MonoBehaviour
    {
        [SerializeField] private Slider slider;
        
        public void SetProgress(float value)
        {
            slider.value = value;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/VanillaEntityType.cs
```cs
namespace Game.Entity.Interface
{
    public static class VanillaEntityType
    {
        public const string VanillaPlayer = "va:Player";
        public const string VanillaItem = "va:Item";
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/GearMinerSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Inventory;
using Core.Master;
using Game.Block.Blocks.Miner;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    /// <summary>
    /// This test class verifies the save and load functionality of the GearMiner block.
    /// It ensures that the miner's state, including its inventory and remaining mining time, is correctly preserved.
    /// </summary>
    public class GearMinerSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            // Initialize the server and get the block factory.
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;

            // Get the block GUID for the GearMiner.
            var minerGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearMiner).BlockGuid;

            // Create the position info for the miner.
            var minerPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);

            // Create an instance of the GearMiner block.
            var originalMiner = blockFactory.Create(ForUnitTestModBlockId.GearMiner, new BlockInstanceId(1), minerPosInfo);
            var originalMinerComponent = originalMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Set the remaining mining time to a specific value.
            var originalRemainingSecond = 0.35;

            // Access the miner's inventory using reflection to set test items.
            var inventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(originalMinerComponent);

            // Set some items in the miner's inventory.
            inventory.SetItem(0, new ItemId(1), 1);
            inventory.SetItem(2, new ItemId(4), 1);

            // Set the remaining mining time using reflection.
            typeof(VanillaMinerProcessorComponent)
                .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                .SetValue(originalMinerComponent, originalRemainingSecond);

            // Save the state of the miner to a JSON string.
            var json = originalMiner.GetSaveState();
            Debug.Log(json);

            // Load a new miner instance from the saved state.
            var loadedMiner = blockFactory.Load(minerGuid, new BlockInstanceId(2), json, minerPosInfo);
            var loadedMinerComponent = loadedMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Access the loaded miner's inventory and remaining mining time.
            var loadedInventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);

            var loadedRemainingSecond =
                (double)typeof(VanillaMinerProcessorComponent)
                    .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);

            // Assert that the original and loaded inventories are equal.
            Assert.AreEqual(inventory.GetItem(0), loadedInventory.GetItem(0));
            Assert.AreEqual(inventory.GetItem(1), loadedInventory.GetItem(1));
            Assert.AreEqual(inventory.GetItem(2), loadedInventory.GetItem(2));

            // Assert that the remaining mining time is the same.
            Assert.AreEqual(originalRemainingSecond, loadedRemainingSecond);
        }
    }
}

```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryMoveUtil/ItemMoveInventoryType.cs
```cs
namespace Server.Protocol.PacketResponse.Util.InventoryMoveUtil
{
    public enum ItemMoveInventoryType
    {
        MainInventory,
        GrabInventory,
        BlockInventory,
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/ServerConst.cs
```cs
namespace Server.Protocol
{
    public class ServerConst
    {
        public const int PollingRateMillSec = 100;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Entity/IEntityObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Entity
{
    public interface IEntityObject
    {
        public void SetDirectPosition(Vector3 position);
        public void SetInterpolationPosition(Vector3 position);
        public void Destroy();
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Json/MapInfoJson.cs
```cs
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Map.Interface.Json
{
    public class MapInfoJson
    {
        [JsonProperty("mapObjects")] public List<MapObjectInfoJson> MapObjects;
        [JsonProperty("mapVeins")] public List<MapVeinInfoJson> MapVeins;
    }
    
    public class MapObjectInfoJson
    {
        [JsonProperty("instanceId")] public int InstanceId;
        [JsonProperty("mapObjectGuid")] public string MapObjectGuidStr;
        [JsonIgnore] public Guid MapObjectGuid => new(MapObjectGuidStr);
        
        [JsonProperty("x")] public float X;
        [JsonProperty("y")] public float Y;
        [JsonProperty("z")] public float Z;
        
        [JsonIgnore] public Vector3 Position => new(X, Y, Z);
    }
    
    public class MapVeinInfoJson
    {
        [JsonProperty("veinItemGuid")] public string VeinItemGuidStr;
        [JsonIgnore] public Guid VeinItemGuid => Guid.Parse(VeinItemGuidStr);
        
        [JsonIgnore] public Vector3Int MinPosition => new(MinX, MinY, MinZ);
        [JsonProperty("minX")] public int MinX;
        [JsonProperty("minY")] public int MinY;
        [JsonProperty("minZ")] public int MinZ;
        
        [JsonIgnore] public Vector3Int MaxPosition => new(MaxX, MaxY, MaxZ);
        [JsonProperty("maxX")] public int MaxX;
        [JsonProperty("maxY")] public int MaxY;
        [JsonProperty("maxZ")] public int MaxZ;
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/TransitionTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class TransitionTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var isShow = parameters[0] == "TRUE";
            var duration = float.Parse(parameters[1]);
            storyContext.SkitUI.ShowTransition(isShow, duration);
            
            await UniTask.Delay((int)(duration * 1000));
            
            return null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/GenerateTextTrackVoice.cs
```cs
using UnityEditor;
using UnityEngine;

public class GenerateTextTrackVoice : EditorWindow
{
    private void CreateGUI()
    {
    }
    
    [MenuItem("moorestech/GenerateTextTrackVoice")]
    private static void ShowWindow()
    {
        var window = GetWindow<GenerateTextTrackVoice>();
        window.titleContent = new GUIContent("GenerateTextTrackVoice");
        window.Show();
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/ComponentAttribute/DisallowMultiple.cs
```cs
using System;

namespace Game.Block.Interface.ComponentAttribute
{
    [AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class)]
    public class DisallowMultiple : Attribute
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/ServerConst.cs
```cs
using static System.IO.Path;

namespace Client.Common
{
    public class ServerConst
    {
        public const string LocalServerIp = "127.0.0.1";
        public const int LocalServerPort = 11564;
        
        public const int DefaultPlayerId = 1;
        
        
        public static readonly string ServerDirName = "Server";
        public static readonly string ServerDirectory = GetFullPath("./" + ServerDirName);
        
        public static readonly string ServerExePath = Combine(ServerDirectory, "moorestech_server.exe");
        public static readonly string ServerModsDirectory = Combine(ServerDirectory, "mods");
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockSaveState.cs
```cs

namespace Game.Block.Interface.Component
{
    public interface IBlockSaveState : IBlockComponent
    {
        public string SaveKey { get; }
        string GetSaveState();
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/WorldSettingJsonObject.cs
```cs
using Newtonsoft.Json;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public class WorldSettingJsonObject
    {
        [JsonProperty("SpawnX")] public int SpawnX;
        [JsonProperty("SpawnY")] public int SpawnY;
        
        public WorldSettingJsonObject(Vector3Int spawnPoint)
        {
            SpawnX = spawnPoint.x;
            SpawnY = spawnPoint.y;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World/WorldBlockUpdateEvent.cs
```cs
using System;
using Game.Block.Interface.Extension;
using Game.World.Interface.DataStore;
using UniRx;
using UnityEngine;

namespace Game.World
{
    public class WorldBlockUpdateEvent : IWorldBlockUpdateEvent
    {
        private readonly Subject<BlockUpdateProperties> _onBlockPlaceEvent = new();
        private readonly Subject<BlockUpdateProperties> _onBlockRemoveEvent = new();
        public IObservable<BlockUpdateProperties> OnBlockPlaceEvent => _onBlockPlaceEvent;
        
        public IObservable<BlockUpdateProperties> OnBlockRemoveEvent => _onBlockRemoveEvent;
        
        public IDisposable SubscribePlace(Vector3Int subscribePos, Action<BlockUpdateProperties> blockPlaceEvent)
        {
            return _onBlockPlaceEvent.Subscribe(data =>
            {
                if (data.BlockData.BlockPositionInfo.IsContainPos(subscribePos)) blockPlaceEvent(new BlockUpdateProperties(subscribePos, data.BlockData));
            });
        }
        
        public IDisposable SubscribeRemove(Vector3Int subscribePos, Action<BlockUpdateProperties> blockPlaceEvent)
        {
            return _onBlockRemoveEvent.Subscribe(data =>
            {
                if (data.BlockData.BlockPositionInfo.IsContainPos(subscribePos)) blockPlaceEvent(new BlockUpdateProperties(subscribePos, data.BlockData));
            });
        }
        
        public void OnBlockPlaceEventInvoke(Vector3Int pos, WorldBlockData worldBlockData)
        {
            _onBlockPlaceEvent.OnNext(new BlockUpdateProperties(pos, worldBlockData));
        }
        
        public void OnBlockRemoveEventInvoke(Vector3Int pos, WorldBlockData worldBlockData)
        {
            _onBlockRemoveEvent.OnNext(new BlockUpdateProperties(pos, worldBlockData));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/PlayerInventoryData.cs
```cs
using Core.Inventory;

namespace Game.PlayerInventory.Interface
{
    public class PlayerInventoryData
    {
        public readonly IOpenableInventory GrabInventory;
        public readonly IOpenableInventory MainOpenableInventory;
        
        public PlayerInventoryData(IOpenableInventory mainOpenableInventory, IOpenableInventory grabInventory)
        {
            MainOpenableInventory = mainOpenableInventory;
            GrabInventory = grabInventory;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Context/ItemStackSaveJsonObjectExtension.cs
```cs
using Core.Item.Interface;

namespace Game.Context
{
    public static class ItemStackSaveJsonObjectExtension
    {
        public static IItemStack ToItemStack(this ItemStackSaveJsonObject itemStackSaveJsonObject)
        {
            return ServerContext.ItemStackFactory.Create(itemStackSaveJsonObject.ItemGuid, itemStackSaveJsonObject.Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIObject/DeleteBarObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.UI.UIState.UIObject
{
    public class DeleteBarObject : MonoBehaviour
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/SetPlayerId.cs
```cs
using Client.Common;
using UnityEngine;

namespace Client.MainMenu
{
    /// <summary>
    ///     プレイヤーIDがセットされてないときに、プレイヤーIDセットする
    /// </summary>
    public class SetPlayerId : MonoBehaviour
    {
        private void Start()
        {
            if (!PlayerPrefs.HasKey(PlayerPrefsKeys.PlayerIdKey))
            {
                //プレイヤーIDをランダムに生成して設定
                PlayerPrefs.SetInt(PlayerPrefsKeys.PlayerIdKey, Random.Range(2, int.MaxValue));
                PlayerPrefs.Save();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/IPlayerInventoryDataStore.cs
```cs
using System.Collections.Generic;

namespace Game.PlayerInventory.Interface
{
    public interface IPlayerInventoryDataStore
    {
        public PlayerInventoryData GetInventoryData(int playerId);
        public List<PlayerInventorySaveJsonObject> GetSaveJsonObject();
        public void LoadPlayerInventory(List<PlayerInventorySaveJsonObject> saveInventoryDataList);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Skit/Starter/SkitStarterObject.cs
```cs
using UnityEngine;

namespace Client.Game.Skit.Starter
{
    public class SkitStarterObject : MonoBehaviour
    {
        [SerializeField] private TextAsset scenarioCsv;
        public TextAsset ScenarioCsv => scenarioCsv;
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/IEntityFactory.cs
```cs
using UnityEngine;

namespace Game.Entity.Interface
{
    public interface IEntityFactory
    {
        public IEntity CreateEntity(string entityType, EntityInstanceId instanceId, Vector3 serverPosition = default);
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/IWorldSettingsDatastore.cs
```cs
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public interface IWorldSettingsDatastore
    {
        public Vector3Int WorldSpawnPoint { get; }
        
        public WorldSettingJsonObject GetSaveJsonObject();
        public void Initialize();
        public void LoadSettingData(WorldSettingJsonObject worldSettingJsonObject);
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/modMeta.json
```cs
{
  "id": "forUniTest",
  "name": "Test Mod 2",
  "version": "2.0",
  "author": "Test Author",
  "description": "This is a test mod."
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad.Interface/IWorldSaveDataSaver.cs
```cs
namespace Game.SaveLoad.Interface
{
    public interface IWorldSaveDataSaver
    {
        public void Save();
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/BlockPlaceChallengeTask.cs
```cs
using System;
using Game.Context;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.ChallengesModule;
using UniRx;

namespace Game.Challenge.Task
{
    public class BlockPlaceChallengeTask : IChallengeTask
    {
        public ChallengeMasterElement ChallengeMasterElement { get; }
        public int PlayerId { get; }
        
        public IObservable<IChallengeTask> OnChallengeComplete => _onChallengeComplete;
        private readonly Subject<IChallengeTask> _onChallengeComplete = new();
        
        private bool _completed;
        
        public static IChallengeTask Create(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            return new BlockPlaceChallengeTask(playerId, challengeMasterElement);
        }
        public BlockPlaceChallengeTask(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            ChallengeMasterElement = challengeMasterElement;
            PlayerId = playerId;
            
            var worldEvent = ServerContext.WorldBlockUpdateEvent;
            worldEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlace);
        }
        
        private void OnBlockPlace(BlockUpdateProperties properties)
        {
            if (_completed) return;
            
            var param = ChallengeMasterElement.TaskParam as BlockPlaceTaskParam;
            if (param.BlockGuid == properties.BlockData.Block.BlockGuid)
            {
                _completed = true;
                _onChallengeComplete.OnNext(this);
            }
        }
        
        public void ManualUpdate()
        {
            
        }
    }
}
```

schema/mapObjects.json
```cs
{
  "$id": "mapObjects",
  "type": "object",
  "isDefaultOpen": true,
  
  "properties": {
    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "MapObjectMasterElement",

      "items": {
        "type": "object",
        "properties": {

          "mapObjectGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "mapObjectName": {
            "type": "string",
            "default": "mapObjectName"
          },

          "hp": {
            "type": "integer",
            "default": 100
          },
          "earnItemHps": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "default": [0]
          },
          "soundEffectType":{
            "type": "string",
            "enum":["tree","stone"]
          },
          "earnItems": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "itemGuid": {
                  "type": "string",
                  "format": "uuid",
                  "foreignKey": "items:itemGuid:name"
                },
                "minCount": {
                  "type": "integer",
                  "default": 1
                },
                "maxCount": {
                  "type": "integer",
                  "default": 3
                }
              }
            }
          },
          
          "miningType": {
            "type": "string",
            "enum":["PickUp","Mining"]
          },
          
          "miningParam": {
            "oneOf": [
              {
                "if": {
                  "properties": {
                    "miningType": { "const": "PickUp" }
                  }
                },
                "then": {
                  "type": "object",
                  "optional": true,
                  "properties": {
                  }
                }
              },

              {
                "if": {
                  "properties": {
                    "miningType": { "const": "Mining" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    
                    "miningTools": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "toolItemGuid": {
                            "type": "string",
                            "format": "uuid",
                            "foreignKey": "items:itemGuid:name"
                          },
                          "damage": {
                            "type": "integer",
                            "default": 10
                          },
                          "attackSpeed": {
                            "type": "number",
                            "default": 1
                          }
                        }
                      }
                    }

                  }
                }
              }

            ]
          }
        }
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/AssembleSaveJsonText.cs
```cs
using Game.Challenge;
using Game.Context;
using Game.Entity.Interface;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using Game.SaveLoad.Json.WorldVersions;
using Game.World.Interface.DataStore;
using Newtonsoft.Json;

namespace Game.SaveLoad.Json
{
    public class AssembleSaveJsonText
    {
        private readonly ChallengeDatastore _challengeDatastore;
        private readonly IEntitiesDatastore _entitiesDatastore;
        private readonly IPlayerInventoryDataStore _inventoryDataStore;
        private readonly IMapObjectDatastore _mapObjectDatastore;
        private readonly IWorldSettingsDatastore _worldSettingsDatastore;
        
        public AssembleSaveJsonText(IPlayerInventoryDataStore inventoryDataStore, IEntitiesDatastore entitiesDatastore, IWorldSettingsDatastore worldSettingsDatastore, IMapObjectDatastore mapObjectDatastore, ChallengeDatastore challengeDatastore)
        {
            _inventoryDataStore = inventoryDataStore;
            _entitiesDatastore = entitiesDatastore;
            _worldSettingsDatastore = worldSettingsDatastore;
            _mapObjectDatastore = mapObjectDatastore;
            _challengeDatastore = challengeDatastore;
        }
        
        public string AssembleSaveJson()
        {
            var saveData = new WorldSaveAllInfoV1(
                ServerContext.WorldBlockDatastore.GetSaveJsonObject(),
                _inventoryDataStore.GetSaveJsonObject(),
                _entitiesDatastore.GetSaveJsonObject(),
                _worldSettingsDatastore.GetSaveJsonObject(),
                _mapObjectDatastore.GetSaveJsonObject(),
                _challengeDatastore.GetSaveJsonObject()
            );
            
            return JsonConvert.SerializeObject(saveData);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad.Interface/IWorldSaveDataLoader.cs
```cs
namespace Game.SaveLoad.Interface
{
    public interface IWorldSaveDataLoader
    {
        public void LoadOrInitialize();
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ElectricMinerSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Inventory;
using Core.Master;
using Game.Block.Blocks.Miner;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    /// <summary>
    /// This test class verifies the save and load functionality of the ElectricMiner block.
    /// It ensures that the miner's state, including its inventory and remaining mining time, is correctly preserved.
    /// </summary>
    public class ElectricMinerSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            // Initialize the server and get the block factory.
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;

            // Get the block GUID for the ElectricMiner.
            var minerGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.ElectricMinerId).BlockGuid;

            // Create the position info for the miner.
            var minerPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);

            // Create an instance of the ElectricMiner block.
            var originalMiner = blockFactory.Create(ForUnitTestModBlockId.ElectricMinerId, new BlockInstanceId(1), minerPosInfo);
            var originalMinerComponent = originalMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Set the remaining mining time to a specific value.
            var originalRemainingSecond = 0.35;

            // Access the miner's inventory using reflection to set test items.
            var inventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(originalMinerComponent);

            // Set some items in the miner's inventory.
            inventory.SetItem(0, new ItemId(1), 1);
            inventory.SetItem(2, new ItemId(4), 1);

            // Set the remaining mining time using reflection.
            typeof(VanillaMinerProcessorComponent)
                .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                .SetValue(originalMinerComponent, originalRemainingSecond);

            // Save the state of the miner to a JSON string.
            var json = originalMiner.GetSaveState();
            Debug.Log(json);
            
            
            // ------- finish Save -------
            // ------- start Load -------

            // Load a new miner instance from the saved state.
            var loadedMiner = blockFactory.Load(minerGuid, new BlockInstanceId(1), json, minerPosInfo);
            var loadedMinerComponent = loadedMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Access the loaded miner's inventory and remaining mining time.
            var loadedInventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);

            var loadedRemainingSecond =
                (double)typeof(VanillaMinerProcessorComponent)
                    .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);

            // Assert that the original and loaded inventories are equal.
            Assert.AreEqual(inventory.GetItem(0), loadedInventory.GetItem(0));
            Assert.AreEqual(inventory.GetItem(1), loadedInventory.GetItem(1));
            Assert.AreEqual(inventory.GetItem(2), loadedInventory.GetItem(2));

            // Assert that the remaining mining time is the same.
            Assert.AreEqual(originalRemainingSecond, loadedRemainingSecond);
        }
    }
}

```

moorestech_client/Assets/Scripts/Client.Common/Server/NetworkConst.cs
```cs
namespace Client.Common.Server
{
    public class NetworkConst
    {
        public const int SecondUpdateRate = 10;
        public const int UpdateIntervalMilliseconds = 1000 / SecondUpdateRate;
        public const float UpdateIntervalSeconds = 1.0f / SecondUpdateRate;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/ITutorialViewManager.cs
```cs
using Mooresmaster.Model.ChallengesModule;

namespace Client.Game.InGame.Tutorial
{
    public interface ITutorialViewManager
    {
        public ITutorialView ApplyTutorial(ITutorialParam param);

    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockVerticalDirection.cs
```cs
namespace Game.Block.Interface
{
    public enum BlockVerticalDirection
    {
        Up,
        Horizontal,
        Down,
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTestModBlockId.cs
```cs
using Core.Master;

namespace Tests.Module.TestMod
{
    public static class ForUnitTestModBlockId
    {
        public static readonly BlockId MachineId = (BlockId)1;
        public static readonly BlockId BlockId = (BlockId)2;
        public static readonly BlockId BeltConveyorId = (BlockId)3;
        public static readonly BlockId ElectricPoleId = (BlockId)4;
        public static readonly BlockId GeneratorId = (BlockId)5;
        public static readonly BlockId ElectricMinerId = (BlockId)6;
        public static readonly BlockId ChestId = (BlockId)7;
        public static readonly BlockId InfinityGeneratorId = (BlockId)8;
        
        public static readonly BlockId MultiBlockGeneratorId = (BlockId)10;
        
        public static readonly BlockId SmallGear = (BlockId)12;
        public static readonly BlockId BigGear = (BlockId)13;
        public static readonly BlockId Shaft = (BlockId)14;
        public static readonly BlockId GearMachine = (BlockId)15;
        public static readonly BlockId SimpleGearGenerator = (BlockId)16;
        public static readonly BlockId SimpleFastGearGenerator = (BlockId)17;
        public static readonly BlockId Teeth10RequireTorqueTestGear = (BlockId)18;
        public static readonly BlockId Teeth20RequireTorqueTestGear = (BlockId)19;
        public static readonly BlockId InfinityTorqueSimpleGearGenerator = (BlockId)20;
        public static readonly BlockId GearBeltConveyor = (BlockId)21;
        
        public static readonly BlockId StraightItemShooter = (BlockId)22;
        public static readonly BlockId DownItemShooter = (BlockId)23;
        public static readonly BlockId UpItemShooter = (BlockId)24;
        
        public static readonly BlockId MachineRecipeTest1 = (BlockId)25;
        public static readonly BlockId MachineRecipeTest2 = (BlockId)26;
        public static readonly BlockId MachineRecipeTest3 = (BlockId)27;
        
        public static readonly BlockId GearMiner = (BlockId)28;
        
        public static readonly BlockId CraftChainerTransporter = (BlockId)29;
        public static readonly BlockId CraftChainerCrafter = (BlockId)30;
        public static readonly BlockId CraftChainerProviderChest = (BlockId)31;
        public static readonly BlockId CraftChainerMainComputer = (BlockId)32;
        public static readonly BlockId CraftChainerBeltConveyor = (BlockId)33;
        public static readonly BlockId CraftChainerMachine1 = (BlockId)34;
        public static readonly BlockId CraftChainerMachine2 = (BlockId)35;
        
        public static readonly BlockId TestTrainRail = (BlockId)35;
        public static readonly BlockId TestTrainStation = (BlockId)36;
        public static readonly BlockId TestTrainCargoPlatform = (BlockId)37;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Map/MapVein/MapVeinGameObject.cs
```cs
using System;
using UnityEngine;

namespace Client.Game.InGame.Map.MapVein
{
    [ExecuteAlways]
    public class MapVeinGameObject : MonoBehaviour
    {
        public Vector3Int MinPosition => new(
            Mathf.RoundToInt(transform.position.x - bounds.size.x / 2f + bounds.center.x),
            Mathf.RoundToInt(transform.position.y - bounds.size.y / 2f + bounds.center.y),
            Mathf.RoundToInt(transform.position.z - bounds.size.z / 2f + bounds.center.z));
        
        public Vector3Int MaxPosition => new(
            Mathf.RoundToInt(transform.position.x + bounds.size.x / 2f + bounds.center.x),
            Mathf.RoundToInt(transform.position.y + bounds.size.y / 2f + bounds.center.y),
            Mathf.RoundToInt(transform.position.z + bounds.size.z / 2f + bounds.center.z));
        
        public Vector3 Size => bounds.size;
        public Vector3 CenterPosition => bounds.center + transform.position;
        
        public Guid VeinItemGuid => Guid.Parse(veinItemGuid);
        [SerializeField] private string veinItemGuid;
        
        public Bounds Bounds => bounds;
        [SerializeField] private Bounds bounds = new(Vector3.zero, Vector3.one);
        
        public void SetBounds(Bounds setBounds)
        {
            bounds = setBounds;
            
            var size = bounds.size;
            var sizeX = size.x < 1 ? 1 : Mathf.RoundToInt(size.x);
            var sizeY = size.y < 1 ? 1 : Mathf.RoundToInt(size.y);
            var sizeZ = size.z < 1 ? 1 : Mathf.RoundToInt(size.z);
            bounds.size = new Vector3(sizeX, sizeY, sizeZ);
            
            var centerX = sizeX % 2f == 0 ? 0 : 0.5f;
            var centerY = sizeY % 2f == 0 ? 0 : 0.5f;
            var centerZ = sizeZ % 2f == 0 ? 0 : 0.5f;
            bounds.center = new Vector3(centerX, centerY, centerZ);
        }
        
        private void Update()
        {
#if UNITY_EDITOR
            OnEditorUpdate();
#endif
        }
        
        private void OnEditorUpdate()
        {
            transform.position = new Vector3Int(
                Mathf.RoundToInt(transform.position.x),
                Mathf.RoundToInt(transform.position.y),
                Mathf.RoundToInt(transform.position.z));
            SetBounds(bounds);
        }
        
        private void OnDrawGizmosSelected()
        {
            var color = Color.red;
            color.a = 0.5f;
            Gizmos.color = color;
            Gizmos.DrawCube(CenterPosition, Size);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Skit/SkitCharacter.cs
```cs
using System.Collections.Generic;
using Client.Skit.SkitTrack;
using DG.Tweening;
using UnityEngine;

namespace Client.Skit.Skit
{
    public class SkitCharacter : MonoBehaviour
    {
        [SerializeField] private AudioSource voiceAudioSource;
        [SerializeField] private SkinnedMeshRenderer faceSkinnedMeshRenderer;
        [SerializeField] private Animator animator;
        
        public void Initialize(Transform parent, string name)
        {
            gameObject.name = name + " (StoryCharacter)";
            transform.SetParent(parent);
        }
        
        public void SetTransform(Vector3 position, Vector3 rotation)
        {
            transform.position = position;
            transform.eulerAngles = rotation;
        }
        
        public void PlayAnimation(string animationName)
        {
            animator.SetTrigger(animationName);
        }
        
        public void PlayVoice(AudioClip voiceClip)
        {
            voiceAudioSource.clip = voiceClip;
            voiceAudioSource.Play();
        }
        
        public void StopVoice()
        {
            voiceAudioSource.Stop();
        }
        
        public void SetEmotion(EmotionType emotion, float duration)
        {
            var blendShapeData = ToBlendShapeData(emotion);
            
            // Tween BlendShape
            foreach (var (key, value) in blendShapeData)
                DOTween.To(
                    () => faceSkinnedMeshRenderer.GetBlendShapeWeight(key),
                    x => faceSkinnedMeshRenderer.SetBlendShapeWeight(key, x),
                    value,
                    duration);
            
            #region Internal
            
            Dictionary<int, float> ToBlendShapeData(EmotionType emotionType)
            {
                return emotionType switch
                {
                    EmotionType.Normal => new Dictionary<int, float> { { 11, 0f } },
                    EmotionType.Happy => new Dictionary<int, float> { { 11, 100 } },
                };
            }
            
            #endregion
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Player/PlayerContainer.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Player
{
    public class PlayerContainer : MonoBehaviour
    {
        [SerializeField] private PlayerGrabItemManager playerGrabItemManager;
        [SerializeField] private PlayerObjectController playerObjectController;
        public PlayerGrabItemManager PlayerGrabItemManager => playerGrabItemManager;
        
        public IPlayerObjectController PlayerObjectController => playerObjectController;
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/craftRecipes.json
```cs
{
  "data": [
    {
      "craftResultCount": 2,
      "craftResultItemGuid": "00000000-0000-0000-1234-000000000003",
      "requiredItems": [
        {
          "percent": 1,
          "count": 2,
          "maxCount": 3,
          "minCount": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        },
        {
          "count": 2,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "craftRecipeGuid": "a7b03292-073b-460f-aed4-78d9dc6db7a8",
      "craftTime": 3
    },
    {
      "craftResultCount": 2,
      "craftResultItemGuid": "00000000-0000-0000-1234-000000000003",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        }
      ],
      "craftRecipeGuid": "aab28fa7-d853-4446-9509-a87070f423f0",
      "craftTime": 3
    },
    {
      "craftResultCount": 80,
      "craftResultItemGuid": "00000000-0000-0000-1234-000000000006",
      "requiredItems": [
        {
          "count": 5,
          "itemGuid": "00000000-0000-0000-1234-000000000006"
        }
      ],
      "craftRecipeGuid": "f94c8265-be95-4a1e-810f-e4d986f05006",
      "craftTime": 3
    },
    {
      "craftResultCount": 1,
      "craftResultItemGuid": "00000000-0000-0000-1234-000000000003",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 5,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "craftRecipeGuid": "f1b23a8e-83fc-43f2-8f79-6d236c56e81b",
      "craftTime": 3
    }
  ]
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/IGear.cs
```cs
namespace Game.Gear.Common
{
    public interface IGear : IGearEnergyTransformer
    {
        public int TeethCount { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/IWorldBlockDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public interface IWorldBlockDatastore
    {
        public IReadOnlyDictionary<BlockInstanceId, WorldBlockData> BlockMasterDictionary { get; }
        
        public IObservable<(BlockState state, WorldBlockData blockData)> OnBlockStateChange { get; }
        
        public bool TryAddBlock(BlockId blockId, Vector3Int position, BlockDirection direction, out IBlock block);
        public bool TryAddLoadedBlock(Guid blockGuid, BlockInstanceId blockInstanceId, Dictionary<string,string> componentStates, Vector3Int position, BlockDirection direction, out IBlock block);
        public bool RemoveBlock(Vector3Int pos);
        
        public IBlock GetBlock(Vector3Int pos);
        public IBlock GetBlock(BlockInstanceId blockInstanceId);
        public IBlock GetBlock(IBlockComponent component);
        
        public WorldBlockData GetOriginPosBlock(Vector3Int pos);
        public Vector3Int GetBlockPosition(BlockInstanceId blockInstanceId);
        public BlockDirection GetBlockDirection(Vector3Int pos);
        
        public List<BlockJsonObject> GetSaveJsonObject();
        public void LoadBlockDataList(List<BlockJsonObject> saveBlockDataList);
    }
    
    public static class WorldBlockDatastoreExtension
    {
        public static bool Exists(this IWorldBlockDatastore datastore, Vector3Int pos)
        {
            var block = datastore.GetBlock(pos);
            return block != null;
        }
        
        public static bool TryGetBlock(this IWorldBlockDatastore datastore, Vector3Int pos, out IBlock block)
        {
            block = datastore.GetBlock(pos);
            return block != null;
        }
        
        public static bool ExistsComponent<TComponent>(this IWorldBlockDatastore datastore, Vector3Int pos) where TComponent : IBlockComponent
        {
            var block = datastore.GetBlock(pos);
            if (block == null) return false;
            return block.ComponentManager.ExistsComponent<TComponent>();
        }
        
        public static TComponent GetBlock<TComponent>(this IWorldBlockDatastore datastore, Vector3Int pos) where TComponent : IBlockComponent
        {
            var block = datastore.GetBlock(pos);
            
            if (block.ComponentManager.TryGetComponent(out TComponent component2)) return component2;
            
            return default;
        }
        
        public static bool TryGetBlock<TComponent>(this IWorldBlockDatastore datastore, Vector3Int pos, out TComponent component) where TComponent : IBlockComponent
        {
            if (datastore.ExistsComponent<TComponent>(pos))
            {
                component = datastore.GetBlock<TComponent>(pos);
                return true;
            }
            
            component = default;
            return false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/WorldVersions/WorldSaveAllInfoV1.cs
```cs
using System.Collections.Generic;
using Game.Challenge;
using Game.Entity.Interface;
using Game.Map.Interface.Json;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using Newtonsoft.Json;

namespace Game.SaveLoad.Json.WorldVersions
{
    public class WorldSaveAllInfoV1
    {
        [JsonProperty("worldVersion")] public int WorldVersion = 1;
        
        public WorldSaveAllInfoV1(List<BlockJsonObject> world, List<PlayerInventorySaveJsonObject> inventory,
            List<EntityJsonObject> entities, WorldSettingJsonObject setting,
            List<MapObjectJsonObject> mapObjects, List<ChallengeJsonObject> challenge)
        {
            World = world;
            Inventory = inventory;
            Entities = entities;
            Setting = setting;
            MapObjects = mapObjects;
            Challenge = challenge;
        }
        
        [JsonProperty("world")] public List<BlockJsonObject> World { get; }
        [JsonProperty("playerInventory")] public List<PlayerInventorySaveJsonObject> Inventory { get; }
        [JsonProperty("entities")] public List<EntityJsonObject> Entities { get; }
        [JsonProperty("setting")] public WorldSettingJsonObject Setting { get; }
        [JsonProperty("mapObjects")] public List<MapObjectJsonObject> MapObjects { get; set; }
        [JsonProperty("challenge")] public List<ChallengeJsonObject> Challenge { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockStateObservable.cs
```cs
using System;
using UniRx;

namespace Game.Block.Interface.Component
{
    public interface IBlockStateObservable : IBlockStateDetail
    {
        public IObservable<Unit> OnChangeBlockState { get; }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/DebugEnvironmentController.cs
```cs
using UnityEngine;

namespace Client.DebugSystem
{
    public class DebugEnvironmentController : MonoBehaviour
    {
        [SerializeField] private GameObject debugEnvironment;
        [SerializeField] private GameObject pureNatureEnvironment;
        
        public static void SetEnvironment(DebugEnvironmentType environmentType)
        {
            var debugEnvironmentController = FindObjectOfType<DebugEnvironmentController>();
            if (debugEnvironmentController == null)
            {
                Debug.LogError("DebugEnvironmentController not found");
                return;
            }
            
            var debugEnvironment = false;
            var pureNatureEnvironment = false;
            switch (environmentType)
            {
                case DebugEnvironmentType.Debug:
                    debugEnvironment = true;
                    break;
                case DebugEnvironmentType.PureNature:
                    pureNatureEnvironment = true;
                    break;
            }
            
            debugEnvironmentController.debugEnvironment.SetActive(debugEnvironment);
            debugEnvironmentController.pureNatureEnvironment.SetActive(pureNatureEnvironment);
        }
    }
    
    public enum DebugEnvironmentType
    {
        Debug,
        PureNature
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearMinerMiningTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Core.Item.Interface;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Miner;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    /// <summary>
    /// Test class for the gear-powered miner component.
    /// </summary>
    public class GearMinerMiningTest
    {
        /// <summary>
        /// Tests that the gear miner produces items after the required mining time when supplied with correct RPM and torque.
        /// </summary>
        [Test]
        public void GearMiningTest()
        {
            // Initialize the dependency injection container and services.
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            // Retrieve necessary services.
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            
            // Locate a map vein (resource deposit) to mine.
            var (mapVein, position) = MinerMiningTest.GetMapVein();
            Assert.NotNull(mapVein, "No map vein found for mining.");

            // Add the gear miner block at the vein position.
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GearMiner, position, BlockDirection.North, out var gearMinerBlock);
            var gearMiner = worldBlockDatastore.GetBlock(position);

            // Retrieve the mining processor component from the gear miner.
            var minerProcessorComponent = gearMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Use reflection to access private fields: _miningItems and _defaultMiningTime.
            var miningItemsField = typeof(VanillaMinerProcessorComponent).GetField("_miningItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var miningTimeField = typeof(VanillaMinerProcessorComponent).GetField("_defaultMiningTime", BindingFlags.NonPublic | BindingFlags.Instance);
            var miningItems = (List<IItemStack>)miningItemsField.GetValue(minerProcessorComponent);
            var miningItemId = miningItems[0].Id;
            var miningTime = (float)miningTimeField.GetValue(minerProcessorComponent);

            // Create a dummy inventory to receive mined items.
            var dummyInventory = new DummyBlockInventory();

            // Connect the dummy inventory to the miner's output.
            var minerConnectors = (Dictionary<IBlockInventory, ConnectedInfo>)gearMiner
                .GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            minerConnectors.Add(dummyInventory, new ConnectedInfo());

            // Place a gear generator adjacent to the gear miner to supply RPM and torque.
            var generatorPosition = position + new Vector3Int(0, 0, -1);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.InfinityTorqueSimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);

            // Ensure the gear network is updated so that the miner receives power.
            var gearNetwork = gearNetworkDatastore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();

            // Wait for the mining time to elapse.
            var mineEndTime = DateTime.Now.AddSeconds(miningTime * 1.2f);
            while (DateTime.Now < mineEndTime)
            {
                GameUpdater.UpdateWithWait();
            }

            // Verify that one item has been mined and transferred to the dummy inventory.
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id, "The mined item ID does not match.");
            Assert.AreEqual(1, dummyInventory.InsertedItems[0].Count, "The mined item count should be 1.");

            // Disconnect the dummy inventory to test internal storage.
            minerConnectors.Remove(dummyInventory);

            // Wait for two more mining cycles.
            mineEndTime = DateTime.Now.AddSeconds(miningTime * 2.2f);
            while (DateTime.Now < mineEndTime)
            {
                GameUpdater.UpdateWithWait();
            }

            // Check that two items are stored in the miner's internal inventory.
            var outputSlot = minerProcessorComponent.InventoryItems[0];
            Assert.AreEqual(miningItemId, outputSlot.Id, "The stored item ID does not match.");
            Assert.AreEqual(2, outputSlot.Count, "The stored item count should be 2.");

            // Reconnect the dummy inventory.
            minerConnectors.Add(dummyInventory, new ConnectedInfo());

            // Update the game state to allow the miner to transfer items to the dummy inventory.
            GameUpdater.UpdateWithWait();

            // Verify that a total of three items are now in the dummy inventory.
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id, "The mined item ID does not match after reconnection.");
            Assert.AreEqual(3, dummyInventory.InsertedItems[0].Count, "The total mined item count should be 3 after reconnection.");
        }
    }
}

```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/BlockJsonObject.cs
```cs
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public class BlockJsonObject
    {
        [JsonProperty("blockGuid")] public string BlockGuidStr;
        [JsonIgnore] public Guid BlockGuid => Guid.Parse(BlockGuidStr);
        
        [JsonProperty("direction")] public int Direction;
        [JsonProperty("entityId")] public int EntityId;
        [JsonProperty("state")] public Dictionary<string,string> ComponentStates;
        
        [JsonIgnore] public Vector3Int Pos => new(X, Y, Z);
        [JsonProperty("X")] public int X;
        [JsonProperty("Y")] public int Y;
        [JsonProperty("Z")] public int Z;
        
        public BlockJsonObject(Vector3Int pos, string blockGuid, int entityId, Dictionary<string,string> componentStates, int direction)
        {
            X = pos.x;
            Y = pos.y;
            Z = pos.z;
            BlockGuidStr = blockGuid;
            EntityId = entityId;
            ComponentStates = componentStates;
            Direction = direction;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryMoveUtil/ItemMoveType.cs
```cs
namespace Server.Protocol.PacketResponse.Util.InventoryMoveUtil
{
    public enum ItemMoveType
    {
        SwapSlot,
        InsertSlot,
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/IBlockInventoryOpenStateDataStore.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface;
using UnityEngine;

namespace Game.PlayerInventory.Interface
{
    public interface IBlockInventoryOpenStateDataStore
    {
        public List<int> GetBlockInventoryOpenPlayers(BlockInstanceId blockBlockInstanceId);
        public void Open(int playerId, Vector3Int pos);
        public void Close(int playerId);
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity/EntitiesDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Game.Entity.Interface;
using UnityEngine;

namespace Game.Entity
{
    public class EntitiesDatastore : IEntitiesDatastore
    {
        private readonly Dictionary<EntityInstanceId, IEntity> _entities = new();
        
        private readonly IEntityFactory _entityFactory;
        
        public EntitiesDatastore(IEntityFactory entityFactory)
        {
            _entityFactory = entityFactory;
        }
        
        public void Add(IEntity entity)
        {
            _entities.Add(entity.InstanceId, entity);
        }
        
        public bool Exists(EntityInstanceId instanceId)
        {
            return _entities.ContainsKey(instanceId);
        }
        
        public IEntity Get(EntityInstanceId instanceId)
        {
            return _entities[instanceId];
        }
        
        public List<EntityJsonObject> GetSaveJsonObject()
        {
            var saveData = new List<EntityJsonObject>();
            foreach (KeyValuePair<EntityInstanceId, IEntity> entity in _entities)
            {
                var e = entity.Value;
                saveData.Add(new EntityJsonObject(e.EntityType, e.InstanceId.AsPrimitive(), e.Position));
            }
            
            return saveData;
        }
        
        public void LoadBlockDataList(List<EntityJsonObject> saveBlockDataList)
        {
            foreach (var save in saveBlockDataList)
            {
                var entity = _entityFactory.CreateEntity(save.Type, new EntityInstanceId(save.InstanceId));
                _entities.Add(entity.InstanceId, entity);
                
                var pos = new Vector3(save.X, save.Y, save.Z);
                SetPosition(new EntityInstanceId(save.InstanceId), pos);
            }
        }
        
        public void SetPosition(EntityInstanceId instanceId, Vector3 position)
        {
            if (_entities.TryGetValue(instanceId, out var entity))
            {
                entity.SetPosition(position);
                return;
            }
            
            throw new Exception("Entity not found " + instanceId);
        }
        
        public Vector3 GetPosition(EntityInstanceId instanceId)
        {
            if (_entities.TryGetValue(instanceId, out var entity)) return entity.Position;
            throw new Exception("Entity not found " + instanceId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/InternalItemContext.cs
```cs
namespace Core.Item
{
    internal class InternalItemContext
    {
        public static ItemStackFactory ItemStackFactory { get; private set; }
        
        public InternalItemContext(ItemStackFactory itemStackFactory)
        {
            ItemStackFactory = itemStackFactory;
        }
    }
}
```

moorestech_server/Assets/ServerStarter.cs
```cs
using System;
using System.Threading;
using Core.Update;
using Server.Boot;
using UnityEngine;

public class ServerStarter : MonoBehaviour
{
    private CancellationTokenSource _autoSaveToken;
    private Thread _serverUpdateThread;

    private void Start()
    {
        (_serverUpdateThread, _autoSaveToken) = StartServer.Start(new string[] { });
        _serverUpdateThread.Start();
    }

    private void FixedUpdate()
    {
        GameUpdater.Update();
    }

    private void OnDestroy()
    {
        _serverUpdateThread.Abort();
        _autoSaveToken.Cancel();
        GameUpdater.Dispose();
    }
}
```

schema/ref/gearConnects.json
```cs
{
  "$id": "gear",

  "type": "object",
  "properties": {

    "gearConnects": {
      "fixedParameter": {
        "path" : "./connectType",
        "value": "Gear"
      },
      "$ref" : "blockConnectInfo"
    }

  }
}

```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/SelectionTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class SelectionTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            storyContext.SkitUI.ShowSelectionUI(true);
            
            var jumpTags = new List<string>();
            var selectionTexts = new List<string>();
            
            for (var i = 0; i < parameters.Count; i += 2)
            {
                var tag = parameters[i];
                var text = parameters[i + 1];
                //テキストが空文字列だったら終了
                if (text == string.Empty) break;
                
                jumpTags.Add(tag);
                selectionTexts.Add(text);
            }
            
            var selectedIndex = await storyContext.SkitUI.WaitSelectText(selectionTexts);
            
            storyContext.SkitUI.ShowSelectionUI(false);
            
            var selectedTag = jumpTags[selectedIndex];
            if (selectedTag == string.Empty) return null;
            
            return selectedTag;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/GearStateChangeProcessor.cs
```cs
using System;
using System.Collections.Generic;
using Game.Gear.Common;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    public class GearStateChangeProcessor : MonoBehaviour, IBlockStateChangeProcessor
    {
        public IReadOnlyList<RotationInfo> RotationInfos => rotationInfos;
        [SerializeField] private List<RotationInfo> rotationInfos;
        
        public GearStateDetail CurrentGearState { get; private set; }
        
        public void OnChangeState(BlockStateMessagePack blockState)
        {
            CurrentGearState = blockState.GetStateDetail<GearStateDetail>(GearStateDetail.BlockStateDetailKey);
        }
        
        private void Update()
        {
            if (CurrentGearState == null) return;
            
            Rotate(CurrentGearState);
        }
        
        public void Rotate(GearStateDetail gearStateDetail)
        {
            var rpm = gearStateDetail.CurrentRpm;
            var rotation = rpm / 60 * Time.deltaTime * 360;
            foreach (var rotationInfo in rotationInfos)
            {
                var rotate = rotationInfo.RotationAxis switch
                {
                    RotationAxis.X => new Vector3(rotation, 0, 0),
                    RotationAxis.Y => new Vector3(0, rotation, 0),
                    RotationAxis.Z => new Vector3(0, 0, rotation),
                    _ => Vector3.zero,
                };
                rotate *= rotationInfo.IsReverse ? -1 : 1;
                rotate *= rotationInfo.RotationSpeed;
                rotate *= gearStateDetail.IsClockwise ? 1 : -1;
                
                rotationInfo.RotationTransform.Rotate(rotate);
            }
        }
    }
    
    [Serializable]
    public class RotationInfo
    {
        [SerializeField] private RotationAxis rotationAxis;
        [SerializeField] private Transform rotationTransform;
        [SerializeField] private bool isReverse;
        [SerializeField] private float rotationSpeed = 1;
        
        public RotationAxis RotationAxis => rotationAxis;
        public Transform RotationTransform => rotationTransform;
        public bool IsReverse => isReverse;
        public float RotationSpeed => rotationSpeed;
    }
    
    public enum RotationAxis
    {
        X,
        Y,
        Z,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/KeyControlTutorialManager.cs
```cs
using Client.Game.InGame.UI.UIState;
using Mooresmaster.Model.ChallengesModule;
using TMPro;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Tutorial
{
    public class KeyControlTutorialManager : MonoBehaviour, ITutorialView, ITutorialViewManager
    {
        public const string TutorialType = "keyControl";
        
        [SerializeField] private GameObject keyControlUIObject;
        [SerializeField] private TMP_Text keyControlTutorialText;
        
        private KeyControlTutorialParam _keyControlTutorialParam;
        private UIStateControl _uiStateControl;
        
        [Inject]
        public void Construct(UIStateControl uiStateControl)
        {
            _uiStateControl = uiStateControl;
        }
        
        private void Update()
        {
            if (_keyControlTutorialParam != null)
            {
                var active = _uiStateControl.CurrentState.ToString() == _keyControlTutorialParam.UiState;
                keyControlUIObject.gameObject.SetActive(active);
            }
            else
            {
                keyControlUIObject.gameObject.SetActive(false);
            }
        }
        
        public ITutorialView ApplyTutorial(ITutorialParam param)
        {
            _keyControlTutorialParam = (KeyControlTutorialParam)param;
            keyControlTutorialText.text = _keyControlTutorialParam.ControlText;
            return this;
        }
        
        public void CompleteTutorial()
        {
            _keyControlTutorialParam = null;
            keyControlUIObject.gameObject.SetActive(false);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/ElectricPower.cs
```cs
using UnitGenerator;

namespace Game.EnergySystem
{
    [UnitOf(typeof(float), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable)]
    public readonly partial struct ElectricPower
    {
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapVein.cs
```cs
using Core.Master;
using Game.Map.Interface.Vein;
using UnityEngine;

namespace Game.Map
{
    public class MapVein : IMapVein
    {
        public ItemId VeinItemId { get; }
        public Vector3Int VeinRangeMin { get; }
        public Vector3Int VeinRangeMax { get; }
        
        public MapVein(ItemId veinItemId, Vector3Int veinRangeMin, Vector3Int veinRangeMax)
        {
            VeinItemId = veinItemId;
            VeinRangeMin = veinRangeMin;
            VeinRangeMax = veinRangeMax;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IUpdatableBlockComponent.cs
```cs
namespace Game.Block.Interface.Component
{
    public interface IUpdatableBlockComponent : IBlockComponent
    {
        public void Update();
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/Torque.cs
```cs
using UnitGenerator;

namespace Game.Gear.Common
{
    [UnitOf(typeof(float), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable)]
    public partial struct Torque
    {
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/craftRecipe.json
```cs
[
  {
    "requiredItems": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 2,
        "isRemain": false
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 3,
        "isRemain": false
      },
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 2,
        "isRemain": false
      }
    ],
    "resultItem": {
      "itemName": "Test3",
      "modId": "Test Author:forUniTest",
      "count": 1
    }
  },
  {
    "requiredItems": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "isRemain": false
      }
    ],
    "resultItem": {
      "itemName": "Test3",
      "modId": "Test Author:forUniTest",
      "count": 2
    }
  },
  {
    "requiredItems": [
      {
        "itemName": "Test6",
        "modId": "Test Author:forUniTest",
        "count": 5,
        "isRemain": false
      }
    ],
    "resultItem": {
      "itemName": "Test6",
      "modId": "Test Author:forUniTest",
      "count": 80
    }
  },
  {
    "requiredItems": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 3,
        "isRemain": true
      },
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 5,
        "isRemain": false
      }
    ],
    "resultItem": {
      "itemName": "Test3",
      "modId": "Test Author:forUniTest",
      "count": 1
    }
  }
]
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/MaxElectricPoleMachineConnectionRange.cs
```cs
using Core.Master;
using Game.Block;
using Mooresmaster.Model.BlocksModule;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public class MaxElectricPoleMachineConnectionRange
    {
        private readonly int _maxElectricPoleMachineConnectionRange = int.MinValue;
        
        public MaxElectricPoleMachineConnectionRange()
        {
            foreach (var blockElement in MasterHolder.BlockMaster.Blocks.Data)
            {
                if (blockElement.BlockType != BlockTypeConst.ElectricPole) continue;
                
                var param = blockElement.BlockParam as ElectricPoleBlockParam;
                if (_maxElectricPoleMachineConnectionRange < param.MachineConnectionRange)
                    _maxElectricPoleMachineConnectionRange = param.MachineConnectionRange;
            }
        }
        
        public int Get()
        {
            return _maxElectricPoleMachineConnectionRange;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/DebugSheet/DebugSheetController.cs
```cs
using Client.Game.GameDebug;
using IngameDebugConsole;
using Tayx.Graphy;
using UnityDebugSheet.Runtime.Core.Scripts;
using UnityDebugSheet.Runtime.Extensions.Graphy;
using UnityDebugSheet.Runtime.Extensions.IngameDebugConsole;
using UnityEngine;

namespace Client.DebugSystem
{
    public sealed class DebugSheetController : MonoBehaviour
    {
        [SerializeField] private GameObject runtimeHierarchyInspector;
        [SerializeField] private DebugSheet debugSheet;
        
        private void Start()
        {
            debugSheet.gameObject.SetActive(true);
            
            var rootPage = debugSheet.GetOrCreateInitialPage();
            
            rootPage.AddPageLinkButton<ItemGetDebugSheet>("Get Item");
            rootPage.AddPageLinkButton<IngameDebugConsoleDebugPage>("In-Game Debug Console", onLoad: x => x.page.Setup(DebugLogManager.Instance));
            rootPage.AddPageLinkButton<GraphyDebugPage>("Graphy", onLoad: x => x.page.Setup(GraphyManager.Instance));
            rootPage.AddSwitch(false, "Runtime Hierarchy Inspector", valueChanged: active => runtimeHierarchyInspector.SetActive(active));
            
            rootPage.AddEnumPickerWithSave(DebugEnvironmentType.Debug, "Select Environment", "DebugEnvironmentTypeKey", DebugEnvironmentController.SetEnvironment);
        }
        
        
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void CreateDebugger()
        {
            var prefab = Resources.Load<GameObject>("moorestech Debug Objects");
            Instantiate(prefab);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockConnectorComponent.cs
```cs
using System.Collections.Generic;
using Mooresmaster.Model.BlockConnectInfoModule;

namespace Game.Block.Interface.Component
{
    public interface IBlockConnectorComponent<TTarget> : IBlockComponent where TTarget : IBlockComponent
    {
        public IReadOnlyDictionary<TTarget, ConnectedInfo> ConnectedTargets { get; }
    }
    
    public struct ConnectedInfo
    {
        public IConnectOption SelfOption { get; }
        public IConnectOption TargetOption { get; }
        
        public IBlock TargetBlock { get; }
        
        public ConnectedInfo(IConnectOption selfOption, IConnectOption targetOption, IBlock targetBlock)
        {
            SelfOption = selfOption;
            TargetOption = targetOption;
            TargetBlock = targetBlock;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/IEntity.cs
```cs
using UnityEngine;

namespace Game.Entity.Interface
{
    public interface IEntity
    {
        EntityInstanceId InstanceId { get; }
        string EntityType { get; }
        
        Vector3 Position { get; }
        
        string State { get; }
        
        void SetPosition(Vector3 serverVector3);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/ClientContext.cs
```cs
using Client.Network.API;
using Client.Network.Settings;

namespace Client.Game.InGame.Context
{
    public class ClientContext
    {
        public static BlockGameObjectContainer BlockGameObjectContainer { get; private set; }
        public static ItemImageContainer ItemImageContainer { get; private set; }
        public static PlayerConnectionSetting PlayerConnectionSetting { get; private set; }
        public static VanillaApi VanillaApi { get; private set; }
        public static DIContainer DIContainer { get; private set; }
        
        public ClientContext(BlockGameObjectContainer blockGameObjectContainer, ItemImageContainer itemImageContainer, PlayerConnectionSetting playerConnectionSetting, VanillaApi vanillaApi)
        {
            BlockGameObjectContainer = blockGameObjectContainer;
            ItemImageContainer = itemImageContainer;
            PlayerConnectionSetting = playerConnectionSetting;
            VanillaApi = vanillaApi;
        }
        
        public void SetDIContainer(DIContainer diContainer)
        {
            DIContainer = diContainer;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/WorldSaverForJson.cs
```cs
using System.IO;
using Game.SaveLoad.Interface;

namespace Game.SaveLoad.Json
{
    public class WorldSaverForJson : IWorldSaveDataSaver
    {
        private readonly AssembleSaveJsonText _assembleSaveJsonText;
        private readonly SaveJsonFileName _fileName;
        
        public WorldSaverForJson(SaveJsonFileName fileName, AssembleSaveJsonText assembleSaveJsonText)
        {
            _fileName = fileName;
            _assembleSaveJsonText = assembleSaveJsonText;
        }
        
        public void Save()
        {
            File.WriteAllText(_fileName.FullSaveFilePath, _assembleSaveJsonText.AssembleSaveJson());
        }
    }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/craftRecipes.json
```cs
{
  "data": [
    {
      "craftTime": 5,
      "craftResultCount": 1,
      "craftResultItemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90",
          "isRemain": true
        },
        {
          "count": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        }
      ],
      "craftRecipeGuid": "f6d07ec4-94db-44ff-90ba-59cee0fb1d0b"
    },
    {
      "craftTime": 4,
      "craftResultCount": 1,
      "craftResultItemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 1,
          "itemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90"
        },
        {
          "count": 1,
          "itemGuid": "d382f613-8dec-4c87-b72c-c75f8d18ce73"
        }
      ],
      "craftRecipeGuid": "b7547ab6-87f2-4700-8d47-a0ec0230a811"
    },
    {
      "craftTime": 2,
      "craftResultCount": 1,
      "craftResultItemGuid": "d382f613-8dec-4c87-b72c-c75f8d18ce73",
      "craftRecipeGuid": "d4cbd944-839b-4d5a-91cc-e664633520c5",
      "requiredItems": [
        {
          "count": 5,
          "itemGuid": "19a3b0bc-10de-4e96-8a41-99f39675556d"
        }
      ]
    },
    {
      "craftTime": 5,
      "craftResultCount": 1,
      "craftResultItemGuid": "de89dc5c-b9d1-40f4-97ef-6b0bdcdd9379",
      "requiredItems": [
        {
          "count": 4,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 5,
          "itemGuid": "f92c51ab-1979-4a44-8c35-e86a51b33e61"
        }
      ],
      "craftRecipeGuid": "0141680f-4146-4bdb-b1be-c1bdb85bf981"
    },
    {
      "time": 1,
      "blockSize": [
        1,
        1,
        1
      ],
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "craftTime": 4,
      "craftResultCount": 1,
      "maxStack": 100,
      "craftResultItemGuid": "6b54897e-e7cb-4df7-807e-1597c2a859da",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "craftRecipeGuid": "bc4efda0-9707-48dc-9474-834db250ffda"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "99c95d35-9ba8-4027-9d88-48174a7322fa",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "craftRecipeGuid": "92585d73-55e4-4ce1-a3c9-9e67ebcf74b2"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "c82061f7-f4b2-45bc-8323-40f76dece8f2",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "craftRecipeGuid": "5d6e5479-c2e7-49c5-bfdb-c0274515083c"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "92fe1a42-ad46-4ff3-aa9a-83a9262c34d6"
        },
        {
          "count": 1,
          "itemGuid": "d382f613-8dec-4c87-b72c-c75f8d18ce73"
        },
        {
          "count": 1,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "8ec19b21-7e01-4932-9198-1ea7e5f9c2bf"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "067f2b59-a088-4fac-98cf-68060c6e9927",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "ee7c1edf-32ba-4bd2-962c-d29ee1309730"
        },
        {
          "count": 10,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "93c83117-c519-4673-9a81-062393722e51"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "requiredItems": [
        {
          "count": 25,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "d0e72dca-b0f0-4d0b-af72-cfb5f489f7c8",
      "craftResultItemGuid": "b7068d1c-f5cb-4af5-94e1-4ed9c9577ca8"
    },
    {
      "time": 1,
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "6f8e7dcb-e7d7-44c0-a63e-ffba1cd5e311",
      "requiredItems": [
        {
          "count": 10,
          "itemGuid": "975384df-a166-48a6-a5cf-d631f48715c0"
        },
        {
          "count": 5,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        }
      ],
      "craftRecipeGuid": "5392fbdb-8d93-4040-96eb-45a915d0c520"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "0559e1c6-5a63-40bc-92d8-64167fa6c3ba",
      "requiredItems": [
        {
          "count": 5,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "8f1d7de3-2ccd-457e-aa19-9c998ee59000"
    },
    {
      "craftTime": 2,
      "craftResultCount": 2,
      "craftResultItemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        },
        {
          "count": 1,
          "itemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e",
          "isRemain": true
        }
      ],
      "craftRecipeGuid": "804e2346-059c-4373-8160-eb4466815ba9"
    },
    {
      "maxStack": 100,
      "craftTime": 5,
      "craftResultCount": 1,
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "craftResultItemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "f92c51ab-1979-4a44-8c35-e86a51b33e61"
        }
      ],
      "craftRecipeGuid": "3d94ea46-b024-4be9-88fa-846e7a04157f"
    },
    {
      "maxStack": 100,
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "craftTime": 2,
      "craftResultCount": 1,
      "craftResultItemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        },
        {
          "count": 1,
          "itemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa",
          "isRemain": true
        }
      ],
      "craftRecipeGuid": "9236abf2-9a07-4397-9f03-f0d99981a6f7"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "17d94f6e-9f34-4d4b-8068-4be4c7dbfbb2",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "ee7c1edf-32ba-4bd2-962c-d29ee1309730"
        },
        {
          "count": 20,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "c850e9e3-95aa-4586-9f14-8d449964cd82"
    }
  ]
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/item.json
```cs
[
  {
    "name": "Test1",
    "maxStacks": 100
  },
  {
    "name": "Test2",
    "maxStacks": 50
  },
  {
    "name": "Test3",
    "maxStacks": 300
  },
  {
    "name": "Test4",
    "maxStacks": 100
  },
  {
    "name": "Test5",
    "maxStacks": 200
  },
  {
    "name": "Test6",
    "maxStacks": 100
  },
  {
    "name": "Test7",
    "maxStacks": 100
  },
  {
    "name": "Test8",
    "maxStacks": 100
  },
  {
    "name": "Test9",
    "maxStacks": 100
  },
  {
    "name": "Test10",
    "maxStacks": 100
  },
  {
    "name": "Test11",
    "maxStacks": 100
  },
  {
    "name": "tree",
    "maxStacks": 100
  },
  {
    "name": "stone",
    "maxStacks": 100
  },
  {
    "name": "SmallTestGear",
    "maxStacks": 100
  },
  {
    "name": "BigTestGear",
    "maxStacks": 100
  },
  {
    "name": "TestShaft",
    "maxStacks": 100
  },
  {
    "name": "TestGearMachine",
    "maxStacks": 100
  },
  {
    "name": "TestSimpleGearGenerator",
    "maxStacks": 100
  },
  {
    "name": "TestFastSimpleGearGenerator",
    "maxStacks": 100
  },
  {
    "name": "SmallRequireTorqueTestGear",
    "maxStacks": 100
  },
  {
    "name": "BigRequireTorqueTestGear",
    "maxStacks": 100
  },
  {
    "name": "InfinityTestSimpleGearGenerator",
    "maxStacks": 100
  },
  {
    "name": "StraightTestItemShooter",
    "maxStacks": 100
  },
  {
    "name": "DownTestItemShooter",
    "maxStacks": 100
  },
  {
    "name": "UpTestItemShooter",
    "maxStacks": 100
  },
  {
    "name": "GearBeltConveyor",
    "maxStacks": 100
  }
]

```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/GetChallengeInfoProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Challenge;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    public class GetChallengeInfoProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:getChallengeInfo";
        
        private readonly ChallengeDatastore _challengeDatastore;
        
        public GetChallengeInfoProtocol(ServiceProvider serviceProvider)
        {
            _challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestChallengeMessagePack>(payload.ToArray());
            
            var info = _challengeDatastore.GetOrCreateChallengeInfo(data.PlayerId);
            var currentChallengeIds = info.CurrentChallenges.Select(c => c.ChallengeMasterElement.ChallengeGuid).ToList();
            
            return new ResponseChallengeInfoMessagePack(data.PlayerId, currentChallengeIds, info.CompletedChallengeGuids);
        }
        
        
        [MessagePackObject]
        public class RequestChallengeMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RequestChallengeMessagePack() { }
            public RequestChallengeMessagePack(int playerId)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
            }
        }
        
        [MessagePackObject]
        public class ResponseChallengeInfoMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public List<string> CurrentChallengeGuidsStr { get; set; }
            [Key(4)] public List<string> CompletedChallengeGuidsStr { get; set; }
            
            [IgnoreMember] public List<Guid> CurrentChallengeGuids => CurrentChallengeGuidsStr.Select(Guid.Parse).ToList();
            [IgnoreMember] public List<Guid> CompletedChallengeGuids => CompletedChallengeGuidsStr.Select(Guid.Parse).ToList();
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseChallengeInfoMessagePack() { }
            public ResponseChallengeInfoMessagePack(int playerId, List<Guid> currentChallengeIds, List<Guid> completedChallengeIds)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                CurrentChallengeGuidsStr = currentChallengeIds.Select(x => x.ToString()).ToList();
                CompletedChallengeGuidsStr = completedChallengeIds.Select(x => x.ToString()).ToList();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Event/BlockOpenableInventoryUpdateEvent.cs
```cs
using System;
using Game.Block.Interface.Event;

namespace Game.Block.Event
{
    public class BlockOpenableInventoryUpdateEvent : IBlockOpenableInventoryUpdateEvent
    {
        public void Subscribe(Action<BlockOpenableInventoryUpdateEventProperties> blockInventoryEvent)
        {
            OnBlockInventoryUpdate += blockInventoryEvent;
        }
        
        public event Action<BlockOpenableInventoryUpdateEventProperties> OnBlockInventoryUpdate;
        
        public void OnInventoryUpdateInvoke(BlockOpenableInventoryUpdateEventProperties properties)
        {
            OnBlockInventoryUpdate?.Invoke(properties);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/ItemStackFactory.cs
```cs
using System;
using System.Collections.Generic;
using Core.Const;
using Core.Item.Implementation;
using Core.Item.Interface;
using Core.Master;

namespace Core.Item
{
    public class ItemStackFactory : IItemStackFactory
    {
        private readonly IItemStack _nullItem;
        
        public ItemStackFactory()
        {
            _nullItem = new NullItemStack();
            new InternalItemContext(this);
        }
        
        public IItemStack Create(ItemId id, int count, Dictionary<string, ItemStackMetaData> metaData = null)
        {
            if (id == ItemMaster.EmptyItemId) return CreatEmpty();
            
            if (count < 1) return CreatEmpty();
            
            metaData = metaData == null ? new Dictionary<string, ItemStackMetaData>() : new Dictionary<string, ItemStackMetaData>(metaData);
            return new ItemStack(id, count, metaData);
        }
        
        public IItemStack Create(ItemId id, int count, ItemInstanceId instanceId, Dictionary<string, ItemStackMetaData> metaData = null)
        {
            if (id == ItemMaster.EmptyItemId) return CreatEmpty();
            
            if (count < 1) return CreatEmpty();
            
            metaData = metaData == null ? new Dictionary<string, ItemStackMetaData>() : new Dictionary<string, ItemStackMetaData>(metaData);
            return new ItemStack(id, count, instanceId, metaData);
        }
        public IItemStack Create(Guid itemGuid, int count, Dictionary<string, ItemStackMetaData> metaData = null)
        {
            if (count < 1) return CreatEmpty();
            
            var id = MasterHolder.ItemMaster.GetItemId(itemGuid);
            return Create(id, count, metaData);
        }
        
        public IItemStack CreatEmpty()
        {
            return _nullItem;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/EntityJsonObject.cs
```cs
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Entity.Interface
{
    public class EntityJsonObject
    {
        [JsonProperty("InstanceId")] public long InstanceId;
        [JsonProperty("Type")] public string Type;
        
        [JsonProperty("X")] public float X;
        [JsonProperty("Y")] public float Y;
        [JsonProperty("Z")] public float Z;
        
        public EntityJsonObject(string type, long instanceId, Vector3 serverVector3)
        {
            Type = type;
            InstanceId = instanceId;
            X = serverVector3.x;
            Y = serverVector3.y;
            Z = serverVector3.z;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/IBlockInventoryView.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Core.Item.Interface;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public interface IBlockInventoryView : ISubInventory
    {
        public void Initialize(BlockGameObject blockGameObject);
        public void UpdateItemList(List<IItemStack> response);
        public void UpdateInventorySlot(int slot, IItemStack item);
        public void DestroyUI();
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Skit/SkitObjectTransfomCopyer.cs
```cs
using UnityEngine;

namespace Client.Skit.Skit
{
    public class SkitObjectTransfomCopyer : MonoBehaviour
    {
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Vein/IMapVein.cs
```cs
using Core.Master;
using UnityEngine;

namespace Game.Map.Interface.Vein
{
    public interface IMapVein
    {
        public ItemId VeinItemId { get; }
        
        public Vector3Int VeinRangeMin { get; }
        public Vector3Int VeinRangeMax { get; }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/CharacterTestDebug.cs
```cs
using System;
using Client.Game.InGame.Control;
using UnityEngine;

namespace Client.DebugSystem
{
    public class CharacterTestDebug : MonoBehaviour
    {
        [SerializeField] private InGameCameraController _cameraController;
        
        private void Start()
        {
            _cameraController.SetControllable(true);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/IMapObjectMiningState.cs
```cs
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Cysharp.Threading.Tasks;

namespace Client.Game.InGame.Mining
{
    public interface IMapObjectMiningState
    {
        IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt);
    }
    
    public class MapObjectMiningControllerContext
    {
        public MapObjectGameObject CurrentFocusMapObjectGameObject { get; private set; }
        
        
        public readonly HotBarView HotBarView;
        public readonly ILocalPlayerInventory LocalPlayerInventory;
        public readonly IPlayerObjectController PlayerObjectController;
        
        public MapObjectMiningControllerContext(HotBarView hotBarView, ILocalPlayerInventory localPlayerInventory, IPlayerObjectController playerObjectController)
        {
            HotBarView = hotBarView;
            LocalPlayerInventory = localPlayerInventory;
            PlayerObjectController = playerObjectController;
        }
        
        
        
        public void SetFocusMapObjectGameObject(MapObjectGameObject mapObjectGameObject)
        {
            if (mapObjectGameObject != CurrentFocusMapObjectGameObject)
            {
                CurrentFocusMapObjectGameObject?.OutlineEnable(false);
                mapObjectGameObject?.OutlineEnable(true);
            }
            
            CurrentFocusMapObjectGameObject = mapObjectGameObject;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/PlayerInventorySaveJsonObject.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Newtonsoft.Json;

namespace Game.PlayerInventory.Interface
{
    public class PlayerInventorySaveJsonObject
    {
        [JsonProperty("PlayerId")] public int PlayerId;
        
        [JsonProperty("MainInventoryItems")] public List<ItemStackSaveJsonObject> MainInventoryItems;
        
        [JsonProperty("GrabInventoryItems")] public ItemStackSaveJsonObject GrabInventoryItem;
        
        public PlayerInventorySaveJsonObject()
        {
        }
        
        public PlayerInventorySaveJsonObject(int playerId, PlayerInventoryData playerInventoryData)
        {
            MainInventoryItems = new List<ItemStackSaveJsonObject>();
            for (var i = 0; i < playerInventoryData.MainOpenableInventory.GetSlotSize(); i++)
            {
                var item = playerInventoryData.MainOpenableInventory.GetItem(i);
                MainInventoryItems.Add(new ItemStackSaveJsonObject(item));
            }
            
            var grabItemStack = playerInventoryData.GrabInventory.GetItem(0);
            GrabInventoryItem = new ItemStackSaveJsonObject(grabItemStack);
            
            PlayerId = playerId;
        }
        
        public (List<IItemStack> mainInventory, IItemStack grabItem) GetPlayerInventoryData()
        {
            var mainItemStack = new List<IItemStack>();
            foreach (var items in MainInventoryItems)
            {
                mainItemStack.Add(items.ToItemStack());
            }
            var grabItem = GrabInventoryItem.ToItemStack();
            
            return (mainItemStack, grabItem);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/machineRecipes.json
```cs
{
  "data": [
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-000000000001",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-000000000002",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-000000000003",
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        },
        {
          "count": 4,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000005"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-00000000000f",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-000000000019",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-00000000001a",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-00000000001b",
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        },
        {
          "count": 4,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000005"
        },
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "maxStack": 100,
      "time": 0.01,
      "blockGuid": "00000000-0000-0000-0000-000000000022",
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
        }
      ],
      "machineRecipeGuid": "76a4be24-66d6-46c6-84d9-e4e865db3e04"
    },
    {
      "time": 0.01,
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
        },
        {
          "count": 1,
          "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "189672cb-6811-4080-bde1-1f9ff0ec63ff"
        }
      ],
      "machineRecipeGuid": "38dfacce-beea-4612-8c7c-29112c12409a",
      "blockGuid": "00000000-0000-0000-0000-000000000023"
    }
  ]
}
```

schema/ref/inventoryConnects.json
```cs
{
  "$id": "inventoryConnects",

  "type": "object",
  "properties": {

    "inputConnects": {
      "fixedParameter": {
        "path" : "./connectType",
        "value": "Inventory"
      },
      "$ref" : "blockConnectInfo"
    },

    "outputConnects": {
      "fixedParameter": {
        "path" : "./connectType",
        "value": "Inventory"
      },
      "$ref" : "blockConnectInfo"
    }

  }
}

```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/EnergyServiceDependencyContainer.cs
```cs
using Game.EnergySystem;
using Game.World.Interface.DataStore;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public class EnergyServiceDependencyContainer<TSegment> where TSegment : EnergySegment, new()
    {
        public readonly IWorldEnergySegmentDatastore<TSegment> WorldEnergySegmentDatastore;
        
        public EnergyServiceDependencyContainer(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore)
        {
            WorldEnergySegmentDatastore = worldEnergySegmentDatastore;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockIconImagePhotographer.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Client.Game.InGame.Context;
using Core.Master;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class BlockIconImagePhotographer : MonoBehaviour
    {
        [SerializeField] private int iconSize = 512;
        [SerializeField] Camera cameraPrefab;
        
        public async UniTask<List<Texture2D>> TakeBlockIconImages(List<BlockObjectInfo> blockObjectInfos)
        {
            var createdBlocks = new List<(GameObject block,BlockObjectInfo blockObjectInfo)>();
            
            foreach (var blockObjectInfo in blockObjectInfos)
            {
                var block = Instantiate(blockObjectInfo.BlockObjectPrefab, transform);
                createdBlocks.Add((block, blockObjectInfo));
            }
            
            // ブロックを一直線に並べる
            var maxSize = GetMaxBlockSize(createdBlocks);
            var spacing = maxSize * 2f;
            for (int i = 0; i < createdBlocks.Count; i++)
            {
                var createdBlock = createdBlocks[i];
                createdBlock.block.transform.position = new Vector3(i * spacing, 0f, 0f);
                createdBlock.block.transform.rotation = Quaternion.identity;
                createdBlock.block.transform.localScale = Vector3.one;
            }
            
            // 全てのブロックでアイコンを取得
            var tasks = new List<UniTask<Texture2D>>();
            foreach (var block in createdBlocks)
            {
                tasks.Add(GetIcon(block.block, block.blockObjectInfo));
            }
            
            var result = await UniTask.WhenAll(tasks);
            
            return result.ToList();
        }
        
        private async UniTask<Texture2D> GetIcon(GameObject block, BlockObjectInfo blockObjectInfo)
        {
            // ブロックの重心とバウンディングを取得
            var bounds = block.GetComponentsInChildren<Renderer>().Select(b => b.bounds).ToList();
            if (bounds.Count == 0)
            {
                throw new System.Exception("ブロックにメッシュレンダラーがありませんでした:" + block.name + " " + blockObjectInfo.BlockMasterElement.Name);
            }
            var center = bounds.Select(b => b.center).Aggregate((b1, b2) => b1 + b2) / bounds.Count;
            
            // カメラ角度設定(例：上から30度、Y軸に対して45度傾ける)
            var blockImageCamera = Instantiate(cameraPrefab);
            blockImageCamera.transform.rotation = Quaternion.Euler(30f, 45f, 0f);
            
            // バウンディングボックスの最大寸法を取得
            var minPos = bounds.Select(b => b.min).Aggregate(Vector3.Min);
            var maxPos = bounds.Select(b => b.max).Aggregate(Vector3.Max);
            var maxSize = Vector3.Distance(minPos, maxPos);
            
            // カメラの視野角(FOV)と最大サイズから距離を計算
            float fovRad = blockImageCamera.fieldOfView * Mathf.Deg2Rad;
            float distance = (maxSize * 0.5f) / Mathf.Tan(fovRad * 0.5f);
            
            blockImageCamera.transform.position = center - blockImageCamera.transform.forward * (distance * 0.8f);
            blockImageCamera.transform.LookAt(center);
            
            // カメラ背景をアルファ付き透明に設定
            blockImageCamera.clearFlags = CameraClearFlags.SolidColor;
            blockImageCamera.backgroundColor = new Color(0f, 0f, 0f, 0f);
            
            await UniTask.Yield(PlayerLoopTiming.Update);
            
            // アルファ付きのRenderTextureを使用
            var renderTexture = new RenderTexture(iconSize, iconSize, 24, RenderTextureFormat.ARGB32)
            {
                useMipMap = false,
                autoGenerateMips = false
            };
            
            blockImageCamera.targetTexture = renderTexture;
            blockImageCamera.Render();
            blockImageCamera.targetTexture = null;
            
            // アルファ付きのTexture2Dに読み込み
            var texture = new Texture2D(iconSize, iconSize, TextureFormat.RGBA32, false);
            RenderTexture.active = renderTexture;
            texture.ReadPixels(new Rect(0, 0, iconSize, iconSize), 0, 0);
            texture.Apply();
            RenderTexture.active = null;
            
            // 不要なオブジェクトを破棄
            Destroy(block);
            Destroy(renderTexture);
            
            return texture;
        }
        
        private float GetMaxBlockSize(List<(GameObject block,BlockObjectInfo blockObjectInfo)> createdBlocks)
        {
            float maxSize = 0f;
            foreach (var createdBlock in createdBlocks)
            {
                var renderers = createdBlock.block.GetComponentsInChildren<MeshRenderer>();
                if (renderers.Length == 0) continue;
                
                var boundsList = renderers.Select(r => r.bounds).ToList();
                var minPos = boundsList.Select(b => b.min).Aggregate(Vector3.Min);
                var maxPos = boundsList.Select(b => b.max).Aggregate(Vector3.Max);
                var size = Vector3.Distance(minPos, maxPos);
                
                if (size > maxSize)
                    maxSize = size;
            }
            
            return maxSize;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ItemConfigTest.cs
```cs
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Other
{
    public class ItemConfigTest
    {
        [TestCase(1, 100)]
        [TestCase(2, 50)]
        [TestCase(3, 300)]
        [TestCase(4, 100)]
        [TestCase(5, 200)]
        [TestCase(7, 100)]
        public void JsonStackTest(int id, int stack)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            Assert.AreEqual(stack, MasterHolder.ItemMaster.GetItemMaster(new ItemId(id)).MaxStack);
        }
        
        [TestCase(1, "Test1")]
        [TestCase(2, "Test2")]
        [TestCase(3, "Test3")]
        [TestCase(4, "Test4")]
        [TestCase(5, "Test5")]
        [TestCase(6, "Test6")]
        [TestCase(7, "Test7")]
        public void JsonNameTest(int id, string name)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            Assert.AreEqual(name, MasterHolder.ItemMaster.GetItemMaster(new ItemId(id)).Name);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/VanillaApi.cs
```cs
using System;
using System.Diagnostics;
using Client.Network.Settings;
using UniRx;
using VContainer.Unity;

namespace Client.Network.API
{
    public class VanillaApi : IInitializable
    {
        private readonly Process _localServerProcess;
        
        private readonly ServerCommunicator _serverCommunicator;
        public readonly VanillaApiEvent Event;
        public readonly VanillaApiWithResponse Response;
        public readonly VanillaApiSendOnly SendOnly;
        
        public VanillaApi(PacketExchangeManager packetExchangeManager, PacketSender packetSender, ServerCommunicator serverCommunicator, PlayerConnectionSetting playerConnectionSetting, Process localServerProcess)
        {
            _serverCommunicator = serverCommunicator;
            _localServerProcess = localServerProcess;
            
            Event = new VanillaApiEvent(packetExchangeManager, playerConnectionSetting);
            Response = new VanillaApiWithResponse(packetExchangeManager, playerConnectionSetting);
            SendOnly = new VanillaApiSendOnly(packetSender, playerConnectionSetting);
        }
        
        public IObservable<Unit> OnDisconnect => _serverCommunicator.OnDisconnect;
        
        public void Initialize()
        {
        }
        
        public void Disconnect()
        {
            _serverCommunicator.Close();
            _localServerProcess?.Kill();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObjectFactory.cs
```cs
using System;
using UnityEngine;

namespace Game.Map.Interface.MapObject
{
    public interface IMapObjectFactory
    {
        public IMapObject Create(int instanceId, Guid mapObjectGuid, int currentHp, bool isDestroyed, Vector3 position);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/ISubInventory.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;

namespace Client.Game.InGame.UI.Inventory
{
    public interface ISubInventory
    {
        public List<IItemStack> SubInventory { get; }
        public int Count { get; }
        public ItemMoveInventoryInfo ItemMoveInventoryInfo { get; }
        public IReadOnlyList<ItemSlotObject> SubInventorySlotObjects { get; }
    }
    
    public class EmptySubInventory : ISubInventory
    {
        public EmptySubInventory()
        {
            Count = 0;
            SubInventorySlotObjects = new List<ItemSlotObject>();
            SubInventory = new List<IItemStack>();
            ItemMoveInventoryInfo = null;
        }
        
        public IReadOnlyList<ItemSlotObject> SubInventorySlotObjects { get; }
        public List<IItemStack> SubInventory { get; }
        public int Count { get; }
        public ItemMoveInventoryInfo ItemMoveInventoryInfo { get; }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/mapObject.json
```cs
[
  {
    "type": "vanilla:Tree",
    "hp": 30,
    "earnItemHps": [
      0,
      10,
      20
    ],
    "earnItems": [
      {
        "itemModId": "Test Author:forUniTest",
        "itemName": "Test1",
        "minCount": 3,
        "maxCount": 5
      }
    ],
    "miningTools": [
      {
        "toolItemModId": "Test Author:forUniTest",
        "toolItemName": "Test1",
        "damage": 1,
        "attackSpeed": 1.6
      }
    ]
  }
]
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockComponent.cs
```cs
namespace Game.Block.Interface.Component
{
    public interface IBlockComponent
    {
        public bool IsDestroy { get; }
        
        public void Destroy();
    }
}
```

moorestech_client/Assets/Scripts/Editor/DirectoryProcessor.cs
```cs
//Credit https://kan-kikuchi.hatenablog.com/entry/DirectoryProcessor

using System.IO;

/// <summary>
///     ディレクトリを操作するクラス
/// </summary>
public static class DirectoryProcessor
{
    /// <summary>
    ///     ディレクトリとその中身を上書きコピー
    /// </summary>
    public static void CopyAndReplace(string sourcePath, string copyPath)
    {
        //既にディレクトリがある場合は削除し、新たにディレクトリ作成
        Delete(copyPath);
        Directory.CreateDirectory(copyPath);
        
        //ファイルをコピー
        foreach (var file in Directory.GetFiles(sourcePath)) File.Copy(file, Path.Combine(copyPath, Path.GetFileName(file)));
        
        //ディレクトリの中のディレクトリも再帰的にコピー
        foreach (var dir in Directory.GetDirectories(sourcePath)) CopyAndReplace(dir, Path.Combine(copyPath, Path.GetFileName(dir)));
    }
    
    /// <summary>
    ///     指定したディレクトリとその中身を全て削除する
    /// </summary>
    public static void Delete(string targetDirectoryPath)
    {
        if (!Directory.Exists(targetDirectoryPath)) return;
        
        //ディレクトリ以外の全ファイルを削除
        var filePaths = Directory.GetFiles(targetDirectoryPath);
        foreach (var filePath in filePaths)
        {
            File.SetAttributes(filePath, FileAttributes.Normal);
            File.Delete(filePath);
        }
        
        //ディレクトリの中のディレクトリも再帰的に削除
        var directoryPaths = Directory.GetDirectories(targetDirectoryPath);
        foreach (var directoryPath in directoryPaths) Delete(directoryPath);
        
        //中が空になったらディレクトリ自身も削除
        Directory.Delete(targetDirectoryPath, false);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/TutorialManager.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Tutorial.UIHighlight;
using Core.Master;
using Game.Context;

namespace Client.Game.InGame.Tutorial
{
    public class TutorialManager
    {
        private readonly Dictionary<Guid, List<ITutorialView>> _tutorialViews = new();
        private readonly Dictionary<string, ITutorialViewManager> _tutorialViewManagers = new();
        
        public TutorialManager(MapObjectPin mapObjectPin, UIHighlightTutorialManager uiHighlightTutorialManager, KeyControlTutorialManager keyControlTutorialManager)
        {
            _tutorialViewManagers.Add(MapObjectPin.TutorialType, mapObjectPin);
            _tutorialViewManagers.Add(UIHighlightTutorialManager.TutorialType, uiHighlightTutorialManager);
            _tutorialViewManagers.Add(KeyControlTutorialManager.TutorialType, keyControlTutorialManager);
        }
        
        public void ApplyTutorial(Guid challengeGuid)
        {
            var tutorialViews = new List<ITutorialView>();
            var challenge = MasterHolder.ChallengeMaster.GetChallenge(challengeGuid);
            
            // チュートリアルを実際のManagerに適用する
            // Apply the tutorial to the actual Manager
            foreach (var tutorial in challenge.Tutorials)
            {
                var tutorialView = _tutorialViewManagers[tutorial.TutorialType].ApplyTutorial(tutorial.TutorialParam);
                
                if (tutorialView != null) tutorialViews.Add(tutorialView);
            }
            
            _tutorialViews.Add(challengeGuid, tutorialViews);
        }
        
        public void CompleteChallenge(Guid challengeId)
        {
            if (!_tutorialViews.TryGetValue(challengeId, out var tutorialViews)) return;
            
            foreach (var tutorialView in tutorialViews)
            {
                tutorialView.CompleteTutorial();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/IEntitiesDatastore.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Game.Entity.Interface
{
    public interface IEntitiesDatastore
    {
        public void Add(IEntity entity);
        public bool Exists(EntityInstanceId instanceId);
        public IEntity Get(EntityInstanceId instanceId);
        
        public void SetPosition(EntityInstanceId instanceId, Vector3 position);
        
        public Vector3 GetPosition(EntityInstanceId instanceId);
        
        
        public List<EntityJsonObject> GetSaveJsonObject();
        public void LoadBlockDataList(List<EntityJsonObject> saveBlockDataList);
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/MapObjectUpdateEventPacketTest.cs
```cs
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class MapObjectUpdateEventPacketTest
    {
        private const int PlayerId = 1;
        
        [Test]
        public void MapObjectDestroyToEventTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            
            var response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(PlayerId));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            //イベントがないことを確認する
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            
            //MapObjectを一つ破壊する
            var mapObject = mapObjectDatastore.MapObjects[0];
            mapObject.Destroy();
            
            //map objectが破壊されたことを確かめる
            response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(1, eventMessagePack.Events.Count);
            
            var data = MessagePackSerializer.Deserialize<MapObjectUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(MapObjectUpdateEventMessagePack.DestroyEventType, data.EventType);
            Assert.AreEqual(mapObject.InstanceId, data.InstanceId);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/HotBarItem.cs
```cs
using Client.Game.InGame.UI.Inventory.Element;
using Client.Mod.Texture;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory
{
    public class HotBarItem : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObject;
        [SerializeField] private TMP_Text keyBoardText;
        
        private void Awake()
        {
        }
        
        public void SetItem(ItemViewData itemViewData, int count)
        {
            itemSlotObject.SetItem(itemViewData, count);
        }
        
        public void SetKeyBoardText(string text)
        {
            keyBoardText.text = text;
        }
        
        public void SetSelect(bool isSelect)
        {
            itemSlotObject.SetHotBarSelect(isSelect);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/GameInitializerSceneLoader.cs
```cs
using Client.Common;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Client.Starter
{
    /// <summary>
    ///     <see cref="GameInitializerSceneLoader" />があるシーンの場合はゲーム初期化シーンをロードする
    /// </summary>
    public class GameInitializerSceneLoader : MonoBehaviour
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void Init()
        {
            var loader = FindObjectOfType<GameInitializerSceneLoader>(true);
            if (loader != null) SceneManager.LoadScene(SceneConstant.GameInitializerSceneName);
        }
    }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/challenges.json
```cs
{
    "data":[]
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/PreviewOnlyObject.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class PreviewOnlyObject : MonoBehaviour
    {
        private readonly List<Renderer> _renderers = new();
        
        public void Initialize()
        {
            _renderers.AddRange(GetComponentsInChildren<Renderer>(true));
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        public void SetEnableRenderers(bool enable)
        {
            foreach (var r in _renderers) r.enabled = enable;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Define/VoiceDefine.cs
```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Client.Skit.Define
{
    [CreateAssetMenu(fileName = "VoiceDefine", menuName = "moorestech/VoiceDefine", order = 0)]
    public class VoiceDefine : ScriptableObject
    {
        [SerializeField] private List<CharacterVoices> characterVoices;
        
        public AudioClip GetVoiceClip(string characterKey, string sentence)
        {
            var characterVoice = characterVoices.Find(x => x.CharacterKey == characterKey);
            if (characterVoice == null) return null;
            
            var voiceInfo = characterVoice.VoiceInfos.Find(x => x.Sentence == sentence);
            return voiceInfo?.VoiceClip;
        }
    }
    
    [Serializable]
    public class CharacterVoices
    {
        [SerializeField] private string characterKey;
        [SerializeField] private List<VoiceInfo> voiceInfos;
        
        [SerializeField] private string credit;
        public string CharacterKey => characterKey;
        
        public List<VoiceInfo> VoiceInfos => voiceInfos;
    }
    
    [Serializable]
    public class VoiceInfo
    {
        [SerializeField] [Multiline] private string sentence;
        [SerializeField] private AudioClip voiceClip;
        public string Sentence => sentence;
        
        public AudioClip VoiceClip => voiceClip;
    }
}
```

moorestech_server/Assets/Scripts/Game.Context/ServerContext.cs
```cs
using Core.Item.Interface;
using Game.Block.Interface;
using Game.Block.Interface.Event;
using Game.Map.Interface.Vein;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;

namespace Game.Context
{
    public class ServerContext
    {
        private static ServiceProvider _serviceProvider;
        
        public static IItemStackFactory ItemStackFactory { get; private set; }
        public static IBlockFactory BlockFactory { get; private set; }
        
        public static IWorldBlockDatastore WorldBlockDatastore { get; private set; }
        public static IMapVeinDatastore MapVeinDatastore { get; private set; }
        
        public static IWorldBlockUpdateEvent WorldBlockUpdateEvent { get; private set; }
        public static IBlockOpenableInventoryUpdateEvent BlockOpenableInventoryUpdateEvent { get; private set; }
        
        public static TType GetService<TType>()
        {
            return _serviceProvider.GetService<TType>();
        }
        
        public void SetMainServiceProvider(ServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }
        
        public ServerContext(ServiceProvider initializeServiceProvider)
        {
            ItemStackFactory = initializeServiceProvider.GetService<IItemStackFactory>();
            BlockFactory = initializeServiceProvider.GetService<IBlockFactory>();
            WorldBlockDatastore = initializeServiceProvider.GetService<IWorldBlockDatastore>();
            MapVeinDatastore = initializeServiceProvider.GetService<IMapVeinDatastore>();
            WorldBlockUpdateEvent = initializeServiceProvider.GetService<IWorldBlockUpdateEvent>();
            BlockOpenableInventoryUpdateEvent = initializeServiceProvider.GetService<IBlockOpenableInventoryUpdateEvent>();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Gear/SimpleGearGeneratorComponent.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Blocks.Gear
{
    public class SimpleGearGeneratorComponent : GearEnergyTransformer, IGearGenerator
    {
        public int TeethCount { get; }
        public RPM GenerateRpm { get; }
        public Torque GenerateTorque { get; }
        public bool GenerateIsClockwise { get; }
        
        public SimpleGearGeneratorComponent(SimpleGearGeneratorBlockParam simpleGearGeneratorBlockParam, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent) :
            base(new Torque(0), blockInstanceId, connectorComponent)
        {
            TeethCount = simpleGearGeneratorBlockParam.TeethCount;
            GenerateRpm = new RPM(simpleGearGeneratorBlockParam.GenerateRpm);
            GenerateTorque = new Torque(simpleGearGeneratorBlockParam.GenerateTorque);
            GenerateIsClockwise = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/IChallengeTask.cs
```cs
using System;
using Mooresmaster.Model.ChallengesModule;

namespace Game.Challenge.Task
{
    public interface IChallengeTask
    {
        public ChallengeMasterElement ChallengeMasterElement { get; }
        public int PlayerId { get; }
        
        public IObservable<IChallengeTask> OnChallengeComplete { get; }
        
        public void ManualUpdate();
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Define/CharacterDefine.cs
```cs
using System;
using System.Collections.Generic;
using Client.Skit.Skit;
using UnityEngine;

namespace Client.Skit.Define
{
    [CreateAssetMenu(fileName = "CharacterDefine", menuName = "moorestech/CharacterDefine", order = 0)]
    public class CharacterDefine : ScriptableObject
    {
        [SerializeField] private List<CharacterInfo> characterInfos;
        public IReadOnlyList<CharacterInfo> CharacterInfos => characterInfos;
    }
    
    [Serializable]
    public class CharacterInfo
    {
        [SerializeField] private string characterKey;
        [SerializeField] private SkitCharacter characterPrefab;
        public string CharacterKey => characterKey;
        
        public SkitCharacter CharacterPrefab => characterPrefab;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Util/GameObjectEnterExplainer.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.UI.Util
{
    public class GameObjectEnterExplainer : MonoBehaviour
    {
        /// <summary>
        ///     カーソルに表示するテキストのキー
        /// </summary>
        [SerializeField] private string textKey;
        
        /// <summary>
        ///     表示するかどうか
        /// </summary>
        [SerializeField] private bool displayEnable = true;
        
        [SerializeField] private int fontSize = IMouseCursorExplainer.DefaultFontSize;
        
        
        public void OnCursorEnter()
        {
            if (displayEnable) MouseCursorExplainer.Instance.Show(textKey, fontSize);
        }
        
        public void OnCursorExit()
        {
            MouseCursorExplainer.Instance.Hide();
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/IItemStackFactory.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;

namespace Core.Item.Interface
{
    public interface IItemStackFactory
    {
        public IItemStack Create(ItemId id, int count, Dictionary<string, ItemStackMetaData> metaData = null);
        public IItemStack Create(ItemId id, int count, ItemInstanceId instanceId, Dictionary<string, ItemStackMetaData> metaData = null);
        public IItemStack Create(Guid itemGuid, int count, Dictionary<string, ItemStackMetaData> metaData = null);
        
        public IItemStack CreatEmpty();
    }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/machineRecipes.json
```cs
{
  "data": [
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "time": 10,
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "inputItems": [
        {
          "count": 1,
          "itemGuid": "6b22a093-0c83-4543-9985-aad0ceb5f8b0"
        },
        {
          "count": 3,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67"
        }
      ],
      "machineRecipeGuid": "5937e6fd-06f9-4b47-88b1-15eae9176c53"
    },
    {
      "time": 1,
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 1,
          "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67"
        },
        {
          "count": 1,
          "itemGuid": "6b54897e-e7cb-4df7-807e-1597c2a859da"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "92fe1a42-ad46-4ff3-aa9a-83a9262c34d6"
        }
      ],
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "machineRecipeGuid": "25e49e81-7217-420a-b328-1939a19cb335"
    },
    {
      "time": 1,
      "inputItems": [
        {
          "count": 8,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 2,
          "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67"
        },
        {
          "count": 1,
          "itemGuid": "99c95d35-9ba8-4027-9d88-48174a7322fa"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "ee7c1edf-32ba-4bd2-962c-d29ee1309730"
        }
      ],
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "machineRecipeGuid": "261c5041-5bde-4fe5-b2e4-4dcb980979ba"
    },
    {
      "time": 1,
      "inputItems": [
        {
          "count": 15,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 5,
          "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67"
        },
        {
          "count": 1,
          "itemGuid": "c82061f7-f4b2-45bc-8323-40f76dece8f2"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "96e59fa9-8468-4315-b8b8-8e087a146dbb"
        }
      ],
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "machineRecipeGuid": "9e318e0b-75b9-4f4c-97d0-c024655cc9eb"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "craftTime": 3,
      "craftResultCount": 1,
      "time": 1,
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "975384df-a166-48a6-a5cf-d631f48715c0"
        }
      ],
      "machineRecipeGuid": "2d5e4d0c-ed24-4753-b386-fb518e2fd9fa"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "time": 5,
      "blockGuid": "1a61abfd-3531-43ff-96df-6b16c3436257",
      "inputItems": [
        {
          "count": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 3,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "machineRecipeGuid": "c9103ef7-cb64-4216-8dd3-23f9e56991d5"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "time": 1,
      "blockGuid": "ea0a407f-f9a5-4d5e-9c3e-69d6df2d383a",
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
        }
      ],
      "machineRecipeGuid": "9035d818-9d4d-42cd-a2df-5b97756d9f7c"
    },
    {
      "time": 1,
      "blockGuid": "87aa9a75-906a-47db-92a5-876afe8a1691",
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "189672cb-6811-4080-bde1-1f9ff0ec63ff"
        }
      ],
      "inputItems": [
        {
          "count": 1,
          "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
        },
        {
          "count": 1,
          "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
        }
      ],
      "machineRecipeGuid": "80a5231b-d51f-454d-bd0a-18646d46403e"
    }
  ]
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/mapObjects.json
```cs
{
  "data": [
    {
      "maxStack": 100,
      "earnItemHps": [
        0
      ],
      "hp": 1,
      "mapObjectName": "Pebble",
      "earnItems": [
        {
          "maxCount": 1,
          "minCount": 1,
          "itemId": "f92c51ab-1979-4a44-8c35-e86a51b33e61",
          "itemGuid": "f92c51ab-1979-4a44-8c35-e86a51b33e61"
        }
      ],
      "mapObjectGuid": "12081941-baa5-42b1-a3ee-5f97f5ee5871",
      "soundEffectType": "stone",
      "miningType": "PickUp",
      "miningParam": {}
    },
    {
      "earnItemHps": [
        0,
        10,
        20
      ],
      "hp": 30,
      "mapObjectName": "Tree",
      "soundEffectType": "tree",
      "earnItems": [
        {
          "maxCount": 3,
          "minCount": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        },
        {
          "maxCount": 8,
          "minCount": 2,
          "itemGuid": "19a3b0bc-10de-4e96-8a41-99f39675556d"
        }
      ],
      "mapObjectGuid": "6c5b31e2-4b26-4a89-b4e5-6f9a4aeaa6b7",
      "miningType": "Mining",
      "miningParam": {
        "miningTools": [
          {
            "attackSpeed": 8,
            "damage": 10,
            "toolItemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90"
          },
          {
            "attackSpeed": 2,
            "damage": 10,
            "toolItemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa"
          },
          {
            "attackSpeed": 1.5,
            "damage": 30,
            "toolItemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e"
          }
        ]
      }
    },
    {
      "resultItem": {
        "count": 1
      },
      "blockSize": [
        1,
        1,
        1
      ],
      "earnItemHps": [
        0,
        1,
        2,
        3
      ],
      "hp": 4,
      "mapObjectName": "ブロンズ鉱石",
      "soundEffectType": "stone",
      "miningType": "Mining",
      "earnItems": [
        {
          "maxCount": 1,
          "minCount": 1,
          "itemGuid": "6b22a093-0c83-4543-9985-aad0ceb5f8b0"
        }
      ],
      "miningParam": {
        "miningTools": [
          {
            "attackSpeed": 7,
            "damage": 1,
            "toolItemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa"
          },
          {
            "attackSpeed": 2,
            "damage": 1,
            "toolItemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e"
          }
        ]
      },
      "mapObjectGuid": "c5ad5661-9ae8-4863-9fc2-94819aff4cf7"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "craftResultCount": 1,
      "earnItemHps": [
        0,
        2
      ],
      "hp": 1,
      "mapObjectName": "粘土",
      "soundEffectType": "stone",
      "miningType": "Mining",
      "earnItems": [
        {
          "maxCount": 2,
          "minCount": 1,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "miningParam": {
        "miningTools": [
          {
            "attackSpeed": 5,
            "damage": 1,
            "toolItemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa"
          },
          {
            "attackSpeed": 1.5,
            "damage": 1,
            "toolItemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e"
          }
        ]
      },
      "mapObjectGuid": "0ea1f1d6-4921-42a7-a7a6-bbb674e29089"
    }
  ]
}
```

moorestech_client/Assets/Scripts/Client.Game/Sequence/S1InitialMovie.cs
```cs
using Client.CutScene;
using Client.Game.Common;
using Client.Game.InGame.BackgroundSkit;
using Client.Game.Skit;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Playables;

namespace Client.Game.Sequence
{
    public class S1InitialMovie : MonoBehaviour
    {
        public const string S1InitialMoviePlayerPrefsKey = "S1InitialMoviePlayed"; //TODo そのうち保存先をワールドに変更する
        [SerializeField] private bool forcePlay;
        
        [SerializeField] private bool playCutscene = true;
        [SerializeField] private bool playSkit = true;
        [SerializeField] private bool playBackgroundSkit = true;
        
        [SerializeField] private TimelinePlayer timelinePlayer;
        [SerializeField] private TextAsset initialSkit;
        
        [SerializeField] private PlayableAsset initialMovie;
        
        [SerializeField] private SkitManager skitManager;
        
        [SerializeField] private TextAsset backgroundSkit;
        [SerializeField] private BackgroundSkitManager backgroundSkitManager;
        
        private void Start()
        {
            if (forcePlay)
            {
                InitialMovie().Forget();
                return;
            }
            
            var hasPlayed = PlayerPrefs.GetInt(S1InitialMoviePlayerPrefsKey, 0);
            if (hasPlayed != 0) return;
            
            PlayerPrefs.SetInt(S1InitialMoviePlayerPrefsKey, 1);
            PlayerPrefs.Save();
            
            InitialMovie().Forget();
        }
        
        private async UniTask InitialMovie()
        {
            if (playCutscene)
            {
                GameStateController.ChangeState(GameStateType.CutScene);
                await timelinePlayer.Play(initialMovie);
            }
            
            if (playSkit)
            {
                GameStateController.ChangeState(GameStateType.Skit);
                await skitManager.StartSkit(initialSkit);
            }
            
            if (playBackgroundSkit)
            {
                GameStateController.ChangeState(GameStateType.InGame);
                await backgroundSkitManager.StartBackgroundSkit(backgroundSkit);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/GetMapObjectInfoProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     map objectの破壊状況を送信するプロトコル
    /// </summary>
    public class GetMapObjectInfoProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:mapObjectInfo";
        
        private readonly IMapObjectDatastore _mapObjectDatastore;
        
        public GetMapObjectInfoProtocol(ServiceProvider serviceProvider)
        {
            _mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var sendMapObjects = new List<MapObjectsInfoMessagePack>();
            foreach (var mapObject in _mapObjectDatastore.MapObjects)
                sendMapObjects.Add(new MapObjectsInfoMessagePack(mapObject.InstanceId, mapObject.IsDestroyed));
            
            var response = new ResponseMapObjectInfosMessagePack(sendMapObjects);
            
            return response;
        }
        
        
        
        [MessagePackObject]
        public class RequestMapObjectInfosMessagePack : ProtocolMessagePackBase
        {
            public RequestMapObjectInfosMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
        
        [MessagePackObject]
        public class ResponseMapObjectInfosMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<MapObjectsInfoMessagePack> MapObjects { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseMapObjectInfosMessagePack() { }
            
            public ResponseMapObjectInfosMessagePack(List<MapObjectsInfoMessagePack> mapObjects)
            {
                Tag = ProtocolTag;
                MapObjects = mapObjects;
            }
        }
        
        [MessagePackObject]
        public class MapObjectsInfoMessagePack
        {
            [Key(0)] public int InstanceId { get; set; }
            [Key(1)] public bool IsDestroyed { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public MapObjectsInfoMessagePack() { }
            public MapObjectsInfoMessagePack(int instanceId, bool isDestroyed)
            {
                InstanceId = instanceId;
                IsDestroyed = isDestroyed;
            }
        }
    }
}
```

schema/craftRecipes.json
```cs
{
  "$id": "craftRecipes",
  "type": "object",
  "isDefaultOpen": true,

  "properties": {
    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "CraftRecipeMasterElement",

      "items": {
        "type": "object",

        "properties": {

          "craftRecipeGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "craftResultItemGuid": {
            "type": "string",
            "format": "uuid",
            "foreignKey": "items:itemGuid:name"
          },

          "craftResultCount": {
            "type": "integer",
            "default": 1
          },

          "craftTime": {
            "type": "number",
            "default": 3
          },

          "requiredItems": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "itemGuid": {
                  "type": "string",
                  "format": "uuid",
                  "foreignKey": "items:itemGuid:name"
                },
                "count": {
                  "type": "integer",
                  "default": 1
                },
                "isRemain": {
                  "type": "boolean",
                  "default": false,
                  "optional": true
                }
              }
            }
          }
        }
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/MapObjectDestructionInformationTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.GetMapObjectInfoProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class MapObjectDestructionInformationTest
    {
        [Test]
        public void GetMapObjectTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            
            
            //一個だけマップオブジェクトを破壊
            mapObjectDatastore.Get(mapObjectDatastore.MapObjects[0].InstanceId).Destroy();
            
            
            var responseArray = packet.GetPacketResponse(MapObjectDestructionInformationProtocol())[0];
            var response = MessagePackSerializer.Deserialize<ResponseMapObjectInfosMessagePack>(responseArray.ToArray());
            
            foreach (var mapObject in mapObjectDatastore.MapObjects)
            {
                var responseObject =
                    response.MapObjects.Find(m => m.InstanceId == mapObject.InstanceId);
                Assert.AreEqual(mapObject.IsDestroyed, responseObject.IsDestroyed);
            }
        }
        
        // Packet
        private List<byte> MapObjectDestructionInformationProtocol()
        {
            return MessagePackSerializer.Serialize(new RequestMapObjectInfosMessagePack()).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/InInventoryItemChallengeTask.cs
```cs
using System;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Mooresmaster.Model.ChallengesModule;
using UniRx;

namespace Game.Challenge.Task
{
    public class InInventoryItemChallengeTask : IChallengeTask
    {
        public ChallengeMasterElement ChallengeMasterElement { get; }
        public int PlayerId { get; }
        
        public IObservable<IChallengeTask> OnChallengeComplete => _onChallengeComplete;
        private readonly Subject<IChallengeTask> _onChallengeComplete = new();
        
        private bool _completed;
        
        private readonly InInventoryItemTaskParam _inInventoryItemTaskParam;
        private readonly PlayerInventoryData _playerInventory;
        
        public static IChallengeTask Create(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            return new InInventoryItemChallengeTask(playerId, challengeMasterElement);
        }
        public InInventoryItemChallengeTask(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            ChallengeMasterElement = challengeMasterElement;
            PlayerId = playerId;
            
            _inInventoryItemTaskParam = (InInventoryItemTaskParam)challengeMasterElement.TaskParam;
            _playerInventory = ServerContext.GetService<IPlayerInventoryDataStore>().GetInventoryData(playerId);
        }
        
        public void ManualUpdate()
        {
            if (_completed) return;
            
            var itemCount = 0;
            foreach (var item in _playerInventory.MainOpenableInventory.InventoryItems)
            {
                var taskItemId = MasterHolder.ItemMaster.GetItemId(_inInventoryItemTaskParam.ItemGuid);
                if (item.Id != taskItemId) continue;
                
                itemCount += item.Count;
                if (itemCount < _inInventoryItemTaskParam.ItemCount) continue;
                
                _onChallengeComplete.OnNext(this);
                _completed = true;
                break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/CompletedChallengeEventPacket.cs
```cs
using System;
using Game.Challenge;
using Game.Challenge.Task;
using MessagePack;
using Newtonsoft.Json;
using UniRx;

namespace Server.Event.EventReceive
{
    public class CompletedChallengeEventPacket
    {
        public const string EventTag = "va:event:completedChallenge";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public CompletedChallengeEventPacket(EventProtocolProvider eventProtocolProvider, ChallengeEvent challengeEvent)
        {
            _eventProtocolProvider = eventProtocolProvider;
            challengeEvent.OnCompleteChallenge.Subscribe(OnCompletedChallenge);
        }
        
        private void OnCompletedChallenge(IChallengeTask currentChallenge)
        {
            var messagePack = new CompletedChallengeEventMessage(currentChallenge.ChallengeMasterElement.ChallengeGuid);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            var playerId = currentChallenge.PlayerId;
            _eventProtocolProvider.AddEvent(playerId, EventTag, payload);
        }
    }
    
    [MessagePackObject]
    public class CompletedChallengeEventMessage
    {
        [Key(0)] public string CompletedChallengeGuidStr { get; set; }
        [IgnoreMember] public Guid CompletedChallengeGuid => Guid.Parse(CompletedChallengeGuidStr);
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public CompletedChallengeEventMessage()
        {
        }
        
        public CompletedChallengeEventMessage(Guid completedChallengeGuid)
        {
            CompletedChallengeGuidStr = completedChallengeGuid.ToString();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/ICraftingOpenableInventory.cs
```cs
using Core.Inventory;
using Core.Item.Interface;

namespace Game.PlayerInventory.Interface
{
    public interface ICraftingOpenableInventory : IOpenableInventory
    {
        public void NormalCraft();
        public void AllCraft();
        public void OneStackCraft();
        public IItemStack GetCreatableItem();
        public bool IsCreatable();
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/CreateItemChallengeTask.cs
```cs
using System;
using Core.Master;
using Game.Context;
using Game.Crafting.Interface;
using Mooresmaster.Model.ChallengesModule;
using Mooresmaster.Model.CraftRecipesModule;
using UniRx;

namespace Game.Challenge.Task
{
    public class CreateItemChallengeTask : IChallengeTask
    {
        public ChallengeMasterElement ChallengeMasterElement { get; }
        public int PlayerId { get; }
        
        public IObservable<IChallengeTask> OnChallengeComplete => _onChallengeComplete;
        private readonly Subject<IChallengeTask> _onChallengeComplete = new();
        
        private bool _completed;
        
        
        public static IChallengeTask Create(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            return new CreateItemChallengeTask(playerId, challengeMasterElement);
        }
        
        public CreateItemChallengeTask(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            ChallengeMasterElement = challengeMasterElement;
            PlayerId = playerId;
            
            var craftEvent = ServerContext.GetService<CraftEvent>();
            craftEvent.OnCraftItem.Subscribe(CreateItem);
        }
        
        private void CreateItem(CraftRecipeMasterElement craftRecipeMasterElement)
        {
            if (_completed) return;
            
            var param = ChallengeMasterElement.TaskParam as CreateItemTaskParam;
            
            if (craftRecipeMasterElement.CraftResultItemGuid == param.ItemGuid)
            {
                _completed = true;
                _onChallengeComplete.OnNext(this);
            }
        }
        
        public void ManualUpdate()
        {
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/ItemSelectModal.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Mod.Texture;
using Core.Master;
using Cysharp.Threading.Tasks;
using UniRx;
using UnityEngine;
using UnityEngine.UI;

namespace Client.DebugSystem
{
    public class ItemSelectModal : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        [SerializeField] private Transform itemSlotParent;
        [SerializeField] private Button closeButton;
        
        private List<ItemSlotObject> _itemSlotObjects;
        private ItemSlotObject _selectedItemSlotObject;
        
        public static ItemSelectModal Instance
        {
            get
            {
                if (_instance == null) { _instance = FindObjectOfType<ItemSelectModal>(true); }
                return _instance;
            }
        }
        
        private static ItemSelectModal _instance;
        
        public async UniTask<ItemViewData> SelectItem()
        {
            if (_itemSlotObjects == null)
            {
                Initialize();
            }
            
            gameObject.SetActive(true);
            
            var waitSelectItem = UniTask.WaitUntil(() => _selectedItemSlotObject != null);
            var waitClose = closeButton.OnClickAsync();
            await UniTask.WhenAny(waitSelectItem, waitClose);
            
            gameObject.SetActive(false);
            if (_selectedItemSlotObject == null)
            {
                return null;
            }
            
            var slotObject = _selectedItemSlotObject;
            _selectedItemSlotObject = null;
            
            return slotObject.ItemViewData;
        }
        
        private void Initialize()
        {
            _itemSlotObjects = new List<ItemSlotObject>();
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemView = ClientContext.ItemImageContainer.GetItemView(itemId);
                var itemSlotObject = Instantiate(itemSlotObjectPrefab, itemSlotParent);
                
                itemSlotObject.SetItem(itemView, 0);
                itemSlotObject.OnRightClickUp.Subscribe(item => _selectedItemSlotObject = item).AddTo(this);
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/DIContainer.cs
```cs
using UnityEngine;
using VContainer;
using VContainer.Unity;

namespace Client.Game.InGame.Context
{
    public class DIContainer
    {
        public IObjectResolver DIContainerResolver { get; private set; }
        
        public DIContainer(IObjectResolver objectResolver)
        {
            DIContainerResolver = objectResolver;
        }
        
        public GameObject Instantiate(GameObject prefab)
        {
            return DIContainerResolver.Instantiate(prefab);
        }
        
        public T Instantiate<T>(T prefab, Transform parent, bool worldPositionStays = false) where T : Object
        {
            return DIContainerResolver.Instantiate(prefab, parent, worldPositionStays);
        }
        
        public T Instantiate<T>(T prefab, Vector3 position, Quaternion rotation) where T : Object
        {
            return DIContainerResolver.Instantiate(prefab, position, rotation);
        }
        
        public T Instantiate<T>(T prefab, Vector3 position, Quaternion rotation, Transform parent) where T : Object
        {
            return DIContainerResolver.Instantiate(prefab, position, rotation, parent);
        }
        
        public void InjectGameObject(GameObject gameObject)
        {
            DIContainerResolver.InjectGameObject(gameObject);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IOpenableBlockInventoryComponent.cs
```cs
using Core.Inventory;

namespace Game.Block.Interface.Component
{
    public interface IOpenableBlockInventoryComponent : IBlockInventory, IOpenableInventory
    {
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/block.json
```cs
{
  "Blocks": [
    {
      "name": "TestElectricMachine",
      "type": "ElectricMachine",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test1",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inputSlot": 2,
        "outputSlot": 3,
        "requiredPower": 100,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestBlock",
      "type": "Block",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test2",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {}
    },
    {
      "name": "TestBeltConveyor",
      "type": "BeltConveyor",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test3",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "slot": 4,
        "time": 2000,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": -1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestElectricPole",
      "type": "ElectricPole",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test4",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "poleConnectionRange": 7,
        "machineConnectionRange": 5
      }
    },
    {
      "name": "TestElectricGenerator",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test5",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "isInfinityPower": false,
        "infinityPower": 0,
        "fuelSlot": 10,
        "fuel": [
          {
            "itemModId": "Test Author:forUniTest",
            "itemName": "Test1",
            "time": 1000,
            "power": 100
          },
          {
            "itemModId": "Test Author:forUniTest",
            "itemName": "Test2",
            "time": 2000,
            "power": 200
          }
        ],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestElectricMiner",
      "type": "ElectricMiner",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test6",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "requiredPower": 100,
        "outputSlot": 3,
        "mineSettings": [
          {
            "time": 1000,
            "itemModId": "Test Author:forUniTest",
            "itemName": "Test1"
          }
        ],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestChest",
      "type": "Chest",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test7",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "slot": 5,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestInfinityElectricGenerator",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test8",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "isInfinityPower": true,
        "infinityPower": 10,
        "fuelSlot": 0,
        "fuel": [],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "MultiBlock1",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test9",
      "size": {
        "x": 1,
        "y": 1,
        "z": 4
      },
      "param": {
        "isInfinityPower": true,
        "infinityPower": 10,
        "fuelSlot": 0,
        "fuel": [],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "MultiBlock2",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test10",
      "size": {
        "x": 3,
        "y": 1,
        "z": 2
      },
      "param": {
        "isInfinityPower": true,
        "infinityPower": 10,
        "fuelSlot": 0,
        "fuel": [],
        "inventoryConnectors": {
          "outputConnects": [
            {
              "offset": {
                "x": 2,
                "y": 0,
                "z": 2
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                }
              ]
            },
            {
              "offset": {
                "x": 2,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "MultiBlock3",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test11",
      "size": {
        "x": 1,
        "y": 2,
        "z": 3
      },
      "param": {
        "isInfinityPower": true,
        "infinityPower": 10,
        "fuelSlot": 0,
        "fuel": [],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "SmallTestGear",
      "type": "Gear",
      "itemModId": "Test Author:forUniTest",
      "itemName": "SmallTestGear",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "requireTorque": 0,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              },
              {
                "x": 0,
                "y": 1,
                "z": 0
              },
              {
                "x": 0,
                "y": -1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "BigTestGear",
      "type": "Gear",
      "itemModId": "Test Author:forUniTest",
      "itemName": "BigTestGear",
      "size": {
        "x": 3,
        "y": 3,
        "z": 1
      },
      "param": {
        "teethCount": 20,
        "requireTorque": 0,
        "gearConnects": [
          {
            "offset": {
              "x": 1,
              "y": 1,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          },
          {
            "offset": {
              "x": 0,
              "y": 1,
              "z": 0
            },
            "directions": [
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 2,
              "y": 1,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 1,
              "y": 2,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 1,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": -1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          }
        ]
      }
    },
    {
      "name": "TestShaft",
      "type": "Shaft",
      "itemModId": "Test Author:forUniTest",
      "itemName": "TestShaft",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "requireTorque": 0.1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "TestGearMachine",
      "type": "GearMachine",
      "itemModId": "Test Author:forUniTest",
      "itemName": "TestGearMachine",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inputSlot": 2,
        "outputSlot": 3,
        "teethCount": 10,
        "requireTorque": 0.1,
        "requiredRpm": 10,
        "requiredTorque": 1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "TestSimpleGearGenerator",
      "type": "SimpleGearGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "TestSimpleGearGenerator",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "generateRpm": 10,
        "generateTorque": 3,
        "requireTorque": 0.1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              },
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "TestFastSimpleGearGenerator",
      "type": "SimpleGearGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "TestFastSimpleGearGenerator",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "generateRpm": 20,
        "generateTorque": 1,
        "requireTorque": 0.1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              },
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "SmallRequireTorqueTestGear",
      "type": "Gear",
      "itemModId": "Test Author:forUniTest",
      "itemName": "SmallRequireTorqueTestGear",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "requireTorque": 1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              },
              {
                "x": 0,
                "y": 1,
                "z": 0
              },
              {
                "x": 0,
                "y": -1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "BigRequireTorqueTestGear",
      "type": "Gear",
      "itemModId": "Test Author:forUniTest",
      "itemName": "BigRequireTorqueTestGear",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 20,
        "requireTorque": 1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              },
              {
                "x": 0,
                "y": 1,
                "z": 0
              },
              {
                "x": 0,
                "y": -1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "InfinityTestSimpleGearGenerator",
      "type": "SimpleGearGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "InfinityTestSimpleGearGenerator",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "generateRpm": 10,
        "generateTorque": 1000000,
        "requireTorque": 0.1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              },
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "GearBeltConveyor",
      "type": "GearBeltConveyor",
      "itemModId": "Test Author:forUniTest",
      "itemName": "GearBeltConveyor",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ],
        "slot": 4,
        "beltConveyorSpeed": 0.01,
        "requiredTorque": 1
      }
    },
    {
      "name": "StraightTestItemShooter",
      "type": "ItemShooter",
      "itemModId": "Test Author:forUniTest",
      "itemName": "StraightTestItemShooter",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inventoryItemNum": 4,
        "initialShootSpeed": 1,
        "itemShootSpeed": 1,
        "acceleration": -0.2,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": -1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": 1
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "DownTestItemShooter",
      "type": "ItemShooter",
      "itemModId": "Test Author:forUniTest",
      "itemName": "DownTestItemShooter",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inventoryItemNum": 4,
        "initialShootSpeed": 1,
        "itemShootSpeed": 1,
        "acceleration": 0.7,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 1,
                  "z": -1
                }
              ]
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": 1
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "UpTestItemShooter",
      "type": "ItemShooter",
      "itemModId": "Test Author:forUniTest",
      "itemName": "UpTestItemShooter",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inventoryItemNum": 4,
        "initialShootSpeed": 1,
        "itemShootSpeed": 1,
        "acceleration": -0.9,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": -1
                }
              ]
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 1,
                  "z": 1
                }
              ]
            }
          ]
        }
      }
    }
  ]
}

```

moorestech_client/Assets/Scripts/Client.Game/InGame/Define/BlockPrefabContainer.cs
```cs
using System;
using System.Collections.Generic;
using Client.Common;
using Core.Const;
using Core.Master;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.Define
{
    [CreateAssetMenu(fileName = "BlockPrefabContainer", menuName = "moorestech/BlockPrefabContainer", order = 0)]
    public class BlockPrefabContainer : ScriptableObject
    {
        [SerializeField] private List<BlockPrefabInfo> blockPrefabs;
        
        public Dictionary<BlockId,BlockObjectInfo> GetBlockDataList()
        {
            var result = new Dictionary<BlockId,BlockObjectInfo>();
            
            foreach (var blockId in MasterHolder.BlockMaster.GetBlockIds())
            {
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                
                var blockPrefab = GetBlockPrefab(blockMasterElement.BlockGuid);
                if (blockPrefab == null) continue;
                
                result.Add(blockId, new BlockObjectInfo(blockPrefab, blockMasterElement));
            }
            
            return result;
        }
        
        private GameObject GetBlockPrefab(Guid blockGuid)
        {
            foreach (var blockPrefab in blockPrefabs)
                if (blockPrefab.GetGuid() == blockGuid)
                    return blockPrefab.BlockPrefab;
            return null;
        }
    }
    
    [Serializable]
    public class BlockPrefabInfo
    {
        public GameObject BlockPrefab => blockPrefab;
        
        [SerializeField] private string blockGuid;
        [SerializeField] private GameObject blockPrefab;
        
        public Guid GetGuid()
        {
            if (Guid.TryParse(blockGuid, out var guid))
            {
                return guid;
            }
            
            Debug.LogError($"InvalidGuid {blockGuid} {blockPrefab.name}");
            return Guid.Empty;
        }
    }
    
    
    
    public class BlockObjectInfo
    {
        public readonly BlockMasterElement BlockMasterElement;
        public readonly GameObject BlockObject;
        
        public BlockObjectInfo(GameObject blockObject, BlockMasterElement blockMasterElement)
        {
            BlockObject = blockObject;
            BlockMasterElement = blockMasterElement;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/VanillaApiSendOnly.cs
```cs
using System;
using System.Collections.Generic;
using Client.Network.Settings;
using Core.Master;
using Game.CraftChainer.CraftChain;
using Server.Protocol.PacketResponse;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using UnityEngine;

namespace Client.Network.API
{
    public class VanillaApiSendOnly
    {
        private readonly PacketSender _packetSender;
        private readonly PlayerConnectionSetting _playerConnectionSetting;
        private readonly int _playerId;
        
        public VanillaApiSendOnly(PacketSender packetSender, PlayerConnectionSetting playerConnectionSetting)
        {
            _packetSender = packetSender;
            _playerConnectionSetting = playerConnectionSetting;
            _playerId = playerConnectionSetting.PlayerId;
        }
        
        public void SetOpenCloseBlock(Vector3Int pos, bool isOpen)
        {
            var request = new BlockInventoryOpenCloseProtocol.BlockInventoryOpenCloseProtocolMessagePack(_playerId, pos, isOpen);
            _packetSender.Send(request);
        }
        
        public void ItemMove(int count, ItemMoveType itemMoveType, ItemMoveInventoryInfo fromInv, int fromSlot, ItemMoveInventoryInfo toInv, int toSlot)
        {
            var request = new InventoryItemMoveProtocol.InventoryItemMoveProtocolMessagePack(_playerId, count, itemMoveType, fromInv, fromSlot, toInv, toSlot);
            _packetSender.Send(request);
        }
        
        public void PlaceHotBarBlock(List<PlaceInfo> placePositions, int hotBarSlot)
        {
            var request = new SendPlaceHotBarBlockProtocol.SendPlaceHotBarBlockProtocolMessagePack(_playerId, hotBarSlot, placePositions);
            _packetSender.Send(request);
        }
        
        public void BlockRemove(Vector3Int pos)
        {
            var request = new RemoveBlockProtocol.RemoveBlockProtocolMessagePack(_playerId, pos);
            _packetSender.Send(request);
        }
        
        public void SendPlayerPosition(Vector3 pos)
        {
            var request = new SetPlayerCoordinateProtocol.PlayerCoordinateSendProtocolMessagePack(_playerId, pos);
            _packetSender.Send(request);
        }
        
        public void Craft(Guid craftRecipeId)
        {
            var request = new OneClickCraft.RequestOneClickCraftProtocolMessagePack(_playerId, craftRecipeId);
            _packetSender.Send(request);
        }
        
        public void Save()
        {
            var request = new SaveProtocol.SaveProtocolMessagePack();
            _packetSender.Send(request);
        }
        
        public void AttackMapObject(int mapObjectInstanceId, int attackDamage)
        {
            var request = new MapObjectAcquisitionProtocol.GetMapObjectProtocolProtocolMessagePack(_playerId, mapObjectInstanceId, attackDamage);
            _packetSender.Send(request);
        }
        
        public void SetCraftChainerCrafterRecipe(Vector3Int block ,List<CraftingSolverItem> inputs, List<CraftingSolverItem> outputs)
        {
            var request = new SetCraftChainerCrafterRecipeProtocol.SetCraftChainerCrafterRecipeProtocolMessagePack(block, inputs, outputs);
            _packetSender.Send(request);
        }
        
        public void SetCraftChainerMainComputerRequestItem(Vector3Int block, ItemId itemId, int count)
        {
            var request = new SetCraftChainerMainComputerRequestItemProtocol.SetCraftChainerMainComputerRequestItemProtocolMessagePack(block, itemId, count);
            _packetSender.Send(request);
        }
        
        public void SendCommand(string command)
        {
            var request = new SendCommandProtocol.SendCommandProtocolMessagePack(command);
            _packetSender.Send(request);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/EventProtocol.cs
```cs
using System;
using System.Collections.Generic;
using MessagePack;
using Server.Event;

namespace Server.Protocol.PacketResponse
{
    public class EventProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:event";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public EventProtocol(EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<EventProtocolMessagePack>(payload.ToArray());
            
            //イベントプロトコルプロバイダからデータを取得して返す
            var events = _eventProtocolProvider.GetEventBytesList(data.PlayerId);
            
            return new ResponseEventProtocolMessagePack(events);
        }
        
        
        
        [MessagePackObject]
        public class EventProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public EventProtocolMessagePack() { }
            
            public EventProtocolMessagePack(int playerId)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
            }
        }
        
        [MessagePackObject]
        public class ResponseEventProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<EventMessagePack> Events { get; set; }
            
            public ResponseEventProtocolMessagePack(List<EventMessagePack> events)
            {
                Tag = ProtocolTag;
                Events = events;
            }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseEventProtocolMessagePack() { }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/machineRecipe.json
```cs
[
  {
    "blockModId": "Test Author:forUniTest",
    "blockName": "TestElectricMachine",
    "time": 1.5,
    "input": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 3
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 1
      }
    ],
    "output": [
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      }
    ]
  },
  {
    "blockModId": "Test Author:forUniTest",
    "blockName": "TestBlock",
    "time": 1.5,
    "input": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 3
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 1
      }
    ],
    "output": [
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      }
    ]
  },
  {
    "blockModId": "Test Author:forUniTest",
    "blockName": "TestBeltConveyor",
    "time": 1.5,
    "input": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 2
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 3
      },
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 4
      }
    ],
    "output": [
      {
        "itemName": "Test5",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      }
    ]
  },
  {
    "blockModId": "Test Author:forUniTest",
    "blockName": "TestGearMachine",
    "time": 1.5,
    "input": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 3
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 1
      }
    ],
    "output": [
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      }
    ]
  }
]

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/GetChallengeInfoProtocolTest.cs
```cs
using System;
using System.Linq;
using Game.Challenge;
using Game.Challenge.Task;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UniRx;
using static Server.Protocol.PacketResponse.GetChallengeInfoProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class GetChallengeInfoProtocolTest
    {
        private const int PlayerId = 1;
        private const string Challenge1Guid = "00000000-0000-0000-4567-000000000001";
        private const string Challenge2Guid = "00000000-0000-0000-4567-000000000002";
        private const string Challenge3Guid = "00000000-0000-0000-4567-000000000003";
        private const string Challenge4Guid = "00000000-0000-0000-4567-000000000004";
        
        [Test]
        public void GetCompletedChallengeTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            // チャレンジを無理やりクリアする
            // Forced to complete a challenge
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            var playerChallengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            foreach (var challenge in playerChallengeInfo.CurrentChallenges.ToList())
            {
                var subject = (Subject<IChallengeTask>)challenge.OnChallengeComplete;
                subject.OnNext(challenge); // 無理やりクリア
            }
            
            // 現在のチャレンジ情報をリクエスト
            // Request current challenge information
            var messagePack = new RequestChallengeMessagePack(PlayerId);
            var response = packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList())[0];
            var challengeInfo = MessagePackSerializer.Deserialize<ResponseChallengeInfoMessagePack>(response.ToArray());
            
            // 検証
            // Verification
            Assert.AreEqual(PlayerId, challengeInfo.PlayerId);
            
            Assert.AreEqual(3, challengeInfo.CompletedChallengeGuids.Count);
            Assert.IsTrue(challengeInfo.CompletedChallengeGuids.Contains(Guid.Parse(Challenge1Guid)));
            Assert.IsTrue(challengeInfo.CompletedChallengeGuids.Contains(Guid.Parse(Challenge2Guid)));
            Assert.IsTrue(challengeInfo.CompletedChallengeGuids.Contains(Guid.Parse(Challenge3Guid)));
            
            Assert.AreEqual(1, challengeInfo.CurrentChallengeGuids.Count);
            Assert.IsTrue(challengeInfo.CurrentChallengeGuids.Contains(Guid.Parse(Challenge4Guid)));
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChestSaveLoadTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChestSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var blockGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.ChestId).BlockGuid;
            
            var chestPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var chestBlock = blockFactory.Create(ForUnitTestModBlockId.ChestId, new BlockInstanceId(1), chestPosInfo);
            var chest = chestBlock.GetComponent<VanillaChestComponent>();
            
            
            chest.SetItem(0, new ItemId(1), 7);
            chest.SetItem(2, new ItemId(2), 45);
            chest.SetItem(4, new ItemId(3), 3);
            
            var save = chest.GetSaveState();
            var states = new Dictionary<string, string>() { { chest.SaveKey, save } };
            Debug.Log(save);
            
            var chestBlock2 = blockFactory.Load(blockGuid, new BlockInstanceId(1), states, chestPosInfo);
            var chest2 = chestBlock2.GetComponent<VanillaChestComponent>();
            
            Assert.AreEqual(chest.GetItem(0), chest2.GetItem(0));
            Assert.AreEqual(chest.GetItem(2), chest2.GetItem(2));
            Assert.AreEqual(chest.GetItem(4), chest2.GetItem(4));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Connector/IBlockInventoryInserter.cs
```cs
using Core.Item.Interface;

namespace Game.Block.Blocks.Connector
{
    public interface IBlockInventoryInserter
    {
        public IItemStack InsertItem(IItemStack itemStack);
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/EntityInstance/ItemEntity.cs
```cs
using Core.Item.Interface;
using Core.Master;
using UnityEngine;

namespace Game.Entity.Interface.EntityInstance
{
    public class ItemEntity : IEntity
    {
        public ItemEntity(EntityInstanceId instanceId, Vector3 position)
        {
            InstanceId = instanceId;
            Position = position;
        }
        
        public EntityInstanceId InstanceId { get; }
        public string EntityType => VanillaEntityType.VanillaItem;
        public Vector3 Position { get; private set; }
        public string State { get; private set; }
        
        
        public void SetPosition(Vector3 position)
        {
            Position = position;
        }
        
        public void SetState(IItemStack itemStack)
        {
            State = itemStack.Id + "," + itemStack.Count;
        }
        
        public void SetState(ItemId id, int count)
        {
            State = id + "," + count;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaMachineBlockStateConst.cs
```cs
namespace Game.Block.Blocks.Machine
{
    public abstract class VanillaMachineBlockStateConst
    {
        public const string IdleState = "idle";
        public const string ProcessingState = "processing";
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/BlockDebug/BlockDebugSystem.cs
```cs
using Client.Game.GameDebug;
using Client.Game.InGame.Block;
using UniRx;
using UnityEngine;

namespace Client.DebugSystem.BlockDebug
{
    public class BlockDebugSystem
    {
        public void Initialize()
        {
            DebugInfoStore.OnClickBlock.Subscribe(OnClickBlock);
        }
        
        public void OnClickBlock(BlockGameObject block)
        {
            Debug.Log($"Block clicked: {block}");
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Mod/ModGetConfigStringTest.cs
```cs
using System.IO;
using Core.Master;
using Mod.Config;
using Mod.Loader;
using NUnit.Framework;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Mod
{
    /// <summary>
    ///     ConfigOnlyのtestConfigOnlyMod1と2をロードできるかテストするクラス
    ///     zip、ディレクトリそれぞれロードできるかチェックする
    /// </summary>
    public class ModGetConfigStringTest
    {
        [Test]
        public void LoadConfigTest()
        {
            var modResource = new ModsResource(Path.Combine(TestModDirectory.ConfigOnlyDirectory, "mods"));
            var loaded = ModJsonStringLoader.GetConfigString(modResource);
            
            Assert.AreEqual(loaded.Count, 2);
            
            var test1modId = new ModId("Test Author 1:testMod1");
            //var test1Config = loaded.Find(x => x.ModId == test1modId);
            var test1Config = loaded["Test Author 1:testMod1"];
            Assert.AreEqual("testItemJson1", test1Config.JsonContents[new JsonFileName("item")]);
            Assert.AreEqual("testBlockJson1", test1Config.JsonContents[new JsonFileName("block")]);
            
            var test2modId = new ModId("Test Author 2:testMod2");
            //var test2Config = loaded.Find(x => x.ModId == test2modId);
            var test2Config = loaded["Test Author 2:testMod2"];
            Assert.AreEqual("testMachineRecipeJson1", test2Config.JsonContents[new JsonFileName("machineRecipe")]);
            Assert.AreEqual("testCraftRecipeJson1", test2Config.JsonContents[new JsonFileName("craftRecipe")]);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Util/AnchorPreset.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Util
{
    /// <summary>
    ///     RectTransformのAnchorのプリセットをスクリプトから「インスペクタ上のenumと同じように」
    ///     指定する為の拡張クラス
    ///     プロジェクト内の適当な場所に保存しておくと、以下のようにRectTransformに対してSetAnchor()メソッドが使えるようになる
    /// </summary>
    /* usage
  var rect = GetComponent<RectTransform>();
  rect.SetAnchor(AnchorPresets.MiddleCenter);
  rect.localPosition = Vector3.zero;
  */
    public enum AnchorPresets
    {
        TopLeft,
        TopCenter,
        TopRight,
        
        MiddleLeft,
        MiddleCenter,
        MiddleRight,
        
        BottomLeft,
        BottonCenter,
        BottomRight,
        BottomStretch,
        
        VertStretchLeft,
        VertStretchRight,
        VertStretchCenter,
        
        HorStretchTop,
        HorStretchMiddle,
        HorStretchBottom,
        
        StretchAll,
    }
    
    public enum PivotPresets
    {
        TopLeft,
        TopCenter,
        TopRight,
        
        MiddleLeft,
        MiddleCenter,
        MiddleRight,
        
        BottomLeft,
        BottomCenter,
        BottomRight,
    }
    
    public static class RectTransformExtensions
    {
        public static void SetAnchor(this RectTransform source, AnchorPresets allign, int offsetX = 0, int offsetY = 0)
        {
            source.anchoredPosition = new Vector3(offsetX, offsetY, 0);
            
            switch (allign)
            {
                case AnchorPresets.TopLeft:
                    {
                        source.anchorMin = new Vector2(0, 1);
                        source.anchorMax = new Vector2(0, 1);
                        break;
                    }
                case AnchorPresets.TopCenter:
                    {
                        source.anchorMin = new Vector2(0.5f, 1);
                        source.anchorMax = new Vector2(0.5f, 1);
                        break;
                    }
                case AnchorPresets.TopRight:
                    {
                        source.anchorMin = new Vector2(1, 1);
                        source.anchorMax = new Vector2(1, 1);
                        break;
                    }
                
                case AnchorPresets.MiddleLeft:
                    {
                        source.anchorMin = new Vector2(0, 0.5f);
                        source.anchorMax = new Vector2(0, 0.5f);
                        break;
                    }
                case AnchorPresets.MiddleCenter:
                    {
                        source.anchorMin = new Vector2(0.5f, 0.5f);
                        source.anchorMax = new Vector2(0.5f, 0.5f);
                        break;
                    }
                case AnchorPresets.MiddleRight:
                    {
                        source.anchorMin = new Vector2(1, 0.5f);
                        source.anchorMax = new Vector2(1, 0.5f);
                        break;
                    }
                
                case AnchorPresets.BottomLeft:
                    {
                        source.anchorMin = new Vector2(0, 0);
                        source.anchorMax = new Vector2(0, 0);
                        break;
                    }
                case AnchorPresets.BottonCenter:
                    {
                        source.anchorMin = new Vector2(0.5f, 0);
                        source.anchorMax = new Vector2(0.5f, 0);
                        break;
                    }
                case AnchorPresets.BottomRight:
                    {
                        source.anchorMin = new Vector2(1, 0);
                        source.anchorMax = new Vector2(1, 0);
                        break;
                    }
                
                case AnchorPresets.HorStretchTop:
                    {
                        source.anchorMin = new Vector2(0, 1);
                        source.anchorMax = new Vector2(1, 1);
                        break;
                    }
                case AnchorPresets.HorStretchMiddle:
                    {
                        source.anchorMin = new Vector2(0, 0.5f);
                        source.anchorMax = new Vector2(1, 0.5f);
                        break;
                    }
                case AnchorPresets.HorStretchBottom:
                    {
                        source.anchorMin = new Vector2(0, 0);
                        source.anchorMax = new Vector2(1, 0);
                        break;
                    }
                
                case AnchorPresets.VertStretchLeft:
                    {
                        source.anchorMin = new Vector2(0, 0);
                        source.anchorMax = new Vector2(0, 1);
                        break;
                    }
                case AnchorPresets.VertStretchCenter:
                    {
                        source.anchorMin = new Vector2(0.5f, 0);
                        source.anchorMax = new Vector2(0.5f, 1);
                        break;
                    }
                case AnchorPresets.VertStretchRight:
                    {
                        source.anchorMin = new Vector2(1, 0);
                        source.anchorMax = new Vector2(1, 1);
                        break;
                    }
                
                case AnchorPresets.StretchAll:
                    {
                        source.anchorMin = new Vector2(0, 0);
                        source.anchorMax = new Vector2(1, 1);
                        break;
                    }
            }
        }
        
        public static void SetPivot(this RectTransform source, PivotPresets preset)
        {
            switch (preset)
            {
                case PivotPresets.TopLeft:
                    {
                        source.pivot = new Vector2(0, 1);
                        break;
                    }
                case PivotPresets.TopCenter:
                    {
                        source.pivot = new Vector2(0.5f, 1);
                        break;
                    }
                case PivotPresets.TopRight:
                    {
                        source.pivot = new Vector2(1, 1);
                        break;
                    }
                
                case PivotPresets.MiddleLeft:
                    {
                        source.pivot = new Vector2(0, 0.5f);
                        break;
                    }
                case PivotPresets.MiddleCenter:
                    {
                        source.pivot = new Vector2(0.5f, 0.5f);
                        break;
                    }
                case PivotPresets.MiddleRight:
                    {
                        source.pivot = new Vector2(1, 0.5f);
                        break;
                    }
                
                case PivotPresets.BottomLeft:
                    {
                        source.pivot = new Vector2(0, 0);
                        break;
                    }
                case PivotPresets.BottomCenter:
                    {
                        source.pivot = new Vector2(0.5f, 0);
                        break;
                    }
                case PivotPresets.BottomRight:
                    {
                        source.pivot = new Vector2(1, 0);
                        break;
                    }
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/SkitObjectTransfomCopyerInspector.cs
```cs
using Client.Skit.Skit;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(SkitObjectTransfomCopyer))]
public class SkitObjectTransfomCopyerInspector : Editor
{
    public override void OnInspectorGUI()
    {
        var obj = target as SkitObjectTransfomCopyer;
        if (GUILayout.Button("座標と角度をコピー"))
        {
            //クリップボードに座標と角度のTSVをコピー
            var pos = obj.transform.position;
            var rot = obj.transform.eulerAngles;
            var str = $"pos\t{pos.x}\t{pos.y}\t{pos.z}\trot\t{rot.x}\t{rot.y}\t{rot.z}";
            EditorGUIUtility.systemCopyBuffer = str;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/BlockConnectorConnectPositionCalculatorTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Component;
using Game.Block.Interface;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    public class BlockConnectorConnectPositionCalculatorTest
    {
        
        [Test]
        public void Calculate_2x2_North_Test()
        {
            var direction = BlockDirection.North;
            
            var blockPositionInfo = new BlockPositionInfo(Vector3Int.zero, direction, new Vector3Int(2, 2, 2));
            
            var connectInfoItems = new List<BlockConnectInfoElement>
            {
                new("", new Vector3Int(1, 0, 0), new []{new Vector3Int(1,0,0)},null),
            };
            var connectionInfo = new BlockConnectInfo(connectInfoItems.ToArray());
            
            
            var result = BlockConnectorConnectPositionCalculator.CalculateConnectPosToConnector(connectionInfo, blockPositionInfo);
            
            Assert.AreEqual(1, result.Count);
            AssertConnectors(result, 0, new Vector3Int(1, 0, 0), new Vector3Int(2, 0, 0));
        }
        
        /// <summary>
        /// 2x2のブロックを、北向きに設置した際に南東のコネクターが東向きにあるとき、そのブロックを東向きに設置して正しく位置が計算されていることを確認するテスト
        /// A test to confirm that a 2x2 block is placed facing north and the southeast connector faces east by placing the block facing east and correctly calculating the position.
        /// </summary>
        [Test]
        public void Calculate_2x2_East_Test()
        {
            var direction = BlockDirection.East;
            
            var blockPositionInfo = new BlockPositionInfo(Vector3Int.zero, direction, new Vector3Int(2, 2, 2));
            
            var connectInfoItems = new List<BlockConnectInfoElement>
            {
                new("", new Vector3Int(1, 0, 0), new []{new Vector3Int(1,0,0)},null),
            };
            var connectionInfo = new BlockConnectInfo(connectInfoItems.ToArray());
            
            
            var result = BlockConnectorConnectPositionCalculator.CalculateConnectPosToConnector(connectionInfo, blockPositionInfo);
            
            AssertConnectors(result, 0, Vector3Int.zero, new Vector3Int(0, 0, -1));
        }
        
        void AssertConnectors(Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)> result, int index, Vector3Int connectorPosition, Vector3Int targetPosition)
        {
            Assert.AreEqual(connectorPosition, result.Values.ToList()[index].position);
            Assert.AreEqual(targetPosition, result.Keys.ToList()[index]);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/IBlockPlacePreview.cs
```cs
using System.Collections.Generic;
using Mooresmaster.Model.BlocksModule;
using Server.Protocol.PacketResponse;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public interface IBlockPlacePreview
    {
        bool IsActive { get; }
        
        public List<bool> SetPreviewAndGroundDetect(List<PlaceInfo> currentPlaceInfos, BlockMasterElement holdingBlockMaster);
        
        public void SetActive(bool active);
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/IItemStackJsonObject.cs
```cs
using System;
using Core.Const;
using Core.Master;
using Newtonsoft.Json;

namespace Core.Item.Interface
{
    public class ItemStackSaveJsonObject
    {
        [JsonProperty("itemGuid")]
        public string ItemGuidStr;
        [JsonProperty("count")]
        public int Count;
        
        [JsonIgnore] public Guid ItemGuid => Guid.Parse(ItemGuidStr);
        
            
        public ItemStackSaveJsonObject() { }
        
        public ItemStackSaveJsonObject(IItemStack itemStack)
        {
            ItemGuidStr = 
                itemStack.Id == ItemMaster.EmptyItemId ?
                    Guid.Empty.ToString() : 
                    MasterHolder.ItemMaster.GetItemMaster(itemStack.Id).ItemGuid.ToString();
            Count = itemStack.Count;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Gear/GearComponent.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Blocks.Gear
{
    public class GearComponent : GearEnergyTransformer, IGear
    {
        public int TeethCount { get; }
        
        public GearComponent(int teethCount, Torque requiredPower, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent)
            : base(requiredPower, blockInstanceId, connectorComponent)
        {
            TeethCount = teethCount;
        }
        
        public GearComponent(GearMachineBlockParam gearMachineBlockParam, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent)
            : base(new Torque(gearMachineBlockParam.RequireTorque), blockInstanceId, connectorComponent)
        {
            TeethCount = gearMachineBlockParam.TeethCount;
        }
        
        public GearComponent(GearBlockParam gearBlockParam, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent)
            : base(new Torque(gearBlockParam.RequireTorque), blockInstanceId, connectorComponent)
        {
            TeethCount = gearBlockParam.TeethCount;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerManager.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using Game.World.Interface.DataStore;
using UniRx;

namespace Game.CraftChainer.CraftNetwork
{
    public class CraftChainerMainComputerManager
    {
        public static CraftChainerMainComputerManager Instance;
        
        private readonly List<CraftChainerMainComputerComponent> _mainComputers = new();
        
        public CraftChainerMainComputerManager()
        {
            Instance = this;
            
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlaceEvent);
            ServerContext.WorldBlockUpdateEvent.OnBlockRemoveEvent.Subscribe(OnBlockRemoveEvent);
        }
        
        private void OnBlockPlaceEvent(BlockUpdateProperties updateProperties)
        {
            var block = updateProperties.BlockData.Block;
            if (block.TryGetComponent<CraftChainerMainComputerComponent>(out var mainComputer))
            {
                _mainComputers.Add(mainComputer);
            }
            if (block.ExistsComponent<ICraftChainerNode>())
            {
                foreach (var computer in _mainComputers)
                {
                    computer.CraftChainerNetworkContext.ReSearchNetwork();
                }
            }
        }
        
        private void OnBlockRemoveEvent(BlockUpdateProperties updateProperties)
        {
            var block = updateProperties.BlockData.Block;
            if (block.TryGetComponent<CraftChainerMainComputerComponent>(out var mainComputer))
            {
                _mainComputers.Remove(mainComputer);
            }
            if (block.ExistsComponent<ICraftChainerNode>())
            {
                foreach (var computer in _mainComputers)
                {
                    computer.CraftChainerNetworkContext.ReSearchNetwork();
                }
            }
        }
        
        
        public CraftChainerNetworkContext GetChainerNetworkContext(CraftChainerNodeId nodeId)
        {
            foreach (var mainComputer in _mainComputers)
            {
                if (mainComputer.CraftChainerNetworkContext.IsExistNode(nodeId))
                {
                    return mainComputer.CraftChainerNetworkContext;
                }
            }
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockFactory.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;

namespace Game.Block.Factory
{
    public class BlockFactory : IBlockFactory
    {
        private readonly VanillaIBlockTemplates _vanillaIBlockTemplates;
        
        public BlockFactory(VanillaIBlockTemplates vanillaIBlockTemplates)
        {
            _vanillaIBlockTemplates = vanillaIBlockTemplates;
        }
        
        public IBlock Create(BlockId blockId, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var dictionary = _vanillaIBlockTemplates.BlockTypesDictionary;
            
            var blockElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            if (dictionary.TryGetValue(blockElement.BlockType, out var value))
                return value.New(blockElement, blockInstanceId, blockPositionInfo);
            
            throw new Exception("Block type not found :" + blockElement.BlockType);
        }
        
        public IBlock Load(Guid blockGuid, BlockInstanceId blockInstanceId, Dictionary<string, string> state, BlockPositionInfo blockPositionInfo)
        {
            var dictionary = _vanillaIBlockTemplates.BlockTypesDictionary;
            
            var blockElement = MasterHolder.BlockMaster.GetBlockMaster(blockGuid);
            if (dictionary.TryGetValue(blockElement.BlockType, out var value))
                return value.Load(state, blockElement, blockInstanceId, blockPositionInfo);
            
            throw new Exception("Block type not found :" + blockElement.BlockType);
        }
        
        public void RegisterTemplateIBlock(string key, IBlockTemplate block)
        {
            _vanillaIBlockTemplates.BlockTypesDictionary.Add(key, block);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/GroundGameObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.BlockSystem
{
    public class GroundGameObject : MonoBehaviour
    {
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/ElectricPole/VanillaElectricPoleComponent.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;

namespace Game.Block.Blocks.ElectricPole
{
    public class VanillaElectricPoleComponent : IElectricTransformer, IBlockComponent
    {
        public VanillaElectricPoleComponent(BlockInstanceId blockInstanceId)
        {
            BlockInstanceId = blockInstanceId;
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Control/InGameCameraController.cs
```cs
using System.Threading;
using Cinemachine;
using Client.Input;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;

namespace Client.Game.InGame.Control
{
    public class InGameCameraController : MonoBehaviour
    {
        public Vector3 Position => transform.position;
        public Vector3 CameraEulerAngle => transform.rotation.eulerAngles;
        public float CameraDistance => _cinemachineFraming.m_CameraDistance;
        
        [SerializeField] private Camera mainCamera;
        
        [SerializeField] private CinemachineVirtualCamera virtualCamera;
        [SerializeField] private Vector2 sensitivity = Vector2.one;
        [SerializeField] private float lerpSpeed = 5.0f; // Adjust this to change the lerp speed
        
        private CinemachineFramingTransposer _cinemachineFraming;
        private Quaternion _targetRotation; // The rotation to smoothly rotate towards
        
        private DG.Tweening.Sequence _currentSequence;
        
        private bool _isControllable;
        
        private void Awake()
        {
            _cinemachineFraming = virtualCamera.GetCinemachineComponent<CinemachineFramingTransposer>();
            _targetRotation = transform.rotation; // Initialize target rotation to current rotation
        }
        
        private void Update()
        {
            var distance = _cinemachineFraming.m_CameraDistance + InputManager.UI.SwitchHotBar.ReadValue<float>() / -200f;
            _cinemachineFraming.m_CameraDistance = Mathf.Clamp(distance, 0.6f, 10);
            
            if (!_isControllable && _currentSequence == null) return;
            
            //マウスのインプットによって向きを変える
            if (_isControllable)
            {
                GetMouseInput();
            }
            LeapCameraRotation();
            
            #region Internal
            
            void GetMouseInput()
            {
                var delta = InputManager.Player.Look.ReadValue<Vector2>();
                
                var rotation = _targetRotation.eulerAngles;
                rotation.x -= delta.y * sensitivity.y;
                if (90 < rotation.x && rotation.x < 180)
                    rotation.x = 90;
                else if (180 < rotation.x && rotation.x < 270) rotation.x = 270;
                
                rotation.y += delta.x * sensitivity.x;
                rotation.z = 0;
                _targetRotation = Quaternion.Euler(rotation);
            }
            
            void LeapCameraRotation()
            {
                var resultRotation = Quaternion.Lerp(transform.rotation, _targetRotation, lerpSpeed * Time.deltaTime);
                resultRotation = Quaternion.Euler(resultRotation.eulerAngles.x, resultRotation.eulerAngles.y, 0);
                transform.rotation = resultRotation;
            }
            
            #endregion
        }
        
        public void SetActive(bool enable)
        {
            enabled = enable;
            mainCamera.gameObject.SetActive(enable);
        }
        
        public void SetControllable(bool enable)
        {
            _isControllable = enable;
        }
        
        public void StartTweenCamera(Vector3 targetRotation, float targetDistance, float duration)
        {
            // DoTweenでカメラの向きを変える
            _currentSequence?.Kill();
            _currentSequence = DOTween.Sequence()
                .Append(DOTween.To(() => _targetRotation, x => _targetRotation = x, targetRotation, duration).SetEase(Ease.InOutQuad))
                .Join(DOTween.To(() => _cinemachineFraming.m_CameraDistance, x => _cinemachineFraming.m_CameraDistance = x, targetDistance, duration).SetEase(Ease.InOutQuad));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Miner/VanillaGearMinerComponent.cs
```cs
using Game.Block.Blocks.Gear;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.MineSettingsModule;
using UniRx;

namespace Game.Block.Blocks.Miner
{
    public class VanillaGearMinerComponent : IBlockComponent
    {
        private readonly GearEnergyTransformer _gearEnergyTransformer;
        private readonly VanillaMinerProcessorComponent _vanillaMinerProcessorComponent;
        private readonly GearMinerBlockParam _gearMinerBlockParam;
        
        public VanillaGearMinerComponent(VanillaMinerProcessorComponent vanillaMinerProcessorComponent, GearEnergyTransformer gearEnergyTransformer, GearMinerBlockParam gearMinerBlockParam)
        {
            _gearMinerBlockParam = gearMinerBlockParam;
            _vanillaMinerProcessorComponent = vanillaMinerProcessorComponent;
            _gearEnergyTransformer = gearEnergyTransformer;
            _gearEnergyTransformer.OnGearUpdate.Subscribe(OnGearUpdate);
        }
        
        private void OnGearUpdate(GearUpdateType gearUpdateType)
        {
            var requiredRpm = new RPM(_gearMinerBlockParam.RequiredRpm);
            var requireTorque = new Torque(_gearMinerBlockParam.RequireTorque);
            
            var currentElectricPower = _gearEnergyTransformer.CalcMachineSupplyPower(requiredRpm, requireTorque);
            _vanillaMinerProcessorComponent.SupplyPower(currentElectricPower);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/InitialHandshakeProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Entity.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;

namespace Server.Protocol.PacketResponse
{
    public class InitialHandshakeProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:initialHandshake";
        
        private readonly IEntitiesDatastore _entitiesDatastore;
        private readonly IEntityFactory _entityFactory;
        private readonly IWorldSettingsDatastore _worldSettingsDatastore;
        
        public InitialHandshakeProtocol(ServiceProvider serviceProvider)
        {
            _entitiesDatastore = serviceProvider.GetService<IEntitiesDatastore>();
            _entityFactory = serviceProvider.GetService<IEntityFactory>();
            _worldSettingsDatastore = serviceProvider.GetService<IWorldSettingsDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestInitialHandshakeMessagePack>(payload.ToArray());
            
            
            var response = new ResponseInitialHandshakeMessagePack(GetPlayerPosition(new EntityInstanceId(data.PlayerId)));
            
            return response;
        }
        
        
        private Vector3MessagePack GetPlayerPosition(EntityInstanceId playerId)
        {
            if (_entitiesDatastore.Exists(playerId))
            {
                //プレイヤーがいるのでセーブされた座標を返す
                var pos = _entitiesDatastore.GetPosition(playerId);
                return new Vector3MessagePack(pos.x, pos.y, pos.z);
            }
            
            var playerEntity = _entityFactory.CreateEntity(VanillaEntityType.VanillaPlayer, playerId);
            _entitiesDatastore.Add(playerEntity);
            
            
            //プレイヤーのデータがなかったのでスポーン地点を取得する
            return new Vector3MessagePack(_worldSettingsDatastore.WorldSpawnPoint);
        }
        
        [MessagePackObject]
        public class RequestInitialHandshakeMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public string PlayerName { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RequestInitialHandshakeMessagePack() { }
            
            public RequestInitialHandshakeMessagePack(int playerId, string playerName)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                PlayerName = playerName;
            }
        }
        
        [MessagePackObject]
        public class ResponseInitialHandshakeMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3MessagePack PlayerPos { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseInitialHandshakeMessagePack() { }
            
            public ResponseInitialHandshakeMessagePack(Vector3MessagePack playerPos)
            {
                Tag = ProtocolTag;
                PlayerPos = playerPos;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/GeneratorBlockInventoryView.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class GeneratorBlockInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform powerGeneratorFuelItemParent;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            
            
            var itemList = new List<IItemStack>();
            var param = blockGameObject.BlockMasterElement.BlockParam;
            var generatorParam = (ElectricGeneratorBlockParam)param;
            for (var i = 0; i < generatorParam.FuelItemSlotCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, powerGeneratorFuelItemParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            UpdateItemList(itemList);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/WorldObjectOffsetConverter.cs
```cs
using Game.Block.Interface;
using UnityEngine;

namespace Client.Common
{
    /// <summary>
    ///     0を基準としたサーバーの座標値を、0.5をプラスして、オブジェクトなどの座標の左端を0,0に合わせるように変換する
    /// </summary>
    public static class WorldObjectOffsetConverter
    {
        public static Vector3 AddBlockPlaceOffset(this Vector3 vector3)
        {
            return vector3 + new Vector3(0.5f, 0, 0.5f);
        }
        
        public static Vector2 AddBlockPlaceOffset(this Vector2 vector2)
        {
            return vector2 + new Vector2(0.5f, 0.5f);
        }
        
        public static Vector3 AddBlockPlaceOffset(this Vector3Int pos)
        {
            return pos + new Vector3(0.5f, 0.5f, 0.5f);
        }
        
        public static (Vector3 minPos, Vector3 maxPos) GetWorldBlockBoundingBox(this Vector3Int blockPos, BlockDirection blockDirection, Vector3Int blockSize)
        {
            var maxPos = BlockPositionInfo.CalcBlockMaxPos(blockPos, blockDirection, blockSize);
            //これはグリッド上のどこが最大値なのかを表しているので、実際のバウンディングボックスにするために +1 する
            maxPos += Vector3Int.one;
            
            return (blockPos, maxPos);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/ElectricSegmentTest.cs
```cs
using Core.Update;
using Game.Block.Interface;
using Game.EnergySystem;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Block
{
    public class ElectricSegmentTest
    {
        [Test]
        public void ElectricEnergyTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var segment = new EnergySegment();
            
            var electric = new BlockElectricConsumer(new ElectricPower(100), new BlockInstanceId(0));
            var generate = new TestElectricGenerator(new ElectricPower(100), new BlockInstanceId(0));
            
            segment.AddGenerator(generate);
            segment.AddEnergyConsumer(electric);
            GameUpdater.UpdateWithWait();
            Assert.AreEqual(100, electric.CurrentPower.AsPrimitive());
            
            segment.RemoveGenerator(generate);
            GameUpdater.UpdateWithWait();
            Assert.AreEqual(0, electric.CurrentPower.AsPrimitive());
            
            var electric2 = new BlockElectricConsumer(new ElectricPower(300), new BlockInstanceId(1));
            segment.AddGenerator(generate);
            segment.AddEnergyConsumer(electric2);
            GameUpdater.UpdateWithWait();
            Assert.AreEqual(25, electric.CurrentPower.AsPrimitive());
            Assert.AreEqual(75, electric2.CurrentPower.AsPrimitive());
            
            segment.RemoveEnergyConsumer(electric);
            GameUpdater.UpdateWithWait();
            Assert.AreEqual(25, electric.CurrentPower.AsPrimitive());
            Assert.AreEqual(100, electric2.CurrentPower.AsPrimitive());
        }
    }
    
    internal class BlockElectricConsumer : IElectricConsumer
    {
        public ElectricPower CurrentPower;
        
        
        public BlockElectricConsumer(ElectricPower requestPower, BlockInstanceId blockInstanceId)
        {
            BlockInstanceId = blockInstanceId;
            RequestEnergy = requestPower;
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        public ElectricPower RequestEnergy　{ get; }
        
        public void SupplyEnergy(ElectricPower power)
        {
            CurrentPower = power;
        }
        
        public bool IsDestroy { get; }
        
        public void Destroy()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Crafting.Interface/CraftEvent.cs
```cs
using System;
using Mooresmaster.Model.CraftRecipesModule;
using UniRx;

namespace Game.Crafting.Interface
{
    public class CraftEvent
    {
        private readonly Subject<CraftRecipeMasterElement> _onCraftItem = new();
        public IObservable<CraftRecipeMasterElement> OnCraftItem => _onCraftItem;
        
        public void InvokeCraftItem(CraftRecipeMasterElement craftMasterElement)
        {
            _onCraftItem.OnNext(craftMasterElement);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/PlaceBlockEventPacket.cs
```cs
using System;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using Server.Util.MessagePack;
using UniRx;
using UnityEngine;

namespace Server.Event.EventReceive
{
    public class PlaceBlockEventPacket
    {
        public const string EventTag = "va:event:blockPlace";
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public PlaceBlockEventPacket(EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnPlaceBlock);
        }
        
        private void OnPlaceBlock(BlockUpdateProperties updateProperties)
        {
            var pos = updateProperties.Pos;
            var direction = updateProperties.BlockData.BlockPositionInfo.BlockDirection;
            var blockId = updateProperties.BlockData.Block.BlockId;
            
            var messagePack = new PlaceBlockEventMessagePack(pos, blockId, direction);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class PlaceBlockEventMessagePack
    {
        [Key(0)] public BlockDataMessagePack BlockData { get; set; }
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public PlaceBlockEventMessagePack()
        {
        }
        
        public PlaceBlockEventMessagePack(Vector3Int blockPos, BlockId blockId, BlockDirection direction)
        {
            BlockData = new BlockDataMessagePack(blockId, blockPos, direction);
        }
    }
    
    
    [MessagePackObject]
    public class BlockDataMessagePack
    {
        [Key(0)] public int BlockIdInt { get; set; }
        [Key(1)] public Vector3IntMessagePack BlockPos { get; set; }
        [Key(2)] public int Direction { get; set; }
        
        [IgnoreMember] public BlockDirection BlockDirection => (BlockDirection)Direction;
        [IgnoreMember] public BlockId BlockId => (BlockId)BlockIdInt;
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public BlockDataMessagePack() { }
        
        public BlockDataMessagePack(BlockId blockId, Vector3Int blockPos, BlockDirection blockDirection)
        {
            BlockIdInt = (int)blockId;
            BlockPos = new Vector3IntMessagePack(blockPos);
            Direction = (int)blockDirection;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/MapObjectAcquisitionProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     MapObjectを取得するときのプロトコル
    /// </summary>
    public class MapObjectAcquisitionProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:mapObjectInfoAcquisition";
        
        
        private readonly IMapObjectDatastore _mapObjectDatastore;
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public MapObjectAcquisitionProtocol(ServiceProvider serviceProvider)
        {
            _mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<GetMapObjectProtocolProtocolMessagePack>(payload.ToArray());
            
            var mapObject = _mapObjectDatastore.Get(data.InstanceId);
            var playerMainInventory = _playerInventoryDataStore.GetInventoryData(data.PlayerId).MainOpenableInventory;
            
            var earnedItem = mapObject.Attack(data.AttackDamage); // ダメージを与える
            
            foreach (var earnItem in earnedItem) playerMainInventory.InsertItem(earnItem);
            
            return null;
        }
        
        [MessagePackObject]
        public class GetMapObjectProtocolProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public int InstanceId { get; set; }
            [Key(4)] public int AttackDamage { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public GetMapObjectProtocolProtocolMessagePack() { }
            
            public GetMapObjectProtocolProtocolMessagePack(int playerId, int instanceId, int attackDamage)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                InstanceId = instanceId;
                AttackDamage = attackDamage;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Chest/VanillaChestComponent.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.Connector;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Context;
using Newtonsoft.Json;
using static Game.Block.Interface.BlockException;

namespace Game.Block.Blocks.Chest
{
    public class VanillaChestComponent : IOpenableBlockInventoryComponent, IBlockSaveState, IUpdatableBlockComponent
    {
        public IReadOnlyList<IItemStack> InventoryItems => _itemDataStoreService.InventoryItems;
        public BlockInstanceId BlockInstanceId { get; }
        
        private readonly IBlockInventoryInserter _blockInventoryInserter;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        public VanillaChestComponent(BlockInstanceId blockInstanceId, int slotNum, IBlockInventoryInserter blockInventoryInserter)
        {
            BlockInstanceId = blockInstanceId;
            
            _blockInventoryInserter = blockInventoryInserter;
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, slotNum);
        }
        
        public VanillaChestComponent(Dictionary<string, string> componentStates, BlockInstanceId blockInstanceId, int slotNum, IBlockInventoryInserter blockInventoryInserter) :
            this(blockInstanceId, slotNum, blockInventoryInserter)
        {
            var itemJsons = JsonConvert.DeserializeObject<List<ItemStackSaveJsonObject>>(componentStates[SaveKey]);
            for (var i = 0; i < itemJsons.Count; i++)
            {
                var itemStack = itemJsons[i].ToItemStack();
                _itemDataStoreService.SetItem(i, itemStack);
            }
        }
        
        public string SaveKey { get; } = typeof(VanillaChestComponent).FullName;
        public string GetSaveState()
        {
            CheckDestroy(this);
            
            var itemJson = new List<ItemStackSaveJsonObject>();
            foreach (var item in _itemDataStoreService.InventoryItems)
            {
                itemJson.Add(new ItemStackSaveJsonObject(item));
            }
            
            return JsonConvert.SerializeObject(itemJson);
        }
        
        public void Update()
        {
            CheckDestroy(this);
            
            for (var i = 0; i < _itemDataStoreService.InventoryItems.Count; i++)
            {
                var setItem = _blockInventoryInserter.InsertItem(_itemDataStoreService.InventoryItems[i]);
                _itemDataStoreService.SetItem(i, setItem);
            }
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            CheckDestroy(this);
            
            var blockInventoryUpdate = (BlockOpenableInventoryUpdateEvent)ServerContext.BlockOpenableInventoryUpdateEvent;
            blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(BlockInstanceId, slot, itemStack));
        }
        
        public void SetItem(int slot, IItemStack itemStack) { CheckDestroy(this); _itemDataStoreService.SetItem(slot, itemStack); }
        public IItemStack InsertItem(IItemStack itemStack) { CheckDestroy(this); return _itemDataStoreService.InsertItem(itemStack); }
        public int GetSlotSize() { CheckDestroy(this); return _itemDataStoreService.GetSlotSize(); }
        public ReadOnlyCollection<IItemStack> CreateCopiedItems() { CheckDestroy(this); return _itemDataStoreService.CreateCopiedItems(); }
        public IItemStack GetItem(int slot) { CheckDestroy(this); return _itemDataStoreService.GetItem(slot); }
        public void SetItem(int slot, ItemId itemId, int count) { CheckDestroy(this); _itemDataStoreService.SetItem(slot, itemId, count); }
        public IItemStack ReplaceItem(int slot, IItemStack itemStack) { CheckDestroy(this); return _itemDataStoreService.ReplaceItem(slot, itemStack); }
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count) { CheckDestroy(this); return _itemDataStoreService.ReplaceItem(slot, itemId, count); }
        public IItemStack InsertItem(ItemId itemId, int count) { CheckDestroy(this); return _itemDataStoreService.InsertItem(itemId, count); }
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks) { CheckDestroy(this); return _itemDataStoreService.InsertItem(itemStacks); }
        public bool InsertionCheck(List<IItemStack> itemStacks) { CheckDestroy(this); return _itemDataStoreService.InsertionCheck(itemStacks); }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Core.Update;
using Game.Challenge.Task;
using Game.Challenge.Task.Factory;
using Game.Context;
using Mooresmaster.Model.ChallengesModule;
using UniRx;

namespace Game.Challenge
{
    public class ChallengeDatastore
    {
        private readonly Dictionary<int, PlayerChallengeInfo> _playerChallengeInfos = new();
        private readonly ChallengeFactory _challengeFactory = new();
        
        public ChallengeDatastore()
        {
            GameUpdater.UpdateObservable.Subscribe(Update);
        }
        
        private void Update(Unit unit)
        {
            foreach (var challengeInfo in _playerChallengeInfos.Values)
                for (var i = challengeInfo.CurrentChallenges.Count - 1; i >= 0; i--)
                {
                    var currentChallenge = challengeInfo.CurrentChallenges[i];
                    currentChallenge.ManualUpdate();
                }
        }
        
        public PlayerChallengeInfo GetOrCreateChallengeInfo(int playerId)
        {
            if (_playerChallengeInfos.TryGetValue(playerId, out var info)) return info;
            
            var initialChallenge = CreateInitialChallenge();
            _playerChallengeInfos.Add(playerId, initialChallenge);
            
            return initialChallenge;
            
            #region Internal
            
            PlayerChallengeInfo CreateInitialChallenge()
            {
                var initialChallenges = new List<IChallengeTask>();
                foreach (var challengeGuid in MasterHolder.ChallengeMaster.InitialChallenge)
                {
                    var challenge = MasterHolder.ChallengeMaster.GetChallenge(challengeGuid);
                    var initialChallenge = CreateChallenge(playerId, challenge);
                    initialChallenges.Add(initialChallenge);
                }
                
                return new PlayerChallengeInfo(initialChallenges, new List<Guid>());
            }
            
            #endregion
        }
        
        public void LoadChallenge(List<ChallengeJsonObject> challengeJsonObjects)
        {
            foreach (var challengeJsonObject in challengeJsonObjects)
            {
                var playerId = challengeJsonObject.PlayerId;
                var currentChallenges = new List<IChallengeTask>();
                
                // InitialChallengeの中でクリアしていないのを登録
                foreach (var initialChallengeGuid in MasterHolder.ChallengeMaster.InitialChallenge)
                {
                    // クリア済みならスキップ
                    if (challengeJsonObject.CompletedGuids.Contains(initialChallengeGuid.ToString())) continue;
                    
                    var challenge = MasterHolder.ChallengeMaster.GetChallenge(initialChallengeGuid);
                    var initialChallenge = CreateChallenge(playerId, challenge);
                    currentChallenges.Add(initialChallenge);
                }
                
                // CurrentChallengeを作成
                foreach (var completedId in challengeJsonObject.CompletedGuids)
                {
                    // 完了したチャレンジの次のチャレンジがクリア済みでなければ、CurrentChallengeに追加
                    //var challenge = MasterHolder.ChallengeMaster.GetChallenge();
                    
                    var nextChallenges = MasterHolder.ChallengeMaster.GetNextChallenges(Guid.Parse(completedId));
                    foreach (var nextChallenge in nextChallenges)
                    {
                        if (challengeJsonObject.CompletedGuids.Contains(nextChallenge.ToString())) continue;
                        
                        var challengeElement = MasterHolder.ChallengeMaster.GetChallenge(nextChallenge.ChallengeGuid);
                        var initialChallenge = CreateChallenge(playerId, challengeElement);
                        currentChallenges.Add(initialChallenge);
                    }
                }
                
                var completedChallengeIds =  challengeJsonObject.CompletedGuids.ConvertAll(Guid.Parse);
                _playerChallengeInfos.Add(playerId, new PlayerChallengeInfo(currentChallenges, completedChallengeIds));
            }
        }
        
        private IChallengeTask CreateChallenge(int playerId, ChallengeMasterElement challengeElement)
        {
            var challenge = _challengeFactory.CreateChallengeTask(playerId, challengeElement);
            challenge.OnChallengeComplete.Subscribe(CompletedChallenge);
            return challenge;
        }
        
        private void CompletedChallenge(IChallengeTask currentChallenge)
        {
            var playerId = currentChallenge.PlayerId;
            var challengeInfo = _playerChallengeInfos[playerId];
            
            challengeInfo.CurrentChallenges.Remove(currentChallenge);
            challengeInfo.CompletedChallengeGuids.Add(currentChallenge.ChallengeMasterElement.ChallengeGuid);
            
            var nextChallenges = MasterHolder.ChallengeMaster.GetNextChallenges(currentChallenge.ChallengeMasterElement.ChallengeGuid);
            foreach (var nextChallengeMaster in nextChallenges)
            {
                var challengeElement = MasterHolder.ChallengeMaster.GetChallenge(nextChallengeMaster.ChallengeGuid);
                
                var nextChallenge = CreateChallenge(playerId, challengeElement);
                challengeInfo.CurrentChallenges.Add(nextChallenge);
            }
            
            ServerContext.GetService<ChallengeEvent>().InvokeCompleteChallenge(currentChallenge);
        }

        
        public List<ChallengeJsonObject> GetSaveJsonObject()
        {
            var result = new List<ChallengeJsonObject>();
            foreach (var challengeInfo in _playerChallengeInfos)
            {
                var playerId = challengeInfo.Key;
                var completedIds = challengeInfo.Value.CompletedChallengeGuids.Select(x => x.ToString()).ToList();
                
                result.Add(new ChallengeJsonObject
                {
                    PlayerId = playerId,
                    CompletedGuids = completedIds
                });
            }
            
            return result;
        }
    }
    
    public class PlayerChallengeInfo
    {
        public List<IChallengeTask> CurrentChallenges { get; }
        public List<Guid> CompletedChallengeGuids { get; }
        
        public PlayerChallengeInfo(List<IChallengeTask> currentChallenges, List<Guid> completedChallengeGuids)
        {
            CurrentChallenges = currentChallenges;
            CompletedChallengeGuids = completedChallengeGuids;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/PacketSender.cs
```cs
using System;
using MessagePack;
using Server.Protocol;

namespace Client.Network.API
{
    /// <summary>
    ///     パケットの送信だけを行うクラス
    ///     受信が必要な場合は<see cref="PacketExchangeManager" />を使用してください
    /// </summary>
    public class PacketSender
    {
        private readonly ServerCommunicator _serverCommunicator;
        
        public PacketSender(ServerCommunicator serverCommunicator)
        {
            _serverCommunicator = serverCommunicator;
        }
        
        public void Send(ProtocolMessagePackBase sendData)
        {
            _serverCommunicator.Send(MessagePackSerializer.Serialize(Convert.ChangeType(sendData, sendData.GetType())));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/IBlockFactory.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Factory.BlockTemplate;

namespace Game.Block.Interface
{
    public interface IBlockFactory
    {
        public IBlock Create(BlockId blockId, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo);
        public IBlock Load(Guid blockGuid, BlockInstanceId blockInstanceId, Dictionary<string,string> state, BlockPositionInfo blockPositionInfo);
        
        public void RegisterTemplateIBlock(string key, IBlockTemplate block);
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Gear/SimpleGearService.cs
```cs
using System;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.Gear.Common;
using MessagePack;
using UniRx;

namespace Game.Block.Blocks.Gear
{
    public class SimpleGearService
    {
        private string _currentState = IGearEnergyTransformer.WorkingStateName;
        public IObservable<Unit> BlockStateChange => _onBlockStateChange;
        private readonly Subject<Unit> _onBlockStateChange = new();
        
        public IObservable<GearUpdateType> OnGearUpdate => _onGearUpdate;
        private readonly Subject<GearUpdateType> _onGearUpdate = new();
        
        public RPM CurrentRpm { get; private set; }
        public Torque CurrentTorque { get; private set; }
        public bool IsCurrentClockwise { get; private set; }
        public bool IsRocked { get; private set; }
        
        public void Rocked()
        {
            IsRocked = true;
            _currentState = IGearEnergyTransformer.RockedStateName;
            CurrentRpm = new RPM(0);
            CurrentTorque = new Torque(0);
            
            _onBlockStateChange.OnNext(Unit.Default);
            _onGearUpdate.OnNext(GearUpdateType.Rocked);
        }
        
        public BlockStateDetail GetBlockStateDetail()
        {
            var stateData = MessagePackSerializer.Serialize(new GearStateDetail(CurrentRpm.AsPrimitive(), IsCurrentClockwise));
            return new BlockStateDetail(GearStateDetail.BlockStateDetailKey, stateData);
        }
        
        public void SupplyPower(RPM rpm, Torque torque, bool isClockwise)
        {
            IsRocked = false;
            var isChanged =
                Math.Abs((CurrentRpm - rpm).AsPrimitive()) > 0.05f ||
                Math.Abs((CurrentTorque - torque).AsPrimitive()) > 0.05f ||
                IsCurrentClockwise != isClockwise;
            
            CurrentRpm = rpm;
            CurrentTorque = torque;
            IsCurrentClockwise = isClockwise;
            
            if (isChanged)
            {
                _onBlockStateChange.OnNext(Unit.Default);
            }
            
            _currentState = IGearEnergyTransformer.WorkingStateName;
            _onGearUpdate.OnNext(GearUpdateType.SupplyPower);
        }
        
        public void Destroy()
        {
            _onBlockStateChange.Dispose();
        }
    }
    
    public enum GearUpdateType
    {
        SupplyPower,
        Rocked,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/PauseMenu/BackToMainMenu.cs
```cs
using System.Threading;
using Client.Common;
using Client.Game.InGame.Context;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace Client.Game.InGame.Presenter.PauseMenu
{
    //ゲームが終了したときかメインメニューに戻るときはサーバーを終了させます
    public class BackToMainMenu : MonoBehaviour
    {
        [SerializeField] private Button backToMainMenuButton;
        
        private void Start()
        {
            backToMainMenuButton.onClick.AddListener(Back);
        }
        
        private void OnDestroy()
        {
            Disconnect();
        }
        
        private void OnApplicationQuit()
        {
            Disconnect();
        }
        
        private void Back()
        {
            Disconnect();
            SceneManager.LoadScene(SceneConstant.MainMenuSceneName);
        }
        
        
        private void Disconnect()
        {
            ClientContext.VanillaApi.SendOnly.Save();
            Thread.Sleep(50);
            ClientContext.VanillaApi.Disconnect();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/RecipeViewerView.cs
```cs
using System;
using Client.Game.InGame.UI.Inventory.Sub;
using Core.Master;
using Game.CraftChainer.Util;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class RecipeViewerView : MonoBehaviour
    {
        [SerializeField] private CraftInventoryView craftInventoryView;
        [SerializeField] private MachineRecipeView machineRecipeView;
        [SerializeField] private RecipeTabView recipeTabView;
        
        [SerializeField] private ItemListView itemListView;
        
        private void Awake()
        {
            itemListView.OnClickItem.Subscribe(SetItemListView);
            craftInventoryView.OnClickItem.Subscribe(SetItemListView);
            machineRecipeView.OnClickItem.Subscribe(SetItemListView);
            recipeTabView.OnClickTab.Subscribe(OnClickTab);
        }
        
        private void SetItemListView(RecipeViewerItemRecipes recipeViewerItemRecipes)
        {
            if (recipeViewerItemRecipes == null)
            {
                return;
            }
            
            craftInventoryView.SetRecipes(recipeViewerItemRecipes);
            machineRecipeView.SetRecipes(recipeViewerItemRecipes);
            recipeTabView.SetRecipeTabView(recipeViewerItemRecipes);
            
            var isFirstCraft = recipeViewerItemRecipes.CraftRecipes.Count != 0; 
            craftInventoryView.SetActive(isFirstCraft);
            machineRecipeView.SetActive(!isFirstCraft);
            if (isFirstCraft)
            {
                craftInventoryView.DisplayRecipe(0);
            }
            else
            {
                machineRecipeView.DisplayRecipe(0);
            }
        }
        
        private void OnClickTab(BlockId? blockId)
        {
            var isCraft = !blockId.HasValue;
            
            if (isCraft)
            {
                craftInventoryView.SetActive(true);
                machineRecipeView.SetActive(false);
            }
            else
            {
                craftInventoryView.SetActive(false);
                machineRecipeView.SetActive(true);
                
                machineRecipeView.SetBlockId(blockId.Value);
            }
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/GearBeltConveyorStateChangeProcessor.cs
```cs
using System;
using Game.Gear.Common;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    public class GearBeltConveyorStateChangeProcessor : MonoBehaviour, IBlockStateChangeProcessor
    {
        [SerializeField] private MeshRenderer meshRenderer;
        [SerializeField] private float speed = 1;
        
        public GearStateDetail CurrentGearState { get; private set; }
        
        private Vector2 _offset;
        private static readonly int BaseMap = Shader.PropertyToID("_BaseMap");
        
        public void OnChangeState(BlockStateMessagePack blockState)
        {
            CurrentGearState = blockState.GetStateDetail<GearStateDetail>(GearStateDetail.BlockStateDetailKey);
        }
        
        private void Update()
        {
            if (CurrentGearState == null) return;
            
            _offset.x += CurrentGearState.CurrentRpm / 60 * Time.time * speed;
            meshRenderer.sharedMaterial.SetTextureOffset(BaseMap, _offset);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlacePreviewObjectPool.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Core.Master;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPlacePreviewObjectPool
    {
        private readonly Transform _parentTransform;
        private readonly Dictionary<BlockId, List<PreviewObject>> _blockPreviewObjects = new();
        
        public BlockPlacePreviewObjectPool(Transform parentTransform)
        {
            _parentTransform = parentTransform;
        }
        
        class PreviewObject
        {
            public BlockPreviewObject BlockPreviewObject;
            public bool IsUsed;
        }
        
        public BlockPreviewObject GetObject(BlockId blockId)
        {
            if (!_blockPreviewObjects.ContainsKey(blockId))
            {
                _blockPreviewObjects.Add(blockId, new List<PreviewObject>());
            }
            
            var unusedObject = _blockPreviewObjects[blockId].Find(obj => !obj.IsUsed);
            if (unusedObject == null)
            {
                unusedObject = new PreviewObject
                {
                    BlockPreviewObject = CreatePreviewObject(blockId),
                    IsUsed = true
                };
                _blockPreviewObjects[blockId].Add(unusedObject);
            }
            else
            {
                unusedObject.IsUsed = true;
                unusedObject.BlockPreviewObject.SetActive(true);
            }
            
            return unusedObject.BlockPreviewObject;
            
            #region Internal
            
            BlockPreviewObject CreatePreviewObject(BlockId id)
            {
                var previewBlock = ClientContext.BlockGameObjectContainer.CreatePreviewBlock(id);
                previewBlock.transform.SetParent(_parentTransform);
                previewBlock.transform.localPosition = Vector3.zero;
                
                return previewBlock;
            }
            
            #endregion
        }
        
        
        public void AllUnUse()
        {
            foreach (var previewObjects in _blockPreviewObjects.Values)
            {
                foreach (var previewObject in previewObjects)
                {
                    previewObject.IsUsed = false;
                    previewObject.BlockPreviewObject.SetActive(false);
                }
            }
        }
        
        public void AllDestroy()
        {
            foreach (var previewObjects in _blockPreviewObjects.Values)
            {
                foreach (var previewObject in previewObjects)
                {
                    previewObject.BlockPreviewObject.Destroy();
                }
            }
            
            _blockPreviewObjects.Clear();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/RemoveBlockEventPacket.cs
```cs
using System;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using Server.Util.MessagePack;
using UniRx;
using UnityEngine;

namespace Server.Event.EventReceive
{
    public class RemoveBlockToSetEventPacket
    {
        public const string EventTag = "va:event:removeBlock";
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public RemoveBlockToSetEventPacket(EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            ServerContext.WorldBlockUpdateEvent.OnBlockRemoveEvent.Subscribe(OnBlockRemove);
        }
        
        private void OnBlockRemove(BlockUpdateProperties updateProperties)
        {
            var pos = updateProperties.Pos;
            var payload = MessagePackSerializer.Serialize(new RemoveBlockEventMessagePack(pos));
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, payload);
        }
    }
    
    [MessagePackObject]
    public class RemoveBlockEventMessagePack
    {
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public RemoveBlockEventMessagePack()
        {
        }
        
        public RemoveBlockEventMessagePack(Vector3Int pos)
        {
            Position = new Vector3IntMessagePack(pos);
        }
        
        [Key(0)] public Vector3IntMessagePack Position { get; set; }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/MapObjectPin.cs
```cs
using System;
using System.Linq;
using Client.Game.InGame.Control;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Mooresmaster.Model.ChallengesModule;
using TMPro;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Tutorial
{
    public class MapObjectPin : MonoBehaviour, ITutorialView, ITutorialViewManager
    {
        public const string TutorialType = "mapObjectPin";
        
        [SerializeField] private TMP_Text pinText;
        
        private InGameCameraController _inGameCameraController;
        private MapObjectGameObjectDatastore _mapObjectGameObjectDatastore;
        private IPlayerObjectController _playerObjectController;
        
        private MapObjectPinTutorialParam _currentTutorialParam;
        private IDisposable _mapObjectOnDestroy;
        
        [Inject]
        public void Construct(InGameCameraController inGameCameraController, MapObjectGameObjectDatastore mapObjectGameObjectDatastore, IPlayerObjectController playerObjectController)
        {
            _inGameCameraController = inGameCameraController;
            _mapObjectGameObjectDatastore = mapObjectGameObjectDatastore;
            _playerObjectController = playerObjectController;
        }
        
        private void Update()
        {
            // Y軸を常にカメラに向ける
            transform.LookAt(_inGameCameraController.Position);
            transform.rotation = Quaternion.Euler(0, transform.rotation.eulerAngles.y, 0);
        }
        
        public ITutorialView ApplyTutorial(ITutorialParam param)
        {
            _currentTutorialParam = (MapObjectPinTutorialParam)param;
            
            _mapObjectOnDestroy?.Dispose();
            
            // 近くのMapObjectを探してピンを表示
            var mapObjects = _mapObjectGameObjectDatastore.CreateMapObjectList(_currentTutorialParam.MapObjectGuid);
            var playerPos = _playerObjectController.Position;
            var sortedMapObjects = mapObjects.OrderBy(x => (playerPos - x.GetPosition()).sqrMagnitude).ToList();
            if (sortedMapObjects.Count == 0)
            {
                Debug.LogWarning($"未破壊のMapObject {_currentTutorialParam.MapObjectGuid} が存在しません");
                return null;
            }
            
            var nearMapObject = sortedMapObjects.First();
            transform.position = nearMapObject.GetPosition();
            
            // そのMapObjectが破壊されたら別のmapObjectを探す
            _mapObjectOnDestroy = nearMapObject.OnDestroyMapObject.Subscribe(_ =>
            {
                ApplyTutorial(_currentTutorialParam);
            }).AddTo(this);
            
            // ピンのテキストを設定
            pinText.text = _currentTutorialParam.PinText;
            
            SetActive(true);
            
            return this;
        }
        
        public void CompleteTutorial()
        {
            SetActive(false);
            _currentTutorialParam = null;
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Miner/VanillaElectricMinerComponent.cs
```cs
using Game.Block.Interface;
using Game.EnergySystem;

namespace Game.Block.Blocks.Miner
{
    public class VanillaElectricMinerComponent : IElectricConsumer
    {
        public BlockInstanceId BlockInstanceId { get; }
        public ElectricPower RequestEnergy { get; }
        
        private readonly VanillaMinerProcessorComponent _vanillaMinerProcessorComponent;
        
        public VanillaElectricMinerComponent(BlockInstanceId blockInstanceId, ElectricPower requestEnergy, VanillaMinerProcessorComponent vanillaMinerProcessorComponent)
        {
            _vanillaMinerProcessorComponent = vanillaMinerProcessorComponent;
            BlockInstanceId = blockInstanceId;
            RequestEnergy = requestEnergy;
        }
        
        public void SupplyEnergy(ElectricPower power)
        {
            _vanillaMinerProcessorComponent.SupplyPower(power);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockPositionInfo.cs
```cs
using UnityEngine;

namespace Game.Block.Interface
{
    public class BlockPositionInfo
    {
        public BlockPositionInfo(Vector3Int originalPos, BlockDirection blockDirection, Vector3Int blockSize)
        {
            OriginalPos = originalPos;
            BlockDirection = blockDirection;
            BlockSize = blockSize;
            
            MaxPos = CalcBlockMaxPos(originalPos, blockDirection, BlockSize);
        }
        
        /// <summary>
        ///     オリジナル座標は常に左下（ブロックが専有する範囲の最小の座標）になる
        /// </summary>
        public Vector3Int OriginalPos { get; }
        
        public Vector3Int BlockSize { get; }
        
        public Vector3Int MinPos => OriginalPos;
        public Vector3Int MaxPos { get; }
        
        public BlockDirection BlockDirection { get; }
        
        /// <summary>
        ///     サーバー側管理のブロックの最大座標を計算する
        ///     これはどのグリッドにブロックが存在しているかということに使われるため、サイズ 1,1 の場合、originとmaxの値はおなじになる
        /// </summary>
        public static Vector3Int CalcBlockMaxPos(Vector3Int originPos, BlockDirection direction, Vector3Int blockSize)
        {
            var addPos = Vector3Int.zero;
            switch (direction)
            {
                case BlockDirection.UpNorth:
                case BlockDirection.UpSouth:
                case BlockDirection.DownNorth:
                case BlockDirection.DownSouth:
                    addPos = new Vector3Int(blockSize.x, blockSize.z, blockSize.y);
                    break;
                case BlockDirection.UpEast:
                case BlockDirection.UpWest:
                case BlockDirection.DownEast:
                case BlockDirection.DownWest:
                    addPos = new Vector3Int(blockSize.y, blockSize.z, blockSize.x);
                    break;
                
                case BlockDirection.North:
                case BlockDirection.South:
                    addPos = new Vector3Int(blockSize.x, blockSize.y, blockSize.z);
                    break;
                case BlockDirection.East:
                case BlockDirection.West:
                    addPos = new Vector3Int(blockSize.z, blockSize.y, blockSize.x);
                    break;
            }
            
            // block sizeは1からとなっているが、ここで求めるのはブロックが占める範囲の最大値なので、-1している
            return addPos + originPos - Vector3Int.one;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/SaveJsonFileName.cs
```cs
using Game.Paths;

namespace Game.SaveLoad.Json
{
    /// <summary>
    ///     JSONでセーブするさいのファイル名を指定するクラス
    /// </summary>
    public class SaveJsonFileName
    {
        public string FullSaveFilePath { get; }
        
        public SaveJsonFileName(string fileName)
        {
            FullSaveFilePath = GameSystemPaths.GetSaveFilePath(fileName);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.Json;

namespace Game.Map.Interface.MapObject
{
    public interface IMapObjectDatastore
    {
        public IReadOnlyList<IMapObject> MapObjects { get; }
        
        /// <summary>
        ///     オブジェクトをロードするか生成する
        ///     既に存在するオブジェクトはデータを適応し、存在しないオブジェクトは生成する
        /// </summary>
        public void LoadMapObject(List<MapObjectJsonObject> savedMapObjects);
        
        public void Add(IMapObject mapObject);
        public IMapObject Get(int instanceId);
        
        public List<MapObjectJsonObject> GetSaveJsonObject();
        
        public event Action<IMapObject> OnDestroyMapObject;
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/CinematicCameraController.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public class CinematicCameraController : MonoBehaviour
    {
        private const float StartVerticalRotationAngle = 70;
        private const float RockVerticalRotationAngle = 88;
        [SerializeField] private Transform cameraRootTransform;
        [SerializeField] private Transform cameraXTransform;
        [SerializeField] private Transform cameraYTransform;
        [SerializeField] private float mouseSpeed = 1f;
        [SerializeField] private float cameraSpeed = 0.05f;
        
        [SerializeField] private float positionMoveSpeed = 0.05f;
        [SerializeField] private float positionLerpSpeed = 0.05f;
        
        
        /// <summary>
        ///     キーボードの操作に対してカメラをゆっくりと動かすために、目標の位置を保持する
        /// </summary>
        private Vector3 _targetPosition;
        
        private float lastXmouse;
        
        /// <summary>
        ///     マウスの操作に対してカメラをゆっくりと動かすために、目標の回転角度を保持する
        /// </summary>
        public Quaternion TargetCameraYRot { get; private set; }
        
        public Quaternion TargetCameraXRot { get; private set; }
        
        //カメラの最初の向きを飛行機の向きと同じにする
        private void Awake()
        {
            _targetPosition = cameraRootTransform.position;
            TargetCameraXRot = cameraXTransform.localRotation;
            TargetCameraYRot = cameraYTransform.localRotation;
        }
        
        private void Update()
        {
            //カーソルを消す
            Cursor.visible = false;
            Cursor.lockState = CursorLockMode.Locked;
            
            float sensi;
            sensi = mouseSpeed;
            var xMouseRot = Input.GetAxis("Mouse X") * sensi;
            var yMouseRot = Input.GetAxis("Mouse Y") * sensi;
            
            // マウスの上下方向の動きはカメラのX軸に、マウスの左右方向の動きはカメラのY軸に対して回転させる
            TargetCameraXRot *= Quaternion.Euler(-yMouseRot, 0, 0);
            
            //X軸を-85〜85度に制限する
            var xRotEuler = TargetCameraXRot.eulerAngles.x;
            //角度を-180〜180度に変換する
            xRotEuler = xRotEuler > 180 ? xRotEuler - 360 : xRotEuler;
            
            //もしX軸が-85度から85どの範囲外の場合はX軸のオブジェクトの動きを加算する
            if (xRotEuler is <= -StartVerticalRotationAngle or >= StartVerticalRotationAngle)
            {
                var addXRate = (Mathf.Abs(xRotEuler) - StartVerticalRotationAngle) / (RockVerticalRotationAngle - StartVerticalRotationAngle);
                addXRate *= 0.7f;
                if (-0.2f < xMouseRot && xMouseRot < 0.2)
                    // +-1の範囲は前回と同じ方向に回転する
                    addXRate *= lastXmouse < 0 ? -1 : 1;
                else
                    // +-1の範囲外はマウスの動きに合わせて回転する
                    addXRate *= xMouseRot < 0 ? -1 : 1;
                
                TargetCameraYRot *= Quaternion.Euler(0, xMouseRot + yMouseRot * addXRate, 0);
            }
            else
            {
                TargetCameraYRot *= Quaternion.Euler(0, xMouseRot, 0);
            }
            
            xRotEuler = Mathf.Clamp(xRotEuler, -RockVerticalRotationAngle, RockVerticalRotationAngle);
            TargetCameraXRot = Quaternion.Euler(xRotEuler, 0, 0);
            
            
            cameraXTransform.localRotation = Quaternion.Lerp(cameraXTransform.localRotation, TargetCameraXRot, cameraSpeed);
            cameraYTransform.localRotation = Quaternion.Lerp(cameraYTransform.localRotation, TargetCameraYRot, cameraSpeed);
            
            
            //キーボード入力をとり、ターゲット位置を更新する
            var move = new Vector3(
                Input.GetKey(KeyCode.W) ? 1 :
                Input.GetKey(KeyCode.S) ? -1 : 0,
                Input.GetKey(KeyCode.LeftShift) ? -1 :
                Input.GetKey(KeyCode.Space) ? 1 : 0,
                Input.GetKey(KeyCode.A) ? -1 :
                Input.GetKey(KeyCode.D) ? 1 : 0
            );
            
            //カメラの向きに合わせてXとZのみ移動方向を変更する
            var cameraForward = transform.forward;
            cameraForward.y = 0;
            cameraForward.Normalize();
            var cameraRight = transform.right;
            cameraRight.y = 0;
            cameraRight.Normalize();
            _targetPosition += cameraForward * move.x * positionMoveSpeed;
            _targetPosition += cameraRight * move.z * positionMoveSpeed;
            _targetPosition.y += move.y * positionMoveSpeed;
            
            
            //線形補完でカメラの位置を更新する
            cameraRootTransform.position = Vector3.Lerp(cameraRootTransform.position, _targetPosition, positionLerpSpeed);
            
            
            lastXmouse = xMouseRot;
        }
        
        public void SetCameraRotation(Quaternion rotation)
        {
            var euler = rotation.eulerAngles;
            TargetCameraXRot = Quaternion.Euler(euler.x, 0, 0);
            TargetCameraYRot = Quaternion.Euler(0, euler.y, 0);
            cameraXTransform.localRotation = TargetCameraXRot;
            cameraYTransform.localRotation = TargetCameraYRot;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerMainComputerSelectRequestItemModal.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Master;
using Cysharp.Threading.Tasks;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class CraftChainerMainComputerSelectRequestItemModal : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform itemsParent;
        [SerializeField] private TMP_InputField countInputField;
        
        [SerializeField] private Button requestButton;
        [SerializeField] private Button cancelButton;
        
        private readonly List<ItemSlotObject> _itemSlotObjects = new();
        private ItemId _selectedItemId;
        
        public void Initialize()
        {
            gameObject.SetActive(false);
            // Initialize item list
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemView = ClientContext.ItemImageContainer.GetItemView(itemId);
                var slotObject = Instantiate(itemSlotObjectPrefab, itemsParent);
                slotObject.SetItem(itemView, 0);
                slotObject.OnLeftClickUp.Subscribe(ClickItem);
                _itemSlotObjects.Add(slotObject);
            }
            countInputField.onValueChanged.AddListener(UpdateRequestButton);
        }
        
        public async UniTask<(ItemId,int)> GetRequestItem()
        {
            SetupUI();
            
            var result = await WaitRequestButton();
            
            gameObject.SetActive(false);
            return result;
            
            #region Internal
            
            void SetupUI()
            {
                gameObject.SetActive(true);
                countInputField.text = 1.ToString();
            }
            
            async UniTask<(ItemId, int)> WaitRequestButton()
            {
                var request = requestButton.OnClickAsync();
                var cancel = cancelButton.OnClickAsync();
                await UniTask.WhenAny(request, cancel);
                
                if (cancel.Status == UniTaskStatus.Succeeded)
                {
                    return (ItemMaster.EmptyItemId, 0);
                }
                
                if (int.TryParse(countInputField.text, out var count))
                {
                    return (_selectedItemId, count);
                }
                
                return (_selectedItemId, 1);
            }
            
            #endregion
        }
        
        
        private void ClickItem(ItemSlotObject itemSlotObject)
        {
            foreach (var slotObject in _itemSlotObjects)
            {
                slotObject.SetHotBarSelect(false);
            }
            
            itemSlotObject.SetHotBarSelect(true);
            _selectedItemId = itemSlotObject.ItemViewData.ItemId;
            
            UpdateRequestButton(countInputField.text);
        }
        
        private void UpdateRequestButton(string inputFieldText)
        {
            if (int.TryParse(inputFieldText, out var count))
            {
                requestButton.interactable = 0 < count;
                return;
            }
            requestButton.interactable = false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/DebugBlockInfoRequestProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface.Component;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class DebugBlockInfoRequestProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:blockDebug";
        
        private readonly IWorldBlockDatastore _worldBlockDatastore;
        
        public DebugBlockInfoRequestProtocol(ServiceProvider serviceProvider)
        {
            _worldBlockDatastore = serviceProvider.GetService<IWorldBlockDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestDebugBlockInfoRequestProtocolMessagePack>(payload.ToArray());
            
            var block = _worldBlockDatastore.GetBlock(data.BlockPos);
            if (block == null)
            {
                return new ResponseDebugBlockInfoRequestProtocolMessagePack(null);
            }
            
            var blockDebugInfo = new List<BlockDebugInfo>();
            var debugInfos = block.ComponentManager.GetComponents<IBlockDebugInfo>();
            foreach (var debug in debugInfos)
            {
                blockDebugInfo.Add(debug.GetDebugInfo());
            }
            
            return new ResponseDebugBlockInfoRequestProtocolMessagePack(blockDebugInfo);
        }
        
        
        [MessagePackObject]
        public class RequestDebugBlockInfoRequestProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RequestDebugBlockInfoRequestProtocolMessagePack() { }
            
            public RequestDebugBlockInfoRequestProtocolMessagePack(Vector3Int pos)
            {
                Tag = BlockInventoryRequestProtocol.ProtocolTag;
                BlockPos = new Vector3IntMessagePack(pos);
            }
        }
        
        [MessagePackObject]
        public class ResponseDebugBlockInfoRequestProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<BlockDebugInfo> BlockDebugInfos { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseDebugBlockInfoRequestProtocolMessagePack() { }
            public ResponseDebugBlockInfoRequestProtocolMessagePack(List<BlockDebugInfo> blockDebugInfo)
            {
                Tag = BlockInventoryRequestProtocol.ProtocolTag;
                BlockDebugInfos = blockDebugInfo;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Gear/GearEnergyTransformerComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlockConnectInfoModule;
using UniRx;
using UnityEngine;

namespace Game.Block.Blocks.Gear
{
    public class GearEnergyTransformer : IGearEnergyTransformer, IBlockStateObservable, IBlockStateDetail
    {
        public IObservable<Unit> OnChangeBlockState => _simpleGearService.BlockStateChange;
        public IObservable<GearUpdateType> OnGearUpdate => _simpleGearService.OnGearUpdate;
        
        public BlockInstanceId BlockInstanceId { get; }
        public RPM CurrentRpm => _simpleGearService.CurrentRpm;
        public Torque CurrentTorque => _simpleGearService.CurrentTorque;
        public bool IsCurrentClockwise => _simpleGearService.IsCurrentClockwise;
        
        public bool IsRocked => _simpleGearService.IsRocked;
        public bool IsDestroy { get; private set; }
        
        private readonly IBlockConnectorComponent<IGearEnergyTransformer> _connectorComponent;
        
        private readonly Torque _requiredTorque;
        private readonly SimpleGearService _simpleGearService;
        
        public GearEnergyTransformer(Torque requiredTorque, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent)
        {
            _requiredTorque = requiredTorque;
            BlockInstanceId = blockInstanceId;
            _connectorComponent = connectorComponent;
            _simpleGearService = new SimpleGearService();
            
            GearNetworkDatastore.AddGear(this);
        }
        
        public BlockStateDetail GetBlockStateDetail()
        {
            return _simpleGearService.GetBlockStateDetail();
        }
        
        public Torque GetRequiredTorque(RPM rpm, bool isClockwise)
        {
            return _requiredTorque;
        }
        
        public void Rocked()
        {
            _simpleGearService.Rocked();
        }
        
        public virtual void SupplyPower(RPM rpm, Torque torque, bool isClockwise)
        {
            _simpleGearService.SupplyPower(rpm, torque, isClockwise);
        }
        
        public List<GearConnect> GetGearConnects()
        {
            var result = new List<GearConnect>();
            foreach (var target in _connectorComponent.ConnectedTargets)
            {
                result.Add(new GearConnect(target.Key, (GearConnectOption)target.Value.SelfOption, (GearConnectOption)target.Value.TargetOption));
            }
            return result;
        }
        
        public void Destroy()
        {
            IsDestroy = true;
            GearNetworkDatastore.RemoveGear(this);
            _simpleGearService.Destroy();
        }
    }
    
    public static class GearEnergyTransformerExtension
    {
        public static ElectricPower CalcMachineSupplyPower(this GearEnergyTransformer energyTransformer, RPM requiredRpm, Torque requiredTorque)
        {
            var currentRpm = energyTransformer.CurrentRpm;
            var currentTorque = energyTransformer.CurrentTorque;
            
            var rpmRate = Mathf.Min((currentRpm / requiredRpm).AsPrimitive(), 1);
            var torqueRate = Mathf.Min((currentTorque / requiredTorque).AsPrimitive(), 1);
            var powerRate = rpmRate * torqueRate;
            
            var requiredGearPower = requiredRpm.AsPrimitive() * requiredTorque.AsPrimitive();
            var currentElectricPower = new ElectricPower(requiredGearPower * powerRate);
            
            return currentElectricPower;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Mod/Texture/ItemTextureLoader.cs
```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Client.Common;
using Core.Master;
using Mod.Loader;
using Mooresmaster.Model.ItemsModule;
using UnityEngine;

namespace Client.Mod.Texture
{
    public static class ItemTextureLoader
    {
        public static Dictionary<ItemId, ItemViewData> GetItemTexture(string modDirectory)
        {
            var textureList = new Dictionary<ItemId, ItemViewData>();
            
            var mods = new ModsResource(modDirectory);
            
            foreach (var mod in mods.Mods)
            {
                // TODO MooresmasterのmodId対応が入ってから、modごとにアイテムを取得する用になる
                
                // 今は仮で全てのアイテムに対してテクスチャを取得する
                var itemIds = MasterHolder.ItemMaster.GetItemAllIds().ToList();
                foreach (var texture in GetTextures(itemIds, mod.Value))
                {
                    textureList.Add(texture.ItemId, texture);
                }
            }
            
            return textureList;
        }
        
        
        private static List<ItemViewData> GetTextures(List<ItemId> itemIds, global::Mod.Loader.Mod mod)
        {
            var textureList = new List<ItemViewData>();
            foreach (var itemId in itemIds)
            {
                var itemMaster = MasterHolder.ItemMaster.GetItemMaster(itemId);
                
                var path = string.IsNullOrEmpty(itemMaster.ImagePath) ? Path.Combine("assets", "item", $"{itemMaster.Name}.png") : itemMaster.ImagePath;
                
                var texture = GetExtractedZipTexture.Get(mod.ExtractedPath, path);
                if (texture == null) Debug.LogWarning("ItemTexture Not Found  ModId:" + mod.ModMetaJson.ModId + " ItemName:" + itemMaster.Name);
                
                textureList.Add(new ItemViewData(texture, itemMaster));
            }
            
            return textureList;
        }
    }
    
    
    public class ItemViewData
    {
        public readonly ItemId ItemId;
        public string ItemName => ItemMasterElement.Name;
        public readonly ItemMasterElement ItemMasterElement;
        
        public readonly Sprite ItemImage;
        public readonly UnityEngine.Texture ItemTexture;
        
        public ItemViewData(Texture2D itemTexture, ItemMasterElement itemMasterElement)
        {
            ItemImage = itemTexture.ToSprite();
            ItemTexture = itemTexture;
            ItemMasterElement = itemMasterElement;
            ItemId = MasterHolder.ItemMaster.GetItemId(itemMasterElement.ItemGuid);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/ConnectServer.cs
```cs
using System;
using System.Net;
using System.Net.Sockets;
using Client.Common;
using Client.MainMenu.PopUp;
using Client.Starter;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace Client.MainMenu
{
    public class ConnectServer : MonoBehaviour
    {
        [SerializeField] private TMP_InputField serverIp;
        [SerializeField] private TMP_InputField serverPort;
        
        [SerializeField] private ServerConnectPopup serverConnectPopup;
        
        [SerializeField] private Button connectButton;
        
        private void Start()
        {
            connectButton.onClick.AddListener(Connect);
        }
        
        private void Connect()
        {
            if (!IPAddress.TryParse(serverIp.text, out var address))
            {
                serverConnectPopup.SetText("IPアドレスが正しくありません");
                return;
            }
            
            var port = int.Parse(serverPort.text);
            if (65535 < port)
            {
                serverConnectPopup.SetText("ポート番号は65535以下である必要があります");
                return;
            }
            
            if (port <= 1024)
            {
                serverConnectPopup.SetText("ポート番号は1024以上である必要があります");
                return;
            }
            
            try
            {
                var remoteEndPoint = new IPEndPoint(address, port);
                var socket = new Socket(remoteEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
                
                socket.Connect(remoteEndPoint);
                
                if (socket.Connected)
                {
                    //接続が確認出来たのでソケットを閉じて実際にゲームに移行
                    socket.Close();
                    
                    SceneManager.sceneLoaded += OnMainGameSceneLoaded;
                    SceneManager.LoadScene(SceneConstant.GameInitializerSceneName);
                }
            }
            catch (Exception e)
            {
                serverConnectPopup.SetText("サーバーへの接続に失敗しました\n" + e);
            }
        }
        
        private void OnMainGameSceneLoaded(Scene scene, LoadSceneMode mode)
        {
            SceneManager.sceneLoaded -= OnMainGameSceneLoaded;
            var starter = FindObjectOfType<InitializeScenePipeline>();
            
            var ip = serverIp.text;
            var port = int.Parse(serverPort.text);
            var playerId = PlayerPrefs.GetInt(PlayerPrefsKeys.PlayerIdKey);
            
            var properties = new InitializeProprieties(false, null, ip, port, playerId);
            
            starter.SetProperty(properties);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/ElectricSegmentMergeService.cs
```cs
using System.Collections.Generic;
using Game.EnergySystem;
using Game.World.Interface.DataStore;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class ElectricSegmentMergeService
    {
        /// <summary>
        ///     電柱に所属するセグメント同士をマージし、データストアにセットするシステム
        /// </summary>
        /// <param name="segmentDatastore"></param>
        /// <param name="poles">マージしたい電柱</param>
        /// <returns></returns>
        public static EnergySegment MergeAndSetDatastoreElectricSegments<TSegment>(
            IWorldEnergySegmentDatastore<TSegment> segmentDatastore, List<IElectricTransformer> poles)
            where TSegment : EnergySegment, new()
        {
            //電力セグメントをリストアップ
            var electricSegments = new List<TSegment>();
            foreach (var pole in poles)
            {
                var electricSegment = segmentDatastore.GetEnergySegment(pole);
                electricSegments.Add(electricSegment);
            }
            
            //電力セグメントをマージする
            var mergedElectricSegment = EnergySegmentExtension.Merge(electricSegments);
            //マージ前のセグメントを削除する
            for (var i = 0; i < electricSegments.Count; i++)
            {
                segmentDatastore.RemoveEnergySegment(electricSegments[i]);
                electricSegments[i] = null;
            }
            
            //マージ後のセグメントを追加する
            segmentDatastore.SetEnergySegment(mergedElectricSegment);
            
            return mergedElectricSegment;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/IBlockTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public interface IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo);
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo);
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/IWorldBlockUpdateEvent.cs
```cs
using System;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public interface IWorldBlockUpdateEvent
    {
        public IObservable<BlockUpdateProperties> OnBlockPlaceEvent { get; }
        public IObservable<BlockUpdateProperties> OnBlockRemoveEvent { get; }
        
        /// <summary>
        ///     特定の座標にブロックが置かれた時のイベントを購読する
        /// </summary>
        public IDisposable SubscribePlace(Vector3Int subscribePos, Action<BlockUpdateProperties> blockPlaceEvent);
        
        /// <summary>
        ///     特定の座標にブロックが削除された時のイベントを購読する
        /// </summary>
        public IDisposable SubscribeRemove(Vector3Int subscribePos, Action<BlockUpdateProperties> blockPlaceEvent);
    }
    
    public class BlockUpdateProperties
    {
        public Vector3Int Pos { get; }
        public WorldBlockData BlockData { get; }
        
        public BlockUpdateProperties(Vector3Int pos, WorldBlockData blockData)
        {
            Pos = pos;
            BlockData = blockData;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningMiningCompleteState.cs
```cs
using Client.Game.InGame.Context;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.SoundEffect;
using Mooresmaster.Model.MapObjectsModule;
using UnityEngine;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningMiningCompleteState : IMapObjectMiningState
    {
        private readonly MapObjectGameObject _completedMapObjectGameObject;
        private readonly int _attackDamage;
        
        public MapObjectMiningMiningCompleteState(MapObjectGameObject completedMapObjectGameObject, int attackDamage)
        {
            _completedMapObjectGameObject = completedMapObjectGameObject;
            _attackDamage = attackDamage;
        }
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            var masterElement = _completedMapObjectGameObject.MapObjectMasterElement;
            
            PlaySoundEffect(masterElement);
            
            var instanceId = _completedMapObjectGameObject.InstanceId;
            ClientContext.VanillaApi.SendOnly.AttackMapObject(instanceId, _attackDamage);
            
            return context.CurrentFocusMapObjectGameObject == null
                ? new MapObjectMiningIdleState()
                : new MapObjectMiningFocusState();
        }
        
        
        void PlaySoundEffect(MapObjectMasterElement masterElement)
        {
            SoundEffectType soundEffectType;
            switch (masterElement.SoundEffectType)
            {
                case MapObjectMasterElement.SoundEffectTypeConst.stone:
                    soundEffectType = SoundEffectType.DestroyStone;
                    break;
                case MapObjectMasterElement.SoundEffectTypeConst.tree:
                    soundEffectType = SoundEffectType.DestroyTree;
                    break;
                default:
                    soundEffectType = SoundEffectType.DestroyStone;
                    Debug.LogError("採掘音が設定されていません");
                    break;
            }
            
            SoundEffectManager.Instance.PlaySoundEffect(soundEffectType);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaElectricPoleTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.ElectricPole;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaElectricPoleTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var transformer = new VanillaElectricPoleComponent(blockInstanceId);
            var components = new List<IBlockComponent>
            {
                transformer,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var transformer = new VanillaElectricPoleComponent(blockInstanceId);
            var components = new List<IBlockComponent>
            {
                transformer,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/MapObjectUpdateEventPacket.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using MessagePack;

namespace Server.Event.EventReceive
{
    /// <summary>
    ///     Mapオブジェクトが破壊など、更新されたらその情報を伝えるためのパケット
    /// </summary>
    public class MapObjectUpdateEventPacket
    {
        public const string EventTag = "va:event:mapObjectUpdate";
        private readonly EventProtocolProvider _eventProtocolProvider;
        private readonly IMapObjectDatastore _mapObjectDatastore;
        
        public MapObjectUpdateEventPacket(IMapObjectDatastore mapObjectDatastore,
            EventProtocolProvider eventProtocolProvider)
        {
            _mapObjectDatastore = mapObjectDatastore;
            _eventProtocolProvider = eventProtocolProvider;
            
            _mapObjectDatastore.OnDestroyMapObject += OnDestroyMapObject;
        }
        
        private void OnDestroyMapObject(IMapObject mapObject)
        {
            var messagePack = new MapObjectUpdateEventMessagePack(MapObjectUpdateEventMessagePack.DestroyEventType, mapObject.InstanceId);
            var data = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, data);
        }
    }
    
    [MessagePackObject]
    public class MapObjectUpdateEventMessagePack
    {
        public const string DestroyEventType = "destroy";
        
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public MapObjectUpdateEventMessagePack()
        {
        }
        
        public MapObjectUpdateEventMessagePack(string eventType, int instanceId)
        {
            EventType = eventType;
            InstanceId = instanceId;
        }
        
        [Key(0)] public string EventType { get; set; }
        
        [Key(1)] public int InstanceId { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/MinerSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Inventory;
using Core.Master;
using Game.Block.Blocks.Miner;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    public class MinerSaveLoadTest
    {
        
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;
            var minerGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.ElectricMinerId).BlockGuid;
            
            var minerPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var originalMiner = blockFactory.Create(ForUnitTestModBlockId.ElectricMinerId, new BlockInstanceId(1), minerPosInfo);
            var originalMinerComponent = originalMiner.GetComponent<VanillaMinerProcessorComponent>();
            var originalRemainingMillSecond = 0.35;
            
            var inventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(originalMinerComponent);
            inventory.SetItem(0, new ItemId(1), 1);
            inventory.SetItem(2, new ItemId(4), 1);
            typeof(VanillaMinerProcessorComponent).GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                .SetValue(originalMinerComponent, originalRemainingMillSecond);
            
            
            var json = originalMiner.GetSaveState();
            Debug.Log(json);
            
            
            var loadedMiner = blockFactory.Load(minerGuid, new BlockInstanceId(1), json, minerPosInfo);
            var loadedMinerComponent = loadedMiner.GetComponent<VanillaMinerProcessorComponent>();
            var loadedInventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(originalMinerComponent);
            var loadedRemainingMillSecond =
                (double)typeof(VanillaMinerProcessorComponent)
                    .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);
            
            Assert.AreEqual(inventory.GetItem(0), loadedInventory.GetItem(0));
            Assert.AreEqual(inventory.GetItem(1), loadedInventory.GetItem(1));
            Assert.AreEqual(inventory.GetItem(2), loadedInventory.GetItem(2));
            Assert.AreEqual(originalRemainingMillSecond, loadedRemainingMillSecond);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/ProviderChest/CraftChainerProviderChestComponent.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Block.Blocks.Chest;
using Game.CraftChainer.CraftNetwork;
using Newtonsoft.Json;
using UniRx;

namespace Game.CraftChainer.BlockComponent.ProviderChest
{
    public class CraftChainerProviderChestComponent : ICraftChainerNode
    {
        public CraftChainerNodeId NodeId { get; }
        public IReadOnlyList<IItemStack> Inventory => _vanillaChestComponent.InventoryItems;
        private VanillaChestComponent _vanillaChestComponent;
        
        public CraftChainerProviderChestComponent()
        {
            NodeId = CraftChainerNodeId.Create();
        }
        public CraftChainerProviderChestComponent(Dictionary<string, string> componentStates) : this()
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerProviderChestComponentJsonObject>(state);
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        public void SetInitialVanillaChestComponent(VanillaChestComponent vanillaChestComponent)
        {
            _vanillaChestComponent = vanillaChestComponent;
        }
        
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public string SaveKey { get; } = typeof(CraftChainerProviderChestComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerProviderChestComponentJsonObject(this));
        }
    }
    
    public class ChainerProviderChestComponentJsonObject
    {
        [JsonProperty("nodeId")] public int NodeId { get; set; }
        
        public ChainerProviderChestComponentJsonObject(){}
        public ChainerProviderChestComponentJsonObject(CraftChainerProviderChestComponent component)
        {
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/BlockPlaceEventPacketTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;
using Random = System.Random;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class BlockPlaceEventPacketTest
    {
        //ブロックを設置しなかった時何も返ってこないテスト
        [Test]
        public void DontBlockPlaceTest()
        {
            var (packetResponse, _) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            List<List<byte>> response = packetResponse.GetPacketResponse(EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        //ブロックを0個以上設置した時にブロック設置イベントが返ってくるテスト
        [Test]
        public void BlockPlaceEvent()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDataStore = ServerContext.WorldBlockDatastore;
            
            
            //イベントキューにIDを登録する
            List<List<byte>> response = packetResponse.GetPacketResponse(EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            
            var random = new Random(1410);
            
            //ランダムな位置にブロックを設置する
            var blocks = new List<TestBlockData>();
            for (var j = 0; j < 10; j++)
            {
                var x = random.Next(-10000, 10000);
                var y = random.Next(-10000, 10000);
                var pos = new Vector3Int(x, y);
                var blockId = random.Next(1, 20);
                var direction = random.Next(0, 4);
                
                //設置したブロックを保持する
                blocks.Add(new TestBlockData(pos, (BlockId)blockId, direction));
                //ブロックの設置
                worldBlockDataStore.TryAddBlock((BlockId)blockId, pos, (BlockDirection)direction, out _);
            }
            
            
            //イベントパケットをリクエストする
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            
            //返ってきたイベントパケットと設置したブロックを照合し、あったら削除する
            foreach (var r in eventMessagePack.Events)
            {
                var b = AnalysisResponsePacket(r.Payload);
                for (var j = 0; j < blocks.Count; j++)
                    if (b.Equals(blocks[j]))
                        blocks.RemoveAt(j);
            }
            
            //設置したブロックリストが残ってなければすべてのイベントが返ってきた事がわかる
            Assert.AreEqual(0, blocks.Count);
            
            
            //イベントのリクエストを送ったので次は何も返ってこないテスト
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        private TestBlockData AnalysisResponsePacket(byte[] payload)
        {
            var data = MessagePackSerializer.Deserialize<PlaceBlockEventMessagePack>(payload).BlockData;
            
            return new TestBlockData(data.BlockPos, data.BlockId, data.Direction);
        }
        
        private List<byte> EventRequestData(int plyaerID)
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(plyaerID)).ToList();
        }
        
        private class TestBlockData
        {
            public readonly BlockDirection BlockDirection;
            public readonly BlockId id;
            public readonly int X;
            public readonly int Y;
            
            public TestBlockData(Vector3Int pos, BlockId id, int blockDirectionNum)
            {
                X = pos.x;
                Y = pos.y;
                this.id = id;
                BlockDirection = (BlockDirection)blockDirectionNum;
            }
            
            public override bool Equals(object? obj)
            {
                var b = obj as TestBlockData;
                return
                    b.id == id &&
                    b.X == X &&
                    b.Y == Y &&
                    b.BlockDirection == BlockDirection;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/Util/MaterialExtension.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Client.Common.Util
{
    public static class MaterialExtension
    {
        private static readonly Material urpMaterial = (Material)Resources.Load("URPLit");
        private static readonly Dictionary<string, string> standardToUrpColor = new() { { "_Color", "_BaseColor" }, { "_EmissionColor", "_EmissionColor" } };
        private static readonly Dictionary<string, string> standardToUrpTexture = new() { { "_MainTex", "_BaseMap" }, { "_BumpMap", "_BumpMap" }, { "_MetallicGlossMap", "_MetallicGlossMap" }, { "_ParallaxMap", "_ParallaxMap" }, { "_OcclusionMap", "_OcclusionMap" } };
        private static readonly Dictionary<string, string> standardToFloat = new() { { "_Metallic", "_Metallic" }, { "_Glossiness", "_Smoothness" } };
        
        public static Material StandardToUrpLit(this Material material)
        {
            if (material.shader.name != "Standard")
            {
                Debug.Log("このマテリアルはStandardではありません :" + material.name);
                return null;
            }
            
            var newMaterial = new Material(urpMaterial);
            newMaterial = CopyProperties(material, newMaterial, standardToUrpColor, standardToUrpTexture, standardToFloat);
            
            return newMaterial;
        }
        
        
        private static Material CopyProperties(Material material, Material newMaterial, Dictionary<string, string> colorIndex, Dictionary<string, string> textureIndex, Dictionary<string, string> floatIndex)
        {
            newMaterial.name = material.name;
            foreach (var index in colorIndex) newMaterial.SetColor(index.Value, material.GetColor(index.Key));
            foreach (var index in colorIndex) newMaterial.SetColor(index.Value, material.GetColor(index.Key));
            foreach (var index in textureIndex)
            {
                newMaterial.SetTexture(index.Value, material.GetTexture(index.Key));
                newMaterial.SetTextureOffset(index.Value, material.GetTextureOffset(index.Key));
                newMaterial.SetTextureScale(index.Value, material.GetTextureScale(index.Key));
            }
            
            foreach (var index in floatIndex) newMaterial.SetFloat(index.Value, material.GetFloat(index.Key));
            return newMaterial;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/UIHighlight/UIHighlightTutorialView.cs
```cs
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.Tutorial.UIHighlight
{
    public class UIHighlightTutorialView : MonoBehaviour, ITutorialView
    {
        [SerializeField] private GameObject highlightObject;
        [SerializeField] private RectTransform highlightImage;
        [SerializeField] private TMP_Text highlightText;
        
        private UIHighlightTutorialTargetObject _highlightTutorialTargetObject;
        
        public void SetTargetObject(UIHighlightTutorialTargetObject tutorialTargetObject, string text)
        {
            _highlightTutorialTargetObject = tutorialTargetObject;
            highlightText.text = text;
        }
        
        private void Update()
        {
            SyncRectTransform();
        }
        
        private void SyncRectTransform()
        {
            highlightObject.SetActive(_highlightTutorialTargetObject.ActiveSelf);
            
            //一旦親を変更し、また親を戻すことによって、ローカル座標を正しく反映することができる
            var currentParent = highlightImage.parent;
            var targetRect = _highlightTutorialTargetObject.RectTransform;
            highlightImage.SetParent(targetRect.parent);
            
            //変更した上で、データを反映する
            highlightImage.position = targetRect.position;
            highlightImage.rotation = targetRect.rotation;
            highlightImage.localScale = targetRect.localScale;
            
            highlightImage.pivot = targetRect.pivot;
            highlightImage.anchoredPosition = targetRect.anchoredPosition;
            highlightImage.anchorMax = targetRect.anchorMax;
            highlightImage.anchorMin = targetRect.anchorMin;
            highlightImage.offsetMax = targetRect.offsetMax;
            highlightImage.offsetMin = targetRect.offsetMin;
            highlightImage.sizeDelta = targetRect.sizeDelta;
            highlightImage.anchoredPosition3D = targetRect.anchoredPosition3D;
            
            //元の親に戻す
            highlightImage.SetParent(currentParent);
        }
        
        public void CompleteTutorial()
        {
            Destroy(gameObject);
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/GearStateChangeProcessorInspector.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Game.Gear.Common;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(GearStateChangeProcessor))]
public class GearStateChangeProcessorInspector : Editor
{
    [SerializeField] private float simulateRpm = 60;
    [SerializeField] private bool simulateIsClockwise = true;
    private bool _isSimulating = false;
    
    private readonly Dictionary<Transform, Quaternion> _initialRotations = new();

    public override void OnInspectorGUI()
    {
        var processor = target as GearStateChangeProcessor;
        if (processor == null)
        {
            return;
        }
        
        GUILayout.BeginVertical("Editor only info", "window");
        
        EditorGUILayout.LabelField("Simulate Gear State", EditorStyles.boldLabel);
        ShowSimulateProperty();
        ShowSimulateButton();
        
        GUILayout.Space(10);
        
        ShowCurrentState();

        GUILayout.EndVertical();
        GUILayout.Space(10);

        base.OnInspectorGUI();
        
        #region Internal
        
        void ShowSimulateProperty()
        {
            // RPMと回転方向のプロパティ
            // RPM and rotation direction properties
            simulateRpm = EditorGUILayout.FloatField("RPM", simulateRpm);
            simulateIsClockwise = EditorGUILayout.Toggle("Is Clockwise", simulateIsClockwise);
        }
        
        void ShowSimulateButton()
        {
            // シミュレーション開始/停止ボタン
            // Simulation start/stop button
            if (_isSimulating)
            {
                if (GUILayout.Button("Stop Simulate"))
                {
                    foreach (var rotationInfo in processor.RotationInfos)
                    {
                        if (_initialRotations.TryGetValue(rotationInfo.RotationTransform, out var initialRotation))
                        {
                            rotationInfo.RotationTransform.rotation = initialRotation;
                        }
                    }
                    _isSimulating = false;
                    EditorApplication.update -= OnEditorUpdate;
                }
            }
            else
            {
                if (GUILayout.Button("Start Simulate"))
                {
                    _initialRotations.Clear();
                    foreach (var rotationInfo in processor.RotationInfos)
                    {
                        _initialRotations.Add(rotationInfo.RotationTransform, rotationInfo.RotationTransform.rotation);
                    }
                    _isSimulating = true;
                    EditorApplication.update += OnEditorUpdate;
                }
            }
        }
        
        void ShowCurrentState()
        {
            // 現在の状態を表示
            // Display the current state
            EditorGUILayout.LabelField("Current Gear State", EditorStyles.boldLabel);
            if (processor.CurrentGearState == null)
            {
                EditorGUILayout.LabelField("State data is null");
            }
            else
            {
                EditorGUILayout.LabelField($"RPM: {processor.CurrentGearState.CurrentRpm}");
                EditorGUILayout.LabelField($"Is Clockwise: {processor.CurrentGearState.IsClockwise}");
            }
        }
        
        
  #endregion
    }

    private void OnEditorUpdate()
    {
        if (!_isSimulating)
        {
            EditorApplication.update -= OnEditorUpdate;
            return;
        }

        var processor = target as GearStateChangeProcessor;
        if (processor != null)
        {
            Rotate(processor);
        }

        // Repaint the inspector to reflect changes
        Repaint();
    }

    private void Rotate(GearStateChangeProcessor processor)
    {
        var state = new GearStateDetail(simulateRpm, simulateIsClockwise);
        processor.Rotate(state);
    }
    
    private void OnDisable()
    {
        EditorApplication.update -= OnEditorUpdate;
    }
    private void OnDestroy()
    {
        EditorApplication.update -= OnEditorUpdate;
    }
}

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/GetMapObjectProtocolTest.cs
```cs
using System.Linq;
using Game.Context;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.MapObjectAcquisitionProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class GetMapObjectProtocolTest
    {
        private const int PlayerId = 0;
        
        [Test]
        public void GetMapObjectProtocol_DestroyAndAddToInventory_Test()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
            var worldMapObjectDataStore = serviceProvider.GetService<IMapObjectDatastore>();
            var itemFactory = ServerContext.ItemStackFactory;
            
            var mapObject = worldMapObjectDataStore.MapObjects[0];
            
            var playerInventory = playerInventoryDataStore.GetInventoryData(PlayerId).MainOpenableInventory;
            var itemSlot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            
            
            // 少ないダメージでアイテムが入手できないことのテスト
            var messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 5);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            Assert.AreEqual(itemFactory.CreatEmpty(), playerInventory.GetItem(itemSlot));
            
            
            // アイテムがもらえるだけのダメージを与えてアイテムを入手できることのテスト
            messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 5);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            var earnItem = mapObject.EarnItems[0];
            Assert.AreEqual(earnItem, playerInventory.GetItem(itemSlot));
            playerInventory.SetItem(itemSlot, itemFactory.CreatEmpty()); // アイテムをリセット
            
            
            //大きくダメージを与えて2倍のアイテムを入手できることのテスト
            messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 20);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            Assert.AreEqual(earnItem.Id, playerInventory.GetItem(itemSlot).Id);
            Assert.AreEqual(earnItem.Count * 2, playerInventory.GetItem(itemSlot).Count);
            
            //破壊されていることのテスト
            Assert.IsTrue(mapObject.IsDestroyed);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/CraftChainerEntryPoint.cs
```cs
using Game.Context;
using Game.CraftChainer.BlockComponent.Template;
using Game.CraftChainer.CraftNetwork;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Game.CraftChainer
{
    public static class CraftChainerEntryPoint
    {
        public static void Entry()
        {
            // block template register
            var blockFactory = ServerContext.BlockFactory;    
            blockFactory.RegisterTemplateIBlock(BlockTypeConst.CraftChainerCrafter, new CraftChainerCrafterTemplate());
            blockFactory.RegisterTemplateIBlock(BlockTypeConst.CraftChainerTransporter, new CraftChainerTransporterTemplate());
            blockFactory.RegisterTemplateIBlock(BlockTypeConst.CraftChainerProviderChest, new CraftChainerProviderChestTemplate());
            blockFactory.RegisterTemplateIBlock(BlockTypeConst.CraftChainerMainComputer, new CraftChainerMainComputerTemplate());
            
            // manager init
            new CraftChainerMainComputerManager();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/RendererMaterialReplacerController.cs
```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class RendererMaterialReplacerController
    {
        private readonly List<RendererMaterialReplacer> _rendererMaterialReplacers;
        
        public RendererMaterialReplacerController(GameObject targetObject)
        {
            _rendererMaterialReplacers = new List<RendererMaterialReplacer>();
            var ignoreParents = targetObject.GetComponentsInChildren<IgnoreRendererMaterialReplacer>(true);
            
            foreach (var renderer in targetObject.GetComponentsInChildren<Renderer>())
            {
                // レンダラーが IgnoreRendererMaterialReplacer の子である場合は無視
                // Ignore if the renderer is a child of the IgnoreRendererMaterialReplacer
                var isIgnore = false;
                foreach (var ignoreParent in ignoreParents)
                {
                    isIgnore |= renderer.transform.IsChildOf(ignoreParent.transform);
                }
                if (isIgnore) continue;
                
                _rendererMaterialReplacers.Add(new RendererMaterialReplacer(renderer));
            }
        }
        
        public void CopyAndSetMaterial(Material placeMaterial)
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.CopyAndSetMaterial(placeMaterial));
        }
        
        public void SetPlaceMaterialProperty(string propertyName, float value)
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.SetPlaceMaterialProperty(propertyName, value));
        }
        
        public void SetColor(string propertyName, Color color)
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.SetColor(propertyName, color));
        }
        
        public void ResetMaterial()
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.ResetMaterial());
        }
        
        public void DestroyMaterial()
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.DestroyMaterial());
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/BlockStateProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Context;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Event.EventReceive;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class BlockStateProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:blockState";
        
        public BlockStateProtocol(ServiceProvider serviceProvider)
        {
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestBlockStateProtocolMessagePack>(payload.ToArray());
            
            var block = ServerContext.WorldBlockDatastore.GetBlock(data.Position.Vector3Int);
            if (block == null)
            {
                return new ResponseBlockStateProtocolMessagePack(null);
            }
            
            var blockState = block.GetBlockState();
            
            return new ResponseBlockStateProtocolMessagePack(new BlockStateMessagePack(blockState, data.Position.Vector3Int));
        }
        
        [MessagePackObject]
        public class RequestBlockStateProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack Position { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RequestBlockStateProtocolMessagePack() { }
            
            public RequestBlockStateProtocolMessagePack(Vector3Int pos)
            {
                Tag = ProtocolTag;
                Position = new Vector3IntMessagePack(pos);
            }
        }
        
        [MessagePackObject]
        public class ResponseBlockStateProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public BlockStateMessagePack State { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseBlockStateProtocolMessagePack() { }
            
            public ResponseBlockStateProtocolMessagePack(BlockStateMessagePack state)
            {
                Tag = ProtocolTag;
                State = state;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock CreateGear(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var configParam = blockMasterElement.BlockParam as GearBlockParam;
            var connectSetting = configParam.Gear.GearConnects;
            
            var gearConnector = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var gearComponent = new GearComponent(configParam, blockInstanceId, gearConnector);
            
            var components = new List<IBlockComponent>
            {
                gearComponent,
                gearConnector,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Mod.Loader/ModMetaJson.cs
```cs
using Newtonsoft.Json;

namespace Mod.Loader
{
    [JsonObject("ModMeta")]
    public class ModMetaJson
    {
        [JsonProperty("author")] private string _modAuthor;
        [JsonProperty("description")] private string _modDescription;
        
        
        [JsonProperty("id")] private string _modId;
        [JsonProperty("name")] private string _modName;
        [JsonProperty("version")] private string _modVersion;
        
        /// <summary>
        ///     内部的にmodIdは 製作者名 + : + modId として扱う
        /// </summary>
        public string ModId => _modAuthor + ":" + _modId;
        
        public string ModName => _modName;
        public string ModVersion => _modVersion;
        public string ModAuthor => _modAuthor;
        public string ModDescription => _modDescription;
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/IgnoreRendererMaterialReplacerInspector.cs
```cs
using Client.Game.InGame.Block;
using UnityEditor;

[CustomEditor(typeof(IgnoreRendererMaterialReplacer))]
public class IgnoreRendererMaterialReplacerInspector : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        //TODO i18n対応
        
        EditorGUILayout.HelpBox("このコンポーネント以下のレンダラーはマテリアル置き換えされません", MessageType.Info);
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/GrabInventoryUpdateEventPacket.cs
```cs
using System;
using Core.Item.Interface;
using Game.PlayerInventory.Interface.Event;
using MessagePack;
using Server.Util.MessagePack;

namespace Server.Event.EventReceive
{
    public class GrabInventoryUpdateEventPacket
    {
        public const string EventTag = "va:event:grabInvUpdate";
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public GrabInventoryUpdateEventPacket(IGrabInventoryUpdateEvent grabInventoryUpdateEvent,
            EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            grabInventoryUpdateEvent.Subscribe(ReceivedEvent);
        }
        
        
        private void ReceivedEvent(PlayerInventoryUpdateEventProperties playerInventoryUpdateEvent)
        {
            var messagePack = new GrabInventoryUpdateEventMessagePack(playerInventoryUpdateEvent.ItemStack);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddEvent(playerInventoryUpdateEvent.PlayerId, EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class GrabInventoryUpdateEventMessagePack
    {
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public GrabInventoryUpdateEventMessagePack()
        {
        }
        
        public GrabInventoryUpdateEventMessagePack(IItemStack item)
        {
            Item = new ItemMessagePack(item);
        }
        
        [Key(0)] public ItemMessagePack Item { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaSimpleGearGeneratorTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaSimpleGearGeneratorTemplate : IBlockTemplate
    {
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock CreateGear(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var configParam = blockMasterElement.BlockParam as SimpleGearGeneratorBlockParam;
            var connectSetting = configParam.Gear.GearConnects;
            
            var blockComponent = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var gearComponent = new SimpleGearGeneratorComponent(configParam, blockInstanceId, blockComponent);
            
            var components = new List<IBlockComponent>
            {
                gearComponent,
                blockComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/CraftChain/CraftingSolverItem.cs
```cs
using System;
using Core.Master;
using MessagePack;
using Newtonsoft.Json;

namespace Game.CraftChainer.CraftChain
{
    public class CraftingSolverItem
    {
        public readonly ItemId ItemId;
        public readonly int Count;
        
        public CraftingSolverItem(ItemId itemId, int count)
        {
            ItemId = itemId;
            Count = count;
        }
    }
    
    [JsonObject, MessagePackObject]
    public class CraftingSolverItemJsonObjectMessagePack
    {
        [JsonProperty("itemGuid"), Key(0)] public string ItemGuid;
        [JsonProperty("count"), Key(1)] public int Count;
        
        public CraftingSolverItemJsonObjectMessagePack() { }
        public CraftingSolverItemJsonObjectMessagePack(CraftingSolverItem craftingSolverItem)
        {
            ItemGuid = MasterHolder.ItemMaster.GetItemMaster(craftingSolverItem.ItemId).ItemGuid.ToString();
            Count = craftingSolverItem.Count;
        }
        
        public CraftingSolverItem ToCraftingSolverItem()
        {
            var guid = new Guid(ItemGuid);
            var itemId = MasterHolder.ItemMaster.GetItemId(guid);
            return new CraftingSolverItem(itemId, Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BackgroundSkit/BackgroundSkitManager.cs
```cs
using Client.Game.InGame.UI.UIState;
using Client.Skit.Define;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Game.InGame.BackgroundSkit
{
    public class BackgroundSkitManager : MonoBehaviour
    {
        [SerializeField] private BackgroundSkitUI backgroundSkitUI;
        [SerializeField] private UIStateControl uiStateControl;
        
        [SerializeField] private VoiceDefine voiceDefine;
        
        public async UniTask StartBackgroundSkit(TextAsset storyCsv)
        {
            // UIステートがGameScreenになるまで待機
            await UniTask.WaitUntil(() => uiStateControl.CurrentState == UIStateEnum.GameScreen);
            
            backgroundSkitUI.SetActive(true);
            
            var lines = storyCsv.text.Split('\n');
            
            foreach (var line in lines)
            {
                var values = line.Split(',');
                var characterName = values[0];
                var text = values[1].Replace("\\n", "\n");
                
                var voice = voiceDefine.GetVoiceClip(characterName, text);
                
                await backgroundSkitUI.SetText(characterName, text, voice);
            }
            
            backgroundSkitUI.SetActive(false);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/AllBlockStateProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Context;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Event.EventReceive;

namespace Server.Protocol.PacketResponse
{
    public class AllBlockStateProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:allBockState";
        
        public AllBlockStateProtocol(ServiceProvider serviceProvider)
        {
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var stateList = new List<BlockStateMessagePack>();
            foreach (var block in ServerContext.WorldBlockDatastore.BlockMasterDictionary.Values)
            {
                var pos = block.BlockPositionInfo.OriginalPos;
                var state = block.Block.GetBlockState();
                if (state != null) stateList.Add(new BlockStateMessagePack(state, pos));
            }
            
            return new ResponseAllBlockStateProtocolMessagePack(stateList);
        }
        
        [MessagePackObject]
        public class RequestAllBlockStateProtocolMessagePack : ProtocolMessagePackBase
        {
            public RequestAllBlockStateProtocolMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
        
        [MessagePackObject]
        public class ResponseAllBlockStateProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<BlockStateMessagePack> StateList { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseAllBlockStateProtocolMessagePack() { }
            
            public ResponseAllBlockStateProtocolMessagePack(List<BlockStateMessagePack> stateList)
            {
                Tag = ProtocolTag;
                StateList = stateList;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/GameScreenState.cs
```cs
using Client.Game.GameDebug;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.Control;
using Client.Game.Skit;
using Client.Input;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class GameScreenState : IUIState
    {
        private readonly IBlockPlacePreview _blockPlacePreview;
        private readonly InGameCameraController _inGameCameraController;
        private readonly SkitManager _skitManager;
        
        public GameScreenState(IBlockPlacePreview blockPlacePreview, SkitManager skitManager, InGameCameraController inGameCameraController)
        {
            _blockPlacePreview = blockPlacePreview;
            _skitManager = skitManager;
            _inGameCameraController = inGameCameraController;
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.PlayerInventory;
            if (InputManager.UI.OpenMenu.GetKeyDown) return UIStateEnum.PauseMenu;
            if (BlockClickDetect.IsClickOpenableBlock(_blockPlacePreview)) return UIStateEnum.BlockInventory;
            if (InputManager.UI.BlockDelete.GetKeyDown) return UIStateEnum.DeleteBar;
            if (_skitManager.IsPlayingSkit) return UIStateEnum.Story;
            //TODO InputSystemのリファクタ対象
            if (UnityEngine.Input.GetKeyDown(KeyCode.B)) return UIStateEnum.PlaceBlock;
            if (DebugInfoStore.EnableBlockDebugMode) return UIStateEnum.BlockDebug;
            
            return UIStateEnum.Current;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            InputManager.MouseCursorVisible(false);
            _inGameCameraController.SetControllable(true);
        }
        
        public void OnExit()
        {
            _inGameCameraController.SetControllable(false);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/PlayerMainInventoryUpdateTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.EventProtocol;
using static Server.Protocol.PacketResponse.InventoryItemMoveProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class PlayerMainInventoryUpdateTest
    {
        private const int PlayerId = 0;
        
        [Test]
        public void UpdateTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var response = packetResponse.GetPacketResponse(EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            
            //インベントリにアイテムを追加
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0);
            var itemStackFactory = ServerContext.ItemStackFactory;
            playerInventoryData.MainOpenableInventory.SetItem(5, itemStackFactory.Create(new ItemId(1), 5));
            
            //追加時のイベントのキャッチ
            response = packetResponse.GetPacketResponse(EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var data = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(5, data.Slot);
            Assert.AreEqual(1, data.Item.Id.AsPrimitive());
            Assert.AreEqual(5, data.Item.Count);
            
            
            //インベントリ内のアイテムの移動を実際に移動のプロトコルを用いてテストする
            //分割のイベントのテスト
            packetResponse.GetPacketResponse(PlayerInventoryItemMove(true, 5, 3));
            packetResponse.GetPacketResponse(PlayerInventoryItemMove(false, 4, 3));
            
            response = packetResponse.GetPacketResponse(EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            
            Assert.AreEqual(4, eventMessagePack.Events.Count);
            
            var grabUp = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            var setMainInventory = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[1].Payload);
            var outMainInventory = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[2].Payload);
            var grabDown = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(eventMessagePack.Events[3].Payload);
            
            Assert.AreEqual(5, setMainInventory.Slot); //移動時のスロット確認
            Assert.AreEqual(4, outMainInventory.Slot);
            
            Assert.AreEqual(1, grabUp.Item.Id.AsPrimitive()); //アイテムIDの確認
            Assert.AreEqual(1, setMainInventory.Item.Id.AsPrimitive());
            Assert.AreEqual(1, outMainInventory.Item.Id.AsPrimitive());
            Assert.AreEqual(0, grabDown.Item.Id.AsPrimitive());
            
            Assert.AreEqual(3, grabUp.Item.Count); //アイテム数の確認
            Assert.AreEqual(2, setMainInventory.Item.Count);
            Assert.AreEqual(3, outMainInventory.Item.Count);
            Assert.AreEqual(0, grabDown.Item.Count);
            
            
            //合成のテスト
            packetResponse.GetPacketResponse(PlayerInventoryItemMove(true, 4, 3));
            packetResponse.GetPacketResponse(PlayerInventoryItemMove(false, 5, 3));
            
            response = packetResponse.GetPacketResponse(EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            
            Assert.AreEqual(4, eventMessagePack.Events.Count);
            grabUp = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            setMainInventory = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[1].Payload);
            outMainInventory = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[2].Payload);
            grabDown = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(eventMessagePack.Events[3].Payload);
            
            Assert.AreEqual(4, setMainInventory.Slot); //移動時のスロット確認
            Assert.AreEqual(5, outMainInventory.Slot);
            
            Assert.AreEqual(1, grabUp.Item.Id.AsPrimitive()); //アイテムIDの確認
            Assert.AreEqual(0, setMainInventory.Item.Id.AsPrimitive());
            Assert.AreEqual(1, outMainInventory.Item.Id.AsPrimitive());
            Assert.AreEqual(0, grabDown.Item.Id.AsPrimitive());
            
            Assert.AreEqual(3, grabUp.Item.Count); //アイテム数の確認
            Assert.AreEqual(0, setMainInventory.Item.Count);
            Assert.AreEqual(5, outMainInventory.Item.Count);
            Assert.AreEqual(0, grabDown.Item.Count);
        }
        
        
        private List<byte> EventRequestData(int plyaerID)
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(plyaerID)).ToList();
            ;
        }
        
        private List<byte> PlayerInventoryItemMove(bool toGrab, int inventorySlot, int itemCount)
        {
            InventoryItemMoveProtocolMessagePack messagePack;
            if (toGrab)
            {
                var from = new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory);
                var to = new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory);
                messagePack = new InventoryItemMoveProtocolMessagePack(PlayerId, itemCount, ItemMoveType.SwapSlot,
                    from, inventorySlot, to, 0);
            }
            else
            {
                var from = new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory);
                var to = new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory);
                messagePack = new InventoryItemMoveProtocolMessagePack(PlayerId, itemCount, ItemMoveType.SwapSlot,
                    from, 0, to, inventorySlot);
            }
            
            return MessagePackSerializer.Serialize(messagePack).ToList();
        }
    }
}
```

schema/machineRecipes.json
```cs
{
  "$id": "machineRecipes",
  "type": "object",
  "isDefaultOpen": true,

  "properties": {

    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "MachineRecipeMasterElement",

      "items": {
        "type": "object",
        "properties": {

          "machineRecipeGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "blockGuid": {
            "type": "string",
            "format": "uuid",
            "foreignKey": "blocks:blockGuid:name"
          },
          "time": {
            "type": "number",
            "default": 1
          },
          "inputItems": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "itemGuid": {
                  "type": "string",
                  "format": "uuid",
                  "foreignKey": "items:itemGuid:name"
                },
                "count": {
                  "type": "integer",
                  "default": 1
                }
              }
            }
          },
          "outputItems": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "itemGuid": {
                  "type": "string",
                  "format": "uuid",
                  "foreignKey": "items:itemGuid:name"
                },
                "count": {
                  "type": "integer",
                  "default": 1
                },
                "percent": {
                  "type": "number",
                  "default": 1,
                  "minimum": 0,
                  "maximum": 1
                }
              }
            }
          }
        }
      }
    }
  }
}

```

moorestech_client/Assets/Scripts/Client.Game/InGame/Control/BlockClickDetect.cs
```cs
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Input;
using UnityEngine;
using UnityEngine.EventSystems;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Client.Game.InGame.Control
{
    public static class BlockClickDetect
    {
        public static bool TryGetCursorOnBlockPosition(out Vector3Int position)
        {
            position = Vector3Int.zero;
            
            if (!TryGetCursorOnBlock(out var blockObject)) return false;
            
            
            position = blockObject.BlockPosInfo.OriginalPos;
            
            return true;
        }
        
        public static bool TryGetClickBlockPosition(out Vector3Int position)
        {
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && TryGetCursorOnBlockPosition(out position)) return true;
            
            position = Vector3Int.zero;
            return false;
        }
        
        public static bool TryGetClickBlock(out BlockGameObject blockObject)
        {
            blockObject = null;
            // UIのクリックかどうかを判定
            if (EventSystem.current.IsPointerOverGameObject()) return false;
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && TryGetCursorOnBlock(out blockObject)) return true;
            
            blockObject = null;
            return false;
        }
        
        public static bool IsClickOpenableBlock(IBlockPlacePreview blockPlacePreview)
        {
            if (blockPlacePreview.IsActive) return false; //ブロック設置中の場合は無効
            if (TryGetClickBlock(out var block))
            {
                var openable = block.BlockMasterElement.BlockType is
                    BlockTypeConst.Chest or
                    BlockTypeConst.ElectricMachine or
                    BlockTypeConst.ElectricGenerator or
                    BlockTypeConst.ElectricMiner or
                    BlockTypeConst.GearMachine or
                    BlockTypeConst.GearMiner or 
                    BlockTypeConst.CraftChainerProviderChest or
                    BlockTypeConst.CraftChainerCrafter or
                    BlockTypeConst.CraftChainerMainComputer;
                return openable;
            }
            
            return false;
        }
        
        public static bool TryGetCursorOnBlock(out BlockGameObject blockObject)
        {
            blockObject = null;
            
            var camera = Camera.main;
            if (camera == null) return false;
            
            //TODO InputSystemのリファクタ対象
            var ray = camera.ScreenPointToRay(UnityEngine.Input.mousePosition);
            
            if (!Physics.Raycast(ray, out var hit, 100, LayerConst.BlockOnlyLayerMask)) return false;
            var child = hit.collider.gameObject.GetComponent<BlockGameObjectChild>();
            if (child is null) return false;
            
            
            blockObject = child.BlockGameObject;
            
            return true;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/PacketExchangeManager.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using JetBrains.Annotations;
using MessagePack;
using Server.Protocol;
using UniRx;
using UnityEngine;

namespace Client.Network.API
{
    /// <summary>
    ///     送信されたパケットの応答パケットを<see cref="ServerCommunicator" />から受け取り、呼び出し元に返すクラス
    /// </summary>
    public class PacketExchangeManager
    {
        private readonly PacketSender _packetSender;
        
        private readonly Dictionary<int, ResponseWaiter> _responseWaiters = new();
        
        private int _sequenceId;
        
        public PacketExchangeManager(PacketSender packetSender)
        {
            _packetSender = packetSender;
            TimeOutUpdate().Forget();
        }
        
        private async UniTask TimeOutUpdate()
        {
            while (true)
            {
                for (var i = _responseWaiters.Count - 1; i >= 0; i--)
                {
                    var sequenceId = _responseWaiters.Keys.ElementAt(i);
                    var waiter = _responseWaiters[sequenceId];
                    var time = DateTime.Now - waiter.SendTime;
                    if (time.TotalSeconds < 10) continue;
                    
                    _responseWaiters[sequenceId].WaitSubject.OnNext(null);
                    _responseWaiters.Remove(sequenceId);
                }
                
                await UniTask.Delay(1000);
            }
        }
        
        public async UniTask ExchangeReceivedPacket(List<byte> data)
        {
            var response = MessagePackSerializer.Deserialize<ProtocolMessagePackBase>(data.ToArray());
            var sequence = response.SequenceId;
            
            await UniTask.SwitchToMainThread();
            
            if (!_responseWaiters.ContainsKey(sequence)) return;
            _responseWaiters[sequence].WaitSubject.OnNext(data);
            _responseWaiters.Remove(sequence);
        }
        
        [CanBeNull]
        public async UniTask<TResponse> GetPacketResponse<TResponse>(ProtocolMessagePackBase request, CancellationToken ct) where TResponse : ProtocolMessagePackBase
        {
            SendPacket();
            
            return await WaitReceive();
            
            #region Internal
            
            void SendPacket()
            {
                _sequenceId++;
                request.SequenceId = _sequenceId;
                _packetSender.Send(request);
            }
            
            async UniTask<TResponse> WaitReceive()
            {
                var responseWaiter = new ResponseWaiter(new Subject<List<byte>>());
                _responseWaiters.Add(_sequenceId, responseWaiter);
                
                var receiveData = await responseWaiter.WaitSubject.ToUniTask(true, ct);
                if (receiveData == null)
                {
                    Debug.Log("Receive null");
                    return null;
                }
                
                try
                {
                    return MessagePackSerializer.Deserialize<TResponse>(receiveData.ToArray());
                }
                catch (Exception e)
                {
                    Debug.LogError($"デシリアライズに失敗しました。Tag:{request.Tag}\n{e.Message}\n{e.StackTrace}");
                    Console.WriteLine(e);
                    return null;
                }
            }
            
            #endregion
        }
    }
    
    
    public class ResponseWaiter
    {
        public ResponseWaiter(Subject<List<byte>> waitSubject)
        {
            WaitSubject = waitSubject;
            SendTime = DateTime.Now;
        }
        
        public Subject<List<byte>> WaitSubject { get; }
        public DateTime SendTime { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockComponentManager.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface.Component;
using Game.Block.Interface.ComponentAttribute;

namespace Game.Block.Interface
{
    public interface IBlockComponentManager
    {
        public T GetComponent<T>() where T : IBlockComponent;
        public List<T> GetComponents<T>() where T : IBlockComponent;
        
        public bool ExistsComponent<T>() where T : IBlockComponent;
        
        public bool TryGetComponent<T>(out T component) where T : IBlockComponent;
    }
    
    public class BlockComponentManager : IBlockComponentManager
    {
        private readonly List<IBlockComponent> _blockComponents = new();
        private bool IsDestroy { get; set; }
        
        public T GetComponent<T>() where T : IBlockComponent
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            return (T)_blockComponents.Find(x => x is T);
        }
        
        public List<T> GetComponents<T>() where T : IBlockComponent
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            return _blockComponents.FindAll(x => x is T).Cast<T>().ToList();
        }
        
        public bool ExistsComponent<T>() where T : IBlockComponent
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            return _blockComponents.Exists(x => x is T);
        }
        
        public bool TryGetComponent<T>(out T component) where T : IBlockComponent
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            var result = _blockComponents.Find(x => x is T);
            if (result == null)
            {
                component = default;
                return false;
            }
            
            component = (T)result;
            return true;
        }
        
        public void Destroy()
        {
            IsDestroy = true;
            foreach (var blockComponent in _blockComponents) blockComponent.Destroy();
        }
        
        public void AddComponent(IBlockComponent blockComponent)
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            CheckDisallowMultiple();
            
            _blockComponents.Add(blockComponent);
            
            #region Internal
            
            void CheckDisallowMultiple()
            {
                var componentType = blockComponent.GetType();
                var interfaces = componentType.GetInterfaces();
                
                foreach (var iface in interfaces)
                {
                    var attrs = iface.GetCustomAttributes(typeof(DisallowMultiple), true);
                    if (attrs.Length == 0) continue;
                    
                    if (_blockComponents.Any(c => iface.IsInstanceOfType(c)))
                    {
                        throw new InvalidOperationException($"{iface.Name}は既に追加されています。");
                    }
                }
            }
            
            #endregion
        }
        
        public void AddComponents(IEnumerable<IBlockComponent> blockComponents)
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            foreach (var blockComponent in blockComponents) AddComponent(blockComponent);
        }
        
        public void RemoveComponent(IBlockComponent blockComponent)
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            _blockComponents.Remove(blockComponent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearNetworkId.cs
```cs
using System;
using UnitGenerator;

namespace Game.Gear.Common
{
    [UnitOf(typeof(int))]
    public readonly partial struct GearNetworkId
    {
        private static readonly Random Random = new(123456);
        
        public static GearNetworkId CreateNetworkId()
        {
            // intの最小から最大までの乱数を生成
            return new GearNetworkId(Random.Next(int.MinValue, int.MaxValue));
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetPlayerCoordinateProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Entity.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     プレイヤー座標のプロトコル
    /// </summary>
    public class SetPlayerCoordinateProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:playerCoordinate";
        
        private readonly IEntitiesDatastore _entitiesDatastore;
        
        public SetPlayerCoordinateProtocol(ServiceProvider serviceProvider)
        {
            _entitiesDatastore = serviceProvider.GetService<IEntitiesDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<PlayerCoordinateSendProtocolMessagePack>(payload.ToArray());
            
            //プレイヤーの座標を更新する
            _entitiesDatastore.SetPosition(new EntityInstanceId(data.PlayerId), data.Pos.Vector3);
            
            return null;
        }
        
        
        [MessagePackObject]
        public class PlayerCoordinateSendProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public Vector3MessagePack Pos { get; set; }
            
            public PlayerCoordinateSendProtocolMessagePack(int playerId, Vector3 pos)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Pos = new Vector3MessagePack(pos);
            }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public PlayerCoordinateSendProtocolMessagePack() { }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/GameDebug/DebugParameters.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Client.Game.GameDebug
{
    /// <summary>
    /// デバッグ用のパラメータを管理するクラス
    /// </summary>
    public static class DebugParameters
    {
        static DebugParameters()
        {
            Load();
        }
        
        public static Dictionary<string, bool> BoolDebugParameters { get; private set; } = new();
        public static Dictionary<string, int> IntDebugParameters { get; private set; } = new();
        public static Dictionary<string, string> StringDebugParameters { get; private set; } = new();

        #region Public Accessors

        public static bool GetBool(string key, bool defaultValue)
        {
            return BoolDebugParameters.GetValueOrDefault(key, defaultValue);
        }

        public static void SaveBool(string key, bool value)
        {
            BoolDebugParameters[key] = value;
            Save();
        }

        public static int GetInt(string key, int defaultValue)
        {
            return IntDebugParameters.GetValueOrDefault(key, defaultValue);
        }

        public static void SaveInt(string key, int value)
        {
            IntDebugParameters[key] = value;
            Save();
        }

        public static string GetString(string key, string defaultValue)
        {
            return StringDebugParameters.GetValueOrDefault(key, defaultValue);
        }

        public static void SaveString(string key, string value)
        {
            StringDebugParameters[key] = value;
            Save();
        }

        #endregion

        #region Save / Load
        
        public const string BoolDebugParametersKey = "DebugParameters_Bool";
        public const string IntDebugParametersKey = "DebugParameters_Int";
        public const string StringDebugParametersKey = "DebugParameters_String";

        /// <summary>
        /// デバッグパラメータを PlayerPrefs に保存します。
        /// </summary>
        private static void Save()
        {
            // bool
            var boolDict = new SerializableDictionary<string, bool>(BoolDebugParameters);
            string boolJson = JsonUtility.ToJson(boolDict);
            PlayerPrefs.SetString(BoolDebugParametersKey, boolJson);

            // int
            var intDict = new SerializableDictionary<string, int>(IntDebugParameters);
            string intJson = JsonUtility.ToJson(intDict);
            PlayerPrefs.SetString(IntDebugParametersKey, intJson);

            // string
            var stringDict = new SerializableDictionary<string, string>(StringDebugParameters);
            string stringJson = JsonUtility.ToJson(stringDict);
            PlayerPrefs.SetString(StringDebugParametersKey, stringJson);

            PlayerPrefs.Save();
        }

        /// <summary>
        /// 保存された PlayerPrefs からデバッグパラメータを読み込みます。
        /// </summary>
        private static void Load()
        {
            // bool
            string boolJson = PlayerPrefs.GetString(BoolDebugParametersKey, "");
            if (!string.IsNullOrEmpty(boolJson))
            {
                var boolDict = JsonUtility.FromJson<SerializableDictionary<string, bool>>(boolJson);
                if (boolDict != null)
                {
                    BoolDebugParameters = boolDict.ToDictionary();
                }
            }

            // int
            string intJson = PlayerPrefs.GetString(IntDebugParametersKey, "");
            if (!string.IsNullOrEmpty(intJson))
            {
                var intDict = JsonUtility.FromJson<SerializableDictionary<string, int>>(intJson);
                if (intDict != null)
                {
                    IntDebugParameters = intDict.ToDictionary();
                }
            }

            // string
            string stringJson = PlayerPrefs.GetString(StringDebugParametersKey, "");
            if (!string.IsNullOrEmpty(stringJson))
            {
                var stringDict = JsonUtility.FromJson<SerializableDictionary<string, string>>(stringJson);
                if (stringDict != null)
                {
                    StringDebugParameters = stringDict.ToDictionary();
                }
            }
        }

        #endregion
    }

    /// <summary>
    /// Dictionary を JSON シリアライズできるようにするためのクラス
    /// </summary>
    /// <typeparam name="TKey"></typeparam>
    /// <typeparam name="TValue"></typeparam>
    [Serializable]
    public class SerializableDictionary<TKey, TValue> : ISerializationCallbackReceiver
    {
        [SerializeField]
        private List<TKey> keys = new();

        [SerializeField]
        private List<TValue> values = new();

        // 実際の Dictionary データ。シリアライズ時・デシリアライズ時に keys/values と相互変換。
        private Dictionary<TKey, TValue> dictionary = new();

        public SerializableDictionary() { }

        public SerializableDictionary(Dictionary<TKey, TValue> dict)
        {
            dictionary = dict;
        }

        /// <summary>
        /// Dictionary 形式に変換して取得
        /// </summary>
        public Dictionary<TKey, TValue> ToDictionary()
        {
            return dictionary;
        }

        #region ISerializationCallbackReceiver implements

        public void OnBeforeSerialize()
        {
            // JSON シリアライズされる前に、Dictionary の情報を keys/values に詰め込む
            keys.Clear();
            values.Clear();

            foreach (var kvp in dictionary)
            {
                keys.Add(kvp.Key);
                values.Add(kvp.Value);
            }
        }

        public void OnAfterDeserialize()
        {
            // JSON デシリアライズ後に、keys/values から Dictionary を再構成する
            dictionary = new Dictionary<TKey, TValue>();
            for (int i = 0; i < Mathf.Min(keys.Count, values.Count); i++)
            {
                dictionary[keys[i]] = values[i];
            }
        }

        #endregion
    }
}

```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/LocalPlayerInventoryController.cs
```cs
using System;
using Client.Game.InGame.Context;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;

namespace Client.Game.InGame.UI.Inventory.Main
{
    public class LocalPlayerInventoryController
    {
        public ILocalPlayerInventory LocalPlayerInventory => _mainAndSubCombine;
        public IItemStack GrabInventory { get; private set; }
        
        private readonly LocalPlayerInventory _mainAndSubCombine;
        private ISubInventory _subInventory;
        
        public LocalPlayerInventoryController(ILocalPlayerInventory localPlayerInventoryMainAndSubCombine)
        {
            _mainAndSubCombine = (LocalPlayerInventory)localPlayerInventoryMainAndSubCombine;
            GrabInventory = ServerContext.ItemStackFactory.Create(new ItemId(0), 0);
        }
        
        public void MoveItem(LocalMoveInventoryType from, int fromSlot, LocalMoveInventoryType to, int toSlot, int count, bool isMoveSendData = true)
        {
            var fromInvItem = from switch
            {
                LocalMoveInventoryType.MainOrSub => LocalPlayerInventory[fromSlot],
                LocalMoveInventoryType.Grab => GrabInventory,
                _ => throw new ArgumentOutOfRangeException(nameof(from), from, null),
            };
            
            if (fromInvItem.Count < count) return;
            
            SetInventory();
            
            if (isMoveSendData) SendMoveItemData();
            
            #region InternalMethod
            
            void SetInventory()
            {
                var itemStackFactory = ServerContext.ItemStackFactory;
                
                var toInvItem = to switch
                {
                    LocalMoveInventoryType.MainOrSub => LocalPlayerInventory[toSlot],
                    LocalMoveInventoryType.Grab => GrabInventory,
                    _ => throw new ArgumentOutOfRangeException(nameof(to), to, null),
                };
                var moveItem = itemStackFactory.Create(fromInvItem.Id, count);
                
                var add = toInvItem.AddItem(moveItem);
                switch (to)
                {
                    case LocalMoveInventoryType.MainOrSub:
                        _mainAndSubCombine[toSlot] = add.ProcessResultItemStack;
                        break;
                    case LocalMoveInventoryType.Grab:
                        GrabInventory = add.ProcessResultItemStack;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(to), to, null);
                }
                
                var fromItemCount = fromInvItem.Count - count + add.RemainderItemStack.Count;
                var fromItem = itemStackFactory.Create(fromInvItem.Id, fromItemCount);
                switch (from)
                {
                    case LocalMoveInventoryType.Grab:
                        GrabInventory = fromItem;
                        break;
                    default:
                        _mainAndSubCombine[fromSlot] = fromItem;
                        break;
                }
            }
            
            void SendMoveItemData()
            {
                var fromInfo = GetServerInventoryInfo(from, fromSlot);
                var toInfo = GetServerInventoryInfo(to, toSlot);
                ClientContext.VanillaApi.SendOnly.ItemMove(count, ItemMoveType.SwapSlot, fromInfo, fromSlot, toInfo, toSlot);
            }
            
            ItemMoveInventoryInfo GetServerInventoryInfo(LocalMoveInventoryType localType, int localSlot)
            {
                return localType switch
                {
                    LocalMoveInventoryType.MainOrSub => localSlot < PlayerInventoryConst.MainInventorySize ? new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory) : _subInventory.ItemMoveInventoryInfo,
                    LocalMoveInventoryType.Grab => new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory),
                    _ => throw new ArgumentOutOfRangeException(nameof(localType), localType, null),
                };
            }
            
            #endregion
        }
        
        public void SetGrabItem(IItemStack itemStack)
        {
            GrabInventory = itemStack;
        }
        
        public void SetMainItem(int slot, IItemStack itemStack)
        {
            _mainAndSubCombine[slot] = itemStack;
        }
        
        public void SetSubInventory(ISubInventory subInventory)
        {
            _mainAndSubCombine.SetSubInventory(subInventory);
            _subInventory = subInventory;
        }
    }
    
    public enum LocalMoveInventoryType
    {
        MainOrSub, //メインインベントリとサブインベントリの両方（ドラッグアンドドロップなどでは統一して扱うから
        Grab, //持ち手のインベントリ
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/PlayerInventoryResponseProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;

namespace Server.Protocol.PacketResponse
{
    public class PlayerInventoryResponseProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:playerInvRequest";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public PlayerInventoryResponseProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<PlayerInventoryResponseProtocolMessagePack>(payload.ToArray());
            
            var playerInventory = _playerInventoryDataStore.GetInventoryData(data.PlayerId);
            
            //メインインベントリのアイテムを設定
            var mainItems = new List<ItemMessagePack>();
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var id = playerInventory.MainOpenableInventory.GetItem(i).Id;
                var count = playerInventory.MainOpenableInventory.GetItem(i).Count;
                mainItems.Add(new ItemMessagePack(id, count));
            }
            
            //グラブインベントリのアイテムを設定
            var grabItem = new ItemMessagePack(
                playerInventory.GrabInventory.GetItem(0).Id,
                playerInventory.GrabInventory.GetItem(0).Count);
            
            
            return new PlayerInventoryResponseProtocolMessagePack(data.PlayerId, mainItems.ToArray(), grabItem);
        }
        
        [MessagePackObject]
        public class RequestPlayerInventoryProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RequestPlayerInventoryProtocolMessagePack() { }
            
            public RequestPlayerInventoryProtocolMessagePack(int playerId)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
            }
        }
        
        [MessagePackObject]
        public class PlayerInventoryResponseProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public ItemMessagePack[] Main { get; set; }
            [Key(4)] public ItemMessagePack Grab { get; set; }
            
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public PlayerInventoryResponseProtocolMessagePack() { }
            
            public PlayerInventoryResponseProtocolMessagePack(int playerId, ItemMessagePack[] main, ItemMessagePack grab)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Main = main;
                Grab = grab;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/CraftRecipeMaster.cs
```cs
using System;
using Mooresmaster.Loader.CraftRecipesModule;
using Mooresmaster.Model.CraftRecipesModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class CraftRecipeMaster
    {
        public readonly CraftRecipes CraftRecipes;
        
        public CraftRecipeMaster(JToken craftRecipeJToken)
        {
            CraftRecipes = CraftRecipesLoader.Load(craftRecipeJToken);
        }
        
        public CraftRecipeMasterElement GetCraftRecipe(Guid guid)
        {
            return Array.Find(CraftRecipes.Data, x => x.CraftRecipeGuid == guid);
        }
        
        public CraftRecipeMasterElement[] GetResultItemCraftRecipes(ItemId itemId)
        {
            var itemGuid = MasterHolder.ItemMaster.GetItemMaster(itemId).ItemGuid;
            return Array.FindAll(CraftRecipes.Data, x => x.CraftResultItemGuid == itemGuid);
        }
        
        public CraftRecipeMasterElement[] GetAllCraftRecipes()
        {
            return CraftRecipes.Data;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/BlockRemoveEventPacketTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    /// <summary>
    ///     ブロックを消したらその情報がイベントで飛んでくるテスト
    /// </summary>
    public class BlockRemoveEventPacketTest
    {
        [Test]
        public void RemoveBlockEvent()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            //イベントキューにIDを登録する
            List<List<byte>> response = packetResponse.GetPacketResponse(EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            var worldBlock = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            //ブロックを設置
            BlockPlace(4, 0, 1, worldBlock, blockFactory);
            BlockPlace(3, 1, 2, worldBlock, blockFactory);
            BlockPlace(2, 3, 3, worldBlock, blockFactory);
            BlockPlace(1, 4, 4, worldBlock, blockFactory);
            
            //イベントを取得
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(4, eventMessagePack.Events.Count);
            
            var worldDataStore = ServerContext.WorldBlockDatastore;
            //一個ブロックを削除
            worldDataStore.RemoveBlock(new Vector3Int(4, 0));
            
            //イベントを取得
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            
            Assert.AreEqual(1, eventMessagePack.Events.Count);
            var pos = AnalysisResponsePacket(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(4, pos.x);
            Assert.AreEqual(0, pos.y);
            
            //二個ブロックを削除
            worldDataStore.RemoveBlock(new Vector3Int(3, 1));
            worldDataStore.RemoveBlock(new Vector3Int(1, 4));
            //イベントを取得
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(2, eventMessagePack.Events.Count);
            pos = AnalysisResponsePacket(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(3, pos.x);
            Assert.AreEqual(1, pos.y);
            pos = AnalysisResponsePacket(eventMessagePack.Events[1].Payload);
            Assert.AreEqual(1, pos.x);
            Assert.AreEqual(4, pos.y);
        }
        
        private void BlockPlace(int x, int y, int id, IWorldBlockDatastore worldBlockDatastore, IBlockFactory blockFactory)
        {
            worldBlockDatastore.TryAddBlock((BlockId)id, new Vector3Int(x, y), BlockDirection.North, out _);
        }
        
        private List<byte> EventRequestData(int playerID)
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(playerID)).ToList();
        }
        
        private Vector3Int AnalysisResponsePacket(byte[] payload)
        {
            var data = MessagePackSerializer.Deserialize<RemoveBlockEventMessagePack>(payload.ToArray());
            
            return data.Position;
        }
    }
}
```

schema/blocks.json
```cs
{
  "$id": "blocks",
  "type": "object",
  "isDefaultOpen": true,


  "defineInterface": [
      {
          "interfaceName": "IMachineParam",
          "properties": {
              "inputSlotCount": {
                  "type": "integer"
              },
              "outputSlotCount": {
                  "type": "integer"
              }
          }
      }
  ],


  "properties": {

    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "BlockMasterElement",

      "items": {
        "type": "object",

        "properties": {
          "blockGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "name": {
            "type": "string"
          },

          "blockType": {
            "type": "string",
            "enum": [
              "Block","BeltConveyor","Chest",
              "ElectricMachine","ElectricPole","ElectricGenerator","ElectricMiner",

              "Gear","Shaft","GearMachine","SimpleGearGenerator","GearBeltConveyor","GearMiner",
              "ItemShooter",
              "CraftChainerTransporter", "CraftChainerCrafter", "CraftChainerProviderChest", "CraftChainerMainComputer",
              "TrainRail", "TrainStation", "TrainCargoPlatform"
            ]
          },

          "itemGuid": {
            "type": "string",
            "format": "uuid",
            "foreignKey": "items:itemGuid:name"
          },
          "blockSize": {
            "type": "array",
            "pattern": "@vector3Int",
            "items": {
              "type": "integer"
            },
            "default": [1,1,1]
          },

          "blockPrefabAddressablesPath": {
            "type": "string",
            "optional": true
          },

          "blockUIAddressablesPath": {
            "type": "string",
            "optional": true
          },

          "blockParam": {
            "oneOf": [
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "Block"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {}
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "BeltConveyor"
                    }
                  }
                },
                "then": {
                  "type": "object",

                  "properties": {
                    "beltConveyorItemCount": {"type": "integer", "default": 1},
                    "timeOfItemEnterToExit": {"type": "number", "default": 1},
                    "slopeType": {"type": "string", "enum": ["Straight", "Up", "Down"] },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "Chest"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "chestItemSlotCount": {"type": "integer", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ElectricMachine"
                    }
                  }
                },
                "then": {

                  "implementationInterface": [
                    "IMachineParam"
                  ],

                  "type": "object",
                  "properties": {

                    "inputSlotCount": { "type": "integer", "default": 1 },
                    "outputSlotCount": { "type": "integer", "default": 1 },
                    
                    "requiredPower": {"type": "number", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ElectricPole"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "poleConnectionRange": {"type": "integer", "default": 5},
                    "machineConnectionRange": {"type": "integer", "default": 5}
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ElectricGenerator"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "fuelItemSlotCount": {"type": "integer", "default": 3},

                    "isInfinityPower": {"type": "boolean", "default": false},
                    "infinityPower": {"type": "integer", "default": 0},

                    "fuelItems": {
                      "type": "array",
                      "optional": true,
                      "items": {
                        "type": "object",
                        "properties": {
                          "itemGuid": {
                            "type": "string",
                            "format": "uuid",
                            "foreignKey": "items:itemGuid:name"
                          },

                          "time": {
                            "type": "number",
                            "default": 1
                          },
                          "power": {
                            "type": "number",
                            "default": 10
                          }
                        }
                      }
                    },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ElectricMiner"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "requiredPower": {"type": "number", "default": 5},
                    "outputItemSlotCount": {"type": "integer", "default": 3},
                    "mineSettings": {
                      "$ref": "mineSettings"
                    },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "Gear"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "teethCount": {"type": "integer", "default": 10},
                    "requireTorque": {"type": "number", "default": 1},
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "Shaft"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "requireTorque": {"type": "number", "default": 1},
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "GearMachine"
                    }
                  }
                },
                "then": {

                  "implementationInterface": [
                    "IMachineParam"
                  ],

                  "type": "object",
                  "properties": {

                    "inputSlotCount": { "type": "integer", "default": 1 },
                    "outputSlotCount": { "type": "integer", "default": 1 },
                    
                    "teethCount": {"type": "integer", "default": 10},
                    "requireTorque": {"type": "number", "default": 1},
                    "requiredRpm": {"type": "number", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    },
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "SimpleGearGenerator"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "teethCount": {"type": "integer", "default": 10},
                    "generateRpm": {"type": "number", "default": 5},
                    "generateTorque": {"type": "number", "default": 1},
                    "requireTorque": {"type": "number", "default": 1},
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "GearBeltConveyor"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "beltConveyorItemCount": {"type": "integer", "default": 4},
                    "beltConveyorSpeed": {"type": "number", "default": 2},
                    "requireTorque": {"type": "number", "default": 2},
                    "slopeType": {"type": "string", "enum": ["Straight", "Up", "Down"] },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    },
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ItemShooter"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "inventoryItemNum": {"type": "integer", "default": 4},
                    "initialShootSpeed": {"type": "number", "default": 3},
                    "itemShootSpeed": {"type": "number", "default": 2},
                    "acceleration": {"type": "number", "default": 1},
                    "slopeType": {"type": "string", "enum": ["Straight", "Up", "Down"] },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "GearMiner"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "teethCount": {"type": "integer", "default": 10},
                    "requireTorque": {"type": "number", "default": 1},
                    "requiredRpm": {"type": "number", "default": 5},
                    
                    "outputItemSlotCount": {"type": "integer", "default": 3},
                    
                    "mineSettings": {
                      "$ref": "mineSettings"
                    },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    },
                    
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "CraftChainerTransporter"
                    }
                  }
                },
                "then": {
                  "type": "object",

                  "properties": {
                    "transporterConveyorItemCount": {"type": "integer", "default": 1},
                    "timeOfItemEnterToExit": {"type": "number", "default": 1},
                    "slopeType": {"type": "string", "enum": ["Straight", "Up", "Down"] },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "CraftChainerCrafter"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    
                    "itemSlotCount": {"type": "integer", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                    
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "CraftChainerProviderChest"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "itemSlotCount": {"type": "integer", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }

                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "CraftChainerMainComputer"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "itemSlotCount": {"type": "integer", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }

                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "TrainRail"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": { }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "TrainStation"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "stationDistance": {"type": "integer", "default": 5}

                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "TrainCargoPlatform"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "platformDistance": {"type": "integer", "default": 5},
                    
                    "inputSlotCount": { "type": "integer", "default": 10 },
                    "outputSlotCount": { "type": "integer", "default": 10 },

                    "loadingSpeed":  { "type": "number", "default": 20 }

                  }
                }
              }
            ]
          },

          "overrideVerticalBlock": {
            "type": "object",
            "optional": true,

            "properties": {

              "upBlockGuid" : {
                "type": "string",
                "format": "uuid",
                "foreignKey": "blocks:blockGuid:name"
              },
              "horizontalBlockGuid" : {
                "type": "string",
                "format": "uuid",
                "foreignKey": "blocks:blockGuid:name"
              },
              "downBlockGuid" : {
                "type": "string",
                "format": "uuid",
                "foreignKey": "blocks:blockGuid:name"
              }

            }

          }
        }
      }
    }
  }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockDirection.cs
```cs
using System;
using UnityEngine;

namespace Game.Block.Interface
{
    /// <summary>
    ///     3次元的な方向に配置するため、上、下、通常の設置×4方向の向きが必要になる
    ///     UpNorthは、ブロックを上方向にした後、通常の設置をした時の下の面が北向きになることを意味する
    ///     DownNorthは、ブロックを下方向にした後、通常の設置をした時の下の面が北向きになることを意味する
    /// </summary>
    public enum BlockDirection
    {
        UpNorth,
        UpEast,
        UpSouth,
        UpWest,
        
        North,
        East,
        South,
        West,
        
        DownNorth,
        DownEast,
        DownSouth,
        DownWest,
    }
    
    public delegate Vector3Int BlockPosConvertAction(Vector3Int pos);
    
    public static class BlockDirectionExtension
    {
        public static Quaternion GetRotation(this BlockDirection direction)
        {
            switch (direction)
            {
                case BlockDirection.UpNorth:
                    return Quaternion.Euler(-90, 0, 0);
                case BlockDirection.UpEast:
                    return Quaternion.Euler(-90, 0, 90);
                case BlockDirection.UpSouth:
                    return Quaternion.Euler(-90, 0, 180);
                case BlockDirection.UpWest:
                    return Quaternion.Euler(-90, 0, 270);
                
                case BlockDirection.North:
                    return Quaternion.Euler(0, 0, 0);
                case BlockDirection.East:
                    return Quaternion.Euler(0, 90, 0);
                case BlockDirection.South:
                    return Quaternion.Euler(0, 180, 0);
                case BlockDirection.West:
                    return Quaternion.Euler(0, 270, 0);
                
                case BlockDirection.DownNorth:
                    return Quaternion.Euler(90, 0, 180);
                case BlockDirection.DownEast:
                    return Quaternion.Euler(90, 0, 90);
                case BlockDirection.DownSouth:
                    return Quaternion.Euler(90, 0, 0);
                case BlockDirection.DownWest:
                    return Quaternion.Euler(90, 0, 270);
                
                default:
                    throw new ArgumentOutOfRangeException(nameof(direction), direction, null);
            }
        }
        
        public static BlockPosConvertAction GetCoordinateConvertAction(this BlockDirection blockDirection)
        {
            var rotation = blockDirection.GetRotation();
            var rotationMatrix = Matrix4x4.Rotate(rotation);
            
            // 変換処理を返す
            return pos =>
            {
                // 行列は float4 × float4 の形なので pos を拡張して計算
                var transformed = rotationMatrix.MultiplyPoint3x4(pos);
                // 戻り値は Vector3Int に丸め
                return Vector3Int.RoundToInt(transformed);
            };
        }
        
        /// <summary>
        /// そのブロックが回転している時、そのブロック座標系の基準座標が、ワールドのどこにあるかを返す
        /// When the block is rotating, return the world position of the reference coordinate in the block's local coordinate system.
        /// </summary>
        public static Vector3Int GetBlockBaseOriginPos(this BlockDirection blockDirection, BlockPositionInfo blockPositionInfo)
        {
            var pos = blockPositionInfo.OriginalPos;
            var size = blockPositionInfo.BlockSize;
            
            var minus = blockDirection.GetBlockDirectionOffset() * Vector3Int.one;
            var originPos = blockDirection.GetBlockModelOriginPos(pos, size);
            
            return originPos - minus;
        }
        
        
        public static Vector3Int GetBlockModelOriginPos(this BlockDirection blockDirection, Vector3Int pos, Vector3Int size)
        {
            var addPos = blockDirection.GetBlockDirectionOffset() * size;
            
            return pos + addPos;
        }
        
        public static Vector3Int GetBlockDirectionOffset(this BlockDirection blockDirection)
        {
            return blockDirection switch
            {
                BlockDirection.UpNorth => new Vector3Int(0, 0, 1),
                BlockDirection.UpEast => new Vector3Int(1, 0, 1),
                BlockDirection.UpSouth => new Vector3Int(1, 0, 1),
                BlockDirection.UpWest => new Vector3Int(0, 0, 1),
                BlockDirection.North => new Vector3Int(0, 0, 0),
                BlockDirection.East => new Vector3Int(0, 0, 1),
                BlockDirection.South => new Vector3Int(1, 0, 1),
                BlockDirection.West => new Vector3Int(1, 0, 0),
                BlockDirection.DownNorth => new Vector3Int(1, 1, 1),
                BlockDirection.DownEast => new Vector3Int(1, 1, 0),
                BlockDirection.DownSouth => new Vector3Int(0, 1, 0),
                BlockDirection.DownWest => new Vector3Int(0, 1, 1),
                _ => Vector3Int.zero
            };
        }
        
        public static BlockDirection HorizonRotation(this BlockDirection blockDirection)
        {
            return blockDirection switch
            {
                BlockDirection.UpNorth => BlockDirection.UpEast,
                BlockDirection.UpEast => BlockDirection.UpSouth,
                BlockDirection.UpSouth => BlockDirection.UpWest,
                BlockDirection.UpWest => BlockDirection.UpNorth,
                
                BlockDirection.North => BlockDirection.East,
                BlockDirection.East => BlockDirection.South,
                BlockDirection.South => BlockDirection.West,
                BlockDirection.West => BlockDirection.North,
                
                BlockDirection.DownNorth => BlockDirection.DownEast,
                BlockDirection.DownEast => BlockDirection.DownSouth,
                BlockDirection.DownSouth => BlockDirection.DownWest,
                BlockDirection.DownWest => BlockDirection.DownNorth,
                
                _ => blockDirection
            };
        }
        
        public static BlockDirection VerticalRotation(this BlockDirection blockDirection)
        {
            return blockDirection switch
            {
                BlockDirection.UpNorth => BlockDirection.DownNorth,
                BlockDirection.UpEast => BlockDirection.DownEast,
                BlockDirection.UpSouth => BlockDirection.DownSouth,
                BlockDirection.UpWest => BlockDirection.DownWest,
                
                BlockDirection.North => BlockDirection.UpNorth,
                BlockDirection.East => BlockDirection.UpEast,
                BlockDirection.South => BlockDirection.UpSouth,
                BlockDirection.West => BlockDirection.UpWest,
                
                BlockDirection.DownNorth => BlockDirection.North,
                BlockDirection.DownEast => BlockDirection.East,
                BlockDirection.DownSouth => BlockDirection.South,
                BlockDirection.DownWest => BlockDirection.West,
                
                _ => blockDirection
            };
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/ChallengeCompletedEventTest.cs
```cs
using System;
using System.Linq;
using Core.Master;
using Core.Update;
using Game.Block.Interface;
using Game.Challenge;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;
using static Server.Protocol.PacketResponse.OneClickCraft;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class ChallengeCompletedEventTest
    {
        private const int PlayerId = 0;
        private const int CraftRecipeId = 1;
        
        [Test]
        // アイテムを作成し、そのチャレンジが完了したイベントを受け取ることを確認するテスト
        // Test to ensure that the item is created and that the challenge receives a completed event
        public void CreateItemChallengeClearTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
         
            ClearCraftChallenge(packet,serviceProvider);
            
            // イベントを受け取り、テストする
            // Receive and test the event
            var response = packet.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var challengeCompleted = eventMessagePack.Events.First(e => e.Tag == CompletedChallengeEventPacket.EventTag);
            var completedChallenge = MessagePackSerializer.Deserialize<CompletedChallengeEventMessage>(challengeCompleted.Payload);
            
            var challengeId = new Guid("00000000-0000-0000-4567-000000000001");
            Assert.AreEqual(challengeId, completedChallenge.CompletedChallengeGuid);
        }
        
        public static void ClearCraftChallenge(PacketResponseCreator packet, ServiceProvider serviceProvider)
        {
            // クラフトの素材をインベントリに追加
            // Add crafting materials to the inventory
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var craftRecipeElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            foreach (var requiredItem in craftRecipeElement.RequiredItems)
            {
                var item = ServerContext.ItemStackFactory.Create(requiredItem.ItemGuid, requiredItem.Count);
                playerInventoryData.MainOpenableInventory.InsertItem(item);
            }
            
            // クラフトを実行
            // Execute the craft
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftRecipeElement.CraftRecipeGuid)).ToList());
        }
        
        [Test]
        // インベントリにアイテムがあることでチャレンジが完了したイベントを受け取ることを確認するテスト
        // Test to ensure that the challenge receives a completed event when an item is in the inventory
        public void InInventoryChallengeClearTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            // インベントリに別々にアイテムを追加
            const int itemId = 1;
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var item1 = ServerContext.ItemStackFactory.Create(new ItemId(itemId), 2);
            playerInventoryData.MainOpenableInventory.SetItem(1, item1);
            var item2 = ServerContext.ItemStackFactory.Create(new ItemId(itemId), 1);
            playerInventoryData.MainOpenableInventory.SetItem(2, item2);
            
            // アップデートしてチャレンジをコンプリートする
            GameUpdater.UpdateWithWait();
            
            // イベントを受け取り、テストする
            // Receive and test the event
            var response = packet.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var challengeCompleted = eventMessagePack.Events.First(e => e.Tag == CompletedChallengeEventPacket.EventTag);
            var completedChallenge = MessagePackSerializer.Deserialize<CompletedChallengeEventMessage>(challengeCompleted.Payload);
            
            var challengeId = new Guid("00000000-0000-0000-4567-000000000002");
            Assert.AreEqual(challengeId, completedChallenge.CompletedChallengeGuid);
        }
        
        [Test]
        public void BlockPlaceChallengeClearTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            // ブロックを設置
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0,0,0), BlockDirection.East, out _);
            
            // イベントを受け取り、テストする
            // Receive and test the event
            var response = packet.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var challengeCompleted = eventMessagePack.Events.First(e => e.Tag == CompletedChallengeEventPacket.EventTag);
            var completedChallenge = MessagePackSerializer.Deserialize<CompletedChallengeEventMessage>(challengeCompleted.Payload);
            
            var challengeId = new Guid("00000000-0000-0000-4567-000000000003");
            Assert.AreEqual(challengeId, completedChallenge.CompletedChallengeGuid);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/AutoSaveSystem.cs
```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using Game.SaveLoad.Interface;

namespace Server.Boot
{
    public class AutoSaveSystem
    {
        private readonly IWorldSaveDataSaver _worldSaveDataSaver;
        
        public AutoSaveSystem(IWorldSaveDataSaver worldSaveDataSaver)
        {
            _worldSaveDataSaver = worldSaveDataSaver;
        }
        
        public async Task AutoSave(CancellationTokenSource cancellationTokenSource)
        {
            cancellationTokenSource.Token.ThrowIfCancellationRequested();
            while (true)
            {
                await Task.Delay(TimeSpan.FromSeconds(30));
                _worldSaveDataSaver.Save();
                if (cancellationTokenSource.Token.IsCancellationRequested) break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/IGearEnergyTransformer.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlockConnectInfoModule;

namespace Game.Gear.Common
{
    public interface IGearEnergyTransformer : IBlockComponent
    {
        public const string WorkingStateName = "Working";
        public const string RockedStateName = "Rocked";
        
        public BlockInstanceId BlockInstanceId { get; }
        
        public bool IsRocked { get; }
        
        public GearPower CurrentPower => new(CurrentRpm.AsPrimitive() * CurrentTorque.AsPrimitive());
        public RPM CurrentRpm { get; }
        public Torque CurrentTorque { get; }
        public bool IsCurrentClockwise { get; }
        
        public Torque GetRequiredTorque(RPM rpm, bool isClockwise);
        
        public void Rocked();
        public void SupplyPower(RPM rpm, Torque torque, bool isClockwise);
        
        public List<GearConnect> GetGearConnects();
    }
    
    public readonly struct GearConnect
    {
        public readonly IGearEnergyTransformer Transformer;
        public readonly GearConnectOption Self;
        public readonly GearConnectOption Target;
        
        public GearConnect(IGearEnergyTransformer transformer, GearConnectOption self, GearConnectOption target)
        {
            Transformer = transformer;
            Self = self;
            Target = target;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningController.cs
```cs
using Client.Common;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.UIState;
using UnityEngine;
using UnityEngine.EventSystems;
using VContainer;

namespace Client.Game.InGame.Mining
{
    /// <summary>
    ///     マップオブジェクトのUIの表示や削除の判定を担当する
    /// </summary>
    public class MapObjectMiningController : MonoBehaviour
    {
        [SerializeField] private HotBarView hotBarView;
        [SerializeField] private float miningDistance = 1.5f;
        
        private IMapObjectMiningState _currentState;
        private MapObjectMiningControllerContext _context;
        
        [Inject]
        public void Constructor(UIStateControl uiStateControl, ILocalPlayerInventory localPlayerInventory, IPlayerObjectController playerObjectController)
        {
            _currentState = new MapObjectMiningIdleState();
            _context = new MapObjectMiningControllerContext(hotBarView, localPlayerInventory, playerObjectController);
        }
        
        
        private void Update()
        {
            // update focus map object
            var currentMapObject = GetCurrentMapObject();
            _context.SetFocusMapObjectGameObject(currentMapObject);
            
            // update state
            _currentState = _currentState.GetNextUpdate(_context, Time.deltaTime);
            
            #region Internal
            
            MapObjectGameObject GetCurrentMapObject()
            {
                if (Camera.main == null) return null;
                
                var ray = Camera.main.ScreenPointToRay(new Vector2(Screen.width / 2.0f, Screen.height / 2.0f));
                if (!Physics.Raycast(ray, out var hit, 10, LayerConst.MapObjectOnlyLayerMask)) return null;
                if (EventSystem.current.IsPointerOverGameObject()) return null;
                if (!hit.collider.gameObject.TryGetComponent(out MapObjectGameObject mapObject)) return null;
                
                var playerPos = _context.PlayerObjectController.Position;
                var mapObjectPos = mapObject.transform.position;
                if (miningDistance < Vector3.Distance(playerPos, mapObjectPos)) return null;
                
                return mapObject;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/ItemManaged/MainOpenableInventoryData.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Event;
using Game.PlayerInventory.Interface;
using Game.PlayerInventory.Interface.Event;

namespace Game.PlayerInventory.ItemManaged
{
    public class MainOpenableInventoryData : IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems => _openableInventoryService.InventoryItems;
        
        private readonly MainInventoryUpdateEvent _mainInventoryUpdateEvent;
        private readonly OpenableInventoryItemDataStoreService _openableInventoryService;
        private readonly int _playerId;
        
        public MainOpenableInventoryData(int playerId, MainInventoryUpdateEvent mainInventoryUpdateEvent)
        {
            _playerId = playerId;
            _mainInventoryUpdateEvent = mainInventoryUpdateEvent;
            _openableInventoryService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, PlayerInventoryConst.MainInventorySize);
        }
        
        public MainOpenableInventoryData(int playerId, MainInventoryUpdateEvent mainInventoryUpdateEvent, List<IItemStack> itemStacks) : this(playerId, mainInventoryUpdateEvent)
        {
            for (var i = 0; i < itemStacks.Count; i++) _openableInventoryService.SetItemWithoutEvent(i, itemStacks[i]);
        }
        
        public IItemStack GetItem(int slot)
        {
            return _openableInventoryService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _openableInventoryService.SetItem(slot, itemStack);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            _openableInventoryService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            return _openableInventoryService.ReplaceItem(slot, itemStack);
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            return _openableInventoryService.ReplaceItem(slot, itemId, count);
        }
        
        /// <summary>
        ///     プレイヤーのメインインベントリの場合はホットバーを優先的にInsertする
        /// </summary>
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return _openableInventoryService.InsertItemWithPrioritySlot(itemStack, PlayerInventoryConst.HotBarSlots);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            return _openableInventoryService.InsertItemWithPrioritySlot(itemId, count, PlayerInventoryConst.HotBarSlots);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return _openableInventoryService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return _openableInventoryService.InsertionCheck(itemStacks);
        }
        
        public int GetSlotSize()
        {
            return _openableInventoryService.GetSlotSize();
        }
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            return _openableInventoryService.CreateCopiedItems();
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _mainInventoryUpdateEvent.OnInventoryUpdateInvoke(new PlayerInventoryUpdateEventProperties(
                _playerId, slot, itemStack));
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/NetworkEventInventoryUpdater.cs
```cs
using Client.Game.InGame.Context;
using Game.Context;
using MessagePack;
using Server.Event.EventReceive;
using VContainer.Unity;

namespace Client.Game.InGame.UI.Inventory.Main
{
    public class NetworkEventInventoryUpdater : IInitializable
    {
        private readonly LocalPlayerInventoryController _localPlayerInventoryController;
        
        public NetworkEventInventoryUpdater(LocalPlayerInventoryController localPlayerInventoryController)
        {
            _localPlayerInventoryController = localPlayerInventoryController;
        }
        
        public void Initialize()
        {
            ClientContext.VanillaApi.Event.SubscribeEventResponse(GrabInventoryUpdateEventPacket.EventTag, OnGrabInventoryUpdateEvent);
            ClientContext.VanillaApi.Event.SubscribeEventResponse(MainInventoryUpdateEventPacket.EventTag, OnMainInventoryUpdateEvent);
        }
        
        /// <summary>
        ///     Grabインベントリの更新イベント
        /// </summary>
        private void OnGrabInventoryUpdateEvent(byte[] payload)
        {
            var packet = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(payload);
            var item = ServerContext.ItemStackFactory.Create(packet.Item.Id, packet.Item.Count);
            _localPlayerInventoryController.SetGrabItem(item);
        }
        
        /// <summary>
        ///     メインインベントリの更新イベント
        /// </summary>
        private void OnMainInventoryUpdateEvent(byte[] payload)
        {
            var packet = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(payload);
            var item = ServerContext.ItemStackFactory.Create(packet.Item.Id, packet.Item.Count);
            _localPlayerInventoryController.SetMainItem(packet.Slot, item);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SaveProtocol.cs
```cs
using System.Collections.Generic;
using Game.SaveLoad.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SaveProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:save";
        
        private readonly IWorldSaveDataSaver _worldSaveDataSaver;
        
        public SaveProtocol(ServiceProvider serviceProvider)
        {
            _worldSaveDataSaver = serviceProvider.GetService<IWorldSaveDataSaver>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            Debug.Log("セーブ開始");
            _worldSaveDataSaver.Save();
            Debug.Log("セーブ完了");
            return null;
        }
        
        
        [MessagePackObject]
        public class SaveProtocolMessagePack : ProtocolMessagePackBase
        {
            public SaveProtocolMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/InitialHandshakeProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.InitialHandshakeProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class InitialHandshakeProtocolTest
    {
        private const int PlayerId = 1;
        
        [Test]
        public void SpawnCoordinateTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            //ワールド設定情報を初期化
            serviceProvider.GetService<IWorldSettingsDatastore>().Initialize();
            
            //最初のハンドシェイクを実行
            var response = packet.GetPacketResponse(GetHandshakePacket(PlayerId))[0];
            var handShakeResponse =
                MessagePackSerializer.Deserialize<ResponseInitialHandshakeMessagePack>(response.ToArray());
            
            //今のところ初期スポーンはゼロ固定
            Assert.AreEqual(0, handShakeResponse.PlayerPos.X);
            Assert.AreEqual(0, handShakeResponse.PlayerPos.Y);
            
            
            //プレイヤーの座標を変更
            packet.GetPacketResponse(GetPlayerPositionPacket(PlayerId, new Vector3(100, 0, -100)));
            
            
            //再度ハンドシェイクを実行して座標が変更されていることを確認
            response = packet.GetPacketResponse(GetHandshakePacket(PlayerId))[0];
            handShakeResponse =
                MessagePackSerializer.Deserialize<ResponseInitialHandshakeMessagePack>(response.ToArray());
            Assert.AreEqual(100, handShakeResponse.PlayerPos.X);
            Assert.AreEqual(0, handShakeResponse.PlayerPos.Y);
            Assert.AreEqual(-100, handShakeResponse.PlayerPos.Z);
        }
        
        private List<byte> GetHandshakePacket(int playerId)
        {
            return MessagePackSerializer.Serialize(
                new RequestInitialHandshakeMessagePack(playerId, "test player name")).ToList();
        }
        
        
        private List<byte> GetPlayerPositionPacket(int playerId, Vector3 pos)
        {
            return MessagePackSerializer.Serialize(
                new SetPlayerCoordinateProtocol.PlayerCoordinateSendProtocolMessagePack(playerId, pos)).ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/TextTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Skit.SkitTrack
{
    public class TextTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var characterName = parameters[0];
            var characterDisplayName = parameters[2] == string.Empty ? characterName : parameters[2];
            var text = parameters[1];
            
            storyContext.SkitUI.SetText(characterDisplayName, text);
            
            var voiceAudioClip = storyContext.VoiceDefine.GetVoiceClip(characterName, text);
            
            var character = storyContext.GetCharacter(characterName);
            if (voiceAudioClip != null) character.PlayVoice(voiceAudioClip);
            
            //クリックされるまで待機
            while (true)
            {
                if (Input.GetMouseButtonDown(0))
                {
                    // 1フレーム待たないとクリックが即座に次のテキストに反映されてしまう
                    await UniTask.Yield();
                    character.StopVoice();
                    return null;
                }
                
                await UniTask.Yield();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Util/PacketBufferParser.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Server.Util
{
    /// <summary>
    ///     複数のパケットがバッファーに入っていた場合にそれらのパケットを別々のパケットに分割するクラス
    /// </summary>
    public class PacketBufferParser
    {
        private readonly List<byte> _packetLengthBytes = new();
        private List<byte> _continuationFromLastTimeBytes = new();
        
        private bool _isGettingLength;
        private int _nextPacketLengthOffset;
        private int _packetLength;
        private int _remainingHeaderLength;
        
        public List<List<byte>> Parse(byte[] packet, int length)
        {
            //プロトコル長から実際のプロトコルを作る
            var actualStartPacketDataIndex = 0;
            var reminderLength = length;
            
            var result = new List<List<byte>>();
            
            //受信したパケットの最後までループ
            while (0 < reminderLength)
            {
                //前回からの続きのデータがない場合
                if (_continuationFromLastTimeBytes.Count == 0)
                {
                    //パケット長を取得
                    if (TryGetLength(packet, actualStartPacketDataIndex, out var payloadLength, out var headerLength))
                    {
                        _packetLength = payloadLength;
                        //パケット長のshort型の4バイトを取り除く
                        reminderLength -= _packetLength + headerLength;
                        actualStartPacketDataIndex += headerLength;
                    }
                    else
                    {
                        //残りバッファサイズ的に取得できない場合は次回の受信で取得する
                        break;
                    }
                }
                else
                {
                    //前回からの続きのデータがある場合
                    _packetLength -= _nextPacketLengthOffset;
                    reminderLength = length - _packetLength;
                }
                
                //パケットが切れているので、残りのデータを一時保存
                if (reminderLength < 0)
                {
                    var addCollection = packet.Skip(actualStartPacketDataIndex).ToList();
                    _continuationFromLastTimeBytes.AddRange(addCollection);
                    //次回の受信のためにどこからデータを保存するかのオフセットを保存
                    _nextPacketLengthOffset = length - actualStartPacketDataIndex;
                    break;
                }
                
                //パケットの長さ分だけデータを取得
                for (var i = 0;
                     i < _packetLength && actualStartPacketDataIndex < length;
                     actualStartPacketDataIndex++, i++)
                    _continuationFromLastTimeBytes.Add(packet[actualStartPacketDataIndex]);
                
                result.Add(_continuationFromLastTimeBytes);
                //受信したパケットに対する応答を返す
                _continuationFromLastTimeBytes = new List<byte>();
            }
            
            return result;
        }
        
        
        private bool TryGetLength(byte[] bytes, int startIndex, out int payloadLength, out int headerLength)
        {
            List<byte> headerBytes;
            if (_isGettingLength)
            {
                headerLength = _remainingHeaderLength;
                for (var i = 0; i < _remainingHeaderLength; i++) _packetLengthBytes.Add(bytes[i]);
                headerBytes = _packetLengthBytes;
                _isGettingLength = false;
            }
            else
            {
                payloadLength = -1;
                headerLength = -1;
                //パケット長が取得でききれない場合
                if (bytes.Length <= startIndex + 3)
                {
                    _packetLengthBytes.Clear();
                    _remainingHeaderLength = 4;
                    for (var i = startIndex; i < bytes.Length; i++)
                    {
                        _remainingHeaderLength = 3 - (i - startIndex);
                        _packetLengthBytes.Add(bytes[i]);
                    }
                    
                    _isGettingLength = true;
                    return false;
                }
                
                headerLength = 4;
                headerBytes = new List<byte>
                {
                    bytes[startIndex],
                    bytes[startIndex + 1],
                    bytes[startIndex + 2],
                    bytes[startIndex + 3],
                };
            }
            
            
            if (BitConverter.IsLittleEndian) headerBytes.Reverse();
            
            payloadLength = BitConverter.ToInt32(headerBytes.ToArray(), 0);
            return true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MasterJsonCpntens.cs
```cs
using System.Collections.Generic;
using UnitGenerator;

namespace Core.Master
{
    public class MasterJsonCpntens
    {
        public readonly string BlockConfigJson;
        public readonly string ChallengeConfigJson;
        public readonly string CraftRecipeConfigJson;
        public readonly string ItemConfigJson;
        public readonly string MachineRecipeConfigJson;
        public readonly string MapObjectConfigJson;
        
        
        public MasterJsonCpntens(string itemJson, string blockConfigJson, string machineRecipeConfigJson, string craftRecipeConfigJson, string mapObjectConfigJson, string challengeConfigJson,ModId modId, Dictionary<JsonFileName,string> jsonContents)
        {
            ModId = modId;
            JsonContents = jsonContents;
            
            ItemConfigJson = itemJson;
            BlockConfigJson = blockConfigJson;
            MachineRecipeConfigJson = machineRecipeConfigJson;
            CraftRecipeConfigJson = craftRecipeConfigJson;
            MapObjectConfigJson = mapObjectConfigJson;
            ChallengeConfigJson = challengeConfigJson;
        }
        
        public readonly ModId ModId;
        
        /// <summary>
        /// Key : json file name ( Do not include ".json" )
        /// Value : json file contents
        /// </summary>
        public readonly Dictionary<JsonFileName,string> JsonContents = new();
        
        
        public MasterJsonCpntens(ModId modId, Dictionary<JsonFileName,string> jsonContents)
        {
            ModId = modId;
            JsonContents = jsonContents;
        }
    }
    
    [UnitOf(typeof(string))]
    public readonly partial struct ModId { }
    
    [UnitOf(typeof(string))]
    public readonly partial struct JsonFileName { }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/items.json
```cs
{
  "data": [
    {
      "maxStack": 100,
      "name": "石",
      "itemGuid": "f92c51ab-1979-4a44-8c35-e86a51b33e61",
      "imagePath": "assets/item/石.png",
      "sortPriority": 100
    },
    {
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "maxStack": 100,
      "name": "麻",
      "itemGuid": "19a3b0bc-10de-4e96-8a41-99f39675556d",
      "imagePath": "assets/item/麻.png",
      "sortPriority": 110
    },
    {
      "maxStack": 100,
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "resultItem": {
        "count": 1,
        "itemGuid": "19a3b0bc-10de-4e96-8a41-99f39675556d"
      },
      "name": "麻紐",
      "itemGuid": "d382f613-8dec-4c87-b72c-c75f8d18ce73",
      "imagePath": "assets/item/麻縄.jpg",
      "sortPriority": 120
    },
    {
      "maxStack": 100,
      "name": "原木",
      "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488",
      "imagePath": "assets/item/原木.png",
      "sortPriority": 130
    },
    {
      "maxStack": 100,
      "name": "ブロンズ鉱石",
      "itemGuid": "6b22a093-0c83-4543-9985-aad0ceb5f8b0",
      "imagePath": "assets/item/ブロンズ鉱石.png",
      "sortPriority": 140
    },
    {
      "maxStack": 100,
      "name": "加工した原木",
      "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5",
      "sortPriority": 150
    },
    {
      "maxStack": 100,
      "name": "石の斧",
      "itemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa",
      "sortPriority": 160
    },
    {
      "maxStack": 100,
      "name": "原始的な溶鉱炉",
      "itemGuid": "de89dc5c-b9d1-40f4-97ef-6b0bdcdd9379",
      "sortPriority": 170
    },
    {
      "maxStack": 100,
      "name": "低品質なブロンズの塊",
      "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67",
      "sortPriority": 180
    },
    {
      "maxStack": 100,
      "name": "粘土",
      "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154",
      "sortPriority": 190
    },
    {
      "maxStack": 100,
      "name": "ブロンズハンマーヘッドの型",
      "itemGuid": "6b54897e-e7cb-4df7-807e-1597c2a859da",
      "sortPriority": 200
    },
    {
      "maxStack": 100,
      "name": "ブロンズハンマーヘッド",
      "itemGuid": "92fe1a42-ad46-4ff3-aa9a-83a9262c34d6",
      "sortPriority": 210
    },
    {
      "maxStack": 100,
      "name": "ブロンズハンマー",
      "itemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e",
      "sortPriority": 220
    },
    {
      "maxStack": 100,
      "name": "ブロンズカッターの型",
      "itemGuid": "99c95d35-9ba8-4027-9d88-48174a7322fa",
      "sortPriority": 230
    },
    {
      "maxStack": 100,
      "name": "ブロンズカッター",
      "itemGuid": "ee7c1edf-32ba-4bd2-962c-d29ee1309730",
      "sortPriority": 240
    },
    {
      "maxStack": 100,
      "name": "ブロンズ製材機",
      "itemGuid": "067f2b59-a088-4fac-98cf-68060c6e9927",
      "sortPriority": 250
    },
    {
      "maxStack": 100,
      "name": "原始的な風車",
      "itemGuid": "b7068d1c-f5cb-4af5-94e1-4ed9c9577ca8",
      "sortPriority": 260
    },
    {
      "maxStack": 100,
      "name": "ブロンズドリルの型",
      "itemGuid": "c82061f7-f4b2-45bc-8323-40f76dece8f2",
      "sortPriority": 270
    },
    {
      "maxStack": 100,
      "name": "ブロンズドリル",
      "itemGuid": "96e59fa9-8468-4315-b8b8-8e087a146dbb",
      "sortPriority": 280
    },
    {
      "maxStack": 100,
      "name": "ブロンズ採掘機",
      "itemGuid": "17d94f6e-9f34-4d4b-8068-4be4c7dbfbb2",
      "sortPriority": 290
    },
    {
      "maxStack": 100,
      "name": "レンガ",
      "itemGuid": "975384df-a166-48a6-a5cf-d631f48715c0",
      "sortPriority": 300
    },
    {
      "maxStack": 100,
      "name": "レンガ作りの精錬炉",
      "itemGuid": "6f8e7dcb-e7d7-44c0-a63e-ffba1cd5e311",
      "sortPriority": 310
    },
    {
      "maxStack": 100,
      "name": "原始的な木の歯車",
      "itemGuid": "0c17174c-bfb2-43a8-ab99-bb4274cb3927",
      "sortPriority": 320
    },
    {
      "maxStack": 100,
      "name": "原始的な木のシャフト",
      "itemGuid": "0559e1c6-5a63-40bc-92d8-64167fa6c3ba",
      "sortPriority": 330
    },
    {
      "maxStack": 100,
      "blockSize": [
        1,
        1,
        1
      ],
      "craftTime": 3,
      "craftResultCount": 1,
      "name": "石器",
      "itemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90",
      "sortPriority": 340
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "直進アイテムシューター",
      "itemGuid": "3568d0bf-c71e-4f5a-beab-d7239da99829",
      "sortPriority": 350
    },
    {
      "maxStack": 100,
      "name": "上りアイテムシューター",
      "itemGuid": "91886efb-6f26-4ff5-80d8-5c5a1966b264",
      "sortPriority": 360
    },
    {
      "maxStack": 100,
      "name": "下りアイテムシューター",
      "itemGuid": "6690cf85-672a-46c0-97b2-45da0b6c954e",
      "sortPriority": 370
    },
    {
      "maxStack": 100,
      "blockSize": [
        1,
        1,
        1
      ],
      "name": "原始的な大きな歯車",
      "itemGuid": "6e05a18a-8e6a-4ba5-9191-a778ed105ae4",
      "sortPriority": 380
    },
    {
      "maxStack": 100,
      "name": "直進歯車ベルトコンベア",
      "itemGuid": "a094cb43-422b-42d0-bb44-ee5bf6d0321b",
      "sortPriority": 390
    },
    {
      "maxStack": 100,
      "name": "上り歯車ベルトコンベア",
      "itemGuid": "bb6170ae-27f8-41a9-90b2-b3b272b05dc2",
      "sortPriority": 400
    },
    {
      "maxStack": 100,
      "name": "下り歯車ベルトコンベア",
      "itemGuid": "8f13936b-8c95-4091-a34a-3739187dca82",
      "sortPriority": 410
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "ブロンズ採掘機Mk2",
      "itemGuid": "42ad9e08-907b-4540-ad64-1393e4dc401f",
      "sortPriority": 420
    },
    {
      "time": 1,
      "craftTime": 3,
      "craftResultCount": 1,
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "直進歯車ベルトコンベアシャフト",
      "itemGuid": "b8986659-052f-4208-a847-dbd975990d3c",
      "sortPriority": 430
    },
    {
      "time": 1,
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "原始的なチェスト",
      "itemGuid": "18e297cc-6c50-41dd-8352-8877af1b37de",
      "sortPriority": 440
    },
    {
      "maxStack": 100,
      "name": "CraftChainerTransporter",
      "itemGuid": "db52f4b0-c28c-4f18-a6c8-0b054e460006",
      "sortPriority": 450
    },
    {
      "maxStack": 100,
      "name": "CraftChainerCrafter",
      "itemGuid": "b76d00ed-72c9-436d-af80-11739a4f3e14",
      "sortPriority": 460
    },
    {
      "maxStack": 100,
      "name": "CraftChainerProviderChest",
      "itemGuid": "35be2026-4730-46d3-9821-5d5f88ac3326",
      "sortPriority": 470
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMainComputer",
      "itemGuid": "59ca039e-7b91-41d9-b387-9bbfa73b74e5",
      "sortPriority": 480
    },
    {
      "maxStack": 100,
      "name": "CraftChainerBeltConveyor",
      "itemGuid": "9ba04edc-1fe0-4528-91a8-80155a51bfe0",
      "sortPriority": 490
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMachine1",
      "itemGuid": "0b9e2f8f-b53f-440f-8913-0664f51e6856",
      "sortPriority": 500
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMachine2",
      "itemGuid": "7dd72da1-e030-494e-a650-a651f7826648",
      "sortPriority": 510
    },
    {
      "maxStack": 100,
      "name": "Chainer - A",
      "itemGuid": "189672cb-6811-4080-bde1-1f9ff0ec63ff",
      "sortPriority": 520
    },
    {
      "maxStack": 100,
      "name": "Chainer - B",
      "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5",
      "sortPriority": 530
    },
    {
      "maxStack": 100,
      "name": "Chainer - C",
      "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627",
      "sortPriority": 540
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "ベルトコンベア",
      "itemGuid": "edfa387f-183a-47dc-a548-5d2f14e315d7",
      "sortPriority": 550
    },
    {
      "maxStack": 100,
      "name": "上りベルトコンベア",
      "itemGuid": "26b38ec5-a2ce-432c-9211-530f2f86d435",
      "sortPriority": 560
    },
    {
      "maxStack": 100,
      "name": "下りベルトコンベア",
      "itemGuid": "3f1b7698-db08-490d-bd0d-b4a3e0fb2f9c",
      "sortPriority": 570
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "溶接加工機械",
      "itemGuid": "cc26c622-c212-47c6-88a5-931329a0509c",
      "sortPriority": 580
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 590,
      "maxStack": 100,
      "name": "油井",
      "itemGuid": "4a35c49b-f662-4a0e-b224-8f43bddd5b30"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 600,
      "maxStack": 100,
      "name": "液体タンク",
      "itemGuid": "0a665a5a-3499-4ad5-a36c-6f52b4a643ec"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "blockPrefabAddressablesPath": "Vanilla/Block/PipeStraight",
      "sortPriority": 610,
      "maxStack": 100,
      "name": "パイプ",
      "itemGuid": "fd1bc661-61d5-4d53-b7e3-0d84d18e8f5d"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 575,
      "maxStack": 100,
      "name": "分岐ベルトコンベア",
      "itemGuid": "caa17dec-8e5e-477b-9b1f-03cdfaa4df08"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 620,
      "maxStack": 100,
      "name": "精製施設",
      "itemGuid": "96f845c8-6365-47e6-b78a-e2853a6ebae7"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 445,
      "maxStack": 100,
      "name": "木の土台",
      "itemGuid": "27218416-d4d8-4583-b8d8-911cc778e95e"
    }
  ]
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/ChangeBlockStateEventPacket.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface.State;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using Server.Util.MessagePack;
using UniRx;
using UnityEngine;

namespace Server.Event.EventReceive
{
    public class ChangeBlockStateEventPacket
    {
        public const string EventTag = "va:event:changeBlockState";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public ChangeBlockStateEventPacket(EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            ServerContext.WorldBlockDatastore.OnBlockStateChange.Subscribe(ChangeState);
        }
        
        private void ChangeState((BlockState state, WorldBlockData blockData) state)
        {
            var messagePack = new BlockStateMessagePack(state.state, state.blockData.BlockPositionInfo.OriginalPos);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, payload);
        }
    }
    
    [MessagePackObject]
    public class BlockStateMessagePack
    {
        /// <summary>
        /// key Component key, value Component state
        /// </summary>
        [Key(0)] public Dictionary<string,byte[]> CurrentStateDetail { get; set; }
        
        [Key(1)] public Vector3IntMessagePack Position { get; set; } // TODO ここをinstanceIdに変更する？
        
        public TBlockState GetStateDetail<TBlockState>(string stateKey)
        {
            if (!CurrentStateDetail.TryGetValue(stateKey, out var bytes))
            {
                return default;
            }
            return MessagePackSerializer.Deserialize<TBlockState>(bytes);
        }
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public BlockStateMessagePack()
        {
        }
        
        public BlockStateMessagePack(BlockState state, Vector3Int pos)
        {
            CurrentStateDetail = state.CurrentStateDetails;
            Position = new Vector3IntMessagePack(pos);
        }

    }
}
```

moorestech_client/Assets/Scripts/Client.Mod/Texture/GetExtractedZipTexture.cs
```cs
using System;
using System.IO;
using UnityEngine;

namespace Client.Mod.Texture
{
    //TODO 成功か失敗かと理由を返すようにする　ログ出力は使う側が行う
    public static class GetExtractedZipTexture
    {
        public static Texture2D Get(string extractedModDirectory, string path)
        {
            //TODO ログ基盤
            var imgPath = Path.Combine(extractedModDirectory, path);
            
            //そのパスにファイルがあるかを確認
            if (!File.Exists(imgPath))
            {
                Debug.LogWarning($"画像ファイルが存在しません パス : {imgPath}");
                return null;
            }
            
            try
            {
                var texture = new Texture2D(1, 1);
                texture.LoadImage(File.ReadAllBytes(imgPath));
                return texture;
            }
            catch (Exception e)
            {
                Debug.Log($"画像のロード中にエラーが発生しました。パス {imgPath} \nMessage {e.Message} \nStackTrace {e.StackTrace}");
                return null;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/PlaceBlockState.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.Control;
using Client.Game.InGame.UI.UIState.Input;
using Client.Game.Skit;
using Client.Input;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class PlaceBlockState : IUIState
    {
        private readonly IBlockPlacePreview _blockPlacePreview;
        private readonly ScreenClickableCameraController _screenClickableCameraController;
        private readonly SkitManager _skitManager;
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        private readonly List<IDisposable> _blockPlacedDisposable = new();
        
        private bool _isChangeCameraAngle;
        
        public PlaceBlockState(IBlockPlacePreview blockPlacePreview, SkitManager skitManager, InGameCameraController inGameCameraController, BlockGameObjectDataStore blockGameObjectDataStore)
        {
            _skitManager = skitManager;
            _blockGameObjectDataStore = blockGameObjectDataStore;
            _blockPlacePreview = blockPlacePreview;
            _screenClickableCameraController = new ScreenClickableCameraController(inGameCameraController);
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            BlockPlaceSystem.SetEnableBlockPlace(true);
            _screenClickableCameraController.OnEnter();
            
            //TODO InputSystemのリファクタ対象
            // シフト+Bのときはカメラの位置を変えない
            // Shift+B does not change camera position
            _isChangeCameraAngle = !UnityEngine.Input.GetKey(KeyCode.LeftShift);
            
            if (_isChangeCameraAngle)
            {
                _screenClickableCameraController.StartTweenFromTop();
            }
            
            // ここが重くなったら近いブロックだけプレビューをオンにするなどする
            foreach (var blockGameObject in _blockGameObjectDataStore.BlockGameObjectDictionary.Values)
            {
                blockGameObject.EnablePreviewOnlyObjects(true, true);
            }
            _blockPlacedDisposable.Add(_blockGameObjectDataStore.OnBlockPlaced.Subscribe(OnPlaceBlock));
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.PlayerInventory;
            if (BlockClickDetect.IsClickOpenableBlock(_blockPlacePreview)) return UIStateEnum.BlockInventory;
            if (InputManager.UI.BlockDelete.GetKeyDown) return UIStateEnum.DeleteBar;
            if (_skitManager.IsPlayingSkit) return UIStateEnum.Story;
            //TODO InputSystemのリファクタ対象
            if (InputManager.UI.CloseUI.GetKeyDown || UnityEngine.Input.GetKeyDown(KeyCode.B)) return UIStateEnum.GameScreen;
            
            _screenClickableCameraController.GetNextUpdate();
            
            return UIStateEnum.Current;
        }
        
        private void OnPlaceBlock(BlockGameObject blockGameObject)
        {
            blockGameObject.EnablePreviewOnlyObjects(true, false);
            
            _blockPlacedDisposable.Add(blockGameObject.OnFinishedPlaceAnimation.Subscribe(_ =>
            {
                blockGameObject.EnablePreviewOnlyObjects(true, true);
            }));
        }
        
        public void OnExit()
        {
            BlockPlaceSystem.SetEnableBlockPlace(false);
            foreach (var blockGameObject in _blockGameObjectDataStore.BlockGameObjectDictionary.Values)
            {
                blockGameObject.EnablePreviewOnlyObjects(false, false);
            }
            
            _blockPlacedDisposable.ForEach(d => d.Dispose());
            _blockPlacedDisposable.Clear();
            _screenClickableCameraController.OnExit();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/VanillaApiWithResponse.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Client.Network.Settings;
using Core.Item.Interface;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Challenge;
using Game.Context;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Client.Network.API
{
    public class VanillaApiWithResponse
    {
        private readonly IItemStackFactory _itemStackFactory;
        private readonly PacketExchangeManager _packetExchangeManager;
        private readonly PlayerConnectionSetting _playerConnectionSetting;
        
        public VanillaApiWithResponse(PacketExchangeManager packetExchangeManager, PlayerConnectionSetting playerConnectionSetting)
        {
            _itemStackFactory = ServerContext.ItemStackFactory;
            _packetExchangeManager = packetExchangeManager;
            _playerConnectionSetting = playerConnectionSetting;
        }
        
        public async UniTask<InitialHandshakeResponse> InitialHandShake(int playerId, CancellationToken ct)
        {
            //最初のハンドシェイクを行う
            var request = new InitialHandshakeProtocol.RequestInitialHandshakeMessagePack(playerId, $"Player {playerId}");
            var response = await _packetExchangeManager.GetPacketResponse<InitialHandshakeProtocol.ResponseInitialHandshakeMessagePack>(request, ct);
            
            List<GetMapObjectInfoProtocol.MapObjectsInfoMessagePack> mapObjects = null;
            WorldDataResponse worldData = null;
            PlayerInventoryResponse inventory = null;
            ChallengeResponse challenge = null;
            List<BlockStateMessagePack> blockStates = null;
            
            //必要なデータを取得する
            await UniTask.WhenAll(GetMapObjects(), GetWorld(), GetInventory(), GetChallenge(), GetBlockStates());
            
            return new InitialHandshakeResponse(response, worldData, mapObjects, inventory, challenge, blockStates);
            
            #region Internal
            
            async UniTask GetMapObjects()
            {
                mapObjects = await GetMapObjectInfo(ct);
            }
            
            async UniTask GetWorld()
            {
                worldData = await GetWorldData(ct);
            }
            
            async UniTask GetInventory()
            {
                inventory = await GetPlayerInventory(playerId, ct);
            }
            
            async UniTask GetChallenge()
            {
                challenge = await GetChallengeResponse(playerId, ct);
            }
            
            async UniTask GetBlockStates()
            {
                blockStates = await GetAllBlockState(ct);
            }
            
            #endregion
        }
        
        public async UniTask<List<GetMapObjectInfoProtocol.MapObjectsInfoMessagePack>> GetMapObjectInfo(CancellationToken ct)
        {
            var request = new GetMapObjectInfoProtocol.RequestMapObjectInfosMessagePack();
            var response = await _packetExchangeManager.GetPacketResponse<GetMapObjectInfoProtocol.ResponseMapObjectInfosMessagePack>(request, ct);
            return response?.MapObjects;
        }
        
        public async UniTask<List<IItemStack>> GetBlockInventory(Vector3Int blockPos, CancellationToken ct)
        {
            var request = new BlockInventoryRequestProtocol.RequestBlockInventoryRequestProtocolMessagePack(blockPos);
            
            var response = await _packetExchangeManager.GetPacketResponse<BlockInventoryRequestProtocol.BlockInventoryResponseProtocolMessagePack>(request, ct);
            
            var items = new List<IItemStack>(response.Items.Length);
            for (var i = 0; i < response.Items.Length; i++)
            {
                var id = response.Items[i].Id;
                var count = response.Items[i].Count;
                items.Add(_itemStackFactory.Create(id, count));
            }
            
            return items;
        }
        
        public async UniTask<PlayerInventoryResponse> GetMyPlayerInventory(CancellationToken ct)
        {
            return await GetPlayerInventory(_playerConnectionSetting.PlayerId, ct);
        }
        
        public async UniTask<PlayerInventoryResponse> GetPlayerInventory(int playerId, CancellationToken ct)
        {
            var request = new PlayerInventoryResponseProtocol.RequestPlayerInventoryProtocolMessagePack(playerId);
            
            var response = await _packetExchangeManager.GetPacketResponse<PlayerInventoryResponseProtocol.PlayerInventoryResponseProtocolMessagePack>(request, ct);
            
            var mainItems = new List<IItemStack>(response.Main.Length);
            foreach (var item in response.Main)
            {
                var id = item.Id;
                var count = item.Count;
                mainItems.Add(_itemStackFactory.Create(id, count));
            }
            
            var grabItem = _itemStackFactory.Create(response.Grab.Id, response.Grab.Count);
            
            return new PlayerInventoryResponse(mainItems, grabItem);
        }
        
        public async UniTask<WorldDataResponse> GetWorldData(CancellationToken ct)
        {
            var request = new RequestWorldDataProtocol.RequestWorldDataMessagePack();
            var response = await _packetExchangeManager.GetPacketResponse<RequestWorldDataProtocol.ResponseWorldDataMessagePack>(request, ct);
            
            return ParseWorldResponse(response);
            
            #region Internal
            
            WorldDataResponse ParseWorldResponse(RequestWorldDataProtocol.ResponseWorldDataMessagePack worldData)
            {
                var blocks = worldData.Blocks.Select(b => new BlockInfo(b));
                var entities = worldData.Entities.Select(e => new EntityResponse(e));
                
                return new WorldDataResponse(blocks.ToList(), entities.ToList());
            }
            
            #endregion
        }
        
        public async UniTask<ChallengeResponse> GetChallengeResponse(int playerId, CancellationToken ct)
        {
            var request = new GetChallengeInfoProtocol.RequestChallengeMessagePack(playerId);
            var response = await _packetExchangeManager.GetPacketResponse<GetChallengeInfoProtocol.ResponseChallengeInfoMessagePack>(request, ct);
            
            var current = response.CurrentChallengeGuids.Select(MasterHolder.ChallengeMaster.GetChallenge).ToList();
            var completed = response.CompletedChallengeGuids.Select(MasterHolder.ChallengeMaster.GetChallenge).ToList();
            
            return new ChallengeResponse(current, completed);
        }
        
        public async UniTask<List<BlockStateMessagePack>> GetAllBlockState(CancellationToken ct)
        {
            var request = new AllBlockStateProtocol.RequestAllBlockStateProtocolMessagePack();
            var response = await _packetExchangeManager.GetPacketResponse<AllBlockStateProtocol.ResponseAllBlockStateProtocolMessagePack>(request, ct);
            
            return response.StateList;
        }
        
        public async UniTask<BlockStateMessagePack> GetBlockState(Vector3Int blockPos, CancellationToken ct)
        {
            var request = new BlockStateProtocol.RequestBlockStateProtocolMessagePack(blockPos);
            var response = await _packetExchangeManager.GetPacketResponse<BlockStateProtocol.ResponseBlockStateProtocolMessagePack>(request, ct);
            
            return response.State;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/GetWorldDataProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Const;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.RequestWorldDataProtocol;
using Random = System.Random;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class GetWorldDataProtocolTest
    {
        public static readonly BlockId Block_1x4_Id = new(9); // 1x4サイズのブロックのID
        
        //ランダムにブロックを設置するテスト
        [Test]
        public void RandomPlaceBlockToWorldDataResponseTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var random = new Random(13944156);
            //ブロックの設置
            for (var i = 0; i < 1000; i++)
            {
                var blockDirection = (BlockDirection)random.Next(0, 4);
                var pos = new Vector3Int(random.Next(-40, 40), random.Next(-40, 40));
                
                var blockId = random.Next(1, 20);
                worldBlockDatastore.TryAddBlock((BlockId)blockId, pos, blockDirection, out _);
            }
            
            var requestBytes = MessagePackSerializer.Serialize(new RequestWorldDataMessagePack());
            List<byte> responseBytes = packetResponse.GetPacketResponse(requestBytes.ToList())[0];
            var responseWorld = MessagePackSerializer.Deserialize<ResponseWorldDataMessagePack>(responseBytes.ToArray());
            
            //検証
            for (var i = 0; i < responseWorld.Blocks.Length; i++)
            {
                var block = responseWorld.Blocks[i];
                var pos = block.BlockPos;
                
                var id = worldBlockDatastore.GetOriginPosBlock(pos)?.Block.BlockId ?? BlockConst.EmptyBlockId;
                Assert.AreEqual(id, block.BlockId);
                
                var direction = worldBlockDatastore.GetOriginPosBlock(pos)?.BlockPositionInfo.BlockDirection ?? BlockDirection.North;
                Assert.AreEqual(direction, block.BlockDirection);
            }
        }
        
        //マルチブロックを設置するテスト
        [Test]
        public void PlaceBlockToWorldDataTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlock = ServerContext.WorldBlockDatastore;
            
            //ブロックの設置
            worldBlock.TryAddBlock(Block_1x4_Id, Vector3Int.zero, BlockDirection.North, out _);
            
            var requestBytes = MessagePackSerializer.Serialize(new RequestWorldDataMessagePack());
            List<byte> responseBytes = packetResponse.GetPacketResponse(requestBytes.ToList())[0];
            var responseWorld = MessagePackSerializer.Deserialize<ResponseWorldDataMessagePack>(responseBytes.ToArray());
            
            //ブロックが設置されていることを確認する
            Assert.AreEqual(Block_1x4_Id, responseWorld.Blocks[0].BlockId);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/ItemImageContainer.cs
```cs
using System;
using System.Collections.Generic;
using Client.Mod.Texture;
using Core.Master;
using UnityEngine;

namespace Client.Game.InGame.Context
{
    /// <summary>
    ///     アイテム画像を管理するクラス
    /// </summary>
    public class ItemImageContainer
    {
        private readonly Dictionary<ItemId, ItemViewData> _itemImageList = new();
        
        private ItemImageContainer(Dictionary<ItemId, ItemViewData> itemImageList)
        {
            _itemImageList = itemImageList;
        }
        
        public static ItemImageContainer CreateAndLoadItemImageContainer(string modsDirectory)
        {
            var itemImageList = ItemTextureLoader.GetItemTexture(modsDirectory);
            
            return new ItemImageContainer(itemImageList);
        }
        
        public ItemViewData GetItemView(Guid itemGuid)
        {
            var itemId = MasterHolder.ItemMaster.GetItemId(itemGuid);
            return GetItemView(itemId);
        }
        
        public ItemViewData GetItemView(ItemId itemId)
        {
            if (itemId == ItemMaster.EmptyItemId)
            {
                return null;
            }
            
            if (_itemImageList.TryGetValue(itemId, out var view)) return view;
            
            Debug.LogError($"ItemViewData not found. itemId:{itemId}");
            return null;
        }
        
        public void AddItemView(ItemId itemId, ItemViewData itemViewData)
        {
            _itemImageList[itemId] = itemViewData;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Component/BlockConnectorConnectPositionCalculator.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Mooresmaster.Model.BlockConnectInfoModule;
using UnityEngine;

namespace Game.Block.Component
{
    public static class BlockConnectorConnectPositionCalculator
    {
        /// <summary>
        /// key: コネクターの位置
        ///      Position of the connector
        ///
        /// value: そのコネクターと接続できる位置のリスト
        ///        List of positions that can be connected to the connector
        /// </summary>
        public static Dictionary<Vector3Int, List<(Vector3Int position, IConnectOption targetOption)>> CalculateConnectorToConnectPosList(BlockConnectInfo inputConnectInfo, BlockPositionInfo blockPositionInfo)
        {
            var blockDirection = blockPositionInfo.BlockDirection;
            var blockBaseOriginPos = blockDirection.GetBlockBaseOriginPos(blockPositionInfo);
            var result = new Dictionary<Vector3Int, List<(Vector3Int position, IConnectOption targetOption)>>();
            
            if (inputConnectInfo == null) return result;
            foreach (var inputConnectSetting in inputConnectInfo.items)
            {
                var blockPosConvertAction = blockDirection.GetCoordinateConvertAction();
                
                var inputConnectorPos = blockBaseOriginPos + blockPosConvertAction(inputConnectSetting.Offset);
                var directions = inputConnectSetting.Directions;
                if (directions == null)
                {
                    result.Add(inputConnectorPos, null);
                    continue;
                }
                
                var targetPositions = directions.Select(c => (inputConnectorPos + blockPosConvertAction(c), inputConnectSetting.ConnectOption)).ToList();
                if (!result.TryAdd(inputConnectorPos, targetPositions)) result[inputConnectorPos] = result[inputConnectorPos].Concat(targetPositions).ToList();
            }
            
            return result;
        }
        
        /// <summary>
        /// key: コネクターと接続する位置
        ///     Position to connect to the connector
        ///
        /// value: その位置と接続するコネクターの位置
        ///        Position of the connector to connect to that position
        /// </summary>
        public static Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)> CalculateConnectPosToConnector(BlockConnectInfo outputConnectInfo, BlockPositionInfo blockPositionInfo)
        {
            var result = new Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)>();
            
            if (outputConnectInfo == null) return result;
            
            var connectorToConnectPosList = CalculateConnectorToConnectPosList(outputConnectInfo, blockPositionInfo);
            foreach (var (connectPos, targetOptions) in connectorToConnectPosList)
            {
                if (targetOptions == null) continue;
                
                foreach (var (targetPos, targetOption) in targetOptions)
                {
                    // targetPosの重複は今のところ考慮しない
                    result[targetPos] = (connectPos, targetOption);
                }
            }
            
            return result;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearMinerTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Miner;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearMinerTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockOpenableInventoryUpdateEvent;
        
        public VanillaGearMinerTemplate(BlockOpenableInventoryUpdateEvent blockOpenableInventoryUpdateEvent)
        {
            _blockOpenableInventoryUpdateEvent = blockOpenableInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var minerParam = blockMasterElement.BlockParam as GearMinerBlockParam;
            var miningSettings = minerParam.MineSettings;
            
            var connectSetting = minerParam.Gear.GearConnects;
            var gearConnector = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var gearEnergyTransformer = new GearEnergyTransformer(new Torque(minerParam.RequireTorque), blockInstanceId, gearConnector);
            
            var requestPower = new ElectricPower(minerParam.RequireTorque * minerParam.RequiredRpm);
            var outputSlot = minerParam.OutputItemSlotCount;
            var inventoryConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(minerParam.InventoryConnectors, blockPositionInfo);
            var minerProcessorComponent = componentStates == null ? 
                new VanillaMinerProcessorComponent(blockInstanceId, requestPower, outputSlot, _blockOpenableInventoryUpdateEvent, inventoryConnectorComponent, blockPositionInfo, miningSettings) : 
                new VanillaMinerProcessorComponent(componentStates, blockInstanceId, requestPower, outputSlot, _blockOpenableInventoryUpdateEvent, inventoryConnectorComponent, blockPositionInfo, miningSettings);
                
            var gearMinerComponent = new VanillaGearMinerComponent(minerProcessorComponent, gearEnergyTransformer, minerParam);
            
            var components = new List<IBlockComponent>
            {
                minerProcessorComponent,
                inventoryConnectorComponent,
                gearConnector,
                gearEnergyTransformer,
                gearMinerComponent,
                
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/ChallengeMaster.cs
```cs
using System;
using System.Collections.Generic;
using Mooresmaster.Loader.ChallengesModule;
using Mooresmaster.Model.ChallengesModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class ChallengeMaster
    {
        public Challenges Challenges;
        public readonly List<Guid> InitialChallenge;
        
        private readonly Dictionary<Guid, List<Guid>> _nextChallenges;
        
        public ChallengeMaster(JToken challengeJToken)
        {
            Challenges = ChallengesLoader.Load(challengeJToken);
            _nextChallenges = new Dictionary<Guid, List<Guid>>();
            foreach (var challengeElement in Challenges.Data)
            {
                var next = new List<Guid>();
                foreach (var checkTarget in Challenges.Data)
                {
                    if (challengeElement.ChallengeGuid == checkTarget.PrevChallengeGuid)
                    {
                        next.Add(checkTarget.ChallengeGuid);
                    }
                }
                
                _nextChallenges.Add(challengeElement.ChallengeGuid, next);
            }
            
            InitialChallenge = new List<Guid>();
            foreach (var challengeElement in Challenges.Data)
            {
                // prevがnullの場合が初期チャレンジ
                if (!challengeElement.PrevChallengeGuid.HasValue)
                {
                    InitialChallenge.Add(challengeElement.ChallengeGuid);
                }
            }
        }
        
        public List<ChallengeMasterElement> GetNextChallenges(Guid challengeGuid)
        {
            if (!_nextChallenges.TryGetValue(challengeGuid, out var nextChallenges))
            {
                throw new InvalidOperationException($"Next challenges not found. ChallengeGuid:{challengeGuid}");
            }
            
            return nextChallenges.ConvertAll(GetChallenge);
        }
        
        public ChallengeMasterElement GetChallenge(Guid guid)
        {
            return Array.Find(Challenges.Data, x => x.ChallengeGuid == guid);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaPowerGeneratorTemplate.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.PowerGenerator;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaPowerGeneratorTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var generatorParam = blockMasterElement.BlockParam as ElectricGeneratorBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(generatorParam.InventoryConnectors, blockPositionInfo);
            
            var properties = new VanillaPowerGeneratorProperties(blockInstanceId, generatorParam, blockPositionInfo, inputConnectorComponent);
            var generatorComponent = new VanillaElectricGeneratorComponent(properties);
            
            var components = new List<IBlockComponent>
            {
                generatorComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var generatorParam = blockMasterElement.BlockParam as ElectricGeneratorBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(generatorParam.InventoryConnectors, blockPositionInfo);
            
            var properties = new VanillaPowerGeneratorProperties(blockInstanceId, generatorParam, blockPositionInfo, inputConnectorComponent);
            var generatorComponent = new VanillaElectricGeneratorComponent(componentStates, properties);
            
            var components = new List<IBlockComponent>
            {
                generatorComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
    
    public class VanillaPowerGeneratorProperties
    {
        public readonly BlockInstanceId BlockInstanceId;
        public readonly BlockPositionInfo BlockPositionInfo;
        public readonly int FuelItemSlot;
        
        public readonly Dictionary<ItemId, FuelItemsElement> FuelSettings;
        public readonly ElectricPower InfinityPower;
        public readonly BlockConnectorComponent<IBlockInventory> InventoryInputConnectorComponent;
        public readonly bool IsInfinityPower;
        
        public VanillaPowerGeneratorProperties(BlockInstanceId blockInstanceId,ElectricGeneratorBlockParam param, BlockPositionInfo blockPositionInfo, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            FuelSettings = new Dictionary<ItemId, FuelItemsElement>();
            
            if (param.FuelItems != null)
            {
                foreach (var fuelItem in param.FuelItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(fuelItem.ItemGuid);
                    FuelSettings.Add(itemId, fuelItem);
                }
            }
            
            BlockInstanceId = blockInstanceId;
            FuelItemSlot = param.FuelItemSlotCount;
            BlockPositionInfo = blockPositionInfo;
            InventoryInputConnectorComponent = blockConnectorComponent;
            
            IsInfinityPower = param.IsInfinityPower;
            InfinityPower = new ElectricPower(param.InfinityPower);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerProviderChestSaveLoadTest.cs
```cs
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.ProviderChest;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerProviderChestSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);

            // CraftChainerProviderChestブロックを作成
            // Create a CraftChainerProviderChest block
            var providerChestBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerProviderChest, new BlockInstanceId(1), posInfo);

            // コンポーネントの取得
            // Get the component
            var originalProviderChestComponent = providerChestBlock.GetComponent<CraftChainerProviderChestComponent>();

            // セーブデータの取得
            // Retrieve the save data
            var saveState = providerChestBlock.GetSaveState();

            // ブロックのロード
            // Load the block
            var loadedBlock = blockFactory.Load(providerChestBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedProviderChestComponent = loadedBlock.GetComponent<CraftChainerProviderChestComponent>();

            // NodeIdが正しく保存・ロードされているか確認
            // Check if NodeId is correctly saved and loaded
            Assert.AreEqual(originalProviderChestComponent.NodeId, loadedProviderChestComponent.NodeId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/RemoveBlockProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface.Component;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class RemoveBlockProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:removeBlock";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        
        public RemoveBlockProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RemoveBlockProtocolMessagePack>(payload.ToArray());
            
            
            //プレイヤーインベントリーの取得
            var playerMainInventory =
                _playerInventoryDataStore.GetInventoryData(data.PlayerId).MainOpenableInventory;
            
            var isNotRemainItem = true;
            
            //インベントリがある時は
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            if (worldBlockDatastore.TryGetBlock<IBlockInventory>(data.Pos, out var blockInventory))
                //プレイヤーインベントリにブロック内のアイテムを挿入
                for (var i = 0; i < blockInventory.GetSlotSize(); i++)
                {
                    //プレイヤーインベントリにアイテムを挿入
                    var remainItem = playerMainInventory.InsertItem(blockInventory.GetItem(i));
                    //余ったアイテムをブロックに戻す
                    //この時、もしプレイヤーインベントリにアイテムを入れれたのなら、空のアイテムをブロックに戻すようになっているs
                    blockInventory.SetItem(i, remainItem);
                    
                    //アイテムが入りきらなかったらブロックを削除しないフラグを立てる
                    var emptyItem = ServerContext.ItemStackFactory.CreatEmpty();
                    if (!remainItem.Equals(emptyItem)) isNotRemainItem = false;
                }
            
            
            //インベントリに削除するブロックを入れる
            
            //壊したブロックをインベントリーに挿入
            //ブロックIdの取得
            var block = worldBlockDatastore.GetBlock(data.Pos);
            if (block == null) return null;
            
            //ブロックのIDを取得
            var blockItemId = MasterHolder.BlockMaster.GetBlockMaster(block.BlockId).ItemGuid;
            //アイテムを挿入
            var remainBlockItem = playerMainInventory.InsertItem(ServerContext.ItemStackFactory.Create(blockItemId, 1));
            
            
            //ブロック内のアイテムを全てインベントリに入れ、ブロックもインベントリに入れれた時だけブロックを削除する
            if (isNotRemainItem && remainBlockItem.Equals(ServerContext.ItemStackFactory.CreatEmpty()))
                worldBlockDatastore.RemoveBlock(data.Pos);
            
            return null;
        }
        
        
        [MessagePackObject]
        public class RemoveBlockProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public Vector3IntMessagePack Pos { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RemoveBlockProtocolMessagePack() { }
            public RemoveBlockProtocolMessagePack(int playerId, Vector3Int pos)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Pos = new Vector3IntMessagePack(pos);
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockGameObjectDataStore.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.BlockSystem;
using Client.Game.InGame.Context;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class BlockGameObjectDataStore : MonoBehaviour
    {
        public IReadOnlyDictionary<Vector3Int, BlockGameObject> BlockGameObjectDictionary => _blockObjectsDictionary;
        private readonly Dictionary<Vector3Int, BlockGameObject> _blockObjectsDictionary = new();
        
        public IObservable<BlockGameObject> OnBlockPlaced => _onBlockPlaced;
        private readonly Subject<BlockGameObject> _onBlockPlaced = new();
        
        
        public BlockGameObject GetBlockGameObject(Vector3Int position)
        {
            return _blockObjectsDictionary.GetValueOrDefault(position);
        }
        
        public bool ContainsBlockGameObject(Vector3Int position)
        {
            return _blockObjectsDictionary.ContainsKey(position);
        }
        
        public bool TryGetBlockGameObject(Vector3Int position, out BlockGameObject blockGameObject)
        {
            return _blockObjectsDictionary.TryGetValue(position, out blockGameObject);
        }
        
        
        public void PlaceBlock(Vector3Int blockPosition, BlockId blockId, BlockDirection blockDirection)
        {
            //すでにブロックがあり、IDが違う場合は新しいブロックに置き換えるために削除する
            if (_blockObjectsDictionary.ContainsKey(blockPosition))
            {
                //IDが同じ時は再設置の必要がないため処理を終了
                if (_blockObjectsDictionary[blockPosition].BlockId == blockId)
                {
                    return;
                }
                
                //IDが違うため削除
                Destroy(_blockObjectsDictionary[blockPosition].gameObject);
                _blockObjectsDictionary.Remove(blockPosition);
            }
            
            //新しいブロックを設置
            var pos = SlopeBlockPlaceSystem.GetBlockPositionToPlacePosition(blockPosition, blockDirection, blockId);
            var rot = blockDirection.GetRotation();
            
            var block = ClientContext.BlockGameObjectContainer.CreateBlock(blockId, pos, rot, transform, blockPosition, blockDirection);
            //設置アニメーションを再生
            block.PlayPlaceAnimation().Forget();
            
            _blockObjectsDictionary.Add(blockPosition, block);
            _onBlockPlaced.OnNext(block);
        }
        
        public void RemoveBlock(Vector3Int blockPosition)
        {
            //すでにブロックが置かれている時のみブロックを削除する
            if (!_blockObjectsDictionary.ContainsKey(blockPosition)) return;
            
            _blockObjectsDictionary[blockPosition].DestroyBlock().Forget();
            _blockObjectsDictionary.Remove(blockPosition);
        }
        
        public bool IsOverlapPositionInfo(BlockPositionInfo target)
        {
            foreach (var block in _blockObjectsDictionary.Values)
                if (block.BlockPosInfo.IsOverlap(target))
                    return true;
            return false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Crafter/CraftChainerCrafterInserter.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent.Crafter
{
    public class CraftChainerCrafterInserter : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        private int _index = 0;
        
        public CraftChainerCrafterInserter(BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockConnectorComponent = blockConnectorComponent;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var notChainerConnector = new List<IBlockInventory>();
            foreach (var connector in _blockConnectorComponent.ConnectedTargets)
            {
                var block = connector.Value.TargetBlock;
                if (block.ComponentManager.ExistsComponent<ICraftChainerNode>())
                {
                    continue;
                }
                
                notChainerConnector.Add(connector.Key);
            }
            if (notChainerConnector.Count == 0)
            {
                return itemStack;
            }
            
            _index++;
            if (notChainerConnector.Count <= _index)
            {
                _index = 0;
            }
            
            return notChainerConnector[_index].InsertItem(itemStack);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPreviewBoundingBoxSurface.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPreviewBoundingBoxSurface : MonoBehaviour
    {
        public PreviewSurfaceType PreviewSurfaceType => _previewSurfaceType;
        [SerializeField] private PreviewSurfaceType _previewSurfaceType;
        
        public void SetPreviewSurfaceType(PreviewSurfaceType previewSurfaceType)
        {
            _previewSurfaceType = previewSurfaceType;
        }
    }
    
    public enum PreviewSurfaceType
    {
        YX_Origin, // YX平面の手前側 Front side of YX plane
        YX_Z, // YX平面のZ方向の奥側 Back side of the YX plane in the Z direction
        
        YZ_Origin, // YZ平面の手前側 Front side of YZ plane
        YZ_X, // YZ平面のX方向の奥側 Back side of the YZ plane in the X direction
        
        XZ_Origin, // XZ平面の下側 Bottom side of XZ plane
        XZ_Y, // XZ平面のY方向の上側 Top side of XZ plane
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaDefaultBlockTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaDefaultBlock : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, new List<IBlockComponent>(), blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, new List<IBlockComponent>(), blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/EnergySegmentExtension.cs
```cs
using System.Collections.Generic;

namespace Game.EnergySystem
{
    public static class EnergySegmentExtension
    {
        public static TSegment Merge<TSegment>(List<TSegment> segments) where TSegment : EnergySegment, new()
        {
            var newSegment = new TSegment();
            //受け取った電気セグメントを1つずつ結合していく
            foreach (var electric in segments)
            {
                //エネルギー供給者の結合
                foreach (var generator in electric.Generators) newSegment.AddGenerator(generator.Value);
                
                //エネルギー消費者の結合
                foreach (var consumer in electric.Consumers) newSegment.AddEnergyConsumer(consumer.Value);
                
                //エネルギー輸送の結合
                foreach (var transformer in electric.EnergyTransformers)
                    newSegment.AddEnergyTransformer(transformer.Value);
            }
            
            return newSegment;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Localization/Localize.cs
```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using Client.Common;
using CsvHelper;
using UniRx;
using UnityEngine;

namespace Client.Localization
{
    public static class Localize
    {
        private const string DefaultLanguageCode = "english";
        private const int StartLocalizeTextIndex = 2;
        
        /// <summary>
        ///     ローカライズ用のテキストが入っている
        ///     Key : 国コード
        ///     Value : キーとテキストのペア
        /// </summary>
        private static readonly Dictionary<string, Dictionary<string, string>> localizeDictionary = new();
        
        private static readonly Subject<Unit> _onLanguageChangedSubject = new();
        
        public static IObservable<Unit> OnLanguageChanged => _onLanguageChangedSubject;
        
        public static string CurrentLanguageCode { get; private set; }
        public static List<string> LanguageCodes => localizeDictionary.Keys.ToList();
        
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void Initialize()
        {
            //player prefsから言語コードを取得
            CurrentLanguageCode = PlayerPrefs.GetString("LanguageCode", DefaultLanguageCode);
            
            // CSVファイルのパス
            var csvFilePath = Path.Combine(ServerConst.ServerDirectory, "config", "localization.csv");
            
            var languageCodes = new List<string>();
            var isFirstRow = true;
            
            using var reader = new StreamReader(csvFilePath);
            using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
            while (csv.Read())
            {
                if (isFirstRow)
                {
                    // csvの1行目は言語コードなので、それを取得
                    // 1列目はキー、2列目はソース文字、3列目以降は言語コードなので2から回す
                    for (var i = StartLocalizeTextIndex; csv.TryGetField<string>(i, out var field); i++)
                    {
                        languageCodes.Add(field);
                        localizeDictionary.Add(field, new Dictionary<string, string>());
                    }
                    
                    isFirstRow = false;
                    continue;
                }
                
                var keyAndValues = new List<string>();
                for (var i = 0; csv.TryGetField<string>(i, out var field); i++) keyAndValues.Add(field);
                
                var key = keyAndValues[0];
                for (var i = StartLocalizeTextIndex; i < keyAndValues.Count; i++)
                    //外部ソースから取得したテキストには改行コードが\nとして入っているので、それを\nに変換
                    localizeDictionary[languageCodes[i - 2]].Add(key, keyAndValues[i].Replace("\\n", "\n"));
            }
        }
        
        public static string Get(string key)
        {
            if (localizeDictionary[CurrentLanguageCode].TryGetValue(key, out var value)) return value;
            return $"[Localize] Key : {key} is not found";
        }
        
        public static void SetLanguage(string languageCode)
        {
            if (localizeDictionary.ContainsKey(languageCode))
            {
                CurrentLanguageCode = languageCode;
                PlayerPrefs.SetString("LanguageCode", languageCode);
                PlayerPrefs.Save();
                _onLanguageChangedSubject?.OnNext(Unit.Default);
            }
            else
            {
                Debug.LogError($"[Localize] Language Code : {languageCode} is not found");
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChallengeSaveLoadTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Challenge;
using Game.Context;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.CombinedTest.Server.PacketTest.Event;
using Tests.Module.TestMod;

namespace Tests.CombinedTest.Game
{
    public class ChallengeSaveLoadTest
    {
        private const int PlayerId = 1;
        
        [Test]
        public void NonCompletedChallengeSaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            
            // そのプレイヤーIDのチャレンジを作成する
            // create a challenge for that player ID
            var challengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            // 初期チャレンジが正しく設定されていることを確認する
            // Check that the initial challenge is set correctly
            var initialChallenge = MasterHolder.ChallengeMaster.InitialChallenge.Select(MasterHolder.ChallengeMaster.GetChallenge).ToList();
            Assert.AreEqual(initialChallenge.Count,challengeInfo.CurrentChallenges.Count);
            foreach (var currentChallenge in challengeInfo.CurrentChallenges)
            {
                var challenge = initialChallenge.Find(c => c.ChallengeGuid == currentChallenge.ChallengeMasterElement.ChallengeGuid);
                Assert.IsNotNull(challenge);
            }
            
            
            // なにもクリアしていない状態でセーブ
            // Save without clearing anything
            var saveJson = assembleSaveJsonText.AssembleSaveJson();
            
            // ロード
            // load
            (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            (serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(saveJson);
            
            // 初期チャレンジが正しく設定されていることを確認する
            // Check that the initial challenge is set correctly
            challengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            Assert.AreEqual(initialChallenge.Count,challengeInfo.CurrentChallenges.Count);
            foreach (var currentChallenge in challengeInfo.CurrentChallenges)
            {
                var challenge = initialChallenge.Find(c => c.ChallengeGuid == currentChallenge.ChallengeMasterElement.ChallengeGuid);
                Assert.IsNotNull(challenge);
            }
            // 何もクリアしていないことを確認
            // Check that nothing is cleared
            Assert.AreEqual(0,challengeInfo.CompletedChallengeGuids.Count);
        }
        
        [Test]
        public void CompletedChallengeSaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            
            // そのプレイヤーIDのチャレンジを作成する
            // create a challenge for that player ID
            var challengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            // 初期チャレンジが正しく設定されていることを確認する
            // Check that the initial challenge is set correctly
            var initialChallenge = MasterHolder.ChallengeMaster.InitialChallenge.Select(MasterHolder.ChallengeMaster.GetChallenge).ToList();
            foreach (var currentChallenge in challengeInfo.CurrentChallenges)
            {
                var challenge = initialChallenge.Find(c => c.ChallengeGuid == currentChallenge.ChallengeMasterElement.ChallengeGuid);
                Assert.IsNotNull(challenge);
            }
            
            // クラフトのチャレンジをクリアする
            // Clear the craft challenge
            ChallengeCompletedEventTest.ClearCraftChallenge(packet, serviceProvider);
            
            // クラフトのチャレンジがクリアされたことを確認する
            // Check that the craft challenge is cleared
            Assert.AreEqual(1, challengeInfo.CompletedChallengeGuids.Count);
            var currentChallengeCount = challengeInfo.CurrentChallenges.Count;
            
            // セーブ
            // Save
            var saveJson = assembleSaveJsonText.AssembleSaveJson();
            
            // ロード
            // load
            (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            (serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(saveJson);
            
            // チャレンジがクリアされていることを確認する
            // Check that the challenge is cleared
            var loadedChallengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            Assert.AreEqual(1, loadedChallengeInfo.CompletedChallengeGuids.Count);
            var challengeGuid = new Guid("00000000-0000-0000-4567-000000000001");
            Assert.AreEqual(challengeGuid, loadedChallengeInfo.CompletedChallengeGuids[0]);
            
            Assert.AreEqual(currentChallengeCount, loadedChallengeInfo.CurrentChallenges.Count);
            for (int i = 0; i < loadedChallengeInfo.CompletedChallengeGuids.Count; i++)
            {
                Assert.AreEqual(challengeInfo.CompletedChallengeGuids[i], loadedChallengeInfo.CompletedChallengeGuids[i]);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapVeinDatastore.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Map.Interface.Json;
using Game.Map.Interface.Vein;
using UnityEngine;

namespace Game.Map
{
    public class MapVeinDatastore : IMapVeinDatastore
    {
        private readonly List<IMapVein> _mapVeins = new();
        
        public MapVeinDatastore(MapInfoJson mapInfoJson)
        {
            //configからmap obejctを生成
            foreach (var veinJson in mapInfoJson.MapVeins)
            {
                var itemId = MasterHolder.ItemMaster.GetItemId(veinJson.VeinItemGuid);
                var vein = new MapVein(itemId, veinJson.MinPosition, veinJson.MaxPosition);
                _mapVeins.Add(vein);
            }
        }
        
        public List<IMapVein> GetOverVeins(Vector3Int pos)
        {
            var veins = new List<IMapVein>();
            foreach (var vein in _mapVeins)
                if (vein.VeinRangeMin.x <= pos.x && pos.x <= vein.VeinRangeMax.x &&
                    vein.VeinRangeMin.y <= pos.y && pos.y <= vein.VeinRangeMax.y)
                    veins.Add(vein);
            
            return veins;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Template/CraftChainerProviderChestTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Chest;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.CraftChainer.BlockComponent.ProviderChest;
using Game.CraftChainer.CraftNetwork;
using Mooresmaster.Model.BlocksModule;

namespace Game.CraftChainer.BlockComponent.Template
{
    public class CraftChainerProviderChestTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var chest = blockMasterElement.BlockParam as CraftChainerProviderChestBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(chest.InventoryConnectors, blockPositionInfo);
            
            var chainerProviderChestComponent = componentStates == null ?
                new CraftChainerProviderChestComponent() :
                new CraftChainerProviderChestComponent(componentStates);
            
            var inserter = new CraftChainerProviderChestBlockInventoryInserter(chainerProviderChestComponent.NodeId, inputConnectorComponent);
            
            var chestComponent = componentStates == null ? 
                new VanillaChestComponent(blockInstanceId, chest.ItemSlotCount, inserter) : 
                new VanillaChestComponent(componentStates, blockInstanceId, chest.ItemSlotCount, inserter);
            
            chainerProviderChestComponent.SetInitialVanillaChestComponent(chestComponent);
            
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
                chainerProviderChestComponent
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/PlaceBlockFromHotBarProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SendPlaceHotBarBlockProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:palceHotbarBlock";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public SendPlaceHotBarBlockProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SendPlaceHotBarBlockProtocolMessagePack>(payload.ToArray());
            var inventoryData = _playerInventoryDataStore.GetInventoryData(data.PlayerId);
            
            foreach (var placeInfo in data.PlacePositions)
            {
                PlaceBlock(placeInfo, data, inventoryData);
            }
            
            return null;
        }
        
        #region GetResponse
        
        static void PlaceBlock(PlaceInfoMessagePack placeInfo, SendPlaceHotBarBlockProtocolMessagePack data, PlayerInventoryData inventoryData)
        {
            //すでにブロックがある場合はそもまま処理を終了
            if (ServerContext.WorldBlockDatastore.Exists(placeInfo.Position)) return;
            
            //アイテムIDがブロックIDに変換できない場合はそもまま処理を終了
            var item = inventoryData.MainOpenableInventory.GetItem(data.InventorySlot);
            if (!MasterHolder.BlockMaster.IsBlock(item.Id)) return;
            
            // ブロックIDの設定
            var blockId = MasterHolder.BlockMaster.GetBlockId(item.Id);
            blockId = blockId.GetVerticalOverrideBlockId(placeInfo.VerticalDirection);
            
            //ブロックの設置
            ServerContext.WorldBlockDatastore.TryAddBlock(blockId, placeInfo.Position, placeInfo.Direction, out var block);
            
            //アイテムを減らし、セットする
            item = item.SubItem(1);
            inventoryData.MainOpenableInventory.SetItem(data.InventorySlot, item);
        }
        
        #endregion
        
        
        [MessagePackObject]
        public class SendPlaceHotBarBlockProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Key(3)] public int HotBarSlot { get; set; }
            [IgnoreMember] public int InventorySlot => PlayerInventoryConst.HotBarSlotToInventorySlot(HotBarSlot);
            
            [Key(4)] public List<PlaceInfoMessagePack> PlacePositions { get; set; }
            
            public SendPlaceHotBarBlockProtocolMessagePack(int playerId, int hotBarSlot, List<PlaceInfo> placeInfos)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                HotBarSlot = hotBarSlot;
                PlacePositions = placeInfos.ConvertAll(v => new PlaceInfoMessagePack(v));
            }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public SendPlaceHotBarBlockProtocolMessagePack() { }
        }
        
        [MessagePackObject]
        public class PlaceInfoMessagePack
        {
            [Key(0)] public Vector3IntMessagePack Position { get; set; }
            
            [Key(1)] public BlockDirection Direction { get; set; }
            
            [Key(2)] public BlockVerticalDirection VerticalDirection { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public PlaceInfoMessagePack() { }
            
            public PlaceInfoMessagePack(PlaceInfo placeInfo)
            {
                Position = new Vector3IntMessagePack(placeInfo.Position);
                Direction = placeInfo.Direction;
                VerticalDirection = placeInfo.VerticalDirection;
            }
        }
    }
    
    public class PlaceInfo
    {
        public Vector3Int Position { get; set; }
        public BlockDirection Direction { get; set; }
        public BlockVerticalDirection VerticalDirection { get; set; }
        
        public bool Placeable { get; set; }
    }
}
```

moorestech_client/Assets/Scripts/Editor/TreePlacer.cs
```cs
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using Random = UnityEngine.Random;

public class TreePlacer : EditorWindow
{
    // 木のPrefabの配列
    [SerializeField] private GameObject[] treePrefabs = Array.Empty<GameObject>();
    
    private float _maxTreeInterval = 8.0f;
    private float _maxTreeSize = 1.3f;
    
    //木同士の間隔
    private float _minTreeInterval = 4.5f;
    
    //木の大きさ
    private float _minTreeSize = 0.8f;
    
    // パーリンノイズのオフセット
    private Vector2 _offset = Vector2.zero;
    
    // 原点
    private Vector2 _origin = Vector2.zero;
    
    private GameObject _parent;
    
    // 配置する範囲
    private Vector2 _range = new(100, 100);
    
    
    // パーリンノイズの大きさ
    private float _scale = 0.1f;
    
    // 配置された木のゲームオブジェクトの配列
    private List<GameObject> _trees = new();
    
    // GUIを描画する処理
    private void OnGUI()
    {
        var so = new SerializedObject(this);
        so.Update();
        
        
        // パーリンノイズの大きさを設定するフィールドを表示
        _scale = EditorGUILayout.FloatField("Scale", _scale);
        // パーリンノイズのオフセットを設定するフィールドを表示
        _offset = EditorGUILayout.Vector2Field("Offset", _offset);
        // 配置する範囲を設定するフィールドを表示
        _range = EditorGUILayout.Vector2Field("Range", _range);
        // 原点を設定するフィールドを表示
        _origin = EditorGUILayout.Vector2Field("Origin", _origin);
        //木同士の感覚を設定するフィールドを表示
        _minTreeInterval = EditorGUILayout.FloatField("MinTreeInterval", _minTreeInterval);
        _maxTreeInterval = EditorGUILayout.FloatField("MaxTreeInterval", _maxTreeInterval);
        //木の大きさを設定するフィールドを表示
        _minTreeSize = EditorGUILayout.FloatField("MinTreeSize", _minTreeSize);
        _maxTreeSize = EditorGUILayout.FloatField("MaxTreeSize", _maxTreeSize);
        
        // 木のPrefabの配列を設定するフィールドを表示
        EditorGUILayout.PropertyField(so.FindProperty(nameof(treePrefabs)), true);
        
        _parent = EditorGUILayout.ObjectField("Parent", _parent, typeof(GameObject), true) as GameObject;
        
        // 木を配置するボタンを表示
        if (GUILayout.Button("Place Trees")) OnPlaceButton();
        
        if (GUILayout.Button("キャッシュをクリア")) _trees.Clear();
        
        so.ApplyModifiedProperties();
    }
    
    [MenuItem("Tools/TreePlacer")]
    private static void ShowWindow()
    {
        var window = GetWindow<TreePlacer>();
        window.titleContent = new GUIContent("TreePlacer");
        window.Show();
    }
    
    // 木を配置するボタンが押された時の処理
    private void OnPlaceButton()
    {
        // 木を配置する範囲を計算
        var min = _origin - _range * 0.5f;
        var max = _origin + _range * 0.5f;
        
        // 木をすべて削除
        foreach (var tree in _trees) DestroyImmediate(tree);
        
        _trees = new List<GameObject>();
        
        // 木を配置する範囲内を繰り返し
        for (var x = min.x; x < max.x; x += _minTreeInterval)
        for (var y = min.y; y < max.y; y += _minTreeInterval)
        {
            var tmpX = x + Random.Range(_minTreeInterval, _maxTreeInterval);
            var tmpY = y + Random.Range(_minTreeInterval, _maxTreeInterval);
            // パーリンノイズを取得
            var noise = Mathf.PerlinNoise((tmpX + _offset.x) * _scale, (tmpY + _offset.y) * _scale);
            // パーリンノイズが0.5より大きければ木を配置
            if (!(noise > 0.5f)) continue;
            
            // 配置する木のPrefabをランダムに選択
            var prefab = treePrefabs[Random.Range(0, treePrefabs.Length)];
            // 木を配置
            var tree = PrefabUtility.InstantiatePrefab(prefab) as GameObject;
            tree.transform.parent = _parent.transform;
            tree.transform.position = new Vector3(tmpX, 0, tmpY);
            var randomRotation = new Vector3(0, Random.Range(0, 360), 0);
            tree.transform.Rotate(randomRotation);
            var randomScale = Random.Range(_minTreeSize, _maxTreeSize);
            tree.transform.localScale = new Vector3(randomScale, randomScale, randomScale);
            // 配置された木を保存
            _trees.Add(tree);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/RecipeViewerTabElement.cs
```cs
using System;
using Client.Mod.Texture;
using Core.Master;
using UniRx;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class RecipeViewerTabElement : MonoBehaviour, IPointerDownHandler
    {
        [SerializeField] private RectTransform selectedTab;
        [SerializeField] private RectTransform unselectedTab;
        [SerializeField] private Image selectedIcon;
        [SerializeField] private Image unselectedIcon;
        
        [SerializeField] private Sprite craftIcon;
        
        public IObservable<RecipeViewerTabElement> OnClickTab => onClickTab; // nullならCraftを選択したことを意味する
        private readonly Subject<RecipeViewerTabElement> onClickTab = new(); // If null, it means that Craft is selected
        
        private RectTransform _rectTransform;
        public BlockId? CurrentBlockId { get; private set; }
    
        public void Initialize()
        {
            _rectTransform = GetComponent<RectTransform>();
        }
        
        public void SetSelected(bool selected)
        {
            selectedTab.gameObject.SetActive(selected);
            unselectedTab.gameObject.SetActive(!selected);
            var width = selected ? selectedTab.rect.width : unselectedTab.rect.width;
            
            _rectTransform.sizeDelta = new Vector2(width, _rectTransform.sizeDelta.y);
        }
        
        public void SetMachineItem(BlockId blockId, ItemViewData itemViewData)
        {
            CurrentBlockId = blockId;
            selectedIcon.sprite = itemViewData.ItemImage;
            unselectedIcon.sprite = itemViewData.ItemImage;
            
        }
        
        public void SetCraftIcon()
        {
            CurrentBlockId = null;
            selectedIcon.sprite = craftIcon;
            unselectedIcon.sprite = craftIcon;
        }
        
        public void OnPointerDown(PointerEventData eventData)
        {
            onClickTab.OnNext(this);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/GearBeltConveyorComponent.cs
```cs
using System;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;

namespace Game.Block.Blocks.BeltConveyor
{
    public class GearBeltConveyorComponent : GearEnergyTransformer, IUpdatableBlockComponent
    {
        private readonly VanillaBeltConveyorComponent _beltConveyorComponent;
        private readonly double _beltConveyorSpeed;
        private readonly Torque _requiredTorque;
        
        public GearBeltConveyorComponent(VanillaBeltConveyorComponent beltConveyorComponent, BlockInstanceId entityId, double beltConveyorSpeed, Torque requiredTorque, BlockConnectorComponent<IGearEnergyTransformer> blockConnectorComponent)
            : base(requiredTorque, entityId, blockConnectorComponent)
        {
            _beltConveyorComponent = beltConveyorComponent;
            _requiredTorque = requiredTorque;
            _beltConveyorSpeed = beltConveyorSpeed;
        }
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
        }
        
        public override void SupplyPower(RPM rpm, Torque torque, bool isClockwise)
        {
            base.SupplyPower(rpm, torque, isClockwise);
            var torqueRate = torque / _requiredTorque;
            var speed = torqueRate.AsPrimitive() * rpm.AsPrimitive() * _beltConveyorSpeed;
            _beltConveyorComponent.SetTimeOfItemEnterToExit(1 / speed);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/MultiSizeBlockTest.cs
```cs
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.World.Interface.DataStore;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    public class MultiSizeBlockTest
    {
        public static readonly BlockId Block_1x4_Id = (BlockId)9;
        public static readonly BlockId Block_3x2_Id = (BlockId)10;
        public static readonly BlockId Block_1x2x3_Id = (BlockId)11;
        
        private IWorldBlockDatastore worldDatastore;
        
        [Test]
        public void BlockPlaceAndGetTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            worldDatastore = ServerContext.WorldBlockDatastore;
            
            //平面設置の検証
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(10, 0, 10), BlockDirection.North, out _);
            RetrieveBlock(Block_1x4_Id, new Vector3Int(10, 0, 10));
            RetrieveBlock(Block_1x4_Id, new Vector3Int(10, 0, 13));
            RetrieveNonExistentBlock(new Vector3Int(9, 0, 10));
            RetrieveNonExistentBlock(new Vector3Int(10, 0, 15));
            
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(10, 0, -10), BlockDirection.East, out _);
            RetrieveBlock(Block_1x4_Id, new Vector3Int(10, 0, -10));
            RetrieveBlock(Block_1x4_Id, new Vector3Int(13, 0, -10));
            RetrieveNonExistentBlock(new Vector3Int(9, 0, -10));
            RetrieveNonExistentBlock(new Vector3Int(15, 0, -10));
            
            worldDatastore.TryAddBlock(Block_3x2_Id, new Vector3Int(-10, 0, -10), BlockDirection.South, out _);
            RetrieveBlock(Block_3x2_Id, new Vector3Int(-10, 0, -10));
            RetrieveBlock(Block_3x2_Id, new Vector3Int(-8, 0, -9));
            RetrieveNonExistentBlock(new Vector3Int(-10, 0, -11));
            RetrieveNonExistentBlock(new Vector3Int(-7, 0, -9));
            
            //立体設置の検証
            worldDatastore.TryAddBlock(Block_1x2x3_Id, new Vector3Int(20, 0, 20), BlockDirection.North, out _);
            RetrieveBlock(Block_1x2x3_Id, new Vector3Int(20, 0, 20));
            RetrieveBlock(Block_1x2x3_Id, new Vector3Int(20, 1, 22));
            RetrieveNonExistentBlock(new Vector3Int(21, 1, 22));
            RetrieveNonExistentBlock(new Vector3Int(20, 2, 22));
            RetrieveNonExistentBlock(new Vector3Int(20, 1, 23));
            
            worldDatastore.TryAddBlock(Block_1x2x3_Id, new Vector3Int(40, 0, 40), BlockDirection.UpEast, out _);
            RetrieveBlock(Block_1x2x3_Id, new Vector3Int(40, 0, 40));
            RetrieveBlock(Block_1x2x3_Id, new Vector3Int(41, 2, 40));
            RetrieveNonExistentBlock(new Vector3Int(42, 2, 40));
            RetrieveNonExistentBlock(new Vector3Int(41, 3, 40));
            RetrieveNonExistentBlock(new Vector3Int(41, 2, 41));
        }
        
        
        [Test]
        public void OverlappingBlockTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            worldDatastore = ServerContext.WorldBlockDatastore;
            
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(10, 0, 10), BlockDirection.North, out _);
            worldDatastore.TryAddBlock(Block_3x2_Id, new Vector3Int(10, 0, 12), BlockDirection.South, out _);
            
            //3x2が設置されてないことをチェックする
            RetrieveBlock(Block_3x2_Id, new Vector3Int(11, 0, 12));
        }
        
        [Test]
        public void BoundaryBlockTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            worldDatastore = ServerContext.WorldBlockDatastore;
            
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(10, 0, 10), BlockDirection.North, out _);
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(11, 0, 11), BlockDirection.East, out _);
            
            //1x4が設置されてないことをチェックする
            RetrieveBlock(Block_1x4_Id, new Vector3Int(11, 0, 11));
        }
        
        /// <summary>
        ///     ブロックが設置されていることを確認する
        /// </summary>
        private void RetrieveBlock(BlockId expectedBlockId, Vector3Int position)
        {
            var block = worldDatastore.GetBlock(position);
            Assert.IsNotNull(block);
            Assert.AreEqual(expectedBlockId, block.BlockId);
        }
        
        /// <summary>
        ///     ブロックが設置されていないことを確認する
        /// </summary>
        private void RetrieveNonExistentBlock(Vector3Int position)
        {
            Assert.False(worldDatastore.Exists(position));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailNodeId.cs
```cs
using System;
using UnitGenerator;

namespace Game.Train.RailGraph
{
    //多分uintで十分
    [UnitOf(typeof(uint))]
    public partial struct RailNodeId
    {
        private static readonly Random Random = new();
        
        public static RailNodeId Create()
        {
            uint result = (uint)Random.Next(int.MinValue, int.MaxValue);
            return new RailNodeId(result);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Crafter/CraftCraftChainerCrafterComponent.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using MessagePack;
using Newtonsoft.Json;

namespace Game.CraftChainer.BlockComponent.Crafter
{
    public class CraftCraftChainerCrafterComponent : ICraftChainerNode, IBlockStateDetail
    {
        public CraftChainerNodeId NodeId { get; } = CraftChainerNodeId.Create();
        
        public CraftingSolverRecipe CraftingSolverRecipe { get; private set; } = new();
        
        public CraftCraftChainerCrafterComponent() { }
        
        public CraftCraftChainerCrafterComponent(Dictionary<string, string> componentStates) : this()
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerCrafterComponentSerializeObject>(state);
            CraftingSolverRecipe = jsonObject.Recipe.ToCraftingSolverRecipe();
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        public void SetRecipe(List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
        {
            var id = CraftingSolverRecipeId.Create();
            CraftingSolverRecipe = new CraftingSolverRecipe(id, inputItems, outputItem);
        }
        
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public BlockStateDetail GetBlockStateDetail()
        {
            var bytes = MessagePackSerializer.Serialize(new ChainerCrafterComponentSerializeObject(this));
            return new BlockStateDetail(ChainerCrafterComponentSerializeObject.StateDetailKey, bytes);
        }
        
        public string SaveKey { get; } = typeof(CraftCraftChainerCrafterComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerCrafterComponentSerializeObject(this));
        }
    }
    
    [JsonObject, MessagePackObject]
    public class ChainerCrafterComponentSerializeObject
    {
        public const string StateDetailKey = "ChainerCrafterComponent";
        
        [JsonProperty("recipe"), Key(0)] public CraftingSolverRecipeJsonObjectMessagePack Recipe { get; set; }
        [JsonProperty("nodeId"), Key(1)] public int NodeId { get; set; }
        
        public ChainerCrafterComponentSerializeObject(){}
        public ChainerCrafterComponentSerializeObject(CraftCraftChainerCrafterComponent component)
        {
            Recipe = new CraftingSolverRecipeJsonObjectMessagePack(component.CraftingSolverRecipe);
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/MainInventoryUpdateEventPacket.cs
```cs
using System;
using Core.Item.Interface;
using Game.PlayerInventory.Interface.Event;
using MessagePack;
using Server.Util.MessagePack;

namespace Server.Event.EventReceive
{
    public class MainInventoryUpdateEventPacket
    {
        public const string EventTag = "va:event:mainInvUpdate";
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public MainInventoryUpdateEventPacket(IMainInventoryUpdateEvent mainInventoryUpdateEvent,
            EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            mainInventoryUpdateEvent.Subscribe(ReceivedEvent);
        }
        
        
        private void ReceivedEvent(PlayerInventoryUpdateEventProperties playerInventoryUpdateEvent)
        {
            var messagePack = new MainInventoryUpdateEventMessagePack(playerInventoryUpdateEvent.InventorySlot, playerInventoryUpdateEvent.ItemStack);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddEvent(playerInventoryUpdateEvent.PlayerId, EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class MainInventoryUpdateEventMessagePack
    {
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public MainInventoryUpdateEventMessagePack()
        {
        }
        
        public MainInventoryUpdateEventMessagePack(int slot, IItemStack itemStack)
        {
            Slot = slot;
            Item = new ItemMessagePack(itemStack.Id, itemStack.Count);
        }
        
        [Key(0)] public int Slot { get; set; }
        
        [Key(1)] public ItemMessagePack Item { get; set; }
    }
}
```

moorestech_client/Assets/Scripts/Editor/MapExportAndSetting.cs
```cs
using System.Collections.Generic;
using System.IO;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Map.MapVein;
using Game.Map.Interface.Json;
using Newtonsoft.Json;
using UnityEditor;
using UnityEngine;

public class MapExportAndSetting : EditorWindow
{
    private void OnGUI()
    {
        if (!GUILayout.Button("Export and Setting Map")) return;
        
        var mapObjectConfig = new MapInfoJson
        {
            MapObjects = SetUpMapObjectInfos(),
            MapVeins = GetMapVeinInfo(),
        };
        
        // jsonに変換
        var json = JsonConvert.SerializeObject(mapObjectConfig, Formatting.Indented);
        
        //ダイアログを出して保存
        var path = EditorUtility.SaveFilePanel("Save map object config", "../../Server/map/", "map", "json");
        if (path.Length != 0) File.WriteAllText(path, json);
        
        
        #region Internal
        
        List<MapObjectInfoJson> SetUpMapObjectInfos()
        {
            var datastore = FindObjectOfType<MapObjectGameObjectDatastore>();
            datastore.FindMapObjects();
            EditorUtility.SetDirty(datastore);
            
            var instanceId = 0;
            var result = new List<MapObjectInfoJson>();
            
            foreach (var mapObject in datastore.MapObjects)
            {
                mapObject.SetMapObjectData(instanceId);
                instanceId++;
                
                var config = new MapObjectInfoJson
                {
                    MapObjectGuidStr = mapObject.MapObjectGuid.ToString(),
                    InstanceId = mapObject.InstanceId,
                    X = mapObject.GetPosition().x,
                    Y = mapObject.GetPosition().y,
                    Z = mapObject.GetPosition().z,
                };
                result.Add(config);
            }
            
            return result;
        }
        
        List<MapVeinInfoJson> GetMapVeinInfo()
        {
            var veins = FindObjectsOfType<MapVeinGameObject>();
            var result = new List<MapVeinInfoJson>();
            
            foreach (var vein in veins)
            {
                var config = new MapVeinInfoJson
                {
                    VeinItemGuidStr = vein.VeinItemGuid.ToString(),
                    MinX = vein.MinPosition.x,
                    MinY = vein.MinPosition.y,
                    MinZ = vein.MinPosition.z,
                    
                    MaxX = vein.MaxPosition.x,
                    MaxY = vein.MaxPosition.y,
                    MaxZ = vein.MaxPosition.z,
                };
                result.Add(config);
            }
            
            return result;
        }
        
        #endregion
    }
    
    [MenuItem("moorestech/MapExportAndSetting")]
    private static void ShowWindow()
    {
        var window = GetWindow<MapExportAndSetting>();
        window.titleContent = new GUIContent("MapExportAndSetting");
        window.Show();
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.Map.Interface.Json;
using Game.Map.Interface.MapObject;
using Game.SaveLoad.Json;

namespace Game.Map
{
    public class MapObjectDatastore : IMapObjectDatastore
    {
        private readonly IMapObjectFactory _mapObjectFactory;
        
        /// <summary>
        ///     このデータが空になる場合はワールドのロードか初期化ができていない状態である可能性が高いです。
        ///     単純にmapObjectがない場合もありますが、、
        ///     <see cref="WorldLoaderFromJson" />でロードもしくは初期化を行ってください。
        /// </summary>
        private readonly Dictionary<int, IMapObject> _mapObjects = new();
        
        public MapObjectDatastore(IMapObjectFactory mapObjectFactory, MapInfoJson mapInfoJson)
        {
            _mapObjectFactory = mapObjectFactory;
            
            foreach (var mapObjectInfo in mapInfoJson.MapObjects)
            {
                var mapObjectConfig = MasterHolder.MapObjectMaster.GetMapObjectElement(mapObjectInfo.MapObjectGuid);
                var hp = mapObjectConfig.Hp;
                
                var mapObject = _mapObjectFactory.Create(mapObjectInfo.InstanceId, mapObjectInfo.MapObjectGuid, hp, false, mapObjectInfo.Position);
                _mapObjects.Add(mapObject.InstanceId, mapObject);
                mapObject.OnDestroy += () => OnDestroyMapObject?.Invoke(mapObject);
            }
        }
        
        public event Action<IMapObject> OnDestroyMapObject;
        
        public IReadOnlyList<IMapObject> MapObjects => _mapObjects.Values.ToList();
        
        public void Add(IMapObject mapObject)
        {
            _mapObjects.Add(mapObject.InstanceId, mapObject);
            mapObject.OnDestroy += () => OnDestroyMapObject?.Invoke(mapObject);
        }
        
        public IMapObject Get(int instanceId)
        {
            return _mapObjects[instanceId];
        }
        
        public void LoadMapObject(List<MapObjectJsonObject> savedMapObjects)
        {
            foreach (var savedMapObject in savedMapObjects)
            {
                if (!_mapObjects.TryGetValue(savedMapObject.instanceId, out var loadedMapObject)) throw new KeyNotFoundException($"セーブデータ内にあるインスタンスID: {savedMapObject.instanceId} のmapObjectが実際のマップに存在しません。");
                
                //破壊状況をロード
                if (savedMapObject.isDestroyed) loadedMapObject.Destroy();
                if (savedMapObject.hp != loadedMapObject.CurrentHp) loadedMapObject.Attack(loadedMapObject.CurrentHp - savedMapObject.hp);
            }
        }
        
        public List<MapObjectJsonObject> GetSaveJsonObject()
        {
            return _mapObjects.Select(m => new MapObjectJsonObject(m.Value)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/RequestWorldDataProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Context;
using Game.Entity.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse.Util;
using Server.Util.MessagePack;

namespace Server.Protocol.PacketResponse
{
    public class RequestWorldDataProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:getWorldData";
        private readonly IEntityFactory _entityFactory;
        
        public RequestWorldDataProtocol(ServiceProvider serviceProvider)
        {
            _entityFactory = serviceProvider.GetService<IEntityFactory>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var blockMasterDictionary = ServerContext.WorldBlockDatastore.BlockMasterDictionary;
            var blockResult = new List<BlockDataMessagePack>();
            foreach (var blockMaster in blockMasterDictionary)
            {
                var block = blockMaster.Value.Block;
                var pos = blockMaster.Value.BlockPositionInfo.OriginalPos;
                var blockDirection = blockMaster.Value.BlockPositionInfo.BlockDirection;
                blockResult.Add(new BlockDataMessagePack(block.BlockId, pos, blockDirection));
            }
            
            //TODO 今はベルトコンベアのアイテムをエンティティとして返しているだけ 今後は本当のentityも返す
            var items = CollectBeltConveyorItems.CollectItemFromWorld(_entityFactory);
            var entities = new List<EntityMessagePack>();
            entities.AddRange(items.Select(item => new EntityMessagePack(item)));
            
            
            return new ResponseWorldDataMessagePack(blockResult.ToArray(), entities.ToArray());
        }
        
        
        [MessagePackObject]
        public class RequestWorldDataMessagePack : ProtocolMessagePackBase
        {
            public RequestWorldDataMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
        
        [MessagePackObject]
        public class ResponseWorldDataMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public BlockDataMessagePack[] Blocks { get; set; }
            [Key(3)] public EntityMessagePack[] Entities { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ResponseWorldDataMessagePack() { }
            public ResponseWorldDataMessagePack(BlockDataMessagePack[] Block, EntityMessagePack[] entities)
            {
                Tag = ProtocolTag;
                Blocks = Block;
                Entities = entities;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaChestTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.Service;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaChestTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var chest = blockMasterElement.BlockParam as ChestBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(chest.InventoryConnectors, blockPositionInfo);
            var inserter = new ConnectingInventoryListPriorityInsertItemService(inputConnectorComponent);
            
            var chestComponent = componentStates == null ?
                new VanillaChestComponent(blockInstanceId, chest.ChestItemSlotCount, inserter) :
                new VanillaChestComponent(componentStates, blockInstanceId, chest.ChestItemSlotCount, inserter);
            
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Sequence/ChallengeManager.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.BackgroundSkit;
using Client.Game.InGame.Context;
using Client.Game.InGame.Tutorial;
using Client.Network.API;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Challenge;
using Game.Context;
using MessagePack;
using Mooresmaster.Model.ChallengesModule;
using Server.Event.EventReceive;
using TMPro;
using UnityEngine;
using VContainer;

namespace Client.Game.Sequence
{
    public class ChallengeManager : MonoBehaviour
    {
        [SerializeField] private TMP_Text currentChallengeSummary;
        [SerializeField] private BackgroundSkitManager backgroundSkitManager;
        
        [SerializeField] private List<ChallengeTextAsset> challengeTextAssets;
        
        private TutorialManager _tutorialManager;
        
        [Inject]
        public void Construct(InitialHandshakeResponse initialHandshakeResponse, TutorialManager tutorialManager)
        {
            _tutorialManager = tutorialManager;
            
            //TODO 複数のチャレンジを表示する
            if (initialHandshakeResponse.Challenge.CurrentChallenges.Count != 0)
            {
                var currentChallenge = initialHandshakeResponse.Challenge.CurrentChallenges.First();
                if (currentChallenge != null) currentChallengeSummary.text = currentChallenge.Summary;
                
                ClientContext.VanillaApi.Event.SubscribeEventResponse(CompletedChallengeEventPacket.EventTag, OnCompletedChallenge);
                
                // チュートリアルの適用
                // Apply tutorial
                initialHandshakeResponse.Challenge.CurrentChallenges.ForEach(c => _tutorialManager.ApplyTutorial(c.ChallengeGuid));
            }
        }
        
        private void OnCompletedChallenge(byte[] packet)
        {
            var message = MessagePackSerializer.Deserialize<CompletedChallengeEventMessage>(packet);
            var challengeInfo = MasterHolder.ChallengeMaster.GetChallenge(message.CompletedChallengeGuid);
            var nextChallenges = MasterHolder.ChallengeMaster.GetNextChallenges(challengeInfo.ChallengeGuid);
            
            // チュートリアルを完了
            _tutorialManager.CompleteChallenge(message.CompletedChallengeGuid);
            
            // スキットの再生
            // Play background skit
            PlaySkit(nextChallenges).Forget();
            
            // チャレンジのテキストの更新 TODO 複数のチャレンジに対応させる
            // Update challenge text TODO Correspond to multiple challenges
            if (nextChallenges.Count != 0)
            {
                var nextChallenge = nextChallenges.First();
                currentChallengeSummary.text = nextChallenge.Summary;
            }
            
            // チュートリアルの適用
            // Apply tutorial
            nextChallenges.ForEach(id => _tutorialManager.ApplyTutorial(id.ChallengeGuid));
        }
        
        private async UniTask PlaySkit(List<ChallengeMasterElement> nextChallenges)
        {
            foreach (var challenge in nextChallenges)
            {
                if (challenge.PlaySkitType == "BackgroundSkit") // TODO いい感じの位置に置きたい
                {
                    var skitParam = (BackgroundSkitPlaySkitParam) challenge.PlaySkitParam;
                    var challengeTextAsset = challengeTextAssets.FirstOrDefault(x => x.SkitName == skitParam.FireSkitName);
                    if (challengeTextAsset == null) continue;
                    
                    await backgroundSkitManager.StartBackgroundSkit(challengeTextAsset.TextAsset);
                }
            }
        }
    }
    
    [Serializable]
    public class ChallengeTextAsset
    {
        public string SkitName;
        public TextAsset TextAsset;
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/PlayerInventoryDataStore.cs
```cs
using System.Collections.Generic;
using Game.PlayerInventory.Event;
using Game.PlayerInventory.Interface;
using Game.PlayerInventory.Interface.Event;
using Game.PlayerInventory.ItemManaged;

namespace Game.PlayerInventory
{
    /// <summary>
    ///     プレイヤーインベントリのデータを扱います。
    /// </summary>
    public class PlayerInventoryDataStore : IPlayerInventoryDataStore
    {
        private readonly GrabInventoryUpdateEvent _grabInventoryUpdateEvent;
        
        
        private readonly MainInventoryUpdateEvent _mainInventoryUpdateEvent;
        private readonly Dictionary<int, PlayerInventoryData> _playerInventoryData = new();
        
        public PlayerInventoryDataStore(IMainInventoryUpdateEvent mainInventoryUpdateEvent, IGrabInventoryUpdateEvent grabInventoryUpdateEvent)
        {
            //イベントの呼び出しをアセンブリに隠蔽するため、インターフェースをキャストします。
            _mainInventoryUpdateEvent = (MainInventoryUpdateEvent)mainInventoryUpdateEvent;
            _grabInventoryUpdateEvent = (GrabInventoryUpdateEvent)grabInventoryUpdateEvent;
        }
        
        public PlayerInventoryData GetInventoryData(int playerId)
        {
            if (!_playerInventoryData.ContainsKey(playerId))
            {
                var main = new MainOpenableInventoryData(playerId, _mainInventoryUpdateEvent);
                var grab = new GrabInventoryData(playerId, _grabInventoryUpdateEvent);
                
                _playerInventoryData.Add(playerId, new PlayerInventoryData(main, grab));
            }
            
            return _playerInventoryData[playerId];
        }
        
        public List<PlayerInventorySaveJsonObject> GetSaveJsonObject()
        {
            var savePlayerInventoryList = new List<PlayerInventorySaveJsonObject>();
            //セーブデータに必要なデータをまとめる
            foreach (var inventory in _playerInventoryData)
            {
                var saveInventoryData = new PlayerInventorySaveJsonObject(inventory.Key, inventory.Value);
                savePlayerInventoryList.Add(saveInventoryData);
            }
            
            return savePlayerInventoryList;
        }
        
        /// <summary>
        ///     プレイヤーのデータを置き換える
        /// </summary>
        public void LoadPlayerInventory(List<PlayerInventorySaveJsonObject> saveInventoryDataList)
        {
            foreach (var saveInventory in saveInventoryDataList)
            {
                var playerId = saveInventory.PlayerId;
                (var mainItems, var grabItem) = saveInventory.GetPlayerInventoryData();
                
                //アイテムを復元
                var main = new MainOpenableInventoryData(playerId, _mainInventoryUpdateEvent, mainItems);
                var grab = new GrabInventoryData(playerId, _grabInventoryUpdateEvent, grabItem);
                
                var playerInventory = new PlayerInventoryData(main, grab);
                
                //インベントリの追加を行う　既にあるなら置き換える
                _playerInventoryData[playerId] = playerInventory;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/RendererMaterialReplacer.cs
```cs
using System;
using System.Collections.Generic;
using Client.Common;
using Client.Game.InGame.Context;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Client.Game.InGame.Block
{
    public class RendererMaterialReplacer
    {
        /// <summary>
        ///     ゲームオブジェクトのパスに、このリストに含まれる文字列が含まれている場合、マテリアルを置き換えない
        ///     Do not replace materials if the game object's path contains any of the strings in this list.
        /// </summary>
        private readonly List<string> _ignoreGameObjectPathKeyWords = new() { "/VFX/"};
        
        private readonly Renderer _renderer;
        private readonly List<Material> _originalMaterials = new();
        private readonly List<Material> _replacedMaterials = new();
        
        public RendererMaterialReplacer(Renderer renderer)
        {
            var path = renderer.gameObject.GetFullPath();
            foreach (var keyWord in _ignoreGameObjectPathKeyWords)
            {
                if (!path.Contains(keyWord)) continue;
                return;
            }
            
            _renderer = renderer;
            _originalMaterials = new List<Material>();
            foreach (var material in renderer.sharedMaterials) _originalMaterials.Add(material);
        }
        
        public void CopyAndSetMaterial(Material placeMaterial)
        {
            if (_renderer == null) return;
            // TODO ログシステムに入れる
            if (placeMaterial == null) throw new NullReferenceException("The specified material is null.");
            
            // TODO ちゃんとマテリアルをアンロードする方法を考える
            ResetMaterial();
            
            foreach (var material in _renderer.sharedMaterials)
            {
                var mainTexture = material.mainTexture;
                var mainColor = material.color;
                
                var newMaterial = new Material(placeMaterial)
                {
                    mainTexture = mainTexture,
                    mainTextureOffset = material.mainTextureOffset,
                    mainTextureScale = material.mainTextureScale,
                    color = mainColor,
                };
                
                _replacedMaterials.Add(newMaterial);
            }
            
            _renderer.materials = _replacedMaterials.ToArray();
        }
        
        public void SetPlaceMaterialProperty(string propertyName, float value)
        {
            foreach (var material in _replacedMaterials) material.SetFloat(propertyName, value);
        }
        
        public void SetColor(string propertyName, Color color)
        {
            foreach (var material in _replacedMaterials) material.SetColor(propertyName, color);
        }
        
        public void ResetMaterial()
        {
            if (_renderer == null) return;
            
            //作ったプレビュー用のマテリアルを削除
            foreach (var material in _replacedMaterials) Object.Destroy(material);
            _replacedMaterials.Clear();
            _renderer.materials = _originalMaterials.ToArray();
        }
        
        public void DestroyMaterial()
        {
            _replacedMaterials.Clear();
            _originalMaterials.Clear();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Util/UIEnterExplainerController.cs
```cs
using UnityEngine;
using UnityEngine.EventSystems;

namespace Client.Game.InGame.UI.Util
{
    /// <summary>
    ///     UIにアタッチして、そのUI要素にマウスカーソルが乗ったら文字列を表示するシステム
    /// </summary>
    public class UIEnterExplainerController : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerMoveHandler
    {
        /// <summary>
        ///     カーソルに表示するテキスト
        /// </summary>
        [SerializeField] private string textKey;
        
        /// <summary>
        ///     表示するかどうか
        /// </summary>
        [SerializeField] private bool displayEnable;
        
        [SerializeField] private int fontSize = IMouseCursorExplainer.DefaultFontSize;
        private bool _isLocalize;
        
        private bool _pointerStay;
        
        public void OnPointerMove(PointerEventData eventData)
        {
            _pointerStay = true;
            UpdateMouseCursorExplainer();
        }
        
        
        public void SetText(string text, bool isLocalize = true)
        {
            _isLocalize = isLocalize;
            textKey = text;
        }
        
        /// <summary>
        ///     フラグが変更されたあと表示、非表示設定を行う
        /// </summary>
        private void UpdateMouseCursorExplainer()
        {
            //表示する設定で、ポインターが乗ったので表示
            if (_pointerStay && displayEnable)
            {
                MouseCursorExplainer.Instance.Show(textKey, fontSize, _isLocalize);
                return;
            }
            
            if (!_pointerStay || //ポインターから外れたので非表示
                _pointerStay && !displayEnable) //ポインターからは外れてないけど非表示設定なったから非表示
                MouseCursorExplainer.Instance.Hide();
        }
        
        
        #region フラグコントローラー
        
        public void DisplayEnable(bool enable)
        {
            displayEnable = enable;
            if (_pointerStay) UpdateMouseCursorExplainer();
        }
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            _pointerStay = true;
            UpdateMouseCursorExplainer();
        }
        
        public void OnPointerExit(PointerEventData eventData)
        {
            _pointerStay = false;
            UpdateMouseCursorExplainer();
        }
        
        private void OnDestroy()
        {
            _pointerStay = false;
            UpdateMouseCursorExplainer();
        }
        
        private void OnDisable()
        {
            _pointerStay = false;
            UpdateMouseCursorExplainer();
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/DisconnectTwoOrMoreElectricPoleFromSegmentService.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class DisconnectTwoOrMoreElectricPoleFromSegmentService<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        public static void Disconnect(IElectricTransformer removedElectricPole,
            EnergyServiceDependencyContainer<TSegment> container)
        {
            //データを取得
            var removedSegment = container.WorldEnergySegmentDatastore.GetEnergySegment(removedElectricPole);
            
            //自身が所属していたセグメントの電柱のリストを取る
            var connectedElectricPoles = new List<IElectricTransformer>();
            foreach (var onePole in removedSegment.EnergyTransformers) connectedElectricPoles.Add(onePole.Value);
            //この電柱のリストをもとに電力セグメントを再構成するため、削除した電柱はリストから削除する
            connectedElectricPoles.Remove(removedElectricPole);
            
            
            //元のセグメントを消す
            container.WorldEnergySegmentDatastore.RemoveEnergySegment(removedSegment);
            
            
            //電柱を全て探索し、電力セグメントを再構成する
            //1個ずつ電柱を取り出し、電力セグメントに追加する
            //電力セグメントに追加した電柱はリストから削除する
            //電柱のリストが空になるまで繰り返す
            while (connectedElectricPoles.Count != 0)
            {
                (var newElectricPoles, var newBlocks, var newGenerators) =
                    GetElectricPoles(
                        connectedElectricPoles[0],
                        removedElectricPole,
                        new Dictionary<BlockInstanceId, IElectricTransformer>(),
                        new Dictionary<BlockInstanceId, IElectricConsumer>(),
                        new Dictionary<BlockInstanceId, IElectricGenerator>(), container);
                
                
                //新しいセグメントに電柱、ブロック、発電機を追加する
                var newElectricSegment = container.WorldEnergySegmentDatastore.CreateEnergySegment();
                foreach (var newElectric in newElectricPoles)
                {
                    newElectricSegment.AddEnergyTransformer(newElectric.Value);
                    //今までの電柱リストから削除する
                    connectedElectricPoles.Remove(newElectric.Value);
                }
                
                foreach (var newBlock in newBlocks) newElectricSegment.AddEnergyConsumer(newBlock.Value);
                foreach (var newGenerator in newGenerators) newElectricSegment.AddGenerator(newGenerator.Value);
            }
        }
        
        //再帰的に電柱を探索する 
        private static (Dictionary<BlockInstanceId, IElectricTransformer>, Dictionary<BlockInstanceId, IElectricConsumer>,
            Dictionary<BlockInstanceId, IElectricGenerator>)
            GetElectricPoles(
                IElectricTransformer electricPole,
                IElectricTransformer removedElectricPole,
                Dictionary<BlockInstanceId, IElectricTransformer> electricPoles,
                Dictionary<BlockInstanceId, IElectricConsumer> blockElectrics,
                Dictionary<BlockInstanceId, IElectricGenerator> powerGenerators,
                EnergyServiceDependencyContainer<TSegment> container)
        {
            var pos = ServerContext.WorldBlockDatastore.GetBlockPosition(electricPole.BlockInstanceId);
            var block = ServerContext.WorldBlockDatastore.GetBlock(pos);
            var poleConfig = block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            
            
            //周辺の機械、発電機を取得
            var (newBlocks, newGenerators) =
                FindMachineAndGeneratorFromPeripheralService.Find(pos, poleConfig);
            //ブロックと発電機を追加
            foreach (var newBlock in newBlocks)
            {
                if (blockElectrics.ContainsKey(newBlock.BlockInstanceId)) continue;
                blockElectrics.Add(newBlock.BlockInstanceId, newBlock);
            }
            
            foreach (var generator in newGenerators)
            {
                if (powerGenerators.ContainsKey(generator.BlockInstanceId)) continue;
                powerGenerators.Add(generator.BlockInstanceId, generator);
            }
            
            
            //周辺の電柱を取得
            var peripheralElectricPoles = FindElectricPoleFromPeripheralService.Find(pos, poleConfig);
            //削除された電柱は除く
            peripheralElectricPoles.Remove(removedElectricPole);
            //自身の電柱は追加する
            electricPoles.Add(electricPole.BlockInstanceId, electricPole);
            //周辺に電柱がない場合は終了
            if (peripheralElectricPoles.Count == 0) return (electricPoles, blockElectrics, powerGenerators);
            
            
            //周辺の電柱を再帰的に取得する
            foreach (var peripheralElectricPole in peripheralElectricPoles)
            {
                //もしもすでに追加されていた電柱ならスキップ
                if (electricPoles.ContainsKey(peripheralElectricPole.BlockInstanceId)) continue;
                //追加されていない電柱なら追加
                (electricPoles, blockElectrics, powerGenerators) =
                    GetElectricPoles(peripheralElectricPole, removedElectricPole, electricPoles, blockElectrics,
                        powerGenerators, container);
            }
            
            return (electricPoles, blockElectrics, powerGenerators);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponseCreator.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Event;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Server.Protocol
{
    public class PacketResponseCreator
    {
        private readonly Dictionary<string, IPacketResponse> _packetResponseDictionary = new();
        
        //TODO この辺もDIコンテナに載せる?こういうパケット周りめっちゃなんとかしたい
        public PacketResponseCreator(ServiceProvider serviceProvider)
        {
            _packetResponseDictionary.Add(InitialHandshakeProtocol.ProtocolTag, new InitialHandshakeProtocol(serviceProvider));
            _packetResponseDictionary.Add(RequestWorldDataProtocol.ProtocolTag, new RequestWorldDataProtocol(serviceProvider));
            _packetResponseDictionary.Add(PlayerInventoryResponseProtocol.ProtocolTag, new PlayerInventoryResponseProtocol(serviceProvider));
            _packetResponseDictionary.Add(SetPlayerCoordinateProtocol.ProtocolTag, new SetPlayerCoordinateProtocol(serviceProvider));
            _packetResponseDictionary.Add(EventProtocol.ProtocolTag, new EventProtocol(serviceProvider.GetService<EventProtocolProvider>()));
            _packetResponseDictionary.Add(InventoryItemMoveProtocol.ProtocolTag, new InventoryItemMoveProtocol(serviceProvider));
            _packetResponseDictionary.Add(SendPlaceHotBarBlockProtocol.ProtocolTag, new SendPlaceHotBarBlockProtocol(serviceProvider));
            _packetResponseDictionary.Add(BlockInventoryRequestProtocol.ProtocolTag, new BlockInventoryRequestProtocol(serviceProvider));
            _packetResponseDictionary.Add(RemoveBlockProtocol.ProtocolTag, new RemoveBlockProtocol(serviceProvider));
            _packetResponseDictionary.Add(SendCommandProtocol.ProtocolTag, new SendCommandProtocol(serviceProvider));
            _packetResponseDictionary.Add(BlockInventoryOpenCloseProtocol.ProtocolTag, new BlockInventoryOpenCloseProtocol(serviceProvider));
            _packetResponseDictionary.Add(SaveProtocol.ProtocolTag, new SaveProtocol(serviceProvider));
            _packetResponseDictionary.Add(GetMapObjectInfoProtocol.ProtocolTag, new GetMapObjectInfoProtocol(serviceProvider));
            _packetResponseDictionary.Add(MapObjectAcquisitionProtocol.ProtocolTag, new MapObjectAcquisitionProtocol(serviceProvider));
            _packetResponseDictionary.Add(OneClickCraft.ProtocolTag, new OneClickCraft(serviceProvider));
            _packetResponseDictionary.Add(GetChallengeInfoProtocol.ProtocolTag, new GetChallengeInfoProtocol(serviceProvider));
            _packetResponseDictionary.Add(AllBlockStateProtocol.ProtocolTag, new AllBlockStateProtocol(serviceProvider));
            _packetResponseDictionary.Add(BlockStateProtocol.ProtocolTag, new BlockStateProtocol(serviceProvider));
            _packetResponseDictionary.Add(DebugBlockInfoRequestProtocol.ProtocolTag, new DebugBlockInfoRequestProtocol(serviceProvider));
            _packetResponseDictionary.Add(SetCraftChainerCrafterRecipeProtocol.ProtocolTag, new SetCraftChainerCrafterRecipeProtocol(serviceProvider));
            _packetResponseDictionary.Add(SetCraftChainerMainComputerRequestItemProtocol.ProtocolTag, new SetCraftChainerMainComputerRequestItemProtocol(serviceProvider));
        }
        
        public List<List<byte>> GetPacketResponse(List<byte> payload)
        {
            ProtocolMessagePackBase request = null;
            ProtocolMessagePackBase response = null;
            try
            {
                request = MessagePackSerializer.Deserialize<ProtocolMessagePackBase>(payload.ToArray());
                response = _packetResponseDictionary[request.Tag].GetResponse(payload);
            }
            catch (Exception e)
            {
                // TODO ログ基盤
                Debug.LogError($"PacketResponseCreator Error:{e.Message}\n{e.StackTrace}");
            }
            
            if (response == null) return new List<List<byte>>();
            
            response.SequenceId = request.SequenceId;
            var responseBytes = MessagePackSerializer.Serialize(Convert.ChangeType(response, response.GetType()));
            
            return new List<List<byte>> { responseBytes.ToList() };
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/WorldLoaderFromJson.cs
```cs
using System;
using System.IO;
using Game.Challenge;
using Game.Context;
using Game.Entity.Interface;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json.WorldVersions;
using Game.World.Interface.DataStore;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.SaveLoad.Json
{
    public class WorldLoaderFromJson : IWorldSaveDataLoader
    {
        private readonly ChallengeDatastore _challengeDatastore;
        private readonly ChallengeJsonObject _challengeJsonObject;
        private readonly IEntitiesDatastore _entitiesDatastore;
        private readonly IPlayerInventoryDataStore _inventoryDataStore;
        private readonly IMapObjectDatastore _mapObjectDatastore;
        
        private readonly SaveJsonFileName _saveJsonFileName;
        private readonly IWorldBlockDatastore _worldBlockDatastore;
        private readonly IWorldSettingsDatastore _worldSettingsDatastore;
        
        public WorldLoaderFromJson(SaveJsonFileName saveJsonFileName,
            IPlayerInventoryDataStore inventoryDataStore, IEntitiesDatastore entitiesDatastore, IWorldSettingsDatastore worldSettingsDatastore,
            IMapObjectDatastore mapObjectDatastore, ChallengeDatastore challengeDatastore)
        {
            _saveJsonFileName = saveJsonFileName;
            _worldBlockDatastore = ServerContext.WorldBlockDatastore;
            _inventoryDataStore = inventoryDataStore;
            _entitiesDatastore = entitiesDatastore;
            _worldSettingsDatastore = worldSettingsDatastore;
            _mapObjectDatastore = mapObjectDatastore;
            _challengeDatastore = challengeDatastore;
        }
        
        public void LoadOrInitialize()
        {
            if (File.Exists(_saveJsonFileName.FullSaveFilePath))
            {
                var json = File.ReadAllText(_saveJsonFileName.FullSaveFilePath);
                try
                {
                    Load(json);
                    Debug.Log("セーブデータのロードが完了しました。");
                    return;
                }
                catch (Exception e)
                {
                    //TODO ログ基盤
                    Debug.Log("セーブデータが破損していたか古いバージョンでした。Discordサーバー ( https://discord.gg/ekFYmY3rDP ) にて連絡をお願いします。");
                    Debug.Log($"セーブファイルパス {_saveJsonFileName.FullSaveFilePath}");
                    throw new Exception(
                        $"セーブファイルのロードに失敗しました。セーブファイルを確認してください。\n Message : {e.Message} \n StackTrace : {e.StackTrace}");
                }
            }
            
            Debug.Log("セーブデータがありませんでした。新規作成します。");
            WorldInitialize();
        }
        
        public void Load(string jsonText)
        {
            var load = JsonConvert.DeserializeObject<WorldSaveAllInfoV1>(jsonText);
            
            _worldBlockDatastore.LoadBlockDataList(load.World);
            _inventoryDataStore.LoadPlayerInventory(load.Inventory);
            _entitiesDatastore.LoadBlockDataList(load.Entities);
            _worldSettingsDatastore.LoadSettingData(load.Setting);
            _mapObjectDatastore.LoadMapObject(load.MapObjects);
            _challengeDatastore.LoadChallenge(load.Challenge);
        }
        
        public void WorldInitialize()
        {
            _worldSettingsDatastore.Initialize();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/challenges.json
```cs
{
  "data": [
    {
      "summary": "テスト1",
      "title": "テスト1",
      "taskCompletionType": "createItem",
      "taskParam": {
        "itemGuid": "00000000-0000-0000-1234-000000000003"
      },
      "challengeGuid": "00000000-0000-0000-4567-000000000001",
      "playSkitType": "None",
      "playSkitParam": {},
      "tutorials": []
    },
    {
      "summary": "テスト2",
      "title": "テスト2",
      "taskCompletionType": "inInventoryItem",
      "taskParam": {
        "itemCount": 3,
        "itemGuid": "00000000-0000-0000-1234-000000000001"
      },
      "challengeGuid": "00000000-0000-0000-4567-000000000002",
      "playSkitType": "None",
      "playSkitParam": {},
      "tutorials": []
    },
    {
      "summary": "テスト3",
      "title": "テスト3",
      "taskCompletionType": "blockPlace",
      "taskParam": {
        "itemCount": 1,
        "blockGuid": "00000000-0000-0000-0000-000000000001"
      },
      "challengeGuid": "00000000-0000-0000-4567-000000000003",
      "playSkitType": "None",
      "playSkitParam": {},
      "tutorials": []
    },
    {
      "summary": "テスト1をクリアしたら始まるチャレンジ",
      "title": "テスト4",
      "taskCompletionType": "inInventoryItem",
      "taskParam": {
        "itemCount": 3,
        "itemGuid": "00000000-0000-0000-1234-000000000003"
      },
      "prevChallengeGuid": "00000000-0000-0000-4567-000000000001",
      "challengeGuid": "00000000-0000-0000-4567-000000000004",
      "playSkitType": "None",
      "playSkitParam": {},
      "tutorials": []
    }
  ]
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockGameObject.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Common;
using Client.Common.Asset;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.Context;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;
using UnityEngine.VFX;

namespace Client.Game.InGame.Block
{
    public class BlockGameObject : MonoBehaviour
    {
        public BlockId BlockId { get; private set; }
        public BlockMasterElement BlockMasterElement { get; private set; }
        public BlockPositionInfo BlockPosInfo { get; private set; }
        public List<IBlockStateChangeProcessor> BlockStateChangeProcessors { get; private set; }
        
        public IObservable<BlockGameObject> OnFinishedPlaceAnimation => _onFinishedPlaceAnimation;
        private readonly Subject<BlockGameObject> _onFinishedPlaceAnimation = new();
        
        private BlockShaderAnimation _blockShaderAnimation;
        private RendererMaterialReplacerController _rendererMaterialReplacerController;
        private List<VisualEffect> _visualEffects = new();
        private List<PreviewOnlyObject> _previewOnlyObjects = new();
        private const string PreviewBoundingBoxAddressablePath = "Vanilla/Block/Util/BlockPreviewBoundingBox";
        
        private bool _isShaderAnimating;
        
        public void Initialize(BlockMasterElement blockMasterElement, BlockPositionInfo posInfo)
        {
            BlockPosInfo = posInfo;
            BlockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            BlockMasterElement = blockMasterElement;
            BlockStateChangeProcessors = gameObject.GetComponentsInChildren<IBlockStateChangeProcessor>().ToList();
            _visualEffects = gameObject.GetComponentsInChildren<VisualEffect>(true).ToList();
            _blockShaderAnimation = gameObject.AddComponent<BlockShaderAnimation>();
           
            _rendererMaterialReplacerController = new RendererMaterialReplacerController(gameObject);
            
            // 子供のBlockGameObjectChildを初期化
            foreach (var child in gameObject.GetComponentsInChildren<BlockGameObjectChild>()) child.Init(this);
            
            // 地面との衝突判定を無効化
            foreach (var groundCollisionDetector in gameObject.GetComponentsInChildren<GroundCollisionDetector>(true))
            {
                groundCollisionDetector.enabled = false;
            }
            
            // プレビュー限定オブジェクトをオフに
            // Turn off preview-only object
            _previewOnlyObjects = gameObject.GetComponentsInChildren<PreviewOnlyObject>(true).ToList();
            _previewOnlyObjects.ForEach(obj =>
            {
                obj.Initialize();
                obj.SetActive(false);
            });
            
            LoadBoundingBox().Forget();
            
            // バウンディングボックス用オブジェクトを作成
            // Create a bounding box object
            #region Internal
            
            async UniTask LoadBoundingBox()
            {
                var previewBoundingBoxPrefab = await AddressableLoader.LoadAsyncDefault<GameObject>(PreviewBoundingBoxAddressablePath);
                var previewBoundingBoxObj = Instantiate(previewBoundingBoxPrefab, transform);
                previewBoundingBoxObj.GetComponent<BlockPreviewBoundingBox>().SetBoundingBox(blockMasterElement.BlockSize, posInfo.BlockDirection);
                
                var previewOnlyObject = previewBoundingBoxObj.GetComponent<PreviewOnlyObject>();
                previewOnlyObject.Initialize();
                previewOnlyObject.SetActive(false);
                _previewOnlyObjects.Add(previewOnlyObject);
            }
            
            #endregion
        }
        
        public async UniTask PlayPlaceAnimation()
        {
            _isShaderAnimating = true;
            SetVfxActive(false);
            await _blockShaderAnimation.PlaceAnimation();
            _isShaderAnimating = false;
            SetVfxActive(true);
            _onFinishedPlaceAnimation.OnNext(this);
        }
        
        public void SetRemovePreviewing()
        {
            if (_isShaderAnimating) return;
            var placePreviewMaterial = Resources.Load<Material>(MaterialConst.PreviewPlaceBlockMaterial);
            
            _rendererMaterialReplacerController.CopyAndSetMaterial(placePreviewMaterial);
            _rendererMaterialReplacerController.SetColor(MaterialConst.PreviewColorPropertyName ,MaterialConst.NotPlaceableColor);
            Resources.UnloadAsset(placePreviewMaterial);
        }
        
        public void ResetMaterial()
        {
            if (_isShaderAnimating) return;
            _rendererMaterialReplacerController.ResetMaterial();
        }
        
        public void EnablePreviewOnlyObjects(bool active, bool renderEnable)
        {
            _previewOnlyObjects.ForEach(obj =>
            {
                obj.SetActive(active);
                obj.SetEnableRenderers(renderEnable);
            });
        }
        
        public async UniTask DestroyBlock()
        {
            _isShaderAnimating = true;
            SetVfxActive(false);
            await _blockShaderAnimation.RemoveAnimation();
            Destroy(gameObject);
        }
        
        private void SetVfxActive(bool isActive)
        {
            foreach (var vfx in _visualEffects) vfx.gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaShaftTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaShaftTemplate : IBlockTemplate
    {
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock CreateGear(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var configParam = blockMasterElement.BlockParam as ShaftBlockParam;
            var connectSetting = configParam.Gear.GearConnects;
            var blockComponent = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var gearEnergyTransformer = new GearEnergyTransformer(new Torque(configParam.RequireTorque), blockInstanceId, blockComponent);
            
            var components = new List<IBlockComponent>
            {
                gearEnergyTransformer,
                blockComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaMinerTemplate.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.Miner;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaMinerTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockOpenableInventoryUpdateEvent;
        
        public VanillaMinerTemplate(BlockOpenableInventoryUpdateEvent blockOpenableInventoryUpdateEvent)
        {
            _blockOpenableInventoryUpdateEvent = blockOpenableInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var (requestPower, outputSlot) = GetData(blockMasterElement);
            
            var minerParam = blockMasterElement.BlockParam as ElectricMinerBlockParam;
            var miningSettings = minerParam.MineSettings;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(minerParam.InventoryConnectors, blockPositionInfo);
            
            var minerProcessorComponent = new VanillaMinerProcessorComponent(blockInstanceId, requestPower, outputSlot, _blockOpenableInventoryUpdateEvent, inputConnectorComponent, blockPositionInfo, miningSettings);
            var electricMinerComponent = new VanillaElectricMinerComponent(blockInstanceId, requestPower, minerProcessorComponent);
            var components = new List<IBlockComponent>
            {
                minerProcessorComponent,
                electricMinerComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var (requestPower, outputSlot) = GetData(blockMasterElement);
            
            var minerParam = blockMasterElement.BlockParam as ElectricMinerBlockParam;
            var miningSettings = minerParam.MineSettings;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(minerParam.InventoryConnectors, blockPositionInfo);
            
            var minerProcessorComponent = new VanillaMinerProcessorComponent(componentStates, blockInstanceId, requestPower, outputSlot, _blockOpenableInventoryUpdateEvent, inputConnectorComponent, blockPositionInfo, miningSettings);
            var electricMinerComponent = new VanillaElectricMinerComponent(blockInstanceId, requestPower, minerProcessorComponent);
            var components = new List<IBlockComponent>
            {
                minerProcessorComponent,
                electricMinerComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        private (ElectricPower requestPower, int outputSlot) GetData(BlockMasterElement blockMasterElement)
        {
            var minerParam = blockMasterElement.BlockParam as ElectricMinerBlockParam;
            
            var requestPower = minerParam.RequiredPower;
            
            return (new ElectricPower(requestPower), minerParam.OutputItemSlotCount);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObject.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using UnityEngine;

namespace Game.Map.Interface.MapObject
{
    /// <summary>
    ///     小石や木など、マップ上にもとから配置されている静的なオブジェクトです。
    /// </summary>
    public interface IMapObject
    {
        /// <summary>
        ///     マップオブジェクト自体の固有ID
        ///     オブジェクトごとに異なる
        /// </summary>
        public int InstanceId { get; }
        
        /// <summary>
        ///     そのオブジェクトのID
        /// </summary>
        public Guid MapObjectGuid { get; }
        
        /// <summary>
        ///     オブジェクトがすでに獲得などされていればtrue
        /// </summary>
        public bool IsDestroyed { get; }
        
        /// <summary>
        ///     オブジェクトが存在する座標
        /// </summary>
        Vector3 Position { get; }
        
        /// <summary>
        ///     MapObjectが破壊されるまでのHP
        /// </summary>
        public int CurrentHp { get; }
        
        /// <summary>
        ///     獲得したとき入手できるアイテム
        /// </summary>
        public List<IItemStack> EarnItems { get; }
        
        public event Action OnDestroy;
        
        /// <summary>
        ///     HPを減らして、入手できるアイテムを返す
        ///     0以下になったらDestroyをする
        /// </summary>
        public List<IItemStack> Attack(int damage);
        
        /// <summary>
        ///     オブジェクトを破壊する
        /// </summary>
        public void Destroy();
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPreviewBoundingBox.cs
```cs
using Game.Block.Interface;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPreviewBoundingBox : MonoBehaviour
    {
        [SerializeField] private GameObject x_Origin_Edge;
        [SerializeField] private GameObject x_Y_Edge;
        [SerializeField] private GameObject x_YZ_Edge;
        [SerializeField] private GameObject x_Z_Edge;
        
        [SerializeField] private GameObject y_Origin_Edge;
        [SerializeField] private GameObject y_X_Edge;
        [SerializeField] private GameObject y_Z_Edge;
        [SerializeField] private GameObject y_XZ_Edge;
        
        [SerializeField] private GameObject z_Origin_Edge;
        [SerializeField] private GameObject z_Y_Edge;
        [SerializeField] private GameObject z_X_Edge;
        [SerializeField] private GameObject z_XY_Edge;
        
        [SerializeField] private GameObject xy_Origin_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface xy_Origin_SurfaceScript;
        [SerializeField] private GameObject xy_Z_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface xy_Z_SurfaceScript;
        
        [SerializeField] private GameObject yz_Origin_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface yz_Origin_SurfaceScript;
        [SerializeField] private GameObject yz_X_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface yz_X_SurfaceScript;
        
        [SerializeField] private GameObject zx_Origin_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface zx_Origin_SurfaceScript;
        [SerializeField] private GameObject zx_Y_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface zx_Y_SurfaceScript;
        
        public void SetBoundingBox(Vector3Int blockSize, BlockDirection blockDirection)
        {
            // ========== X軸方向のエッジ ==========
            x_Origin_Edge.transform.localScale = new Vector3(blockSize.x, 1, 1);
            x_Origin_Edge.transform.localPosition = new Vector3(0, 0, 0);
            
            x_Y_Edge.transform.localScale = new Vector3(blockSize.x, 1, 1);
            x_Y_Edge.transform.localPosition = new Vector3(0, blockSize.y, 0);
            
            x_YZ_Edge.transform.localScale = new Vector3(blockSize.x, 1, 1);
            x_YZ_Edge.transform.localPosition = new Vector3(0, blockSize.y, blockSize.z);
            
            x_Z_Edge.transform.localScale = new Vector3(blockSize.x, 1, 1);
            x_Z_Edge.transform.localPosition = new Vector3(0, 0, blockSize.z);
            
            
            // ========== Y軸方向のエッジ ==========
            y_Origin_Edge.transform.localScale = new Vector3(blockSize.y, 1, 1);
            y_Origin_Edge.transform.localPosition = new Vector3(0, 0, 0);
            
            y_X_Edge.transform.localScale = new Vector3(blockSize.y, 1, 1);
            y_X_Edge.transform.localPosition = new Vector3(blockSize.x, 0, 0);
            
            y_Z_Edge.transform.localScale = new Vector3(blockSize.y, 1, 1);
            y_Z_Edge.transform.localPosition = new Vector3(0, 0, blockSize.z);
            
            y_XZ_Edge.transform.localScale = new Vector3(blockSize.y, 1, 1);
            y_XZ_Edge.transform.localPosition = new Vector3(blockSize.x, 0, blockSize.z);
            
            
            // ========== Z軸方向のエッジ ==========
            z_Origin_Edge.transform.localScale = new Vector3(blockSize.z, 1, 1);
            z_Origin_Edge.transform.localPosition = new Vector3(0, 0, 0);
            
            z_Y_Edge.transform.localScale = new Vector3(blockSize.z, 1, 1);
            z_Y_Edge.transform.localPosition = new Vector3(0, blockSize.y, 0);
            
            z_X_Edge.transform.localScale = new Vector3(blockSize.z, 1, 1);
            z_X_Edge.transform.localPosition = new Vector3(blockSize.x, 0, 0);
            
            z_XY_Edge.transform.localScale = new Vector3(blockSize.z, 1, 1);
            z_XY_Edge.transform.localPosition = new Vector3(blockSize.x, blockSize.y, 0);
            
            
            // ========== x-y 平面 ==========
            xy_Origin_Surface.transform.localScale = new Vector3(blockSize.x, blockSize.y, 1);
            xy_Origin_Surface.transform.localPosition = new Vector3(0, 0, 0);
            xy_Origin_SurfaceScript.SetPreviewSurfaceType(blockDirection switch
            { 
                BlockDirection.North => PreviewSurfaceType.YX_Origin,
                BlockDirection.East => PreviewSurfaceType.YZ_Origin,
                BlockDirection.South => PreviewSurfaceType.YX_Z,
                BlockDirection.West => PreviewSurfaceType.YZ_X,
            });
            
            xy_Z_Surface.transform.localScale = new Vector3(blockSize.x, blockSize.y, 1);
            xy_Z_Surface.transform.localPosition = new Vector3(0, 0, blockSize.z);
            xy_Z_SurfaceScript.SetPreviewSurfaceType(blockDirection switch
            {
                BlockDirection.North => PreviewSurfaceType.YX_Z,
                BlockDirection.East => PreviewSurfaceType.YZ_X,
                BlockDirection.South => PreviewSurfaceType.YX_Origin,
                BlockDirection.West => PreviewSurfaceType.YZ_Origin,
            });
            
            
            // ========== y-z 平面 ==========
            yz_Origin_Surface.transform.localScale = new Vector3(1, blockSize.y, blockSize.z);
            yz_Origin_Surface.transform.localPosition = new Vector3(0, 0, 0);
            yz_Origin_SurfaceScript.SetPreviewSurfaceType(blockDirection switch
            {
                BlockDirection.North => PreviewSurfaceType.YZ_Origin,
                BlockDirection.East => PreviewSurfaceType.YX_Z,
                BlockDirection.South => PreviewSurfaceType.YZ_X,
                BlockDirection.West => PreviewSurfaceType.YX_Origin,
            });
            
            yz_X_Surface.transform.localScale = new Vector3(1, blockSize.y, blockSize.z);
            yz_X_Surface.transform.localPosition = new Vector3(blockSize.x, 0, 0);
            yz_X_SurfaceScript.SetPreviewSurfaceType(blockDirection switch
            {
                BlockDirection.North => PreviewSurfaceType.YZ_X,
                BlockDirection.East => PreviewSurfaceType.YX_Origin,
                BlockDirection.South => PreviewSurfaceType.YZ_Origin,
                BlockDirection.West => PreviewSurfaceType.YX_Z,
            });
            
            
            // ========== z-x 平面 ==========
            zx_Origin_Surface.transform.localScale = new Vector3(blockSize.x, 1, blockSize.z);
            zx_Origin_Surface.transform.localPosition = new Vector3(0, 0, 0);
            
            zx_Y_Surface.transform.localScale = new Vector3(blockSize.x, 1, blockSize.z);
            zx_Y_Surface.transform.localPosition = new Vector3(0, blockSize.y, 0);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World/DataStore/WorldEnergySegmentDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Game.EnergySystem;
using Game.World.Interface.DataStore;

namespace Game.World.DataStore
{
    public class WorldEnergySegmentDatastore<TSegment> : IWorldEnergySegmentDatastore<TSegment>
        where TSegment : EnergySegment, new()
    {
        private readonly List<TSegment> _segmentDictionary = new();
        
        //電柱オブジェクトから所属している電力セグメントを取得する
        public TSegment GetEnergySegment(IElectricTransformer transformer)
        {
            foreach (var segment in _segmentDictionary)
            {
                if (!segment.EnergyTransformers.ContainsKey(transformer.BlockInstanceId)) continue;
                return segment;
            }
            
            throw new Exception("電力セグメントが見つかりませんでした");
        }
        
        public TSegment GetEnergySegment(int index)
        {
            return _segmentDictionary[index];
        }
        
        public TSegment CreateEnergySegment()
        {
            var electricSegment = new TSegment();
            _segmentDictionary.Add(electricSegment);
            return electricSegment;
        }
        
        public void SetEnergySegment(TSegment energySegment)
        {
            _segmentDictionary.Add(energySegment);
        }
        
        public void RemoveEnergySegment(TSegment energySegment)
        {
            _segmentDictionary.Remove(energySegment);
        }
        
        public int GetEnergySegmentListCount()
        {
            return _segmentDictionary.Count;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/IBlockStateChangeProcessor.cs
```cs
using Server.Event.EventReceive;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    /// <summary>
    ///     ステートの変更を受け取り、その変更に合わせてアニメーション、エフェクト、音を再生するためのinterface
    ///     各ブロックやタイプによって実行する内容が違うため、各ブロックやタイプで実装する
    /// </summary>
    public interface IBlockStateChangeProcessor
    {
        /// <summary>
        ///     ブロックのステートに基づいてアニメーションを再生する
        ///     タイプに応じてアニメーションを再生する
        /// </summary>
        public void OnChangeState(BlockStateMessagePack blockState);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/NullBlockStateChangeProcessor.cs
```cs
using Server.Event.EventReceive;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    /// <summary>
    ///     無機能のブロックに使うステートプロセッサー
    /// </summary>
    public class NullBlockStateChangeProcessor : IBlockStateChangeProcessor
    {
        public void OnChangeState(BlockStateMessagePack blockState)
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/PlaceHotBarBlockProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.SendPlaceHotBarBlockProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class PlaceHotBarBlockProtocolTest
    {
        private const int PlacedBlockId = 1;
        private static readonly ItemId BlockItemId = new(1);
        private const int PlayerId = 3;
        private const int HotBarSlot = 3;
        
        [Test]
        public void BlockPlaceTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //パケットでプレイヤーインベントリを生成
            
            //ホットバーにアイテムとしてのブロックをセットする
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(HotBarSlot);
            var inventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            inventory.MainOpenableInventory.SetItem(slot, itemStackFactory.Create(BlockItemId, 3));
            
            //ブロックを置く
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 4, 0));
            
            //ブロックが置かれているかチェック
            var world = ServerContext.WorldBlockDatastore;
            Assert.AreEqual(PlacedBlockId, world.GetBlock(new Vector3Int(2, 4)).BlockId.AsPrimitive());
            //アイテムが減っているかチェック
            Assert.AreEqual(2, inventory.MainOpenableInventory.GetItem(slot).Count);
            
            
            //既にブロックがあるところに置こうとしてもアイテムが減らないテスト
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 4, 0));
            //アイテムが減っていないかのチェック
            Assert.AreEqual(2,
                inventory.MainOpenableInventory.GetItem(slot).Count);
            
            //ホットバー内のアイテムを使い切る
            packet.GetPacketResponse(CreateUseHotBarProtocol(3, 4, 0));
            packet.GetPacketResponse(CreateUseHotBarProtocol(4, 4, 0));
            //ホットバーのアイテムが空になっているかのテスト
            Assert.AreEqual(itemStackFactory.CreatEmpty(), inventory.MainOpenableInventory.GetItem(slot));
            
            
            //さらにブロックを置こうとしても置けないテスト
            packet.GetPacketResponse(CreateUseHotBarProtocol(10, 10, 0));
            Assert.True(world.GetBlock(new Vector3Int(10, 10)) == null);
        }
        
        
        //ブロックの設置する向きが正しいかテスト
        [Test]
        public void PlaceDirectionTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //パケットでプレイヤーインベントリを生成
            
            //ホットバーにアイテムとしてのブロックをセットする
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(HotBarSlot);
            var inventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            inventory.MainOpenableInventory.SetItem(slot, itemStackFactory.Create(BlockItemId, 4));
            
            
            //ブロックを置く
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 4, BlockDirection.North));
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 5, BlockDirection.East));
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 6, BlockDirection.South));
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 7, BlockDirection.West));
            
            //ブロックの向きをチェック
            Assert.AreEqual(BlockDirection.North, worldBlockDatastore.GetBlockDirection(new Vector3Int(2, 4)));
            Assert.AreEqual(BlockDirection.East, worldBlockDatastore.GetBlockDirection(new Vector3Int(2, 5)));
            Assert.AreEqual(BlockDirection.South, worldBlockDatastore.GetBlockDirection(new Vector3Int(2, 6)));
            Assert.AreEqual(BlockDirection.West, worldBlockDatastore.GetBlockDirection(new Vector3Int(2, 7)));
        }
        
        private List<byte> CreateUseHotBarProtocol(int x, int y, BlockDirection blockDirection)
        {
            var placeInfo = new List<PlaceInfo>
            {
                new()
                {
                    Position = new Vector3Int(x, y),
                    Direction = blockDirection,
                    VerticalDirection = BlockVerticalDirection.Horizontal
                }
            };
            
            return MessagePackSerializer
                .Serialize(new SendPlaceHotBarBlockProtocolMessagePack(PlayerId, HotBarSlot, placeInfo))
                .ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/Player/PlayerPositionSender.cs
```cs
using Client.Common.Server;
using Client.Game.InGame.Context;
using Client.Game.InGame.Player;
using UnityEngine;
using VContainer.Unity;

namespace Client.Game.InGame.Presenter.Player
{
    public class PlayerPositionSender : ITickable
    {
        private readonly IPlayerObjectController _playerObjectController;
        
        private float _timer;
        
        public PlayerPositionSender(IPlayerObjectController playerObjectController)
        {
            _playerObjectController = playerObjectController;
        }
        
        /// <summary>
        ///     Updateと同じタイミングで呼ばれる
        /// </summary>
        public void Tick()
        {
            _timer += Time.deltaTime;
            if (_timer < NetworkConst.UpdateIntervalSeconds) return;
            _timer = 0;
            ClientContext.VanillaApi.SendOnly.SendPlayerPosition(_playerObjectController.Position);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Util/MouseCursorExplainer.cs
```cs
using Client.Localization;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.UI.Util
{
    public interface IMouseCursorExplainer
    {
        public const int DefaultFontSize = 36;
        
        // TODO hotbarから毎フレーム呼び出されると常にfalseになってしまうので、何か実装方法を考えたいな、、
        public void Hide();
        public void Show(string key, int fontSize = DefaultFontSize, bool isLocalize = true);
    }
    
    /// <summary>
    ///     マウスカーソルのそばにアイテム名やTips、その他文章を表示するシステム
    /// </summary>
    public class MouseCursorExplainer : MonoBehaviour, IMouseCursorExplainer
    {
        [SerializeField] private GameObject itemNameBar;
        [SerializeField] private TMP_Text itemName;
        [SerializeField] private CanvasGroup canvasGroup;
        
        
        public static IMouseCursorExplainer Instance { get; private set; }
        
        private void Awake()
        {
            Instance = this;
        }
        
        public void Show(string key, int fontSize = IMouseCursorExplainer.DefaultFontSize, bool isLocalize = true)
        {
            canvasGroup.alpha = 1;
            itemName.text = isLocalize ? Localize.Get(key) : key;
            itemName.fontSize = fontSize;
        }
        
        public void Hide()
        {
            canvasGroup.alpha = 0;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/VanillaBeltConveyorInventoryItem.cs
```cs
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Newtonsoft.Json;

namespace Game.Block.Blocks.BeltConveyor
{
    public interface IOnBeltConveyorItem
    {
        public double RemainingPercent { get; }
        public ItemId ItemId { get; }
        public ItemInstanceId ItemInstanceId { get; }
    }
    
    public class VanillaBeltConveyorInventoryItem : IOnBeltConveyorItem
    {
        public double RemainingPercent { get; set; }
        public ItemId ItemId { get; }
        public ItemInstanceId ItemInstanceId { get; }
        
        public VanillaBeltConveyorInventoryItem(ItemId itemId, ItemInstanceId itemInstanceId)
        {
            ItemId = itemId;
            ItemInstanceId = itemInstanceId;
            RemainingPercent = 1;
        }
        
        public string GetSaveJsonString()
        {
            return JsonConvert.SerializeObject(new VanillaBeltConveyorInventoryItemJsonObject(this));
        }
        
        public static VanillaBeltConveyorInventoryItem LoadItem(string jsonString)
        {
            if (jsonString == null) return null;
            
            var jsonData = JsonConvert.DeserializeObject<VanillaBeltConveyorInventoryItemJsonObject>(jsonString);
            if (jsonData.ItemStack == null) return null;
            
            var itemId = MasterHolder.ItemMaster.GetItemId(jsonData.ItemStack.ItemGuid);
            var remainingPercent = jsonData.RemainingPercent;
            var itemInstanceId = ItemInstanceId.Create();
            
            return new VanillaBeltConveyorInventoryItem(itemId, itemInstanceId)
            {
                RemainingPercent = remainingPercent
            };
        }
    }
    
    public class VanillaBeltConveyorInventoryItemJsonObject
    {
        [JsonProperty("itemStack")] public ItemStackSaveJsonObject ItemStack;
        
        [JsonProperty("remainingTime")] public double RemainingPercent;
        
        public VanillaBeltConveyorInventoryItemJsonObject(VanillaBeltConveyorInventoryItem vanillaBeltConveyorInventoryItem)
        {
            if (vanillaBeltConveyorInventoryItem == null)
            {
                ItemStack = null;
                RemainingPercent = 1;
                return;
            }
            
            var item = ServerContext.ItemStackFactory.Create(vanillaBeltConveyorInventoryItem.ItemId, 1);
            ItemStack = new ItemStackSaveJsonObject(item);
            RemainingPercent = vanillaBeltConveyorInventoryItem.RemainingPercent;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/VanillaStaticMapObject.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.Map.Interface.MapObject;
using UnityEngine;
using Random = System.Random;

namespace Game.Map
{
    /// <summary>
    ///     木や小石など基本的に動かないマップオブジェクト
    /// </summary>
    public class VanillaStaticMapObject : IMapObject
    {
        public int InstanceId { get; }
        public Guid MapObjectGuid { get; }
        public bool IsDestroyed { get; private set; }
        public Vector3 Position { get; }
        public int CurrentHp { get; private set; }
        
        public List<IItemStack> EarnItems { get; }
        
        public event Action OnDestroy;
        
        private readonly int[] _earnItemHps;
        
        public VanillaStaticMapObject(int instanceId, Guid mapObjectGuid, bool isDestroyed, int currentHp, Vector3 position)
        {
            var mapObjectConfig = MasterHolder.MapObjectMaster.GetMapObjectElement(mapObjectGuid);
            InstanceId = instanceId;
            MapObjectGuid = mapObjectGuid;
            IsDestroyed = isDestroyed;
            Position = position;
            CurrentHp = currentHp;
            
            
            _earnItemHps = mapObjectConfig.EarnItemHps;
            
            var random = new Random(instanceId);
            EarnItems = new List<IItemStack>();
            foreach (var earnItemConfig in mapObjectConfig.EarnItems)
            {
                var itemCount = random.Next(earnItemConfig.MinCount, earnItemConfig.MaxCount + 1);
                var itemStack = ServerContext.ItemStackFactory.Create(earnItemConfig.ItemGuid, itemCount);
                
                EarnItems.Add(itemStack);
            }
        }
        
        public List<IItemStack> Attack(int damage)
        {
            var lastHp = CurrentHp;
            CurrentHp -= damage;
            if (CurrentHp <= 0) Destroy();
            
            var earnedCount = _earnItemHps.Count(hp => lastHp > hp && CurrentHp <= hp);
            if (earnedCount == 0) return new List<IItemStack>();
            
            var earnedItems = new List<IItemStack>();
            foreach (var item in EarnItems)
            {
                var id = item.Id;
                var count = item.Count * earnedCount;
                
                earnedItems.Add(ServerContext.ItemStackFactory.Create(id, count));
            }
            
            return earnedItems;
        }
        
        public void Destroy()
        {
            CurrentHp = 0;
            IsDestroyed = true;
            OnDestroy?.Invoke();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/CommandProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    public class SendCommandProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:sendCommand";
        
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public SendCommandProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SendCommandProtocolMessagePack>(payload.ToArray());
            
            var command = data.Command.Split(' '); //command text
            
            //他のコマンドを実装する場合、この実装方法をやめる
            if (command[0] == "give")
            {
                var inventory = _playerInventoryDataStore.GetInventoryData(int.Parse(command[1]));
                
                var itemId = new ItemId(int.Parse(command[2]));
                var count = int.Parse(command[3]);
                
                var item = ServerContext.ItemStackFactory.Create(itemId, count);
                inventory.MainOpenableInventory.InsertItem(item);
            }
            
            return null;
        }
        
        [MessagePackObject]
        public class SendCommandProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public string Command { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public SendCommandProtocolMessagePack()
            {
            }
            
            public SendCommandProtocolMessagePack(string command)
            {
                Tag = ProtocolTag;
                Command = command;
            }
        }
    }
    
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Json/MapObjectJsonObject.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Map.Interface.Json
{
    [Serializable]
    public class MapObjectJsonObject
    {
        [JsonProperty("instanceId")] public int instanceId;
        [JsonProperty("isDestroyed")] public bool isDestroyed;
        [JsonProperty("hp")] public int hp;
        [JsonProperty("guid")] public string guidStr;
        [JsonIgnore] public Guid MapObjectGuid => new(guidStr);
        
        [JsonProperty("x")] public float x;
        [JsonProperty("y")] public float y;
        [JsonProperty("z")] public float z;
        
        [Obsolete("Json用にのみ使用してください。")]
        public MapObjectJsonObject()
        {
        }
        
        public MapObjectJsonObject(IMapObject mapObject)
        {
            instanceId = mapObject.InstanceId;
            isDestroyed = mapObject.IsDestroyed;
            guidStr = mapObject.MapObjectGuid.ToString();
            hp = mapObject.CurrentHp;
            x = mapObject.Position.x;
            y = mapObject.Position.y;
            z = mapObject.Position.z;
        }
        
        [JsonIgnore] public Vector3 Position => new(x, y, z);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningFocusState.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.UI.Util;
using Client.Input;
using Core.Master;
using Game.PlayerInventory.Interface;
using Mooresmaster.Model.MapObjectsModule;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningFocusState : IMapObjectMiningState
    {
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            // フォーカスが外れたのであればIdleに遷移
            // If the focus is lost, transition to Idle
            if (context.CurrentFocusMapObjectGameObject == null)
            {
                return new MapObjectMiningIdleState();
            }
            
            var currentMapObjectMaster = context.CurrentFocusMapObjectGameObject.MapObjectMasterElement;
            var miningType = currentMapObjectMaster.MiningType;
            
            if (miningType == MapObjectMasterElement.MiningTypeConst.PickUp)
            {
                return PickUpProcess(context);
            }
            if (miningType == MapObjectMasterElement.MiningTypeConst.Mining)
            {
                return MiningProcess(currentMapObjectMaster, context);
            }
            
            throw new System.Exception("MiningType is not defined");
        }
        
        private IMapObjectMiningState PickUpProcess(MapObjectMiningControllerContext context)
        {
            if (InputManager.Playable.ScreenLeftClick.GetKey)
            {
                MouseCursorExplainer.Instance.Hide();
                return new MapObjectMiningMiningCompleteState(context.CurrentFocusMapObjectGameObject, int.MaxValue);
            }
            
            // 左クリックがされていなければ現状を維持
            // If left click is not pressed, maintain the current state
            MouseCursorExplainer.Instance.Show("左クリックで取得", isLocalize: false);
            return this;
        }
        
        private IMapObjectMiningState MiningProcess(MapObjectMasterElement masterElement,MapObjectMiningControllerContext context)
        {
            // 今持っているアイテムがマイニングツールとして登録されているかどうかをチェック
            // Check if the item you are currently holding is registered as a mining tool
            var hotBarInventoryIndex = PlayerInventoryConst.HotBarSlotToInventorySlot(context.HotBarView.SelectIndex);
            var inventoryItem = context.LocalPlayerInventory[hotBarInventoryIndex];
                
            
            // 何も選択していない場合はフォーカスを維持
            // If nothing is selected, maintain focus
            var miningTools = ((MiningMiningParam)masterElement.MiningParam).MiningTools;
            if (inventoryItem.Id == ItemMaster.EmptyItemId)
            {
                ShowRecommendMiningTools(miningTools);
                return this;
            }
            
            
            // マイニングツールとして登録されているかどうかをチェック
            // Check if it is registered as a mining tool
            MiningToolsElement usableMiningTool = null; 
            var currentItemGuid = MasterHolder.ItemMaster.GetItemMaster(inventoryItem.Id).ItemGuid;
            foreach (var miningTool in miningTools)
            {
                if (miningTool.ToolItemGuid != currentItemGuid) continue;
                
                usableMiningTool = miningTool;
                break;
            }
            
            // マイニングツールとして登録されていない場合はフォーカスを維持
            // If it is not registered as a mining tool, maintain focus
            if (usableMiningTool == null)
            {
                ShowRecommendMiningTools(miningTools);
                return this;
            }
            
            // クリックしていあない場合はフォーカスを維持
            // If not clicked, maintain focus
            if (!InputManager.Playable.ScreenLeftClick.GetKey)
            {
                MouseCursorExplainer.Instance.Show("左クリック長押しで取得", isLocalize: false);
                return this;
            }
            
            // マイニング状態に遷移
            // Transition to mining state
            MouseCursorExplainer.Instance.Hide();
            return new MapObjectMiningMiningState(usableMiningTool, context.PlayerObjectController);
        }
        
        
        private void ShowRecommendMiningTools(MiningToolsElement[] miningTools)
        {
            var result = new List<string>();
            
            foreach (var tool in miningTools)
            {
                var itemMaster = MasterHolder.ItemMaster.GetItemMaster(tool.ToolItemGuid);
                result.Add(itemMaster.Name);
            }
            
            var text = "このアイテムが必要です:" + string.Join(", ",result);
            
            MouseCursorExplainer.Instance.Show(text, isLocalize: false);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/World/WorldDataHandler.cs
```cs
using System.Threading;
using Client.Common;
using Client.Common.Server;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Entity;
using Client.Game.InGame.SoundEffect;
using Client.Network.API;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;
using VContainer.Unity;

namespace Client.Game.InGame.World
{
    /// <summary>
    ///     サーバーからのパケットを受け取り、Viewにブロックの更新情報を渡す
    ///     IInitializableがないとDIコンテナ作成時にインスタンスが生成されないので実装しています
    /// </summary>
    public class WorldDataHandler : IInitializable
    {
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        private readonly EntityObjectDatastore _entitiesDatastore;
        
        public WorldDataHandler(BlockGameObjectDataStore blockGameObjectDataStore, EntityObjectDatastore entitiesDatastore, InitialHandshakeResponse initialHandshakeResponse)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            _entitiesDatastore = entitiesDatastore;
            //イベントをサブスクライブする
            ClientContext.VanillaApi.Event.SubscribeEventResponse(PlaceBlockEventPacket.EventTag, OnBlockUpdate);
            ClientContext.VanillaApi.Event.SubscribeEventResponse(RemoveBlockToSetEventPacket.EventTag, OnBlockRemove);
        }
        
        public void Initialize()
        {
            UpdateWorldData().Forget();
        }
        
        /// <summary>
        ///     単一のブロックの更新イベント
        /// </summary>
        private void OnBlockUpdate(byte[] payload)
        {
            var data = MessagePackSerializer.Deserialize<PlaceBlockEventMessagePack>(payload);
            
            var blockPos = (Vector3Int)data.BlockData.BlockPos;
            var blockId = data.BlockData.BlockId;
            var blockDirection = data.BlockData.BlockDirection;
            
            //viewにブロックがおかれたことを通知する
            PlaceBlock(blockPos, blockId, blockDirection);
        }
        
        private void OnBlockRemove(byte[] packet)
        {
            var data = MessagePackSerializer.Deserialize<RemoveBlockEventMessagePack>(packet);
            
            //viewにブロックがおかれたことを通知する
            SoundEffectManager.Instance.PlaySoundEffect(SoundEffectType.DestroyBlock);
            _blockGameObjectDataStore.RemoveBlock(data.Position);
        }
        
        /// <summary>
        ///     0.5秒に1回のワールドの更新をリクエストし、適用する
        /// </summary>
        private async UniTask UpdateWorldData()
        {
            var ct = new CancellationTokenSource().Token;
            
            while (true)
            {
                await GetAndApplyWorldData();
                await UniTask.Delay(NetworkConst.UpdateIntervalMilliseconds, cancellationToken: ct); //TODO 本当に0.5秒に1回でいいのか？
            }
            
            #region Internal
            
            async UniTask GetAndApplyWorldData()
            {
                var data = await ClientContext.VanillaApi.Response.GetWorldData(ct);
                if (data == null) return;
                
                ApplyWorldData(data);
            }
            
            #endregion
        }
        
        
        private void ApplyWorldData(WorldDataResponse worldData)
        {
            foreach (var block in worldData.Blocks) PlaceBlock(block.BlockPos, block.BlockId, block.BlockDirection);
            
            if (worldData.Entities == null)
            {
                return;
            }
            
            _entitiesDatastore.OnEntitiesUpdate(worldData.Entities);
        }
        
        private void PlaceBlock(Vector3Int position, BlockId id, BlockDirection blockDirection)
        {
            if (id == BlockConstant.NullBlockId)
            {
                _blockGameObjectDataStore.RemoveBlock(position);
                return;
            }
            
            _blockGameObjectDataStore.PlaceBlock(position, id, blockDirection);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/ItemShooter/ShooterInventoryItem.cs
```cs
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.BeltConveyor;

namespace Game.Block.Blocks.ItemShooter
{
    public class ShooterInventoryItem : IOnBeltConveyorItem
    {
        public ItemId ItemId { get; }
        
        public ItemInstanceId ItemInstanceId { get; }
        
        public double RemainingPercent { get; set; }
        
        public float CurrentSpeed { get; set; }
        
        public ShooterInventoryItem(ItemId itemId, ItemInstanceId itemInstanceId, float currentSpeed)
        {
            ItemId = itemId;
            ItemInstanceId = itemInstanceId;
            CurrentSpeed = currentSpeed;
            RemainingPercent = 1;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/LocalPlayerInventory.cs
```cs
using System;
using System.Collections;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Main
{
    public interface ILocalPlayerInventory : IEnumerable<IItemStack>
    {
        public IItemStack this[int index] { get; }
        public IObservable<int> OnItemChange { get; }
        
        public int Count { get; }
        public bool IsItemExist(ItemId itemId, int itemSlot);
    }
    
    /// <summary>
    ///     メインインベントリとサブインベントリを統合して扱えるローカルのプレイヤーインベントリ
    /// </summary>
    public class LocalPlayerInventory : ILocalPlayerInventory
    {
        public IObservable<int> OnItemChange => _onItemChange;
        private readonly Subject<int> _onItemChange = new();
        
        public int Count => _mainInventory.Count + _subInventory.Count;
        
        private readonly List<IItemStack> _mainInventory;
        private ISubInventory _subInventory;
        
        public LocalPlayerInventory()
        {
            _mainInventory = new List<IItemStack>();
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++) _mainInventory.Add(itemStackFactory.CreatEmpty());
            
            _subInventory = new EmptySubInventory();
        }
        
        public IEnumerator<IItemStack> GetEnumerator()
        {
            var merged = new List<IItemStack>();
            merged.AddRange(_mainInventory);
            merged.AddRange(_subInventory.SubInventory);
            return merged.GetEnumerator();
        }
        
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
        
        public bool IsItemExist(ItemId itemId, int itemSlot)
        {
            if (itemSlot < _mainInventory.Count) return _mainInventory[itemSlot].Id == itemId;
            
            var subIndex = itemSlot - _mainInventory.Count;
            var subItemId = _subInventory.SubInventory[itemSlot - _mainInventory.Count].Id;
            
            if (subIndex < _subInventory.Count) return subItemId == itemId;
            
            Debug.LogError("sub inventory index out of range  SubInventoryCount:" + _subInventory.Count + " index:" + itemSlot);
            return false;
        }
        
        public IItemStack this[int index]
        {
            get
            {
                if (index < _mainInventory.Count) return _mainInventory[index];
                var subIndex = index - _mainInventory.Count;
                if (subIndex < _subInventory.Count) return _subInventory.SubInventory[index - _mainInventory.Count];
                
                Debug.LogError("sub inventory index out of range  SubInventoryCount:" + _subInventory.Count + " index:" + index);
                return ServerContext.ItemStackFactory.CreatEmpty();
            }
            set
            {
                if (index < _mainInventory.Count)
                {
                    _mainInventory[index] = value;
                    _onItemChange.OnNext(index);
                    return;
                }
                
                var subIndex = index - _mainInventory.Count;
                if (subIndex < _subInventory.Count)
                {
                    _subInventory.SubInventory[subIndex] = value;
                    _onItemChange.OnNext(index);
                    return;
                }
                
                Debug.LogError("sub inventory index out of range  SubInventoryCount:" + _subInventory.Count + " index:" + index);
            }
        }
        
        public void SetSubInventory(ISubInventory subInventory)
        {
            _subInventory = subInventory;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Element/ItemSlotObject.cs
```cs
using System;
using Client.Game.InGame.UI.Util;
using Client.Mod.Texture;
using Core.Const;
using Core.Master;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Element
{
    public class ItemSlotObject : MonoBehaviour, IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerClickHandler, IPointerExitHandler, IPointerMoveHandler
    {
        [SerializeField] private Image itemImage;
        
        [SerializeField] private GameObject normalFrame;
        [SerializeField] private GameObject machineSlotFrame;
        [SerializeField] private GameObject craftRecipeFrame;
        
        [SerializeField] private GameObject hotBarSelect;
        
        [SerializeField] private GameObject grayOutImage;
        [SerializeField] private GameObject hoverImage; // TODO 後で対応
        [SerializeField] private GameObject clickImage; // TODO 後で対応
        
        [SerializeField] private GameObject normalItemSlotObject;
        [SerializeField] private GameObject noneCrossObject;
        
        [SerializeField] private TMP_Text countText;
        [SerializeField] private UIEnterExplainerController uiEnterExplainerController;
        
        private bool _onPointing;
        
        public ItemViewData ItemViewData { get; private set; }
        public int Count { get; private set; }
        
        private void Awake()
        {
            OnPointerEvent.Subscribe(OnInvokeOtherEvent).AddTo(this);
            SubscribeHover();
            SubscribeClick();
        }
        
        private void SubscribeHover()
        {
            _onCursorEnter.Subscribe(_ => hoverImage.SetActive(true)).AddTo(this);
            _onCursorExit.Subscribe(_ => hoverImage.SetActive(false)).AddTo(this);
        }
        
        private void SubscribeClick()
        {
            _onLeftClickDown.Subscribe(_ => clickImage.SetActive(true)).AddTo(this);
            _onLeftClickUp.Subscribe(_ => clickImage.SetActive(false)).AddTo(this);
        }
        
        
        public void SetItem(ItemViewData itemView, int count)
        {
            ItemViewData = itemView;
            
            Count = count;
            countText.text = count != 0 ? count.ToString() : string.Empty;
            
            if (itemView == null || itemView.ItemId == ItemMaster.EmptyItemId)
            {
                itemImage.gameObject.SetActive(false);
                
                uiEnterExplainerController.DisplayEnable(false);
            }
            else
            {
                itemImage.gameObject.SetActive(true);
                itemImage.sprite = itemView.ItemImage;
                
                uiEnterExplainerController.SetText($"{itemView.ItemName}\n<size=25>ID:{itemView.ItemId}</size>", false);
                uiEnterExplainerController.DisplayEnable(true);
            }
        }
        
        public void SetGrayOut(bool active)
        {
            grayOutImage.SetActive(active);
        }
        
        public void SetFrame(ItemSlotFrameType frameType)
        {
            normalFrame.SetActive(frameType == ItemSlotFrameType.Normal);
            machineSlotFrame.SetActive(frameType == ItemSlotFrameType.MachineSlot);
            craftRecipeFrame.SetActive(frameType == ItemSlotFrameType.CraftRecipe);
        }
        
        public void SetItemSlotType(ItemSlotType slotType)
        {
            normalItemSlotObject.SetActive(slotType == ItemSlotType.Normal);
            noneCrossObject.SetActive(slotType == ItemSlotType.NoneCross);
        }
        
        public void SetHotBarSelect(bool active)
        {
            hotBarSelect.SetActive(active);
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        
        #region PointerEvents
        
        public IObservable<(ItemSlotObject, ItemUIEventType)> OnPointerEvent => _onPointerEvent;
        private readonly Subject<(ItemSlotObject, ItemUIEventType)> _onPointerEvent = new();
        
        public IObservable<ItemSlotObject> OnRightClickDown => _onRightClickDown;
        private readonly Subject<ItemSlotObject> _onRightClickDown = new();
        public IObservable<ItemSlotObject> OnLeftClickDown => _onLeftClickDown;
        private readonly Subject<ItemSlotObject> _onLeftClickDown = new();
        public IObservable<ItemSlotObject> OnRightClickUp => _onRightClickUp;
        private readonly Subject<ItemSlotObject> _onRightClickUp = new();
        public IObservable<ItemSlotObject> OnLeftClickUp => _onLeftClickUp;
        private readonly Subject<ItemSlotObject> _onLeftClickUp = new();
        public IObservable<ItemSlotObject> OnCursorEnter => _onCursorEnter;
        private readonly Subject<ItemSlotObject> _onCursorEnter = new();
        public IObservable<ItemSlotObject> OnCursorExit => _onCursorExit;
        private readonly Subject<ItemSlotObject> _onCursorExit = new();
        public IObservable<ItemSlotObject> OnCursorMove => _onCursorMove;
        private readonly Subject<ItemSlotObject> _onCursorMove = new();
        public IObservable<ItemSlotObject> OnDoubleClick => _onDoubleClick;
        private readonly Subject<ItemSlotObject> _onDoubleClick = new();
        
        private void OnInvokeOtherEvent((ItemSlotObject, ItemUIEventType) data)
        {
            var type = data.Item2;
            var slot = data.Item1;
            switch (type)
            {
                case ItemUIEventType.RightClickDown:
                    _onRightClickDown.OnNext(slot);
                    break;
                case ItemUIEventType.LeftClickDown:
                    _onLeftClickDown.OnNext(slot);
                    break;
                case ItemUIEventType.RightClickUp:
                    _onRightClickUp.OnNext(slot);
                    break;
                case ItemUIEventType.LeftClickUp:
                    _onLeftClickUp.OnNext(slot);
                    break;
                case ItemUIEventType.CursorEnter:
                    _onCursorEnter.OnNext(slot);
                    break;
                case ItemUIEventType.CursorExit:
                    _onCursorExit.OnNext(slot);
                    break;
                case ItemUIEventType.CursorMove:
                    _onCursorMove.OnNext(slot);
                    break;
                case ItemUIEventType.DoubleClick:
                    _onDoubleClick.OnNext(slot);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
        
        public void OnPointerClick(PointerEventData eventData)
        {
            if (2 == eventData.clickCount && eventData.button == PointerEventData.InputButton.Left) _onPointerEvent.OnNext((this, ItemUIEventType.DoubleClick));
        }
        
        public void OnPointerDown(PointerEventData eventData)
        {
            switch (eventData.button)
            {
                case PointerEventData.InputButton.Left:
                    _onPointerEvent.OnNext((this, ItemUIEventType.LeftClickDown));
                    break;
                case PointerEventData.InputButton.Right:
                    _onPointerEvent.OnNext((this, ItemUIEventType.RightClickDown));
                    break;
            }
        }
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            _onPointing = true;
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorEnter));
        }
        
        public void OnPointerExit(PointerEventData eventData)
        {
            _onPointing = false;
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorExit));
        }
        
        public void OnPointerMove(PointerEventData eventData)
        {
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorMove));
        }
        
        public void OnPointerUp(PointerEventData eventData)
        {
            switch (eventData.button)
            {
                case PointerEventData.InputButton.Left:
                    _onPointerEvent.OnNext((this, ItemUIEventType.LeftClickUp));
                    break;
                case PointerEventData.InputButton.Right:
                    _onPointerEvent.OnNext((this, ItemUIEventType.RightClickUp));
                    break;
            }
        }
        
        #endregion
    }
    
    public enum ItemUIEventType
    {
        RightClickDown,
        LeftClickDown,
        RightClickUp,
        LeftClickUp,
        
        CursorEnter,
        CursorExit,
        CursorMove,
        
        DoubleClick,
    }
    
    public enum ItemSlotType
    {
        Normal, // 通常のアイテム表示
        NoneCross, // アイテムが何もないクロス表示
    }
    
    public enum ItemSlotFrameType
    {
        Normal,
        MachineSlot,
        CraftRecipe,
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/BlockInventoryOpenStateDataStore.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using UnityEngine;

namespace Game.PlayerInventory
{
    public class BlockInventoryOpenStateDataStore : IBlockInventoryOpenStateDataStore
    {
        //key playerId, value block entity id
        private readonly Dictionary<int, BlockInstanceId> _openCoordinates = new();
        
        public List<int> GetBlockInventoryOpenPlayers(BlockInstanceId blockBlockInstanceId)
        {
            return _openCoordinates.Where(x => x.Value == blockBlockInstanceId).Select(x => x.Key).ToList();
        }
        
        public void Open(int playerId, Vector3Int pos)
        {
            //開けるインベントリのブロックが存在していなかったらそのまま終了
            if (!ServerContext.WorldBlockDatastore.TryGetBlock<IOpenableBlockInventoryComponent>(pos, out _)) return;
            
            var entityId = ServerContext.WorldBlockDatastore.GetBlock(pos).BlockInstanceId;
            _openCoordinates[playerId] = entityId;
        }
        
        public void Close(int playerId)
        {
            if (_openCoordinates.ContainsKey(playerId)) _openCoordinates.Remove(playerId);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Util/AllGameObjectEnterExplainerController.cs
```cs
using Client.Input;
using UnityEngine;
using UnityEngine.EventSystems;

namespace Client.Game.InGame.UI.Util
{
    /// <summary>
    ///     GameObjectのマウスカーソル説明コンポーネントにマウスカーソルが乗っているかを統合的に管理するシステム
    ///     TODO 命名を変えたい
    /// </summary>
    public class AllGameObjectEnterExplainerController : MonoBehaviour
    {
        private GameObjectEnterExplainer _lastTargetExplainer;
        
        private void Awake()
        {
        }
        
        private void Update()
        {
            if (TryGetOnCursorExplainer(out var explainer))
            {
                if (_lastTargetExplainer == explainer) return;
                
                if (_lastTargetExplainer != null) _lastTargetExplainer.OnCursorExit();
                explainer.OnCursorEnter();
                _lastTargetExplainer = explainer;
            }
            else
            {
                if (_lastTargetExplainer != null) _lastTargetExplainer.OnCursorExit();
                _lastTargetExplainer = null;
            }
        }
        
        private bool TryGetOnCursorExplainer(out GameObjectEnterExplainer explainer)
        {
            explainer = null;
            if (Camera.main == null) return false;
            if (EventSystem.current.IsPointerOverGameObject()) return false;
            
            var mousePosition = InputManager.Playable.ClickPosition.ReadValue<Vector2>();
            var ray = Camera.main.ScreenPointToRay(mousePosition);
            if (!Physics.Raycast(ray, out var hit, 100)) return false;
            
            if (!hit.collider.gameObject.TryGetComponent<GameObjectEnterExplainer>(out var gameObjectEnterExplainer)) return false;
            
            explainer = gameObjectEnterExplainer;
            return true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/State/BlockState.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface.Component;

namespace Game.Block.Interface.State
{
    /// <summary>
    ///     変化したステートを通知するクラスです
    ///     <see cref="CurrentState" />や<see cref="PreviousState" />がStringなのは、ブロックの種類によって表現したいステートが異なり、
    ///     それらをパケットで取り扱う必要があるからです
    /// </summary>
    public class BlockState
    {
        public readonly Dictionary<string, byte[]> CurrentStateDetails;
        
        public BlockState(Dictionary<string, byte[]> currentStateDetails)
        {
            CurrentStateDetails = currentStateDetails;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Skit/SkitManager.cs
```cs
using System.Collections.Generic;
using Client.Skit.Define;
using Client.Skit.Skit;
using Client.Skit.SkitTrack;
using Client.Skit.UI;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Game.Skit
{
    public class SkitManager : MonoBehaviour
    {
        [SerializeField] private SkitUI skitUI;
        
        [SerializeField] private SkitCamera skitCamera;
        
        [SerializeField] private CharacterDefine characterDefine;
        [SerializeField] private VoiceDefine voiceDefine;
        
        public bool IsPlayingSkit { get; private set; }
        
        public async UniTask StartSkit(TextAsset storyCsv)
        {
            IsPlayingSkit = true;
            
            //前処理 Pre process
            var storyContext = PreProcess();
            var lines = storyCsv.text.Split('\n');
            var tagIndexTable = CreateTagIndexTable(storyCsv.text.Split('\n'));
            
            //トラックの実行処理 Execute track
            for (var i = 0; i < lines.Length; i++)
            {
                var values = lines[i].Split(',');
                
                //トラックの取得と終了判定
                var trackKey = values[1];
                if (trackKey == string.Empty) continue; //空行はスキップ
                if (trackKey == "End") break;
                
                var track = StoryTrackDefine.GetStoryTrack(trackKey);
                if (track == null)
                {
                    Debug.LogError($"トラックが見つかりません : {trackKey}\nパラメータ : {string.Join(", ", values)}");
                    break;
                }
                
                //トラックの実行
                var parameters = CreateParameter(values);
                var nextTag = await track.ExecuteTrack(storyContext, parameters);
                
                //タグがなかったのでそのまま継続
                if (nextTag == null) continue;
                
                //次のタグにジャンプ
                if (!tagIndexTable.TryGetValue(nextTag, out var nextIndex))
                {
                    Debug.LogError($"次のタグが見つかりません : トラック : {trackKey} 当該タグ : {nextTag}\nパラメータ : {string.Join(", ", values)}");
                    break;
                }
                
                i = nextIndex - 1;
            }
            
            //後処理 Post process
            skitUI.gameObject.SetActive(false);
            storyContext.DestroyCharacter();
            IsPlayingSkit = false;
            
            #region Internal
            
            StoryContext PreProcess()
            {
                //キャラクターを生成
                var characters = new Dictionary<string, SkitCharacter>();
                foreach (var characterInfo in characterDefine.CharacterInfos)
                {
                    var character = Instantiate(characterInfo.CharacterPrefab);
                    character.Initialize(transform, characterInfo.CharacterKey);
                    characters.Add(characterInfo.CharacterKey, character);
                }
                
                // 表示の設定
                skitUI.gameObject.SetActive(true);
                
                return new StoryContext(skitUI, characters, skitCamera, voiceDefine);
            }
            
            List<string> CreateParameter(string[] values)
            {
                var parameters = new List<string>();
                for (var j = 2; j < values.Length; j++) parameters.Add(values[j]);
                
                return parameters;
            }
            
            Dictionary<string, int> CreateTagIndexTable(string[] lines)
            {
                var tagIndex = new Dictionary<string, int>();
                for (var i = 0; i < lines.Length; i++)
                {
                    var values = lines[i].Split(',');
                    var tag = values[0];
                    if (tag == string.Empty) continue;
                    
                    if (tagIndex.ContainsKey(tag))
                    {
                        Debug.LogError($"タグが重複しています : {tag} {i}");
                        break;
                    }
                    
                    tagIndex.Add(tag, i);
                }
                
                return tagIndex;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/WorldInstallationDatastoreTest.cs
```cs
using Game.Block.Interface;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Random = System.Random;

namespace Tests.UnitTest.Game
{
    public class WorldBlockDatastoreTest
    {
        [Test]
        public void RegisteredDataCoordinateFromFetchTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldData = ServerContext.WorldBlockDatastore;
            
            var random = new Random(131513);
            for (var i = 0; i < 10; i++)
            {
                var x = random.Next(-1000, 1000);
                var z = random.Next(-1000, 1000);
                var pos = new Vector3Int(x, 0, z);
                
                worldData.TryAddBlock(ForUnitTestModBlockId.MachineId, pos, BlockDirection.North, out var block);
                
                var output = worldData.GetBlock(pos);
                Assert.AreEqual(block.BlockInstanceId, output.BlockInstanceId);
            }
        }
        
        
        [Test]
        public void AlreadyRegisteredEntityIdSecondTimeFailTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldData = ServerContext.WorldBlockDatastore;
            
            var entityId = BlockInstanceId.Create();
            
            //TODO 同じIDになることない
            worldData.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(1, 1), BlockDirection.North, out var originalBlock);
            var blockGuid = originalBlock.BlockGuid;
            var state = originalBlock.GetSaveState();
            
            //座標だけ変えてintIDは同じ
            var result = worldData.TryAddLoadedBlock(blockGuid, originalBlock.BlockInstanceId, state, new Vector3Int(10, 10), BlockDirection.North, out _);
            Assert.False(result);
        }
        
        [Test]
        public void AlreadyCoordinateSecondTimeFailTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldData = ServerContext.WorldBlockDatastore;
            
            worldData.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(1, 1), BlockDirection.North, out _);
            
            //idだけ変えて座標は同じ
            var result = worldData.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(1, 1), BlockDirection.North, out _);
            Assert.False(result);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/ItemInstanceId.cs
```cs
using System;
using UnitGenerator;

namespace Core.Item.Interface
{
    [UnitOf(typeof(long))]
    public partial struct ItemInstanceId
    {
        //TODO randomを全て一つのシードから生成するようにする
        private static readonly Random Random = new();
        
        public static ItemInstanceId Create()
        {
            long result = Random.Next(int.MinValue, int.MaxValue);
            result <<= 32;
            result |= (uint)Random.Next(int.MinValue, int.MaxValue);
            return new ItemInstanceId(result);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/SendCommandProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.SendCommandProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class SendCommandProtocolTest
    {
        [Test]
        public void GiveCommandTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            //送信するパケットの作成
            //ID2のアイテムを5個入れる
            var commandPacket = GetGiveCommandPacket(10, 2, 5);
            //送信を実行
            packet.GetPacketResponse(commandPacket);
            
            
            //アイテムが正しく入っているかチェック
            
            //プレイヤーインベントリを取得
            var playerInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(10);
            
            //何もないインベントリに入れたのでホットバースロット0にアイテムが入っているかチェック
            var id2Slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            Assert.AreEqual(2, playerInventory.MainOpenableInventory.GetItem(id2Slot).Id.AsPrimitive());
            Assert.AreEqual(5, playerInventory.MainOpenableInventory.GetItem(id2Slot).Count);
            
            
            //別のアイテムIDを入れたので、ホットバースロット1にアイテムが入っているかチェック
            packet.GetPacketResponse(GetGiveCommandPacket(10, 3, 7));
            var id3Slot = PlayerInventoryConst.HotBarSlotToInventorySlot(1);
            Assert.AreEqual(3, playerInventory.MainOpenableInventory.GetItem(id3Slot).Id.AsPrimitive());
            Assert.AreEqual(7, playerInventory.MainOpenableInventory.GetItem(id3Slot).Count);
            
            //アイテムID2を入れたので、ホットバースロット0のアイテムが増えているかチェック
            packet.GetPacketResponse(GetGiveCommandPacket(10, 2, 3));
            Assert.AreEqual(2, playerInventory.MainOpenableInventory.GetItem(id2Slot).Id.AsPrimitive());
            Assert.AreEqual(8, playerInventory.MainOpenableInventory.GetItem(id2Slot).Count);
        }
        
        private List<byte> GetGiveCommandPacket(int playerId, int itemId, int count)
        {
            var giveCommand = $"give {playerId} {itemId} {count}"; //give <playerId> <itemId> <count>
            
            
            return MessagePackSerializer.Serialize(new SendCommandProtocolMessagePack(giveCommand)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World/DataStore/WorldBlockDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Block.Interface.State;
using Game.Context;
using Game.World.Interface.DataStore;
using UniRx;
using UnityEngine;

namespace Game.World.DataStore
{
    /// <summary>
    ///     ワールドに存在するブロックとその座標の対応づけを行います。
    /// </summary>
    public class WorldBlockDatastore : IWorldBlockDatastore
    {
        //メインのデータストア
        public IReadOnlyDictionary<BlockInstanceId, WorldBlockData> BlockMasterDictionary => _blockMasterDictionary;
        private readonly Dictionary<BlockInstanceId, WorldBlockData> _blockMasterDictionary = new(); //ブロックのEntityIdとブロックの紐づけ
        //イベント
        public IObservable<(BlockState state, WorldBlockData blockData)> OnBlockStateChange => _onBlockStateChange;
        private readonly Subject<(BlockState state, WorldBlockData blockData)> _onBlockStateChange = new();
        
        private readonly Dictionary<IBlockComponent, IBlock> _blockComponentDictionary = new(); //コンポーネントとブロックの紐づけ
        
        //座標とキーの紐づけ
        private readonly Dictionary<Vector3Int, BlockInstanceId> _coordinateDictionary = new();
        private readonly IBlockFactory _blockFactory;
        
        public WorldBlockDatastore(IBlockFactory blockFactory)
        {
            _blockFactory = blockFactory;
        }
        
        public bool TryAddLoadedBlock(Guid blockGuid, BlockInstanceId blockInstanceId, Dictionary<string,string> componentStates, Vector3Int position, BlockDirection direction, out IBlock block)
        {
            var blockSize = MasterHolder.BlockMaster.GetBlockMaster(blockGuid).BlockSize;
            var blockPositionInfo = new BlockPositionInfo(position, direction, blockSize);
            block = _blockFactory.Load(blockGuid, blockInstanceId, componentStates, blockPositionInfo);
            return TryAddBlock(block);
        }
        public bool RemoveBlock(Vector3Int pos)
        {
            if (!this.Exists(pos)) return false;
            
            var entityId = GetEntityId(pos);
            if (!_blockMasterDictionary.ContainsKey(entityId)) return false;
            
            var data = _blockMasterDictionary[entityId];
            ((WorldBlockUpdateEvent)ServerContext.WorldBlockUpdateEvent).OnBlockRemoveEventInvoke(pos, data);
            
            data.Block.Destroy();
            _blockMasterDictionary.Remove(entityId);
            _coordinateDictionary.Remove(pos);
            return true;
        }
        
        
        public IBlock GetBlock(Vector3Int pos)
        {
            return GetBlockData(pos)?.Block;
        }
        
        public IBlock GetBlock(IBlockComponent component)
        {
            return _blockComponentDictionary.GetValueOrDefault(component);
        }
        
        public WorldBlockData GetOriginPosBlock(Vector3Int pos)
        {
            return _coordinateDictionary.TryGetValue(pos, out var entityId)
                ? _blockMasterDictionary.TryGetValue(entityId, out var data) ? data : null
                : null;
        }
        
        public BlockDirection GetBlockDirection(Vector3Int pos)
        {
            var block = GetBlockData(pos);
            //TODO ブロックないときの処理どうしよう
            return block?.BlockPositionInfo.BlockDirection ?? BlockDirection.North;
        }
        
        public IBlock GetBlock(BlockInstanceId blockInstanceId)
        {
            return _blockMasterDictionary.TryGetValue(blockInstanceId, out var data) ? data.Block : null;
        }
        
        public Vector3Int GetBlockPosition(BlockInstanceId blockInstanceId)
        {
            if (_blockMasterDictionary.TryGetValue(blockInstanceId, out var data)) return data.BlockPositionInfo.OriginalPos;
            
            throw new Exception("ブロックがありません");
        }
        
        public bool TryAddBlock(BlockId blockId, Vector3Int position, BlockDirection direction, out IBlock block)
        {
            var blockSize = MasterHolder.BlockMaster.GetBlockMaster(blockId).BlockSize;
            var blockPositionInfo = new BlockPositionInfo(position, direction, blockSize);
            block = _blockFactory.Create(blockId, BlockInstanceId.Create(), blockPositionInfo);
            return TryAddBlock(block);
        }
        
        private bool TryAddBlock(IBlock block)
        {
            var pos = block.BlockPositionInfo.OriginalPos;
            var blockDirection = block.BlockPositionInfo.BlockDirection;
            
            //既にキーが登録されてないか、同じ座標にブロックを置こうとしてないかをチェック
            if (!_blockMasterDictionary.ContainsKey(block.BlockInstanceId) &&
                !_coordinateDictionary.ContainsKey(pos))
            {
                var data = new WorldBlockData(block, pos, blockDirection);
                _blockMasterDictionary.Add(block.BlockInstanceId, data);
                _coordinateDictionary.Add(pos, block.BlockInstanceId);
                ((WorldBlockUpdateEvent)ServerContext.WorldBlockUpdateEvent).OnBlockPlaceEventInvoke(pos, data);
                
                block.BlockStateChange.Subscribe(state => { _onBlockStateChange.OnNext((state, data)); });
                
                foreach (var component in block.ComponentManager.GetComponents<IBlockComponent>())
                {
                    _blockComponentDictionary.Add(component, block);
                }
                
                return true;
            }
            
            return false;
        }
        
        private BlockInstanceId GetEntityId(Vector3Int pos)
        {
            return GetBlockData(pos).Block.BlockInstanceId;
        }
        
        /// <summary>
        ///     TODO GetBlockは頻繁に呼ばれる訳では無いが、この方式は効率が悪いのでなにか改善したい
        /// </summary>
        private WorldBlockData GetBlockData(Vector3Int pos)
        {
            foreach (KeyValuePair<BlockInstanceId, WorldBlockData> block in
                     _blockMasterDictionary.Where(block => block.Value.BlockPositionInfo.IsContainPos(pos)))
                return block.Value;
            
            return null;
        }
        
        #region Save&Load
        
        public List<BlockJsonObject> GetSaveJsonObject()
        {
            var list = new List<BlockJsonObject>();
            foreach (KeyValuePair<BlockInstanceId, WorldBlockData> block in _blockMasterDictionary)
                list.Add(new BlockJsonObject(
                    block.Value.BlockPositionInfo.OriginalPos,
                    block.Value.Block.BlockGuid.ToString(),
                    block.Value.Block.BlockInstanceId.AsPrimitive(),
                    block.Value.Block.GetSaveState(),
                    (int)block.Value.BlockPositionInfo.BlockDirection));
            
            return list;
        }
        
        //TODO ここに書くべきではないのでは？セーブも含めてこの処理は別で書くべきだと思う
        public void LoadBlockDataList(List<BlockJsonObject> saveBlockDataList)
        {
            var blockFactory = ServerContext.BlockFactory;
            foreach (var blockSave in saveBlockDataList)
            {
                var blockId = MasterHolder.BlockMaster.GetBlockId(blockSave.BlockGuid);
                
                var pos = blockSave.Pos;
                var direction = (BlockDirection)blockSave.Direction;
                var size = MasterHolder.BlockMaster.GetBlockMaster(blockId).BlockSize;
                
                var blockData = new BlockPositionInfo(pos, direction, size);
                var block = blockFactory.Load(blockSave.BlockGuid, new BlockInstanceId(blockSave.EntityId), blockSave.ComponentStates, blockData);
                
                TryAddBlock(block);
            }
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/ICraftChainerNode.cs
```cs
using Game.Block.Interface.Component;
using UnitGenerator;
using UnityEngine;
using Random = System.Random;

namespace Game.CraftChainer.CraftNetwork
{
    /// <summary>
    /// CraftChainerネットワークを構成するブロックであることを示すためのインターフェース
    /// IDを永続化する必要があるため、IBlockSaveStateを継承している
    ///
    /// An interface to indicate that it is a block that makes up the CraftChainer network.
    /// Inherits IBlockSaveState because the ID needs to be persisted
    /// </summary>
    public interface ICraftChainerNode : IBlockSaveState 
    {
        public CraftChainerNodeId NodeId { get; }
    }
    
    [UnitOf(typeof(int))]
    public partial struct CraftChainerNodeId
    {
        public static CraftChainerNodeId Invalid => new(-1); 
            
        private static readonly Random _random = new();
        
        public static CraftChainerNodeId Create()
        {
            var id = _random.Next(int.MinValue, int.MaxValue);
            while (id == Invalid.value)
            {
                id = _random.Next(int.MinValue, int.MaxValue);
            }
            
            return new CraftChainerNodeId(id);
        } 
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventProtocolProvider.cs
```cs
using System;
using System.Collections.Generic;
using MessagePack;
using Server.Event.EventReceive;

namespace Server.Event
{
    /// <summary>
    ///     サーバー内で起こったイベントの中で、各プレイヤーに送る必要があるイベントを管理します。
    ///     送る必要のある各イベントはEventReceiveフォルダの中に入っています
    ///     TODO ここのロックは一時的なものなので今後はちゃんとゲーム全体としてセマフォをしっかりやる！！
    /// </summary>
    public class EventProtocolProvider
    {
        private readonly Dictionary<int, List<EventMessagePack>> _events = new();
        
        public void AddEvent(int playerId, string tag, byte[] payload)
        {
            lock (_events)
            {
                var eventMessagePack = new EventMessagePack(tag, payload);
                
                if (_events.TryGetValue(playerId, out var eventList))
                    eventList.Add(eventMessagePack);
                else
                    _events.Add(playerId, new List<EventMessagePack> { eventMessagePack });
            }
        }
        
        public void AddBroadcastEvent(string tag, byte[] payload)
        {
            lock (_events)
            {
                var eventMessagePack = new EventMessagePack(tag, payload);
                
                foreach (var key in _events.Keys) _events[key].Add(eventMessagePack);
            }
        }
        
        public List<EventMessagePack> GetEventBytesList(int playerId)
        {
            lock (_events)
            {
                if (_events.ContainsKey(playerId))
                {
                    var events = _events[playerId];
                    var data = new List<EventMessagePack>();
                    data.AddRange(events);
                    
                    _events[playerId].Clear();
                    return data;
                }
                
                //ブロードキャストイベントの時に使うので、何かしらリクエストがあった際はDictionaryにキーを追加しておく
                _events.Add(playerId, new List<EventMessagePack>());
                
                return new List<EventMessagePack>();
            }
        }
    }
    
    
    [MessagePackObject]
    public class EventMessagePack
    {
        public EventMessagePack(string tag, byte[] payload)
        {
            Tag = tag;
            Payload = payload;
        }
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public EventMessagePack()
        {
        }
        
        [Key(0)] public string Tag { get; set; }
        
        [Key(1)] public byte[] Payload { get; set; }
        
        [Key(2)] public Dictionary<string,BlockStateMessagePack> MessagePacks { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/RemoveBlockProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.RemoveBlockProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class RemoveBlockProtocolTest
    {
        private const int MachineBlockId = 1;
        private const int PlayerId = 0;
        
        [Test]
        public void RemoveTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlock = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            
            //削除するためのブロックの生成
            worldBlock.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var block);
            var blockInventory = block.GetComponent<IBlockInventory>();
            blockInventory.InsertItem(itemStackFactory.Create(new ItemId(10), 7));
            var blockElement = MasterHolder.BlockMaster.GetBlockMaster(block.BlockId);
            
            //プロトコルを使ってブロックを削除
            packet.GetPacketResponse(RemoveBlock(new Vector3Int(0, 0), PlayerId));
            
            
            //削除したブロックがワールドに存在しないことを確認
            Assert.False(worldBlock.Exists(new Vector3Int(0, 0)));
            
            
            var playerSlotIndex = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            //ブロック内のアイテムがインベントリに入っているか
            Assert.AreEqual(10, playerInventoryData.MainOpenableInventory.GetItem(playerSlotIndex).Id.AsPrimitive());
            Assert.AreEqual(7, playerInventoryData.MainOpenableInventory.GetItem(playerSlotIndex).Count);
            
            //削除したブロックは次のスロットに入っているのでそれをチェック
            var blockItemId = MasterHolder.ItemMaster.GetItemId(blockElement.ItemGuid);
            Assert.AreEqual(blockItemId, playerInventoryData.MainOpenableInventory.GetItem(playerSlotIndex + 1).Id);
            Assert.AreEqual(1, playerInventoryData.MainOpenableInventory.GetItem(playerSlotIndex + 1).Count);
        }
        
        
        //インベントリがいっぱいで一部のアイテムが残っている場合のテスト
        [Test]
        public void InventoryFullToRemoveBlockSomeItemRemainTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlock = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId).MainOpenableInventory;
            
            //インベントリの2つのスロットを残してインベントリを満杯にする
            for (var i = 2; i < mainInventory.GetSlotSize(); i++)
                mainInventory.SetItem(i, itemStackFactory.Create(new ItemId(10), 1));
            
            //一つの目のスロットにはID3の最大スタック数から1個少ないアイテムを入れる
            var id3MaxStack = MasterHolder.ItemMaster.GetItemMaster(new ItemId(3)).MaxStack;
            mainInventory.SetItem(0, itemStackFactory.Create(new ItemId(3), id3MaxStack - 1));
            //二つめのスロットにはID4のアイテムを1つ入れておく
            mainInventory.SetItem(1, itemStackFactory.Create(new ItemId(4), 1));
            
            
            //削除するためのブロックを設置
            worldBlock.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var block);
            var blockInventory = block.GetComponent<IBlockInventory>();
            //ブロックにはID3のアイテムを2個と、ID4のアイテムを5個入れる
            //このブロックを削除したときに、ID3のアイテムが1個だけ残る
            blockInventory.SetItem(0, itemStackFactory.Create(new ItemId(3), 2));
            blockInventory.SetItem(1, itemStackFactory.Create(new ItemId(4), 5));
            
            
            //プロトコルを使ってブロックを削除
            packet.GetPacketResponse(RemoveBlock(new Vector3Int(0, 0), PlayerId));
            
            
            //削除したブロックがワールドに存在してることを確認
            Assert.True(worldBlock.Exists(new Vector3Int(0, 0)));
            
            //プレイヤーのインベントリにブロック内のアイテムが入っているか確認
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), id3MaxStack), mainInventory.GetItem(0));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(4), 6), mainInventory.GetItem(1));
            
            //ブロックのインベントリが減っているかを確認
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 1), blockInventory.GetItem(0));
            Assert.AreEqual(itemStackFactory.CreatEmpty(), blockInventory.GetItem(1));
        }
        
        //ブロックの中にアイテムはないけど、プレイヤーのインベントリが満杯でブロックを破壊できない時のテスト
        [Test]
        public void InventoryFullToCantRemoveBlockTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlock = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var mainInventory =
                serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId)
                    .MainOpenableInventory;
            
            //インベントリを満杯にする
            for (var i = 0; i < mainInventory.GetSlotSize(); i++)
                mainInventory.SetItem(i, itemStackFactory.Create(new ItemId(10), 1));
            
            //ブロックを設置
            worldBlock.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out _);
            
            
            //プロトコルを使ってブロックを削除
            packet.GetPacketResponse(RemoveBlock(new Vector3Int(0, 0), PlayerId));
            
            
            //ブロックが削除できていないことを検証
            Assert.True(worldBlock.Exists(new Vector3Int(0, 0)));
        }
        
        
        private List<byte> RemoveBlock(Vector3Int pos, int playerId)
        {
            return MessagePackSerializer.Serialize(new RemoveBlockProtocolMessagePack(playerId, pos)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Mod.Base/MoorestechServerModEntryPoint.cs
```cs
using Core.Update;
using UniRx;

namespace Mod.Base
{
    public abstract class MoorestechServerModEntryPoint
    {
        public MoorestechServerModEntryPoint()
        {
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        /// <summary>
        ///     ゲームがアップデートされるたびに呼ばれます。
        /// </summary>
        private void Update()
        {
        }
        
        /// <summary>
        ///     Modがロードされた時に呼ばれます
        /// </summary>
        /// <param name="serverModEntryInterface">DIコンテナを利用して、各種サービスを提供します。比較的よく使うものは直接アクセスできる様にしています。</param>
        public abstract void OnLoad(ServerModEntryInterface serverModEntryInterface);
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearStateDetail.cs
```cs
using System;
using MessagePack;

namespace Game.Gear.Common
{
    [MessagePackObject]
    public class GearStateDetail
    {
        [Key(0)] public float CurrentRpm { get; set; }
        
        [Key(1)] public bool IsClockwise { get; set; }
        
        public const string BlockStateDetailKey = "GearStateData";
        public GearStateDetail(float currentRpm, bool isClockwise)
        {
            CurrentRpm = currentRpm;
            IsClockwise = isClockwise;
        }
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public GearStateDetail()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/AssemblePlayerInventorySaveJsonTextTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class AssemblePlayerInventorySaveJsonTextTest
    {
        [Test]
        public void OnePlayerTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventory = saveServiceProvider.GetService<IPlayerInventoryDataStore>();
            var itemStackFactory = ServerContext.ItemStackFactory;
            var assembleJsonText = saveServiceProvider.GetService<AssembleSaveJsonText>();
            
            var playerEntityId = 100;
            
            //プレイヤーインベントリの作成
            var inventory = playerInventory.GetInventoryData(playerEntityId);
            
            //セットするアイテムを定義する
            var mainItems = new Dictionary<int, IItemStack>();
            mainItems.Add(0, itemStackFactory.Create(new ItemId(2), 10));
            mainItems.Add(10, itemStackFactory.Create(new ItemId(5), 1));
            mainItems.Add(30, itemStackFactory.Create(new ItemId(10), 10));
            mainItems.Add(PlayerInventoryConst.MainInventorySize - 1, itemStackFactory.Create(new ItemId(12), 11));
            
            var craftItems = new Dictionary<int, IItemStack>();
            craftItems.Add(0, itemStackFactory.Create(new ItemId(2), 5));
            craftItems.Add(1, itemStackFactory.Create(new ItemId(3), 4));
            craftItems.Add(7, itemStackFactory.Create(new ItemId(4), 7));
            
            //メインアイテムをセットする
            foreach (var item in mainItems) inventory.MainOpenableInventory.SetItem(item.Key, item.Value);
            
            
            //セーブする
            var json = assembleJsonText.AssembleSaveJson();
            
            
            //セーブしたデータをロードする
            var (_, loadServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            (loadServiceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(json);
            var loadedPlayerInventory = loadServiceProvider.GetService<IPlayerInventoryDataStore>()
                .GetInventoryData(playerEntityId);
            
            //メインのインベントリのチェック
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                if (mainItems.ContainsKey(i))
                {
                    Assert.AreEqual(mainItems[i], loadedPlayerInventory.MainOpenableInventory.GetItem(i));
                    continue;
                }
                
                Assert.AreEqual(itemStackFactory.CreatEmpty(), loadedPlayerInventory.MainOpenableInventory.GetItem(i));
            }
        }
        
        /// <summary>
        ///     複数ユーザーの時インベントリのデータが正しくセーブできるか
        /// </summary>
        [Test]
        public void MultiplePlayerSaveTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventory = saveServiceProvider.GetService<IPlayerInventoryDataStore>();
            var itemStackFactory = ServerContext.ItemStackFactory;
            var seed = 13143;
            
            //プレイヤーのインベントリを作成
            var playerItems = new Dictionary<int, Dictionary<int, IItemStack>>();
            var random = new Random(seed);
            for (var i = 0; i < 20; i++)
            {
                var playerId = random.Next();
                playerItems.Add(playerId, CreateSetItems(random, itemStackFactory));
            }
            
            //プレイヤーインベントリにアイテムをセットする
            foreach (var playerItem in playerItems)
            {
                var inventory = playerInventory.GetInventoryData(playerItem.Key);
                foreach (var item in playerItem.Value) inventory.MainOpenableInventory.SetItem(item.Key, item.Value);
            }
            
            //セーブする
            var json = saveServiceProvider.GetService<AssembleSaveJsonText>().AssembleSaveJson();
            
            
            //セーブしたデータをロードする
            var (_, loadServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            (loadServiceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(json);
            var loadedPlayerInventory = loadServiceProvider.GetService<IPlayerInventoryDataStore>();
            
            //データを検証する
            foreach (var playerItem in playerItems)
            {
                var loadedInventory = loadedPlayerInventory.GetInventoryData(playerItem.Key);
                //インベントリのチェック
                for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
                {
                    if (playerItem.Value.ContainsKey(i))
                    {
                        Assert.AreEqual(playerItem.Value[i], loadedInventory.MainOpenableInventory.GetItem(i));
                        continue;
                    }
                    
                    Assert.AreEqual(itemStackFactory.CreatEmpty(), loadedInventory.MainOpenableInventory.GetItem(i));
                }
            }
        }
        
        private Dictionary<int, IItemStack> CreateSetItems(Random random, IItemStackFactory itemStackFactory)
        {
            var items = new Dictionary<int, IItemStack>();
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                if (random.Next(0, 2) == 0) continue;
                var id = new ItemId(random.Next(1, 20));
                var count = random.Next(1, 20);
                items.Add(i, itemStackFactory.Create(id, count));
            }
            
            return items;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/BlockInventoryState.cs
```cs
using System.Threading;
using Client.Common.Asset;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Control;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Block;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Input;
using Cysharp.Threading.Tasks;
using Game.Context;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class BlockInventoryState : IUIState
    {
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        private readonly PlayerInventoryViewController _playerInventoryViewController;
        
        private CancellationTokenSource _loadBlockInventoryCts;
        private IBlockInventoryView _iIBlockInventoryView;
        private Vector3Int _openBlockPos;
        
        public BlockInventoryState(BlockGameObjectDataStore blockGameObjectDataStore, PlayerInventoryViewController playerInventoryViewController)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            _playerInventoryViewController = playerInventoryViewController;
            
            ClientContext.VanillaApi.Event.SubscribeEventResponse(OpenableBlockInventoryUpdateEventPacket.EventTag, OnOpenableBlockInventoryUpdateEvent);
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.CloseUI.GetKeyDown || InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.GameScreen;
            
            return UIStateEnum.Current;
        }
        
        // ReSharper disable Unity.PerformanceAnalysis
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            BlockGameObject blockGameObject = null;
            if (!IsExistBlock())
            {
                return;
            }
            
            _loadBlockInventoryCts = new CancellationTokenSource();
            LoadBlockInventory().Forget();
            
            #region Internal
            
            bool IsExistBlock()
            {
                if (!BlockClickDetect.TryGetCursorOnBlockPosition(out _openBlockPos))
                {
                    // TODO ログ基盤に入れる
                    Debug.LogError("開いたブロックの座標が取得できませんでした。UIステートに不具合があります。");
                    return false;
                }
                
                if (!_blockGameObjectDataStore.TryGetBlockGameObject(_openBlockPos, out blockGameObject))
                {
                    // TODO ログ基盤に入れる
                    Debug.LogError("開いたブロックの情報が取得できませんでした。");
                    return false;
                }
                
                var blockMaster = blockGameObject.BlockMasterElement;
                var inventoryPath = blockMaster.BlockUIAddressablesPath;
                if (string.IsNullOrEmpty(inventoryPath))
                {
                    // TODO ログ基盤に入れる
                    Debug.LogError($"開こうとしたブロックインベントリのAddressableパスが指定されていません。 Guid:{blockMaster.BlockGuid} Name:{blockMaster.Name}");

                    return false;
                }
                
                return true;
            }
            
            async UniTask LoadBlockInventory()
            {
                //ブロックインベントリのビューを設定する
                var blockMaster = blockGameObject.BlockMasterElement;
                var path = blockMaster.BlockUIAddressablesPath;
                using var loadedInventory = await AddressableLoader.LoadAsync<GameObject>(path);
                if (loadedInventory == null)
                {
                    // TODO ログ基盤に入れる
                    Debug.LogError($"ブロックインベントリのビューが取得できませんでした。 Guid:{blockMaster.BlockGuid} Name:{blockMaster.Name} Path:{path}");
                    return;
                }
                if (!loadedInventory.Asset.TryGetComponent(out IBlockInventoryView _))
                {
                    // TODO ログ基盤に入れる
                    Debug.LogError($"ブロックインベントリのビューにコンポーネントがついていませんでした。 Guid:{blockMaster.BlockGuid} Name:{blockMaster.Name} Path:{path}");
                    return;
                }
                
                // check cts
                if (_loadBlockInventoryCts.IsCancellationRequested) return;
                
                // カーソルを表示する
                // Show cursor
                InputManager.MouseCursorVisible(true);
                
                // UIのオブジェクトを生成し、オンにする
                // Generate and turn on the UI object
                _iIBlockInventoryView = ClientContext.DIContainer.Instantiate(loadedInventory.Asset, _playerInventoryViewController.SubInventoryParent).GetComponent<IBlockInventoryView>();
                _iIBlockInventoryView.Initialize(blockGameObject);
                _playerInventoryViewController.SetActive(true);
                _playerInventoryViewController.SetSubInventory(_iIBlockInventoryView);
                
                // check cts
                if (_loadBlockInventoryCts.IsCancellationRequested) return;
                
                // ブロックインベントリのデータを取得する
                // Get block inventory data
                ClientContext.VanillaApi.SendOnly.SetOpenCloseBlock(_openBlockPos, true);
                var response = await ClientContext.VanillaApi.Response.GetBlockInventory(_openBlockPos, _loadBlockInventoryCts.Token);
                _iIBlockInventoryView?.UpdateItemList(response);
            }
            
            #endregion
        }
        
        public void OnExit()
        {
            _loadBlockInventoryCts?.Cancel();
            
            // ブロックを閉じる設定
            // Close block settings
            ClientContext.VanillaApi.SendOnly.SetOpenCloseBlock(_openBlockPos, false);
            
            // サブインベントリを空にする
            // Set the sub inventory to empty
            _playerInventoryViewController.SetSubInventory(new EmptySubInventory());
            
            // ブロックインベントリを閉じる
            // Close the block inventory
            _playerInventoryViewController.SetActive(false);
            _iIBlockInventoryView?.DestroyUI();
            _iIBlockInventoryView = null;
        }
        
        private void OnOpenableBlockInventoryUpdateEvent(byte[] payload)
        {
            if (_iIBlockInventoryView == null) return;
            
            var packet = MessagePackSerializer.Deserialize<OpenableBlockInventoryUpdateEventMessagePack>(payload);
            var item = ServerContext.ItemStackFactory.Create(packet.Item.Id, packet.Item.Count);
            _iIBlockInventoryView.UpdateInventorySlot(packet.Slot, item);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/UtilTest.cs
```cs
using Game.Block;
using NUnit.Framework;

namespace Tests.UnitTest.Core.Other
{
    public class UtilTest
    {
        //確立のテストだから1万回繰り返して平均を取る
        //+-5%なら許容範囲内
        [TestCase(0.0)]
        [TestCase(0.1)]
        [TestCase(0.2)]
        [TestCase(0.3)]
        [TestCase(0.3)]
        [TestCase(0.5)]
        [TestCase(0.6)]
        [TestCase(0.7)]
        [TestCase(0.8)]
        [TestCase(0.9)]
        [TestCase(1)]
        public void DetectFromPercentTest(double percent)
        {
            var trueCnt = 0;
            for (var i = 0; i < 10000; i++)
                if (ProbabilityCalculator.DetectFromPercent(percent))
                    trueCnt++;
            
            var truePercent = trueCnt / 10000.0;
            Assert.True(percent - 0.5 < truePercent);
            Assert.True(truePercent < percent + 0.5);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerMainComputerSaveLoadTest.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerMainComputerSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);
            
            // ChainerMainComputerブロックを作成
            // Create a ChainerMainComputer block
            var mainComputerBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerMainComputer, new BlockInstanceId(1), posInfo);
            var originalMainComputerComponent = mainComputerBlock.GetComponent<CraftChainerMainComputerComponent>();
            
            
            // セーブデータを取得
            // Get the save data
            var saveState = mainComputerBlock.GetSaveState();
            
            // ブロックをロード
            // Load the block
            var loadedBlock = blockFactory.Load(mainComputerBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedMainComputerComponent = loadedBlock.GetComponent<CraftChainerMainComputerComponent>();
            
            // NodeIdが正しく保存・ロードされているか確認
            // Check if NodeId is correctly saved and loaded
            Assert.AreEqual(originalMainComputerComponent.NodeId, loadedMainComputerComponent.NodeId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/VanillaBeltConveyorBlockInventoryInserter.cs
```cs
using System.Linq;
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;

namespace Game.Block.Blocks.BeltConveyor
{
    public class VanillaBeltConveyorBlockInventoryInserter : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        public VanillaBeltConveyorBlockInventoryInserter(BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockConnectorComponent = blockConnectorComponent;
        }

        public IItemStack InsertItem(IItemStack itemStack)
        {
            var targets = _blockConnectorComponent.ConnectedTargets;
            if (targets.Count == 0) return itemStack;
            
            var connector = targets.First();
            var output = connector.Key.InsertItem(itemStack);
            
            return output;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/IItemCollectableBeltConveyor.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface.Component;

namespace Game.Block.Blocks.BeltConveyor
{
    public interface IItemCollectableBeltConveyor : IBlockComponent
    {
        public BeltConveyorSlopeType SlopeType { get; }
        public IReadOnlyList<IOnBeltConveyorItem> BeltConveyorItems { get; }
    }
    
    public enum BeltConveyorSlopeType
    {
        Straight,
        Up,
        Down
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaItemShooterTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.ItemShooter;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaItemShooterTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var itemShooter = blockMasterElement.BlockParam as ItemShooterBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(itemShooter.InventoryConnectors, blockPositionInfo);
            
            var direction = blockPositionInfo.BlockDirection;
            var chestComponent = new ItemShooterComponent(inputConnectorComponent, itemShooter);
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var itemShooter = blockMasterElement.BlockParam as ItemShooterBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(itemShooter.InventoryConnectors, blockPositionInfo);
            
            var direction = blockPositionInfo.BlockDirection;
            var chestComponent = new ItemShooterComponent(componentStates, inputConnectorComponent, itemShooter);
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/RecipeTabView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Sub;
using Core.Master;
using Game.CraftChainer.Util;
using UniRx;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class RecipeTabView : MonoBehaviour
    {
        [SerializeField] private RecipeViewerTabElement tabElementPrefab;
        [SerializeField] private Transform tabElementParent;
        [SerializeField] private HorizontalLayoutGroup tabElementLayoutGroup; 
        
        public IObservable<BlockId?> OnClickTab => onClickTab; // nullならCraftを選択したことを意味する
        private readonly Subject<BlockId?> onClickTab = new(); // If null, it means that Craft is selected
        
        private readonly List<RecipeViewerTabElement> _currentTabs = new();
        
        public void SetRecipeTabView(RecipeViewerItemRecipes recipes)
        {
            foreach (var tab in _currentTabs)
            {
                Destroy(tab.gameObject);
            }
            
            _currentTabs.Clear();
            
            // クラフトタブがあればそれを優先的異選択
            // If there is a craft tab, select it preferentially
            var isFirstCraft = false;
            if (recipes.CraftRecipes.Count != 0)
            {
                var tabElement = Instantiate(tabElementPrefab, tabElementParent);
                tabElement.Initialize();
                tabElement.SetCraftIcon();
                tabElement.SetSelected(true);
                tabElement.OnClickTab.Subscribe(OnClickTabAction);
                _currentTabs.Add(tabElement);
                isFirstCraft = true;
            }
            
            var isFirst = true;
            foreach (var machineRecipe in recipes.MachineRecipes)
            {
                var blockId = machineRecipe.Key;
                var itemId = MasterHolder.BlockMaster.GetItemId(blockId);
                var blockItemView = ClientContext.ItemImageContainer.GetItemView(itemId);
                
                var tabElement = Instantiate(tabElementPrefab, tabElementParent);
                tabElement.Initialize();
                tabElement.SetMachineItem(blockId, blockItemView);
                tabElement.OnClickTab.Subscribe(OnClickTabAction);
                _currentTabs.Add(tabElement);
                
                // クラフトタブがない場合は最初のタブを選択
                // If there is no craft tab, select the first tab
                tabElement.SetSelected(isFirst && !isFirstCraft);
                isFirst = false;
            }
            
            // レイアウトの適用を強制  
            // Force the layout to be applied
            UpdateLayoutGroup();
        }
        
        
        private void OnClickTabAction(RecipeViewerTabElement tabElement)
        {
            tabElement.SetSelected(true);
            foreach (var tab in _currentTabs)
            {
                if (tab == tabElement) continue;
                tab.SetSelected(false);
            }
            
            onClickTab.OnNext(tabElement.CurrentBlockId);
            
            UpdateLayoutGroup();
        }
        
        private void UpdateLayoutGroup()
        {
            tabElementLayoutGroup.CalculateLayoutInputHorizontal();
            tabElementLayoutGroup.CalculateLayoutInputVertical();
            
            tabElementLayoutGroup.SetLayoutHorizontal();
            tabElementLayoutGroup.SetLayoutVertical();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/CraftChain/CraftingSolverRecipe.cs
```cs
using System;
using System.Collections.Generic;
using MessagePack;
using Newtonsoft.Json;
using UnitGenerator;

namespace Game.CraftChainer.CraftChain
{
    public class CraftingSolverRecipe
    {
        public readonly CraftingSolverRecipeId CraftingSolverRecipeId;
        public readonly List<CraftingSolverItem> Inputs;
        public readonly List<CraftingSolverItem> Outputs;
        
        public CraftingSolverRecipe(CraftingSolverRecipeId craftingSolverRecipeId, List<CraftingSolverItem> inputs, List<CraftingSolverItem> outputs)
        {
            CraftingSolverRecipeId = craftingSolverRecipeId;
            Inputs = inputs;
            Outputs = outputs;
        }
        
        public CraftingSolverRecipe()
        {
            CraftingSolverRecipeId = CraftingSolverRecipeId.InvalidId;
            Inputs = new List<CraftingSolverItem>();
            Outputs = new List<CraftingSolverItem>();
        }
    }
    
    [UnitOf(typeof(int), UnitGenerateOptions.Comparable)]
    public partial struct CraftingSolverRecipeId
    {
        public static readonly CraftingSolverRecipeId InvalidId = new(0);
        
        private static readonly Random Random = new();
        public static CraftingSolverRecipeId Create()
        {
            // 1 〜 int.Max
            var id = Random.Next(1, int.MaxValue);
            return new CraftingSolverRecipeId(id);
        }
    }
    
    [JsonObject, MessagePackObject]
    public class CraftingSolverRecipeJsonObjectMessagePack
    {
        [JsonProperty("recipeId"), Key(0)] public int RecipeId;
        [JsonProperty("inputs"), Key(1)] public List<CraftingSolverItemJsonObjectMessagePack> Inputs;
        [JsonProperty("outputs"), Key(2)] public List<CraftingSolverItemJsonObjectMessagePack> Outputs;
        
        public CraftingSolverRecipeJsonObjectMessagePack() { }

        public CraftingSolverRecipeJsonObjectMessagePack(CraftingSolverRecipe craftingSolverRecipe)
        {
            RecipeId = craftingSolverRecipe.CraftingSolverRecipeId.AsPrimitive();
            Inputs = new List<CraftingSolverItemJsonObjectMessagePack>();
            foreach (var input in craftingSolverRecipe.Inputs)
            {
                Inputs.Add(new CraftingSolverItemJsonObjectMessagePack(input));
            }
            Outputs = new List<CraftingSolverItemJsonObjectMessagePack>();
            foreach (var output in craftingSolverRecipe.Outputs)
            {
                Outputs.Add(new CraftingSolverItemJsonObjectMessagePack(output));
            }
        }
        
        public CraftingSolverRecipe ToCraftingSolverRecipe()
        {
            var inputs = new List<CraftingSolverItem>();
            foreach (var input in Inputs)
            {
                inputs.Add(input.ToCraftingSolverItem());
            }
            var outputs = new List<CraftingSolverItem>();
            foreach (var output in Outputs)
            {
                outputs.Add(output.ToCraftingSolverItem());
            }
            
            return new CraftingSolverRecipe(new CraftingSolverRecipeId(RecipeId), inputs, outputs);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/BlockInventoryRequestProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Interface.Component;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlocksModule;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class BlockInventoryRequestProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:blockInvReq";
        
        public BlockInventoryRequestProtocol(ServiceProvider serviceProvider)
        {
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestBlockInventoryRequestProtocolMessagePack>(payload.ToArray());
            
            //開けるインベントリを持つブロックが存在するかどうかをチェック
            var blockDatastore = ServerContext.WorldBlockDatastore;
            if (!blockDatastore.ExistsComponent<IOpenableBlockInventoryComponent>(data.Pos))
                return null;
            
            
            //存在したらアイテム数とアイテムIDをまとめてレスポンスする
            var blockId = blockDatastore.GetBlock(data.Pos).BlockId;
            
            return new BlockInventoryResponseProtocolMessagePack(blockId, blockDatastore.GetBlock<IOpenableBlockInventoryComponent>(data.Pos).InventoryItems);
        }
        
        //データのレスポンスを実行するdelegateを設定する
        private delegate byte[] InventoryResponse(Vector3Int pos, IBlockParam blockParam);
        
        
        [MessagePackObject]
        public class RequestBlockInventoryRequestProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack Pos { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RequestBlockInventoryRequestProtocolMessagePack()
            {
            }
            
            public RequestBlockInventoryRequestProtocolMessagePack(Vector3Int pos)
            {
                Tag = ProtocolTag;
                Pos = new Vector3IntMessagePack(pos);
            }
        }
        
        [MessagePackObject]
        public class BlockInventoryResponseProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int BlockId { get; set; }
            [Key(3)] public ItemMessagePack[] Items { get; set; }
            
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public BlockInventoryResponseProtocolMessagePack() { }
            
            public BlockInventoryResponseProtocolMessagePack(BlockId blockId, IReadOnlyList<IItemStack> items)
            {
                Tag = ProtocolTag;
                BlockId = (int)blockId;
                Items = items.Select(item => new ItemMessagePack(item)).ToArray();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/OneClickCraft.cs
```cs
using System;
using System.Collections.Generic;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.Crafting.Interface;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.CraftRecipesModule;

namespace Server.Protocol.PacketResponse
{
    public class OneClickCraft : IPacketResponse
    {
        public const string ProtocolTag = "va:oneClickCraft";
        private readonly CraftEvent _craftEvent;
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public OneClickCraft(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
            _craftEvent = serviceProvider.GetService<CraftEvent>();
        }
        
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestOneClickCraftProtocolMessagePack>(payload.ToArray());
            
            var craftConfig = MasterHolder.CraftRecipeMaster.GetCraftRecipe(data.CraftRecipeGuid);
            //プレイヤーインベントリを取得
            var playerInventory = _playerInventoryDataStore.GetInventoryData(data.PlayerId);
            var mainInventory = playerInventory.MainOpenableInventory;
            
            //クラフト可能かどうかを確認
            if (!IsCraftable(mainInventory, craftConfig))
                //クラフト不可能な場合は何もしない
                return null;
            
            //クラフト可能な場合はクラフトを実行
            
            //クラフトに必要なアイテムを消費
            ConsumptionItem(mainInventory, craftConfig);
            //クラフト結果をプレイヤーインベントリに追加
            var resultItem = ServerContext.ItemStackFactory.Create(craftConfig.CraftResultItemGuid, craftConfig.CraftResultCount);
            playerInventory.MainOpenableInventory.InsertItem(resultItem);
            
            _craftEvent.InvokeCraftItem(craftConfig);
            
            return null;
        }
        
        private static bool IsCraftable(IOpenableInventory mainInventory, CraftRecipeMasterElement recipe)
        {
            //クラフト結果のアイテムをインサートできるかどうかをチェックする
            var resultItem = ServerContext.ItemStackFactory.Create(recipe.CraftResultItemGuid, recipe.CraftResultCount);
            var resultItemList = new List<IItemStack> { resultItem };
            if (!mainInventory.InsertionCheck(resultItemList))
                return false;
            
            //クラフトに必要なアイテムを収集する
            //key itemId value count
            var requiredItems = new Dictionary<ItemId, int>();
            foreach (var requiredItem in recipe.RequiredItems)
            {
                var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (requiredItems.ContainsKey(requiredItemId))
                {
                    requiredItems[requiredItemId] += requiredItem.Count;
                }
                else
                {
                    requiredItems.Add(requiredItemId, requiredItem.Count);
                }
            }
            
            //クラフトに必要なアイテムを持っているか確認する
            var checkResult = new Dictionary<ItemId, int>();
            foreach (var itemStack in mainInventory.InventoryItems)
            {
                if (!requiredItems.ContainsKey(itemStack.Id)) continue;
                
                if (checkResult.ContainsKey(itemStack.Id))
                    checkResult[itemStack.Id] += itemStack.Count;
                else
                    checkResult[itemStack.Id] = itemStack.Count;
            }
            
            //必要なアイテムを持っていない場合はクラフトできない
            foreach (var requiredItem in requiredItems)
            {
                if (!checkResult.ContainsKey(requiredItem.Key)) return false;
                if (checkResult[requiredItem.Key] < requiredItem.Value) return false;
            }
            
            
            return true;
        }
        
        
        /// <summary>
        ///     クラフトしてアイテムを消費する
        /// </summary>
        private static void ConsumptionItem(IOpenableInventory mainInventory, CraftRecipeMasterElement recipe)
        {
            //クラフトに必要なアイテムを収集する
            //key itemId value count
            var requiredItems = new Dictionary<ItemId, int>();
            foreach (var requiredItem in recipe.RequiredItems)
            {
                if (requiredItem.IsRemain.HasValue && requiredItem.IsRemain.Value) 
                {
                    continue;
                }
                
                var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (requiredItems.ContainsKey(requiredItemId))
                    requiredItems[requiredItemId] += requiredItem.Count;
                else
                    requiredItems.Add(requiredItemId, requiredItem.Count);
            }
            
            //クラフトのために消費する
            for (var i = 0; i < mainInventory.InventoryItems.Count; i++)
            {
                var inventoryItem = mainInventory.InventoryItems[i];
                if (!requiredItems.TryGetValue(inventoryItem.Id, out var subCount)) continue;
                
                if (inventoryItem.Count <= subCount)
                {
                    mainInventory.SetItem(i, inventoryItem.SubItem(inventoryItem.Count));
                    requiredItems[inventoryItem.Id] -= inventoryItem.Count;
                }
                else
                {
                    mainInventory.SetItem(i, inventoryItem.SubItem(subCount));
                    requiredItems[inventoryItem.Id] -= subCount;
                }
            }
        }
        
        [MessagePackObject]
        public class RequestOneClickCraftProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Key(3)] public string CraftRecipeGuidStr { get; set; }
            [IgnoreMember] public Guid CraftRecipeGuid => Guid.Parse(CraftRecipeGuidStr);
            
            public RequestOneClickCraftProtocolMessagePack(int playerId, Guid craftRecipeGuid)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                CraftRecipeGuidStr = craftRecipeGuid.ToString();
            }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public RequestOneClickCraftProtocolMessagePack() { }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Server/PacketBufferParserTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using MessagePack;
using NUnit.Framework;
using Server.Util;

namespace Tests.UnitTest.Server
{
    /// <summary>
    ///     <see cref="PacketBufferParser" />が正しくパースで来ているかのテスト
    /// </summary>
    public class PacketBufferParserTest
    {
        /// <summary>
        ///     オーバーフローして、ヘッダーが分離されたときに正しくパースできるかのテスト
        ///     1回目と2回目を複合して正しくパースできるかのテスト
        /// </summary>
        [Test]
        public void PacketBufferPasserNoOverflowTest()
        {
            //これは確定で5バイトになる
            var testMessageBytes = MessagePackSerializer.Serialize(new PasserTestMessagePack { t = "t" });
            
            
            //すべてがぴったりと入っているパターン
            // 4Bのヘッダ + 2Bのダミー + 4Bのヘッダ + 5Bのメインデータ
            var parser = new PacketBufferParser();
            var sendBytes = new List<byte>();
            sendBytes.AddRange(BitConverter.GetBytes(2).Reverse()); //4Bのヘッダ
            sendBytes.Add(0); //2Bのダミー
            sendBytes.Add(0);
            sendBytes.AddRange(BitConverter.GetBytes(5).Reverse()); //4Bのヘッダ
            sendBytes.AddRange(testMessageBytes); //5Bのメインデータ
            
            var result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            //結果のデータの二番目が正しくパースできていることを確認する
            Assert.AreEqual("t", MessagePackSerializer.Deserialize<PasserTestMessagePack>(result[1].ToArray()).t);
            
            
            //ヘッダーが1バイトオーバーフローしているパターン
            //1回目のパケットを送る
            parser = new PacketBufferParser();
            sendBytes.Clear();
            var header = BitConverter.GetBytes(5).Reverse().ToList();
            sendBytes.Add(header[0]);
            sendBytes.Add(header[1]);
            sendBytes.Add(header[2]);
            //1回目パース
            result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            Assert.AreEqual(0, result.Count); //まだ2個目はパースできない
            
            //2回目のパケットを送る
            //結果のデータの二番目が正しくパースできていることを確認する
            sendBytes.Clear();
            sendBytes.Add(header[3]); //最後のヘッダ
            sendBytes.AddRange(testMessageBytes); //5Bのメインデータ
            //2回目パース
            result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            Assert.AreEqual("t", MessagePackSerializer.Deserialize<PasserTestMessagePack>(result[0].ToArray()).t);
            
            
            PacketBufferPasserNoOverflowTestSendOnly(1);
            PacketBufferPasserNoOverflowTestSendOnly(2);
            PacketBufferPasserNoOverflowTestSendOnly(3);
        }
        
        
        /// <summary>
        ///     <see cref="PacketBufferPasserNoOverflowTest" />の送信、検証だけを行う
        ///     引数に示された
        /// </summary>
        private void PacketBufferPasserNoOverflowTestSendOnly(int overflowCountByte)
        {
            //これは確定で5バイトになる
            var testMessageBytes = MessagePackSerializer.Serialize(new PasserTestMessagePack { t = "t" });
            
            var parser = new PacketBufferParser();
            var sendBytes = new List<byte>();
            var header = BitConverter.GetBytes(5).Reverse().ToList();
            for (var i = 0; i < 4 - overflowCountByte; i++) sendBytes.Add(header[i]);
            //1回目パース
            var result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            Assert.AreEqual(0, result.Count); //まだ2個目はパースできない
            
            //2回目のパケットを送る
            //結果のデータの二番目が正しくパースできていることを確認する
            sendBytes.Clear();
            for (var i = 4 - overflowCountByte; i < 4; i++) sendBytes.Add(header[i]);
            sendBytes.AddRange(testMessageBytes); //5Bのメインデータ
            //2回目パース
            result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            Assert.AreEqual("t", MessagePackSerializer.Deserialize<PasserTestMessagePack>(result[0].ToArray()).t);
        }
    }
    
    [MessagePackObject(true)]
    public class PasserTestMessagePack
    {
        public string t;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningMiningState.cs
```cs
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.ProgressBar;
using Client.Input;
using Mooresmaster.Model.MapObjectsModule;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningMiningState : IMapObjectMiningState
    {
        private readonly MiningToolsElement _miningToolsElement;
        
        private float _currentMiningProgressTime;
        
        public MapObjectMiningMiningState(MiningToolsElement miningToolsElement, IPlayerObjectController playerObjectController)
        {
            _miningToolsElement = miningToolsElement;
            _currentMiningProgressTime = 0;
            
            playerObjectController.SetAnimationState(PlayerAnimationState.Axe);
            ProgressBarView.Instance.Show();
        }
        
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            var next = GetNextUpdateInternal(context, dt);
            if (next != this)
            {
                context.PlayerObjectController.SetAnimationState(PlayerAnimationState.IdleWalkRunBlend);
                ProgressBarView.Instance.Hide();
            }
            return next;
        }
        
        private IMapObjectMiningState GetNextUpdateInternal(MapObjectMiningControllerContext context, float dt)
        {
            // フォーカスが外れた場合はidleに遷移
            // if focus is lost, transition to idle
            if (context.CurrentFocusMapObjectGameObject == null)
            {
                return new MapObjectMiningFocusState();
            }
            
            // 左クリックされていない場合はフォーカス状態に遷移
            // If left click is not pressed, transition to focus state
            if (!InputManager.Playable.ScreenLeftClick.GetKey)
            {
                return new MapObjectMiningFocusState();
            }
            
            _currentMiningProgressTime += dt;
            ProgressBarView.Instance.SetProgress(_currentMiningProgressTime / _miningToolsElement.AttackSpeed);
            
            // マイニングが完了した場合はマイニング完了状態に遷移
            // If mining is complete, transition to mining complete state
            if (_miningToolsElement.AttackSpeed <= _currentMiningProgressTime)
            {
                var attackDamage = _miningToolsElement.Damage;
                return new MapObjectMiningMiningCompleteState(context.CurrentFocusMapObjectGameObject, attackDamage);
            }
            
            return this;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/InventoryItemMoveProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.InventoryItemMoveProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class InventoryItemMoveProtocolTest
    {
        private const int PlayerId = 0;
        
        [Test]
        public void MainInventoryMoveTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).MainOpenableInventory;
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //インベントリの設定
            mainInventory.SetItem(0, new ItemId(1), 10);
            
            //インベントリを持っているアイテムに移す
            packet.GetPacketResponse(GetPacket(7,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory), 0,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory), 0));
            
            //移っているかチェック
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 3), mainInventory.GetItem(0));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 7), grabInventory.GetItem(0));
            
            
            //持っているアイテムをインベントリに移す
            packet.GetPacketResponse(GetPacket(5,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory), 0,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory), 0));
            
            
            //移っているかチェック
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 8), mainInventory.GetItem(0));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 2), grabInventory.GetItem(0));
        }
        
        
        [Test]
        public void BlockInventoryTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            var worldDataStore = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var chestPosition = new Vector3Int(5, 10);
            
            worldDataStore.TryAddBlock(ForUnitTestModBlockId.ChestId, chestPosition, BlockDirection.North, out var chest);
            var chestComponent = chest.GetComponent<VanillaChestComponent>();
            
            //ブロックインベントリの設定
            chestComponent.SetItem(1, new ItemId(1), 10);
            
            //インベントリを持っているアイテムに移す
            packet.GetPacketResponse(GetPacket(7,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.BlockInventory, new Vector3Int(5, 10)), 1 + PlayerInventoryConst.MainInventorySize,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory), 0));
            
            //移っているかチェック
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 3), chestComponent.GetItem(1));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 7), grabInventory.GetItem(0));
            
            
            //持っているアイテムをインベントリに移す
            packet.GetPacketResponse(GetPacket(5,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory), 0,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.BlockInventory, new Vector3Int(5, 10)), 1 + PlayerInventoryConst.MainInventorySize));
            
            //移っているかチェック
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 8), chestComponent.GetItem(1));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 2), grabInventory.GetItem(0));
        }
        
        
        private List<byte> GetPacket(int count, ItemMoveInventoryInfo from, int fromSlot, ItemMoveInventoryInfo to, int toSlot,
            ItemMoveType itemMoveType = ItemMoveType.SwapSlot)
        {
            return MessagePackSerializer.Serialize(
                new InventoryItemMoveProtocolMessagePack(PlayerId, count, itemMoveType, from, fromSlot, to, toSlot)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/PlayerInventoryProtocolTest.cs
```cs
using System.Linq;
using Core.Const;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.PlayerInventoryResponseProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class PlayerInventoryProtocolTest
    {
        [Test]
        public void GetPlayerInventoryProtocolTest()
        {
            var playerId = 1;
            
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            
            //からの時のデータ要求
            var payload = MessagePackSerializer.Serialize(new RequestPlayerInventoryProtocolMessagePack(playerId))
                .ToList();
            //データの検証
            var data = MessagePackSerializer.Deserialize<PlayerInventoryResponseProtocolMessagePack>(
                packet.GetPacketResponse(payload)[0].ToArray());
            Assert.AreEqual(playerId, data.PlayerId);
            
            //プレイヤーインベントリの検証
            for (var i = 0; i < PlayerInventoryConst.MainInventoryColumns; i++)
            {
                Assert.AreEqual(ItemMaster.EmptyItemId, data.Main[i].Id);
                Assert.AreEqual(0, data.Main[i].Count);
            }
            
            //グラブインベントリの検証
            Assert.AreEqual(0, data.Grab.Id.AsPrimitive());
            Assert.AreEqual(0, data.Grab.Count);
            
            
            //インベントリにアイテムが入っている時のテスト
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(playerId);
            var itemStackFactory = ServerContext.ItemStackFactory;
            playerInventoryData.MainOpenableInventory.SetItem(0, itemStackFactory.Create(new ItemId(1), 5));
            playerInventoryData.MainOpenableInventory.SetItem(20, itemStackFactory.Create(new ItemId(3), 1));
            playerInventoryData.MainOpenableInventory.SetItem(34, itemStackFactory.Create(new ItemId(10), 7));
            
            
            //2回目のデータ要求
            data = MessagePackSerializer.Deserialize<PlayerInventoryResponseProtocolMessagePack>(
                packet.GetPacketResponse(payload)[0].ToArray());
            Assert.AreEqual(playerId, data.PlayerId);
            
            //データの検証
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
                if (i == 0)
                {
                    Assert.AreEqual(1, data.Main[i].Id.AsPrimitive());
                    Assert.AreEqual(5, data.Main[i].Count);
                }
                else if (i == 20)
                {
                    Assert.AreEqual(3, data.Main[i].Id.AsPrimitive());
                    Assert.AreEqual(1, data.Main[i].Count);
                }
                else if (i == 34)
                {
                    Assert.AreEqual(10, data.Main[i].Id.AsPrimitive());
                    Assert.AreEqual(7, data.Main[i].Count);
                }
                else
                {
                    Assert.AreEqual(ItemMaster.EmptyItemId, data.Main[i].Id);
                    Assert.AreEqual(0, data.Main[i].Count);
                }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/HotBarView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.Define;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Input;
using Core.Const;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.Inventory
{
    public class HotBarView : MonoBehaviour
    {
        [SerializeField] private List<HotBarItem> hotBarItems;
        [SerializeField] private ItemObjectContainer itemObjectContainer;
        [SerializeField] private PlayerGrabItemManager playerGrabItemManager;
        
        private GameObject _currentGrabItem;
        private ILocalPlayerInventory _localPlayerInventory;
        
        public IItemStack CurrentItem => _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(SelectIndex)];
        public int SelectIndex { get; private set; }
        
        private void Start()
        {
            SelectIndex = 0;
            UpdateSelectedView(0, 0);
            for (var i = 0; i < hotBarItems.Count; i++)
            {
                var keyBordText = (i + 1).ToString();
                hotBarItems[i].SetKeyBoardText(keyBordText);
            }
        }
        
        private void Update()
        {
            UpdateHotBarItem();
            var nextSelectIndex = SelectedHotBar();
            if (nextSelectIndex != -1 && nextSelectIndex != SelectIndex)
            {
                UpdateSelectedView(SelectIndex, nextSelectIndex);
                UpdateHoldItem(nextSelectIndex); //アイテムの再生成があるので変化を検知して変更する
                
                SelectIndex = nextSelectIndex;
            }
            
            #region Internal
            
            void UpdateHotBarItem()
            {
                for (var i = 0; i < _localPlayerInventory.Count; i++) UpdateHotBarElement(i, _localPlayerInventory[i]);
            }
            
            void UpdateHotBarElement(int slot, IItemStack item)
            {
                //スロットが一番下の段もしくはメインインベントリの範囲外の時はスルー
                var c = PlayerInventoryConst.MainInventoryColumns;
                var r = PlayerInventoryConst.MainInventoryRows;
                var startHotBarSlot = c * (r - 1);
                
                if (slot < startHotBarSlot || PlayerInventoryConst.MainInventorySize <= slot) return;
                
                var viewData = ClientContext.ItemImageContainer.GetItemView(item.Id);
                slot -= startHotBarSlot;
                hotBarItems[slot].SetItem(viewData, item.Count);
            }
            
            int SelectedHotBar()
            {
                //キーボード入力で選択
                if (InputManager.UI.HotBar.ReadValue<int>() == 0) return -1;
                
                //キー入力で得られる値は1〜9なので-1する
                var selected = InputManager.UI.HotBar.ReadValue<int>() - 1;
                
                OnSelectHotBar?.Invoke(selected);
                return selected;
            }
            
            
            void UpdateHoldItem(int selectIndex)
            {
                if (_currentGrabItem != null) Destroy(_currentGrabItem.gameObject);
                
                var itemId = _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(selectIndex)].Id;
                
                if (itemId == ItemMaster.EmptyItemId) return;
                
                var itemObjectData = itemObjectContainer.GetItemPrefab(itemId);
                if (itemObjectData != null)
                {
                    _currentGrabItem = Instantiate(itemObjectData.ItemPrefab);
                    playerGrabItemManager.SetItem(_currentGrabItem, false, itemObjectData.Position, Quaternion.Euler(itemObjectData.Rotation));
                }
            }
            
            #endregion
        }
        
        public event Action<int> OnSelectHotBar;
        
        [Inject]
        public void Construct(ILocalPlayerInventory localPlayerInventory)
        {
            _localPlayerInventory = localPlayerInventory;
        }
        
        private void UpdateSelectedView(int prevIndex, int nextIndex)
        {
            hotBarItems[prevIndex].SetSelect(false);
            hotBarItems[nextIndex].SetSelect(true);
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPreviewObject.cs
```cs
using System.Linq;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Core.Master;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using UnityEngine.VFX;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPreviewObject : MonoBehaviour
    {
        public BlockMasterElement BlockMasterElement { get; private set; }
        
        public bool IsCollisionGround
        {
            get
            {
                foreach (var collisionDetector in _collisionDetectors)
                {
                    if (collisionDetector.IsCollision) return true;
                }
                return false;
            }
        }
        private GroundCollisionDetector[] _collisionDetectors;
        private RendererMaterialReplacerController _rendererMaterialReplacerController;
        
        public void Initialize(BlockId blockId)
        {
            BlockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            
            var placeMaterial = Resources.Load<Material>(MaterialConst.PreviewPlaceBlockMaterial);
            _rendererMaterialReplacerController = new RendererMaterialReplacerController(gameObject);
            _rendererMaterialReplacerController.CopyAndSetMaterial(placeMaterial);
            
            _collisionDetectors = GetComponentsInChildren<GroundCollisionDetector>(true);
            
            SetPlaceableColor(true);
            
            var visualEffects = GetComponentsInChildren<VisualEffect>(false);
            foreach (var visualEffect in visualEffects) visualEffect.gameObject.SetActive(false);
            
            // プレビュー限定オブジェクトをオンに
            // Turn on preview-only object
            var previewOnlyObjects = gameObject.GetComponentsInChildren<PreviewOnlyObject>(true).ToList();
            previewOnlyObjects.ForEach(obj =>
            {
                obj.Initialize();
                obj.SetActive(true);
            });
        }
        
        public void SetPlaceableColor(bool isPlaceable)
        {
            var color = isPlaceable ? MaterialConst.PlaceableColor : MaterialConst.NotPlaceableColor;
            _rendererMaterialReplacerController.SetColor(MaterialConst.PreviewColorPropertyName, color);
        }
        
        public void SetTriggerCollider(bool isTrigger)
        {
            var childrenColliders = GetComponentsInChildren<Collider>();
            foreach (var childrenCollider in childrenColliders) childrenCollider.isTrigger = isTrigger;
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        public void SetTransform(Vector3 pos, Quaternion rotation)
        {
            transform.position = pos;
            transform.rotation = rotation;
        }
        
        public void Destroy()
        {
            _rendererMaterialReplacerController.DestroyMaterial();
            Destroy(gameObject);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/DisconnectElectricPoleToFromElectricSegment.cs
```cs
using Game.Context;
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UniRx;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     電柱などのエネルギー伝達ブロックが破壊されたときに、セグメントを新しく作成するか、既存のセグメントから切り離すかを判断し、実行するクラス
    /// </summary>
    public class DisconnectElectricPoleToFromElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        private readonly EnergyServiceDependencyContainer<TSegment> _dependencyContainer;
        private readonly IWorldEnergySegmentDatastore<TSegment> _worldEnergySegmentDatastore;
        
        
        public DisconnectElectricPoleToFromElectricSegment(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore)
        {
            _worldEnergySegmentDatastore = worldEnergySegmentDatastore;
            
            _dependencyContainer = new EnergyServiceDependencyContainer<TSegment>(worldEnergySegmentDatastore);
            ServerContext.WorldBlockUpdateEvent.OnBlockRemoveEvent.Subscribe(OnBlockRemove);
        }
        
        private void OnBlockRemove(BlockUpdateProperties updateProperties)
        {
            var pos = updateProperties.Pos;
            
            //電柱かどうか判定
            //電柱だったら接続範囲内周りにある電柱を取得する
            if (!ServerContext.WorldBlockDatastore.TryGetBlock<TTransformer>(pos, out var removedElectricPole)) return;
            
            
            //接続範囲内の電柱を取得
            var electricPoleConfigParam = updateProperties.BlockData.Block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            var electricPoles = FindElectricPoleFromPeripheralService.Find(pos, electricPoleConfigParam);
            
            //削除した電柱のセグメントを取得
            var removedSegment = _worldEnergySegmentDatastore.GetEnergySegment(removedElectricPole);
            
            
            switch (electricPoles.Count)
            {
                //周りに電柱がないとき
                case 0:
                    //セグメントを削除する
                    _worldEnergySegmentDatastore.RemoveEnergySegment(removedSegment);
                    return;
                //周りの電柱が1つの時
                case 1:
                    DisconnectOneElectricPoleFromSegmentService<TSegment, TConsumer, TGenerator, TTransformer>
                        .Disconnect(removedElectricPole, _dependencyContainer);
                    return;
                //周りの電柱が2つ以上の時
                case >= 2:
                    DisconnectTwoOrMoreElectricPoleFromSegmentService<TSegment, TConsumer, TGenerator, TTransformer>
                        .Disconnect(removedElectricPole, _dependencyContainer);
                    break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Template/CraftChainerMainComputerTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Chest;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.CraftChainer.BlockComponent.Computer;
using Mooresmaster.Model.BlocksModule;

namespace Game.CraftChainer.BlockComponent.Template
{
    public class CraftChainerMainComputerTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var chest = blockMasterElement.BlockParam as CraftChainerMainComputerBlockParam;
            var connector = BlockTemplateUtil.CreateInventoryConnector(chest.InventoryConnectors, blockPositionInfo);
            var inserter = new CraftChainerMainComputerInserter();
            
            var chestComponent = componentStates == null ?
                new VanillaChestComponent(blockInstanceId, chest.ItemSlotCount, inserter) :
                new VanillaChestComponent(componentStates, blockInstanceId, chest.ItemSlotCount, inserter);
            
            var mainComputerComponent = componentStates == null ?
                new CraftChainerMainComputerComponent(connector) :
                new CraftChainerMainComputerComponent(componentStates, connector);
            
            
            var components = new List<IBlockComponent>
            {
                chestComponent,
                connector,
                mainComputerComponent
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Transporter/CraftChainerTransporterComponent.cs
```cs
using System.Collections.Generic;
using Game.CraftChainer.CraftNetwork;
using Newtonsoft.Json;

namespace Game.CraftChainer.BlockComponent
{
    public class CraftChainerTransporterComponent : ICraftChainerNode
    {
        public CraftChainerNodeId NodeId { get; } = CraftChainerNodeId.Create();
        
        public CraftChainerTransporterComponent() { }
        public CraftChainerTransporterComponent(Dictionary<string, string> componentStates) : this()
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerTransporterComponentJsonObject>(state);
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        
        public string SaveKey { get; } = typeof(CraftChainerTransporterComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerTransporterComponentJsonObject(this));
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
    
    public class ChainerTransporterComponentJsonObject 
    {
        [JsonProperty("nodeId")] public int NodeId { get; set; }
        
        public ChainerTransporterComponentJsonObject(){}
        public ChainerTransporterComponentJsonObject(CraftChainerTransporterComponent component)
        {
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/Implementation/ItemStack.cs
```cs
#nullable enable
using System;
using System.Collections.Generic;
using Core.Const;
using Core.Item.Interface;
using Core.Master;

namespace Core.Item.Implementation
{
    internal class ItemStack : IItemStack
    {
        public ItemId Id { get; }
        public int Count { get; }
        public ItemInstanceId ItemInstanceId { get; }
        private readonly Dictionary<string, ItemStackMetaData> _metaData;
        
        public ItemStack(ItemId id, int count, Dictionary<string, ItemStackMetaData> metaData)
        {
            if (id == ItemMaster.EmptyItemId) throw new ArgumentException("Item id cannot be null");
            if (count < 1) throw new ArgumentOutOfRangeException();
            
            var itemMaster = MasterHolder.ItemMaster.GetItemMaster(id);
            if (itemMaster.MaxStack < count)
                throw new ArgumentOutOfRangeException($"アイテムスタック数の最大値を超えています ID:{id} Count:{count} MaxStack:{itemMaster.MaxStack}");
            
            Id = id;
            Count = count;
            ItemInstanceId = ItemInstanceId.Create();
            _metaData = metaData;
        }
        
        public ItemStack(ItemId id, int count, ItemInstanceId instanceId, Dictionary<string, ItemStackMetaData> metaData) : this(id, count, metaData)
        {
            ItemInstanceId = instanceId;
        }
        
        public ItemProcessResult AddItem(IItemStack receiveItemStack)
        {
            var factory = InternalItemContext.ItemStackFactory;
            //加算するアイテムがnullならそのまま追加して返す
            if (receiveItemStack.GetType() == typeof(NullItemStack))
            {
                // インスタンスIDが同じだとベルトコンベアなどの輸送時に問題が生じるので、新しいインスタンスを生成する
                var newItem = factory.Create(Id, Count, _metaData);
                return new ItemProcessResult(newItem, factory.CreatEmpty());
            }
            
            // アイテムが同じでない場合は追加できない
            if (!Addable((ItemStack)receiveItemStack))
            {
                var newItem = factory.Create(Id, Count, _metaData);
                return new ItemProcessResult(newItem, receiveItemStack);
            }
            
            
            var newCount = ((ItemStack)receiveItemStack).Count + Count;
            var tmpStack = MasterHolder.ItemMaster.GetItemMaster(Id).MaxStack;
            
            //量が指定数より多かったらはみ出した分を返す
            if (tmpStack < newCount)
            {
                var tmpItem = factory.Create(Id, tmpStack, _metaData);
                var tmpReceive = factory.Create(Id, newCount - tmpStack, _metaData);
                
                return new ItemProcessResult(tmpItem, tmpReceive);
            }
            
            return new ItemProcessResult(factory.Create(Id, newCount), factory.CreatEmpty());
        }
        
        public IItemStack SubItem(int subCount)
        {
            var factory = InternalItemContext.ItemStackFactory;
            if (0 < Count - subCount) return factory.Create(Id, Count - subCount, _metaData);
            
            return factory.CreatEmpty();
        }
        
        public bool IsAllowedToAdd(IItemStack item)
        {
            var tmpStack = MasterHolder.ItemMaster.GetItemMaster(Id).MaxStack;
            
            return (Id == item.Id || item.Id == ItemMaster.EmptyItemId) &&
                   item.Count + Count <= tmpStack;
        }
        
        public bool IsAllowedToAddWithRemain(IItemStack item)
        {
            return Id == item.Id || item.Id == ItemMaster.EmptyItemId;
        }
        
        public ItemStackMetaData GetMeta(string key)
        {
            return _metaData.GetValueOrDefault(key);
        }
        
        public bool TryGetMeta(string key, out ItemStackMetaData value)
        {
            return _metaData.TryGetValue(key, out value);
        }
        
        public IItemStack SetMeta(string key, ItemStackMetaData value)
        {
            var copiedMeta = new Dictionary<string, ItemStackMetaData>(_metaData)
            {
                [key] = value,
            };
            return new ItemStack(Id, Count, copiedMeta);
        }
        
        private bool Addable(ItemStack target)
        {
            return Id == target.Id && CompareMeta(target);
        }
        
        public override bool Equals(object? obj)
        {
            if (typeof(ItemStack) != obj?.GetType()) return false;
            var other = (ItemStack)obj;
            
            return Id == other.Id &&
                   Count == other.Count &&
                   CompareMeta(other);
        }
        
        private bool CompareMeta(ItemStack other)
        {
            if (_metaData.Count != other._metaData.Count) return false;
            
            foreach (var (key, value) in _metaData)
            {
                if (!other._metaData.TryGetValue(key, out var otherValue)) return false;
                if (!value.Equals(otherValue)) return false;
            }
            foreach (var (key, value) in other._metaData)
            {
                if (!_metaData.TryGetValue(key, out var otherValue)) return false;
                if (!value.Equals(otherValue)) return false;
            }
            
            return true;
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(Id, Count, ItemInstanceId);
        }
        
        public override string ToString()
        {
            return $"ID:{Id} Count:{Count}";
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/SoundEffect/SoundEffectManager.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Client.Game.InGame.SoundEffect
{
    /// <summary>
    ///     TODO 仮のSE専用マネージャ 将来的な作り変えを意識しつつ、とりあえずこれで実装する
    /// </summary>
    public class SoundEffectManager : MonoBehaviour
    {
        [SerializeField] private AudioClip destroyBlockSound;
        [SerializeField] private AudioClip destroyStoneSound;
        [SerializeField] private AudioClip destroyTreeSound;
        [SerializeField] private AudioClip destroyBushSound;
        [SerializeField] private AudioClip placeBlockSound;
        
        [SerializeField] private AudioSource audioSource;
        
        private readonly Dictionary<SoundEffectType, AudioClip> _soundEffectTypeToAudioClip = new();
        
        /// <summary>
        ///     サウンド関係はstaticの方がべんりかな、、って思うけど、改善したほうがいいような気もする
        /// </summary>
        public static SoundEffectManager Instance { get; private set; }
        
        private void Awake()
        {
            _soundEffectTypeToAudioClip.Add(SoundEffectType.DestroyBlock, destroyBlockSound);
            _soundEffectTypeToAudioClip.Add(SoundEffectType.DestroyStone, destroyStoneSound);
            _soundEffectTypeToAudioClip.Add(SoundEffectType.DestroyTree, destroyTreeSound);
            _soundEffectTypeToAudioClip.Add(SoundEffectType.DestroyBush, destroyBushSound);
            _soundEffectTypeToAudioClip.Add(SoundEffectType.PlaceBlock, placeBlockSound);
            
            Instance = this;
        }
        
        public void PlaySoundEffect(SoundEffectType soundEffectType)
        {
            audioSource.PlayOneShot(_soundEffectTypeToAudioClip[soundEffectType]);
        }
    }
    
    public enum SoundEffectType
    {
        DestroyBlock,
        DestroyStone,
        DestroyTree,
        DestroyBush,
        PlaceBlock,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/CraftButton.cs
```cs
using System;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Util;
using UniRx;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    public class CraftButton : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler
    {
        [SerializeField] private RectTransform rectTransform;
        
        [SerializeField] private Image buttonImage;
        [SerializeField] private Color interactableColor = Color.white;
        [SerializeField] private Color nonInteractableColor = Color.gray;
        
        [SerializeField] private ProgressArrowView progressArrow;
        
        public IObservable<Unit> OnCraftFinish => _onCraftFinishSubject;
        private readonly Subject<Unit> _onCraftFinishSubject = new();
        
        private float _currentCraftTime;
        private float _buttonDownElapsed;
        private bool _isButtonDown;
        private bool _isCursorStay = true;
        private bool _isInteractable = true;
        
        private void Update()
        {
            if (_isButtonDown && _isCursorStay) _buttonDownElapsed += Time.deltaTime;
            
            if (_buttonDownElapsed >= _currentCraftTime)
            {
                _buttonDownElapsed = 0;
                _onCraftFinishSubject.OnNext(Unit.Default);
            }
            
            if (_isButtonDown)
            {
                var percent = Mathf.Clamp(_buttonDownElapsed, 0, _currentCraftTime) / _currentCraftTime;
                progressArrow.SetProgress(percent);
            }
            else
            {
                progressArrow.SetProgress(1);
            }
        }
        
        public void SetCraftTime(float craftTime)
        {
            _currentCraftTime = craftTime;
        }
        
        private void OnDestroy()
        {
            _onCraftFinishSubject.Dispose();
        }
        
        public void SetInteractable(bool interactable)
        {
            _isInteractable = interactable;
            buttonImage.color = interactable ? interactableColor : nonInteractableColor;
            
            if (!_isInteractable)
            {
                ResetButton();
            }
        }
        
        #region このフラグはあとで決定して消す
        
        [SerializeField] private bool resetElapsedTimeOnPointerExit;
        [SerializeField] private bool stopElapsedTimeUpdateOnPointerExit;
        [SerializeField] private bool restartElapsedTimeUpdateOnPointerEnter;
        
        #endregion
        
        
        public void OnPointerDown(PointerEventData eventData)
        {
            if (_isInteractable)
            {
                _isButtonDown = true;
            }
        }
        
        public void OnPointerUp(PointerEventData eventData)
        {
            if (_isInteractable)
            {
                _isButtonDown = false;
                _buttonDownElapsed = 0;
            }
        }
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            if (!_isInteractable)
            {
                MouseCursorExplainer.Instance.Show("アイテムが足りないためクラフトできません", isLocalize: false);
            }
            
            if (restartElapsedTimeUpdateOnPointerEnter) _isCursorStay = true;
        }
        
        public void OnPointerExit(PointerEventData eventData)
        {
            MouseCursorExplainer.Instance.Hide();
            if (resetElapsedTimeOnPointerExit) _buttonDownElapsed = 0;
            if (stopElapsedTimeUpdateOnPointerExit) _isCursorStay = false;
        }
        
        private void OnDisable()
        {
            ResetButton();
        }
        
        private void ResetButton()
        {
            MouseCursorExplainer.Instance.Hide();
            _buttonDownElapsed = 0;
            _isCursorStay = false;
            _isButtonDown = false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Editor/SchemaWatcher.cs
```cs
using UnityEditor;
using UnityEngine;
using System.IO;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using UnityEditor.Compilation;

[InitializeOnLoad]
public static class SchemaWatcher
{
    private static readonly string schemaFolderPath;
    private static readonly string cacheFilePath;
    private static Dictionary<string, string> cachedFileHashes = new Dictionary<string, string>();
    
    // Core.Masterフォルダのパスを指定
    private static readonly string coreMasterFolderPath;
    
    static SchemaWatcher()
    {
        // プロジェクトフォルダ/../schema のパスを取得
        schemaFolderPath = Path.GetFullPath(Path.Combine(Application.dataPath, "../../schema"));
        // キャッシュファイルのパスを設定（Libraryフォルダ内）
        cacheFilePath = Path.Combine(Application.dataPath, "../Library/SchemaCache.txt");
        // Core.Masterフォルダのパスを取得（Assets/Core.Master）
        coreMasterFolderPath = Path.GetFullPath(Path.Combine(Application.dataPath, "../../moorestech_server/Assets/Scripts/Core.Master"));
        
        LoadCache();
        
        // エディタの更新イベントに登録
        EditorApplication.update += Update;
        
        #region Internal
        
        // キャッシュの読み込み
        void LoadCache()
        {
            if (!File.Exists(cacheFilePath)) return;
            
            cachedFileHashes = new Dictionary<string, string>();
            var lines = File.ReadAllLines(cacheFilePath);
            foreach (var line in lines)
            {
                var split = line.Split('|');
                if (split.Length == 2)
                {
                    cachedFileHashes[split[0]] = split[1];
                }
            }
        }
        
  #endregion
    }
    
    private const float CheckInterval = 1f; // 1秒ごとにチェック
    private static float timer = 0f;
    private static void Update()
    {
        timer += Time.deltaTime;
        if (timer >= CheckInterval)
        {
            timer = 0f;
            CheckForChanges();
        }
    }
    
    // 変更のチェック
    [MenuItem("moorestech/Check Schema Changes")]
    public static void CheckForChanges()
    {
        var currentFileHashes = new Dictionary<string, string>();
        
        if (Directory.Exists(schemaFolderPath))
        {
            var files = Directory.GetFiles(schemaFolderPath, "*.*", SearchOption.AllDirectories);
            foreach (var file in files)
            {
                var relativePath = file.Substring(schemaFolderPath.Length + 1).Replace('\\', '/');
                var hash = ComputeHash(file);
                currentFileHashes[relativePath] = hash;
            }
        }
        else
        {
            Debug.LogWarning($"Schemaフォルダが見つかりません: {schemaFolderPath}");
            return;
        }
        
        bool hasChanged = HasFolderChanged(cachedFileHashes, currentFileHashes);
        
        if (hasChanged)
        {
            Debug.Log("Schemaフォルダに変更がありました。Core.Masterアセンブリを再コンパイルします。");
            
            // キャッシュを更新
            cachedFileHashes = currentFileHashes;
            SaveCache();
            
            // Core.Masterアセンブリを再コンパイルするためにDummy.csを更新
            UpdateDummyScript();
            CompilationPipeline.RequestScriptCompilation();
        }
        
        #region Internal
        
        // ファイルのハッシュ値を計算
        string ComputeHash(string filePath)
        {
            using var md5 = MD5.Create();
            
            var content = File.ReadAllBytes(filePath);
            var hash = md5.ComputeHash(content);
            return System.BitConverter.ToString(hash);
        }
        
        // キャッシュの保存
        void SaveCache()
        {
            var lines = new List<string>();
            foreach (var kvp in cachedFileHashes)
            {
                lines.Add($"{kvp.Key}|{kvp.Value}");
            }
            
            File.WriteAllLines(cacheFilePath, lines.ToArray());
        }
        
        // フォルダの変更を検出
        static bool HasFolderChanged(Dictionary<string, string> oldHashes, Dictionary<string, string> newHashes)
        {
            if (oldHashes.Count != newHashes.Count)
                return true;
            
            foreach (var kvp in newHashes)
            {
                if (!oldHashes.TryGetValue(kvp.Key, out string oldHash) || oldHash != kvp.Value)
                    return true;
            }
            
            return false;
        }
        
        // Dummy.csを更新してCore.Masterアセンブリを再コンパイル
        static void UpdateDummyScript()
        {
            // Core.Masterフォルダが存在するか確認
            if (!Directory.Exists(coreMasterFolderPath))
            {
                Debug.LogError($"Core.Masterフォルダが見つかりません: {coreMasterFolderPath}");
                return;
            }
            
            // Dummy.csのパスを指定
            string dummyFilePath = Path.Combine(coreMasterFolderPath, "Dummy.cs");
            
            // 現在の日付を取得
            string currentDateTime = System.DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss");
            
            // Dummy.csの内容を作成
            string dummyScriptContent = $@"
// このコードはCore.Masterアセンブリを再コンパイルするためのスクリプトです。gitignoreに設定しています。
// This code is a script to recompile the Core.Master assembly. It is set in gitignore.
public class Dummy
{{
    private const string dummyText = ""{currentDateTime}"";
}}";
            
            // Dummy.csに書き込む
            File.WriteAllText(dummyFilePath, dummyScriptContent);
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/PacketHandle/UserResponse.cs
```cs
using System;
using System.Net.Sockets;
using Server.Protocol;
using Server.Util;
using UnityEngine;

namespace Server.Boot.PacketHandle
{
    public class UserResponse
    {
        private readonly Socket _client;
        private readonly PacketResponseCreator _packetResponseCreator;
        private int _byteCount;
        
        private DateTime _startTime;
        
        public UserResponse(Socket client, PacketResponseCreator packetResponseCreator)
        {
            _packetResponseCreator = packetResponseCreator;
            _client = client;
        }
        
        
        public void StartListen()
        {
            _startTime = DateTime.Now;
            
            var buffer = new byte[4096];
            //切断されるまでパケットを受信
            try
            {
                var parser = new PacketBufferParser();
                while (true)
                {
                    var error = ReceiveProcess(parser, buffer);
                    if (error)
                    {
                        Debug.Log("切断されました");
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                _client.Close();
                Debug.LogError("moorestech内のロジックによるエラーで切断");
                Debug.LogException(e);
            }
        }
        
        
        private bool ReceiveProcess(PacketBufferParser parser, byte[] buffer)
        {
            var length = _client.Receive(buffer);
            if (length == 0) return true;
            
            //受信データをパケットに分割
            var packets = parser.Parse(buffer, length);
            
            foreach (var packet in packets)
            {
                var results = _packetResponseCreator.GetPacketResponse(packet);
                foreach (var result in results)
                {
                    result.InsertRange(0, ToByteList.Convert(result.Count));
                    var array = result.ToArray();
                    _byteCount += array.Length;
                    _client.Send(array);
                }
            }
            
            //LogDataConsumption(_byteCount, _startTime);
            
            return false;
        }
        
        public static void LogDataConsumption(int bytesSent, DateTime startTime)
        {
            // Convert bytes to Megabytes
            var megabytesSent = (double)bytesSent / 1024;
            
            // Calculate elapsed time in seconds
            var elapsedTimeSeconds = (DateTime.Now - startTime).TotalSeconds;
            
            // Calculate avg bandwidth in MB/s
            var avgBandwidth = megabytesSent / elapsedTimeSeconds;
            
            // Output the result
            Debug.Log($"送信量 {megabytesSent:F1} KB 平均消費帯域 {avgBandwidth:F1} KB/s 時間 {elapsedTimeSeconds}");
        }
    }
}
```

moorestech_server/Assets/Scripts/Mod.Base/ServerModEntryInterface.cs
```cs
using Microsoft.Extensions.DependencyInjection;
using Server.Protocol;

namespace Mod.Base
{
    public class ServerModEntryInterface
    {
        /// <summary>
        ///     パケットを送信することができるインスタンス
        /// </summary>
        public readonly PacketResponseCreator PacketResponseCreator;
        
        /// <summary>
        ///     各種サービスを取得できるDIコンテナ
        /// </summary>
        public readonly ServiceProvider ServiceProvider;
        
        public ServerModEntryInterface(ServiceProvider serviceProvider, PacketResponseCreator packetResponseCreator)
        {
            ServiceProvider = serviceProvider;
            PacketResponseCreator = packetResponseCreator;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/ItemProcessResult.cs
```cs
namespace Core.Item.Interface
{
    public class ItemProcessResult
    {
        public ItemProcessResult(IItemStack processResultItemStack, IItemStack remainderItemStack)
        {
            ProcessResultItemStack = processResultItemStack;
            RemainderItemStack = remainderItemStack;
        }
        
        /// <summary>
        ///     処理した結果余ったアイテムスタック
        /// </summary>
        public IItemStack RemainderItemStack { get; }
        
        /// <summary>
        ///     元のアイテムスタックに対する処理結果のアイテムスタック
        /// </summary>
        public IItemStack ProcessResultItemStack { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Template/CraftChainerCrafterTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.Service;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.CraftChainer.BlockComponent.Crafter;
using Mooresmaster.Model.BlocksModule;

namespace Game.CraftChainer.BlockComponent.Template
{
    public class CraftChainerCrafterTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var param = blockMasterElement.BlockParam as CraftChainerCrafterBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(param.InventoryConnectors, blockPositionInfo);
            var inserter = new CraftChainerCrafterInserter(inputConnectorComponent);
            
            var chestComponent = componentStates == null ? 
                new VanillaChestComponent(blockInstanceId, param.ItemSlotCount, inserter) : 
                new VanillaChestComponent(componentStates, blockInstanceId, param.ItemSlotCount, inserter);
            
            var chainerCrafter = componentStates == null ?
                new CraftCraftChainerCrafterComponent() :
                new CraftCraftChainerCrafterComponent(componentStates);
            
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
                chainerCrafter
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Const/xxHashConst.cs
```cs
namespace Core.Const
{
    /// <summary>
    ///     鉱石生成に使うxxHashの定数
    /// </summary>
    // ReSharper disable once InconsistentNaming
    public class xxHashConst
    {
        /// <summary>
        ///     取りえあずのシード値
        ///     TODO 将来的には何か一つのシード値から取得するようにするが、今はこのままで
        /// </summary>
        public const ulong DefaultSeed = 1235131;
        
        public const int DefaultSize = 64;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Map/MapObject/MapObjectGameObject.cs
```cs
using System;
using Core.Master;
using Mooresmaster.Model.MapObjectsModule;
using UniRx;
using UnityEditor;
using UnityEngine;

namespace Client.Game.InGame.Map.MapObject
{
    /// <summary>
    ///     MapObjectのGameObjectを表すクラス
    ///     TODO 今はUnity上に直接おいているので、今後はちゃんとサーバーからデータを受け取って生成するようにする
    /// </summary>
    public class MapObjectGameObject : MonoBehaviour
    {
        public int InstanceId => instanceId;
        public Guid MapObjectGuid => new(mapObjectGuid);
        public MapObjectMasterElement MapObjectMasterElement => MasterHolder.MapObjectMaster.GetMapObjectElement(MapObjectGuid);
        
        [SerializeField] private GameObject outlineObject;
        [SerializeField] private int instanceId;
        [SerializeField] private string mapObjectGuid;
        
        public bool IsDestroyed { get; private set; }
        
        public IObservable<Unit> OnDestroyMapObject => _onDestroyMapObject;
        private readonly Subject<Unit> _onDestroyMapObject = new();
        
        public void OutlineEnable(bool enable)
        {
            if (outlineObject != null)
            {
                outlineObject.SetActive(enable);
            }
        }
        
        public void DestroyMapObject()
        {
            IsDestroyed = true;
            //自分を含む全ての子のコライダーとレンダラーを無効化する
            foreach (var child in GetComponentsInChildren<Transform>())
            {
                var collider = child.GetComponent<Collider>();
                if (collider != null) collider.enabled = false;
                var renderer = child.GetComponent<Renderer>();
                if (renderer != null) renderer.enabled = false;
            }
            
            _onDestroyMapObject.OnNext(Unit.Default);
        }
        
        public Vector3 GetPosition()
        {
            return transform.position;
        }
        
#if UNITY_EDITOR
        public void SetMapObjectData(int instanceId)
        {
            Undo.RecordObject(this, "SetMapObjectData");
            
            this.instanceId = instanceId;
            
            //Dirtyフラグを立てる
            EditorUtility.SetDirty(this);
        }
        
#endif
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Common/SkitFireManager.cs
```cs
using Client.CutScene;
using Client.Game.Skit;
using Client.Game.Skit.Starter;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Playables;

namespace Client.Game.Common
{
    public class SkitFireManager : MonoBehaviour
    {
        [SerializeField] private PlayerSkitStarterDetector playerSkitStarterDetector;
        [SerializeField] private SkitManager skitManager;
        
        
        [SerializeField] private TimelinePlayer timelinePlayer; // TODO こういうのは全部やめてマスタで管理するようにしたい
        [SerializeField] private PlayableAsset trailerMovie;
        
        
        private void Update()
        {
            if (playerSkitStarterDetector.IsStartReady && UnityEngine.Input.GetKeyDown(KeyCode.F))
            {
                PlayCutscene().Forget();
            }
        }
        
        private async UniTask PlayStory() // TODo トレイラー対応のために仮でこのメソッドを使っていない
        {
            GameStateController.ChangeState(GameStateType.Skit);
            
            var csv = playerSkitStarterDetector.CurrentSkitStarterObject.ScenarioCsv;
            await skitManager.StartSkit(csv);
            
            GameStateController.ChangeState(GameStateType.InGame);
        }
        
        
        
        private async UniTask PlayCutscene()
        {
            GameStateController.ChangeState(GameStateType.CutScene);
            
            await timelinePlayer.Play(trailerMovie);
            
            GameStateController.ChangeState(GameStateType.InGame);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Event/IBlockOpenableInventoryUpdateEvent.cs
```cs
using System;
using Core.Item.Interface;

namespace Game.Block.Interface.Event
{
    /// <summary>
    ///     Subscribeだけができるイベントインタフェース
    ///     勝手にInvokeされないように定義している
    /// </summary>
    public interface IBlockOpenableInventoryUpdateEvent
    {
        public void Subscribe(Action<BlockOpenableInventoryUpdateEventProperties> blockInventoryEvent);
    }
    
    public class BlockOpenableInventoryUpdateEventProperties
    {
        public readonly BlockInstanceId BlockInstanceId;
        public readonly IItemStack ItemStack;
        public readonly int Slot;
        
        public BlockOpenableInventoryUpdateEventProperties(BlockInstanceId blockInstanceId, int slot, IItemStack itemStack)
        {
            ItemStack = itemStack;
            Slot = slot;
            BlockInstanceId = blockInstanceId;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIStateControl.cs
```cs
using System;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.UIState
{
    public class UIStateControl : MonoBehaviour
    {
        private UIStateDictionary _uiStateDictionary;
        public UIStateEnum CurrentState { get; private set; } = UIStateEnum.GameScreen;
        
        private void Start()
        {
            _uiStateDictionary.GetState(CurrentState).OnEnter(UIStateEnum.Current);
        }
        
        //UIステート
        private void Update()
        {
            //UIステートが変更されたら
            var state = _uiStateDictionary.GetState(CurrentState).GetNextUpdate();
            if (state == UIStateEnum.Current) return;
            
            var lastState = CurrentState;
            CurrentState = state;
            
            //現在のUIステートを終了し、次のステートを呼び出す
            _uiStateDictionary.GetState(lastState).OnExit();
            _uiStateDictionary.GetState(CurrentState).OnEnter(lastState);
            
            OnStateChanged?.Invoke(CurrentState);
        }
        
        public event Action<UIStateEnum> OnStateChanged;
        
        [Inject]
        public void Construct(UIStateDictionary uiStateDictionary)
        {
            _uiStateDictionary = uiStateDictionary;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/FindMachineAndGeneratorFromPeripheralService.cs
```cs
using System.Collections.Generic;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class FindMachineAndGeneratorFromPeripheralService
    {
        public static (List<IElectricConsumer>, List<IElectricGenerator>) Find(Vector3Int pos, ElectricPoleBlockParam poleConfigParam)
        {
            var blocks = new List<IElectricConsumer>();
            var generators = new List<IElectricGenerator>();
            var machineRange = poleConfigParam.MachineConnectionRange;
            
            var startMachineX = pos.x - machineRange / 2;
            var startMachineY = pos.y - machineRange / 2;
            for (var i = startMachineX; i < startMachineX + machineRange; i++)
            for (var j = startMachineY; j < startMachineY + machineRange; j++)
            {
                var machinePos = new Vector3Int(i, j);
                
                var worldBlockDatastore = ServerContext.WorldBlockDatastore;
                //範囲内に機械がある場合
                if (worldBlockDatastore.TryGetBlock<IElectricConsumer>(machinePos, out var consumer))
                    //機械を電力セグメントに追加
                    blocks.Add(consumer);
                
                //範囲内に発電機がある場合
                if (worldBlockDatastore.TryGetBlock<IElectricGenerator>(machinePos, out var generator))
                    //機械を電力セグメントに追加
                    generators.Add(generator);
            }
            
            return (blocks, generators);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/AssembleEntitySaveJsonTextTest.cs
```cs
using Game.Entity.Interface;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class AssembleEntitySaveJsonTextTest
    {
        [Test]
        public void EntitySaveTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var entitiesDatastore = serviceProvider.GetService<IEntitiesDatastore>();
            var entityFactory = serviceProvider.GetService<IEntityFactory>();
            
            
            //セーブ用のエンティ追加
            var entity1 = entityFactory.CreateEntity(VanillaEntityType.VanillaPlayer, new EntityInstanceId(10));
            var entityPosition = new Vector3(1, 2, 3);
            entity1.SetPosition(entityPosition);
            entitiesDatastore.Add(entity1);
            
            var entity2 = entityFactory.CreateEntity(VanillaEntityType.VanillaPlayer, new EntityInstanceId(30));
            var entityPosition2 = new Vector3(4, 5, 6);
            entity2.SetPosition(entityPosition2);
            entitiesDatastore.Add(entity2);
            
            
            //セーブの実行
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            
            //ロードの実行
            var (_, loadServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            (loadServiceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(json);
            
            
            //ロードしたエンティティを取得
            var loadedEntity1 = entitiesDatastore.Get(new EntityInstanceId(10));
            Assert.AreEqual(entity1.InstanceId, loadedEntity1.InstanceId);
            Assert.AreEqual(entityPosition, loadedEntity1.Position);
            Assert.AreEqual(entity1.EntityType, loadedEntity1.EntityType);
            
            var loadedEntity2 = entitiesDatastore.Get(new EntityInstanceId(30));
            Assert.AreEqual(entity2.InstanceId, loadedEntity2.InstanceId);
            Assert.AreEqual(entityPosition2, loadedEntity2.Position);
            Assert.AreEqual(entity2.EntityType, loadedEntity2.EntityType);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/BlockStateEventHandler.cs
```cs
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Network.API;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;
using VContainer.Unity;

namespace Client.Game.InGame.BlockSystem
{
    public class BlockStateEventHandler : IPostStartable
    {
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        private readonly InitialHandshakeResponse _initialHandshakeResponse;
        
        public BlockStateEventHandler(BlockGameObjectDataStore blockGameObjectDataStore, InitialHandshakeResponse initialHandshakeResponse)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            _initialHandshakeResponse = initialHandshakeResponse;
            
            ClientContext.VanillaApi.Event.SubscribeEventResponse(ChangeBlockStateEventPacket.EventTag,
                payload =>
                {
                    var data = MessagePackSerializer.Deserialize<BlockStateMessagePack>(payload);
                    ChangeState(data);
                });
        }
        
        public void PostStart()
        {
            foreach (var state in _initialHandshakeResponse.BlockStates) ChangeState(state);
        }
        
        private void ChangeState(BlockStateMessagePack state)
        {
            var pos = state.Position;
            if (!_blockGameObjectDataStore.BlockGameObjectDictionary.TryGetValue(pos, out var _))
            {
                Debug.Log("ブロックがない : " + pos);
            }
            else
            {
                var blockObject = _blockGameObjectDataStore.BlockGameObjectDictionary[pos];
                foreach (var processor in blockObject.BlockStateChangeProcessors)
                {
                    processor.OnChangeState(state);
                }
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ItemStackMetaTest.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Other
{
    public class ItemStackMetaTest
    {
        [Test]
        // メタデータの同一性の評価
        public void MetaDataEqualityTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemsStackFactory = ServerContext.ItemStackFactory;
            
            var meta = new Dictionary<string, ItemStackMetaData> { { "test1", new TestMeta1() } };
            
            var itemStack1 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            var itemStack2 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            
            Assert.IsTrue(itemStack1.Equals(itemStack2));
            
            meta.Add("test2", new TestMeta2());
            
            Assert.IsTrue(itemStack1.Equals(itemStack2));
            
            var itemStack3 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            
            Assert.IsFalse(itemStack1.Equals(itemStack3));
            Assert.IsFalse(itemStack2.Equals(itemStack3));
        }
        
        [Test]
        // Addできる、できないの評価
        public void AddTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemsStackFactory = ServerContext.ItemStackFactory;
            
            var meta = new Dictionary<string, ItemStackMetaData> { { "test1", new TestMeta1() } };
            
            var itemStack1 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            var itemStack2 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            
            var result = itemStack1.AddItem(itemStack2);
            Assert.AreEqual(result.ProcessResultItemStack.Count, 2);
            
            meta.Add("test2", new TestMeta2());
            
            var itemStack3 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            
            var result2 = itemStack1.AddItem(itemStack3);
            Assert.AreEqual(1, result2.ProcessResultItemStack.Count);
            Assert.AreEqual(1, result2.RemainderItemStack.Count);
        }
        
        [Test]
        // セーブ、ロードの評価
        public void SaveLoadTest()
        {
            //TODO セーブできるようにする
        }
        
        //TODO ベルトコンベアのメタ設定
    }
    
    public class TestMeta1 : ItemStackMetaData
    {
        public override bool Equals(ItemStackMetaData target)
        {
            return target is TestMeta1;
        }
    }
    
    public class TestMeta2 : ItemStackMetaData
    {
        public override bool Equals(ItemStackMetaData target)
        {
            return target is TestMeta2;
        }
    }
}
```

moorestech_server/Assets/Scripts/Mod.Loader/ModsResource.cs
```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using Game.Paths;
using Mod.Base;
using Newtonsoft.Json;
using UnityEngine;

namespace Mod.Loader
{
    public class ModsResource
    {
        private const string ModMetaFilePath = "modMeta.json";
        public readonly Dictionary<string, Mod> Mods;
        
        /// <summary>
        ///     Mod内に格納されているリソースをロードする
        ///     TODO これもコンストラクタに入れる
        /// </summary>
        public ModsResource(string modDirectory)
        {
            Mods = LoadModFromZip(modDirectory);
            foreach (var mod in LoadModFromFolder(modDirectory)) Mods.Add(mod.Key, mod.Value);
        }
        
        /// <summary>
        ///     Zipファイル形式のmodをロードする
        ///     Zipを展開して展開済みフォルダに入れ、そこからデータをロードする
        /// </summary>
        private static Dictionary<string, Mod> LoadModFromZip(string modDirectory)
        {
            var loadedMods = new Dictionary<string, Mod>();
            // zipファイルのmodをロードする
            foreach (var zipFile in Directory.GetFiles(modDirectory, "*.zip").ToList())
            {
                var zip = ZipFile.Open(zipFile, ZipArchiveMode.Read);
                var modMeta = JsonConvert.DeserializeObject<ModMetaJson>(LoadConfigFromZip(zip, ModMetaFilePath));
                
                if (modMeta == null)
                {
                    Debug.Log("Mod meta file not found in " + zipFile);
                    continue;
                }
                
                //extract zip
                var extractedDir = ExtractModZip(zipFile, modMeta);
                zip.Dispose();
                
                loadedMods.Add(modMeta.ModId, new Mod(modMeta, extractedDir));
            }
            
            return loadedMods;
        }
        
        /// <summary>
        ///     フォルダーのmodをロードする
        /// </summary>
        private static Dictionary<string, Mod> LoadModFromFolder(string modDirectory)
        {
            var loadedMods = new Dictionary<string, Mod>();
            // 通常のディレクトリのmodをロードする
            foreach (var modDir in Directory.GetDirectories(modDirectory))
            {
                //mod metaファイルがあるかどうかをチェック
                var modMetaFile = Path.Combine(modDir, ModMetaFilePath);
                if (!File.Exists(modMetaFile))
                {
                    //TODO ログ基盤に入れる
                    Debug.Log("Mod meta file not found in " + modDir);
                    continue;
                }
                
                var modMeta = JsonConvert.DeserializeObject<ModMetaJson>(File.ReadAllText(modMetaFile));
                
                loadedMods.Add(modMeta.ModId, new Mod(modMeta, modDir));
            }
            
            return loadedMods;
        }
        
        /// <summary>
        ///     Zipを展開せず中身のコンフィグファイルを読み込む
        /// </summary>
        /// <param name="zip">Zipファイル</param>
        /// <param name="configPath">Zipファイル内のコンフィグのパス</param>
        /// <returns>ロードされたJSONのデータ</returns>
        private static string LoadConfigFromZip(ZipArchive zip, string configPath)
        {
            var config = zip.GetEntry(configPath);
            if (config == null) return string.Empty;
            
            using var itemJsonStream = config.Open();
            using var itemJsonString = new StreamReader(itemJsonStream);
            return itemJsonString.ReadToEnd();
        }
        
        /// <summary>
        ///     Zipフォルダを展開し、指定されたフォルダにデータを移す
        /// </summary>
        /// <returns>展開後のmodのパス</returns>
        private static string ExtractModZip(string zipPath, ModMetaJson modMetaJson)
        {
            var fixModId = modMetaJson.ModId.ReplaceFileNotAvailableCharacter("-");
            var fixModVersion = modMetaJson.ModVersion.ReplaceFileNotAvailableCharacter("-");
            var sha1Hash = CalcFileHash.GetSha1Hash(zipPath);
            
            var folderName = $"{fixModId}_ver_{fixModVersion}_sha1_{sha1Hash}";
            
            var path = GameSystemPaths.GetExtractedModDirectory(folderName);
            // 既に解凍済みかチェック
            if (Directory.Exists(path)) return path;
            
            //解凍を実行
            ZipFile.ExtractToDirectory(zipPath, path, true);
            return path;
        }
    }
    
    public class Mod
    {
        public readonly string ExtractedPath;
        
        public readonly List<MoorestechServerModEntryPoint> ModEntryPoints;
        
        public readonly ModMetaJson ModMetaJson;
        
        public Mod(ModMetaJson modMetaJson, string extractedPath)
        {
            ModMetaJson = modMetaJson;
            ExtractedPath = extractedPath;
            ModEntryPoints = LoadEntryPoints(extractedPath);
        }
        
        private static List<MoorestechServerModEntryPoint> LoadEntryPoints(string modDirectory)
        {
            var entryPoints = new List<MoorestechServerModEntryPoint>();
            
            try
            {
                //modディレクトリの全てディレクトリでdllを全てロードし、ModBaseを継承しているクラスを探す
                foreach (var dllPath in Directory.GetFiles(modDirectory, "*.dll", SearchOption.AllDirectories))
                {
                    var assembly = Assembly.LoadFrom(dllPath);
                    var modBaseTypes = assembly.GetTypes()
                        .Where(t => t.IsSubclassOf(typeof(MoorestechServerModEntryPoint)));
                    foreach (var modBaseType in modBaseTypes)
                    {
                        var modBase = (MoorestechServerModEntryPoint)Activator.CreateInstance(modBaseType);
                        entryPoints.Add(modBase);
                    }
                }
            }
            catch (ReflectionTypeLoadException)
            {
                //クライアント側でエラーが出るので、ここでキャッチしておく
            }
            
            return entryPoints;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/FindElectricPoleFromPeripheralService.cs
```cs
using System.Collections.Generic;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class FindElectricPoleFromPeripheralService
    {
        /// <summary>
        ///     周辺ブロックから電柱を探索します
        ///     ただし、自身の電柱は含みません
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="electricPoleConfigParam"></param>
        /// <returns></returns>
        public static List<IElectricTransformer> Find(Vector3Int pos, ElectricPoleBlockParam electricPoleConfigParam)
        {
            var electricPoles = new List<IElectricTransformer>();
            //for文のための設定
            var poleRange = electricPoleConfigParam.PoleConnectionRange;
            var blockDatastore = ServerContext.WorldBlockDatastore;
            blockDatastore.GetBlock(pos);
            var startElectricX = pos.x - poleRange / 2;
            var startElectricY = pos.y - poleRange / 2;
            
            //実際の探索
            for (var i = startElectricX; i < startElectricX + poleRange; i++)
            for (var j = startElectricY; j < startElectricY + poleRange; j++)
            {
                //範囲内に電柱がある場合 ただし自身のブロックは除く
                var electricPolePos = new Vector3Int(i, j);
                if (!blockDatastore.ExistsComponent<IElectricTransformer>(electricPolePos) || i == pos.x && j == pos.y) continue;
                
                //電柱を追加
                electricPoles.Add(blockDatastore.GetBlock<IElectricTransformer>(electricPolePos));
            }
            
            return electricPoles;
        }
    }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/modMeta.json
```cs
{
    "id":"moorestechAlphaMod",
    "name":"moorestech Alpha Mod",
    "version":"1.0",
    "author":"sakastudio",
    "description":"moorestechのAlpha版限定で利用するmodです。将来的にこれは使わなくなります。"
}
```

moorestech_server/Assets/Scripts/Tests.Module/DummyBlockInventory.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Const;
using Core.Item.Interface;
using Core.Item.Util;
using Core.Master;
using Game.Block.Interface.Component;

namespace Tests.Module
{
    public class DummyBlockInventory : IBlockInventory
    {
        private readonly List<IItemStack> _insertedItems;
        
        private int _endInsertCnt;
        
        public DummyBlockInventory(int insertToEndNum = 1, int maxSlot = 100)
        {
            IsItemExists = false;
            InsertToEndNum = insertToEndNum;
            _endInsertCnt = 0;
            _insertedItems = CreateEmptyItemStacksList.Create(maxSlot).ToList();
        }
        
        public bool IsItemExists { get; private set; }
        
        public List<IItemStack> InsertedItems
        {
            get
            {
                var a = _insertedItems.Where(i => i.Id != ItemMaster.EmptyItemId).ToList();
                a.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
                return a.ToList();
            }
        }
        
        private int InsertToEndNum { get; }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            for (var i = 0; i < _insertedItems.Count; i++)
            {
                if (!_insertedItems[i].IsAllowedToAdd(itemStack)) continue;
                var r = _insertedItems[i].AddItem(itemStack);
                _insertedItems[i] = r.ProcessResultItemStack;
                _endInsertCnt++;
                IsItemExists = InsertToEndNum <= _endInsertCnt;
                
                return r.RemainderItemStack;
            }
            
            return itemStack;
        }
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return true;
        }
        
        public IItemStack GetItem(int slot)
        {
            return _insertedItems[slot];
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _insertedItems[slot] = itemStack;
        }
        
        public int GetSlotSize()
        {
            return _insertedItems.Count;
        }
        
        public bool IsDestroy => false;
        
        public void Destroy()
        {
        }
        
        public void AddOutputConnector(IBlockInventory blockInventory)
        {
        }
        
        public void RemoveOutputConnector(IBlockInventory blockInventory)
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World/DataStore/WorldSettings/WorldSettingsDatastore.cs
```cs
using Game.World.Interface.DataStore;
using UnityEngine;

namespace Game.World.DataStore.WorldSettings
{
    /// <summary>
    ///     ワールドの基本的な設定を保持します
    ///     TODO ロード、セーブに対応させる
    /// </summary>
    public class WorldSettingsDatastore : IWorldSettingsDatastore
    {
        public Vector3Int WorldSpawnPoint { get; private set; }
        
        public void Initialize()
        {
            WorldSpawnPoint = Vector3Int.zero;
        }
        
        public WorldSettingJsonObject GetSaveJsonObject()
        {
            return new WorldSettingJsonObject(WorldSpawnPoint);
        }
        
        public void LoadSettingData(WorldSettingJsonObject worldSettingJsonObject)
        {
            WorldSpawnPoint = new Vector3Int(worldSettingJsonObject.SpawnX, worldSettingJsonObject.SpawnY);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/challenge.json
```cs
{
  "challenges": [
    {
      "id": 1000,
      "prevId": -1,
      "taskCompletionType": "createItem",
      "taskParam": {
        "itemModId": "Test Author:forUniTest",
        "itemName": "Test3"
      },
      "summary": "テスト1",
      "playSkitType": "None",
      "playSkitParam": {}
    },
    {
      "id": 1010,
      "prevId": -1,
      "taskCompletionType": "inInventoryItem",
      "taskParam": {
        "itemModId": "Test Author:forUniTest",
        "itemName": "Test1",
        "itemCount": 3
      },
      "summary": "テスト2",
      "playSkitType": "None",
      "playSkitParam": {}
    },
    {
      "id": 1020,
      "prevId": -1,
      "taskCompletionType": "blockPlace",
      "taskParam": {
        "blockModId": "Test Author:forUniTest",
        "blockName": "TestElectricMachine"
      },
      "summary": "テスト2",
      "playSkitType": "None",
      "playSkitParam": {}
    },
    {
      "id": 1030,
      "prevId": 1000,
      "taskCompletionType": "inInventoryItem",
      "taskParam": {
        "itemModId": "Test Author:forUniTest",
        "itemName": "Test3",
        "itemCount": 3
      },
      "summary": "テスト1をクリアしたら始まるチャレンジ",
      "playSkitType": "None",
      "playSkitParam": {}
    }
  ]
}
```

moorestech_client/Assets/Scripts/Client.Network/ServerCommunicator.cs
```cs
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;
using Client.Network.API;
using Client.Network.Settings;
using Cysharp.Threading.Tasks;
using MessagePack;
using Server.Util;
using UniRx;
using UnityEngine;

namespace Client.Network
{
    /// <summary>
    ///     C#の<see cref="Socket" />クラスを用いて実際にサーバーと通信するクラス
    ///     受信他データは<see cref="PacketExchangeManager" />に送っている
    /// </summary>
    public class ServerCommunicator
    {
        private readonly IPAddress _ipAddress;
        private readonly Subject<Unit> _onDisconnect = new();
        
        private readonly Socket _socket;
        
        private ServerCommunicator(Socket connectedSocket)
        {
            //ソケットを作成
            _socket = connectedSocket;
        }
        
        public IObservable<Unit> OnDisconnect => _onDisconnect;
        
        public static async UniTask<ServerCommunicator> CreateConnectedInstance(ConnectionServerConfig connectionServerConfig)
        {
            //IPアドレスやポートを設定
            if (!IPAddress.TryParse(connectionServerConfig.IP, out var ipAddress)) throw new ArgumentException("IP解析失敗");
            
            var socket = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            
            //接続を行う
            socket.Connect(ipAddress, connectionServerConfig.Port);
            
            // 接続に10秒かかったらエラーを出す
            await UniTask.WaitUntil(() => socket.Connected).Timeout(TimeSpan.FromSeconds(10));
            
            Debug.Log("サーバーに接続しました");
            
            return new ServerCommunicator(socket);
        }
        
        
        public Task StartCommunicat(PacketExchangeManager packetExchangeManager)
        {
            var buffer = new byte[4096];
            
            var parser = new PacketBufferParser();
            try
            {
                while (true)
                {
                    //Receiveで受信
                    var length = _socket.Receive(buffer);
                    if (length == 0)
                    {
                        Debug.LogError("ストリームがゼロによる切断");
                        break;
                    }
                    
                    //解析をしてunity viewに送る
                    var packets = parser.Parse(buffer, length);
                    foreach (var packet in packets) packetExchangeManager.ExchangeReceivedPacket(packet).Forget();
                }
            }
            catch (Exception e)
            {
                Debug.LogError("エラーによりサーバーから切断されました");
                Debug.LogError($"Message {e.Message} StackTrace {e.StackTrace}");
                if (_socket.Connected) _socket.Close();
                
                try
                {
                    var json = MessagePackSerializer.ConvertToJson(buffer);
                    Debug.LogError("受信パケット内容 JSON:" + json);
                }
                catch (Exception exception)
                {
                    Debug.LogError("受信パケット内容 JSON:解析に失敗");
                }
                
                throw;
            }
            finally
            {
                Debug.Log("通信ループ終了");
                InvokeDisconnect().Forget();
            }
            
            return Task.CompletedTask;
        }
        
        private async UniTask InvokeDisconnect()
        {
            await UniTask.SwitchToMainThread();
            _onDisconnect.OnNext(Unit.Default);
        }
        
        public void Send(byte[] data)
        {
            //先頭にパケット長を設定して送信
            var byteCount = ToByteList.Convert(data.Length);
            var newData = new byte[byteCount.Count + data.Length];
            
            byteCount.CopyTo(newData, 0);
            data.CopyTo(newData, byteCount.Count);
            
            _socket.Send(newData);
        }
        
        public void Close()
        {
            _socket.Close();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetCraftChainerCrafterRecipeProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SetCraftChainerCrafterRecipeProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:setChainerRecipe";
        
        public SetCraftChainerCrafterRecipeProtocol(ServiceProvider serviceProvider) { }
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SetCraftChainerCrafterRecipeProtocolMessagePack>(payload.ToArray());
            
            var blockPos = data.BlockPos.Vector3Int;
            
            var crafterBlock = ServerContext.WorldBlockDatastore.GetBlock(blockPos);
            if (crafterBlock == null) return null;
            
            var chainerCrafter = crafterBlock.ComponentManager.GetComponent<CraftCraftChainerCrafterComponent>();
            
            var inputs = data.GetInputs();
            var outputs = data.GetOutputs();
            chainerCrafter.SetRecipe(inputs, outputs);
            
            return null;
        }
        
        [MessagePackObject]
        public class SetCraftChainerCrafterRecipeProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            [Key(3)] public List<CraftingSolverItemJsonObjectMessagePack> Inputs { get; set; }
            [Key(4)] public List<CraftingSolverItemJsonObjectMessagePack> Outputs { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public SetCraftChainerCrafterRecipeProtocolMessagePack() { }
            
            public SetCraftChainerCrafterRecipeProtocolMessagePack(Vector3Int blockPos, List<CraftingSolverItem> inputs, List<CraftingSolverItem> outputs)
            {
                Tag = ProtocolTag;
                BlockPos = new Vector3IntMessagePack(blockPos);
                Inputs = inputs.Select(item => new CraftingSolverItemJsonObjectMessagePack(item)).ToList();
                Outputs = outputs.Select(item => new CraftingSolverItemJsonObjectMessagePack(item)).ToList();
            }
            
            public List<CraftingSolverItem> GetInputs()
            {
                return Inputs.Select(item => item.ToCraftingSolverItem()).ToList();
            }
            public List<CraftingSolverItem> GetOutputs()
            {
                return Outputs.Select(item => item.ToCraftingSolverItem()).ToList();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaMachineTemplate.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaMachineTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdateEvent;
        
        public VanillaMachineTemplate(BlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            _blockInventoryUpdateEvent = blockInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var machineParam = blockMasterElement.BlockParam as ElectricMachineBlockParam;
            
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(machineParam.InventoryConnectors, blockPositionInfo);
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            var (input, output) = BlockTemplateUtil.GetMachineIOInventory(blockId, blockInstanceId, machineParam, inputConnectorComponent, _blockInventoryUpdateEvent);

            var processor = new VanillaMachineProcessorComponent(input, output, null, new ElectricPower(machineParam.RequiredPower));
            
            var blockInventory = new VanillaMachineBlockInventoryComponent(input, output);
            var machineSave = new VanillaMachineSaveComponent(input, output, processor);
            var machineComponent = new VanillaElectricMachineComponent(blockInstanceId, processor);
            
            var components = new List<IBlockComponent>
            {
                blockInventory,
                machineSave,
                processor,
                machineComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var machineParam = blockMasterElement.BlockParam as ElectricMachineBlockParam;
            
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(machineParam.InventoryConnectors, blockPositionInfo);
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            var (input, output) = BlockTemplateUtil.GetMachineIOInventory(blockId, blockInstanceId, machineParam, inputConnectorComponent, _blockInventoryUpdateEvent);
            
            var processor = BlockTemplateUtil.MachineLoadState(componentStates, input, output, new ElectricPower(machineParam.RequiredPower));
            
            var blockInventory = new VanillaMachineBlockInventoryComponent(input, output);
            var machineSave = new VanillaMachineSaveComponent(input, output, processor);
            var machineComponent = new VanillaElectricMachineComponent(blockInstanceId, processor);
            
            var components = new List<IBlockComponent>
            {
                blockInventory,
                machineSave,
                processor,
                machineComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/IBlock.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface.State;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Interface
{
    public interface IBlock : IEquatable<IBlock>
    {
        public BlockInstanceId BlockInstanceId { get; }
        public BlockId BlockId { get; }
        public Guid BlockGuid { get; }
        public BlockMasterElement BlockMasterElement { get; }
        public IBlockComponentManager ComponentManager { get; }
        public BlockPositionInfo BlockPositionInfo { get; }
        
        /// <summary>
        ///     ブロックで何らかのステートが変化したときに呼び出されます
        ///     例えば、動いている機械が止まったなど
        ///     クライアント側で稼働アニメーションや稼働音を実行するときに使用します
        /// </summary>
        public IObservable<BlockState> BlockStateChange { get; }
        
        public BlockState GetBlockState();
        
        public Dictionary<string,string> GetSaveState();
        
        public void Destroy();
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Entity/EntityObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Network.API;
using Core.Master;
using Game.Entity.Interface;
using UnityEngine;

namespace Client.Game.InGame.Entity
{
    public class EntityObjectDatastore : MonoBehaviour
    {
        [SerializeField] private ItemEntityObject itemPrefab;
        
        private readonly Dictionary<long, (DateTime lastUpdate, IEntityObject objectEntity)> _entities = new();
        
        /// <summary>
        ///     エンティティ最終更新時間をチェックし、一定時間経過していたら削除する
        /// </summary>
        private void Update()
        {
            //1秒以上経過していたら削除
            var removeEntities = new List<long>();
            foreach (var entity in _entities)
                if ((DateTime.Now - entity.Value.lastUpdate).TotalSeconds > 1)
                    removeEntities.Add(entity.Key);
            foreach (var removeEntity in removeEntities)
            {
                _entities[removeEntity].objectEntity.Destroy();
                _entities.Remove(removeEntity);
            }
        }
        
        /// <summary>
        ///     エンティティの生成、更新を行う
        /// </summary>
        public void OnEntitiesUpdate(List<EntityResponse> entities)
        {
            foreach (var entity in entities)
                if (_entities.ContainsKey(entity.InstanceId))
                {
                    _entities[entity.InstanceId].objectEntity.SetInterpolationPosition(entity.Position);
                    _entities[entity.InstanceId] = (DateTime.Now, _entities[entity.InstanceId].objectEntity);
                }
                else
                {
                    var entityObject = CreateEntity(entity);
                    _entities.Add(entity.InstanceId, (DateTime.Now, entityObject));
                }
        }
        
        /// <summary>
        ///     タイプに応じたエンティティの作成
        /// </summary>
        private IEntityObject CreateEntity(EntityResponse entity)
        {
            if (entity.Type == VanillaEntityType.VanillaItem)
            {
                var item = Instantiate(itemPrefab, entity.Position, Quaternion.identity, transform);
                
                var id = new ItemId(int.Parse(entity.State.Split(',')[0]));
                var viewData = ClientContext.ItemImageContainer.GetItemView(id);
                Texture texture = null;
                if (viewData == null)
                {
                    Debug.LogError("ItemTexture Not Found  ItemId:" + id);
                }
                else
                {
                    texture = viewData.ItemTexture;
                }
                item.SetTexture(texture);
                return item;
            }
            
            throw new ArgumentException("エンティティタイプがありません");
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/InventoryItemMoveProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Inventory;
using Game.Block.Interface.Component;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using Server.Protocol.PacketResponse.Util.InventoryService;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     インベントリでマウスを使ってアイテムの移動を操作するプロトコルです
    /// </summary>
    public class InventoryItemMoveProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:invItemMove";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public InventoryItemMoveProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<InventoryItemMoveProtocolMessagePack>(payload.ToArray());
            
            var fromInventory = GetInventory(data.FromInventory.InventoryType, data.PlayerId, data.FromInventory.Pos);
            if (fromInventory == null) return null;
            
            var fromSlot = data.FromInventory.Slot;
            if (data.FromInventory.InventoryType == ItemMoveInventoryType.BlockInventory)
                fromSlot -= PlayerInventoryConst.MainInventorySize;
            
            
            var toInventory = GetInventory(data.ToInventory.InventoryType, data.PlayerId, data.ToInventory.Pos);
            if (toInventory == null) return null;
            
            var toSlot = data.ToInventory.Slot;
            if (data.ToInventory.InventoryType == ItemMoveInventoryType.BlockInventory)
                toSlot -= PlayerInventoryConst.MainInventorySize;
            
            
            switch (data.ItemMoveType)
            {
                case ItemMoveType.SwapSlot:
                    InventoryItemMoveService.Move(fromInventory, fromSlot, toInventory, toSlot, data.Count);
                    break;
                case ItemMoveType.InsertSlot:
                    InventoryItemInsertService.Insert(fromInventory, fromSlot, toInventory, data.Count);
                    break;
            }
            
            return null;
        }
        
        private IOpenableInventory GetInventory(ItemMoveInventoryType inventoryType, int playerId, Vector3Int pos)
        {
            IOpenableInventory inventory = null;
            switch (inventoryType)
            {
                case ItemMoveInventoryType.MainInventory:
                    inventory = _playerInventoryDataStore.GetInventoryData(playerId).MainOpenableInventory;
                    break;
                case ItemMoveInventoryType.GrabInventory:
                    inventory = _playerInventoryDataStore.GetInventoryData(playerId).GrabInventory;
                    break;
                case ItemMoveInventoryType.BlockInventory:
                    inventory = ServerContext.WorldBlockDatastore.ExistsComponent<IOpenableBlockInventoryComponent>(pos)
                        ? ServerContext.WorldBlockDatastore.GetBlock<IOpenableBlockInventoryComponent>(pos)
                        : null;
                    break;
            }
            
            return inventory;
        }
        
        [MessagePackObject]
        public class InventoryItemMoveProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public int Count { get; set; }
            [Key(4)] public int ItemMoveTypeId { get; set; }
            [IgnoreMember] public ItemMoveType ItemMoveType => (ItemMoveType)ItemMoveTypeId;
            [Key(5)] public ItemMoveInventoryInfoMessagePack FromInventory { get; set; }
            [Key(6)] public ItemMoveInventoryInfoMessagePack ToInventory { get; set; }
            
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public InventoryItemMoveProtocolMessagePack() { }
            public InventoryItemMoveProtocolMessagePack(int playerId, int count, ItemMoveType itemMoveType,
                ItemMoveInventoryInfo inventory, int fromSlot,
                ItemMoveInventoryInfo toInventory, int toSlot)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Count = count;
                
                ItemMoveTypeId = (int)itemMoveType;
                FromInventory = new ItemMoveInventoryInfoMessagePack(inventory, fromSlot);
                ToInventory = new ItemMoveInventoryInfoMessagePack(toInventory, toSlot);
            }
        }
        
        [MessagePackObject]
        public class ItemMoveInventoryInfoMessagePack
        {
            [Obsolete("シリアライズ用の値です。InventoryTypeを使用してください。")]
            [Key(2)] public int InventoryId { get; set; }
            
            [IgnoreMember] public ItemMoveInventoryType InventoryType => (ItemMoveInventoryType)Enum.ToObject(typeof(ItemMoveInventoryType), InventoryId);
            
            [Key(3)] public int Slot { get; set; }
            
            [Key(4)] public Vector3IntMessagePack Pos { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public ItemMoveInventoryInfoMessagePack() { }
            public ItemMoveInventoryInfoMessagePack(ItemMoveInventoryInfo info, int slot)
            {
                //メッセージパックでenumは重いらしいのでintを使う
                InventoryId = (int)info.ItemMoveInventoryType;
                Slot = slot;
                Pos = new Vector3IntMessagePack(info.Pos);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/BlockInventoryOpenCloseProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class BlockInventoryOpenCloseProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:blockInvOpen";
        private readonly IBlockInventoryOpenStateDataStore _inventoryOpenState;
        
        public BlockInventoryOpenCloseProtocol(ServiceProvider serviceProvider)
        {
            _inventoryOpenState = serviceProvider.GetService<IBlockInventoryOpenStateDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<BlockInventoryOpenCloseProtocolMessagePack>(payload.ToArray());
            
            //開く、閉じるのセット
            if (data.IsOpen)
                _inventoryOpenState.Open(data.PlayerId, data.Pos);
            else
                _inventoryOpenState.Close(data.PlayerId);
            
            return null;
        }
        
        
        [MessagePackObject]
        public class BlockInventoryOpenCloseProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Key(3)] public Vector3IntMessagePack Pos { get; set; }
            
            [Key(4)] public bool IsOpen { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public BlockInventoryOpenCloseProtocolMessagePack() { }
            /// <summary>
            ///     TODO このプロトコル消していいのでは（どうせステートの変化を送るなら、それと一緒にインベントリの情報を送った方が設計的に楽なのでは？
            /// </summary>
            /// <param name="playerId"></param>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="isOpen"></param>
            public BlockInventoryOpenCloseProtocolMessagePack(int playerId, Vector3Int pos, bool isOpen)
            {
                Tag = ProtocolTag;
                Pos = new Vector3IntMessagePack(pos);
                PlayerId = playerId;
                IsOpen = isOpen;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockShaderAnimation.cs
```cs
using System;
using Client.Common;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class BlockShaderAnimation : MonoBehaviour
    {
        private const string WorldMinY = "_WorldMinY";
        private const string WorldMaxY = "_WorldMaxY";
        private const string DevolveRate = "_DevolveRate";
        private const string LightPower = "_LightPower";
        
        private RendererMaterialReplacerController _rendererMaterialReplacerController;
        
        public async UniTask PlaceAnimation()
        {
            _rendererMaterialReplacerController ??= new RendererMaterialReplacerController(gameObject);
            
            //マテリアルを更新
            var placeAnimationMaterial = Resources.Load<Material>(MaterialConst.PlaceBlockAnimationMaterial);
            _rendererMaterialReplacerController.CopyAndSetMaterial(placeAnimationMaterial);
            
            //マテリアルにセット
            var (worldMinY, worldMaxY) = GetWorldMinMaxY();
            SetMaterialProperty(WorldMinY, worldMinY);
            SetMaterialProperty(WorldMaxY, worldMaxY);
            SetMaterialProperty(DevolveRate, 0);
            SetMaterialProperty(LightPower, 0.6f);
            
            //接地されているアニメーション
            TweenMaterialProperty(DevolveRate, 0, 1, 2.5f, Ease.InOutSine);
            TweenMaterialProperty(LightPower, 0.6f, 1, 2.0f, Ease.InOutSine);
            
            await UniTask.Delay(2000);
            
            //最後のフラッシュ
            SetMaterialProperty(LightPower, 1);
            TweenMaterialProperty(LightPower, 1, 2, 0.4f, Ease.InOutSine);
            await UniTask.Delay(200);
            
            TweenMaterialProperty(LightPower, 2, 0.5f, 0.2f, Ease.InOutSine);
            await UniTask.Delay(200);
            
            //マテリアルをリセット
            _rendererMaterialReplacerController.ResetMaterial();
        }
        
        public async UniTask RemoveAnimation()
        {
            _rendererMaterialReplacerController ??= new RendererMaterialReplacerController(gameObject);
            
            //マテリアルを更新
            var placeAnimationMaterial = Resources.Load<Material>(MaterialConst.PlaceBlockAnimationMaterial);
            _rendererMaterialReplacerController.CopyAndSetMaterial(placeAnimationMaterial);
            
            //マテリアルにセット
            var (worldMinY, worldMaxY) = GetWorldMinMaxY();
            SetMaterialProperty(WorldMinY, worldMinY);
            SetMaterialProperty(WorldMaxY, worldMaxY);
            SetMaterialProperty(DevolveRate, 1);
            SetMaterialProperty(LightPower, 0);
            
            //アニメーションを実行
            TweenMaterialProperty(LightPower, 0, 1, 0.5f, Ease.InOutSine);
            
            await UniTask.Delay(250);
            
            TweenMaterialProperty(DevolveRate, 1, 0, 0.55f, Ease.InOutSine);
            
            await UniTask.Delay(500);
        }
        
        private (float worldMinY, float worldMaxY) GetWorldMinMaxY()
        {
            var worldMinY = float.MaxValue;
            var worldMaxY = float.MinValue;
            foreach (var renderer in GetComponentsInChildren<Renderer>())
            {
                worldMinY = Mathf.Min(worldMinY, renderer.bounds.min.y);
                worldMaxY = Mathf.Max(worldMaxY, renderer.bounds.max.y);
            }
            
            return (worldMinY, worldMaxY);
        }
        
        private void TweenMaterialProperty(string keyword, float startValue, float endValue, float duration, Ease ease)
        {
            var value = startValue;
            DOTween.To(() => value, x => value = x, endValue, duration).SetEase(ease).OnUpdate(() =>
            {
                _rendererMaterialReplacerController.SetPlaceMaterialProperty(keyword, value);
            });
        }
        
        private void SetMaterialProperty(string keyword, float value)
        {
            _rendererMaterialReplacerController.SetPlaceMaterialProperty(keyword, value);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/SaveJsonFileTest.cs
```cs
using System;
using System.IO;
using System.Reflection;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    /// <summary>
    ///     実際にファイルに保存、ロードをして正しく動作するかテストする
    /// </summary>
    public class SaveJsonFileTest
    {
        [Test]
        public void SaveJsonAndLoadTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            
            //リフレクションでテスト用のファイル名を変更
            ChangeFilePath(saveServiceProvider.GetService<SaveJsonFileName>(), "SaveJsonAndLoadTest.json");
            Debug.Log(saveServiceProvider.GetService<SaveJsonFileName>().FullSaveFilePath);
            
            
            //ブロックの追加
            worldBlockDatastore.TryAddBlock((BlockId)1, new Vector3Int(0, 0), BlockDirection.North, out var block0);
            worldBlockDatastore.TryAddBlock((BlockId)2, new Vector3Int(0, 1), BlockDirection.East, out var block1);
            worldBlockDatastore.TryAddBlock((BlockId)3, new Vector3Int(30, -10), BlockDirection.West, out var block2);
            
            saveServiceProvider.GetService<IWorldSaveDataSaver>().Save();
            
            
            var (_, loadServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            
            //テスト用にファイル名を変更
            //リフレクションでテスト用のファイル名を変更
            ChangeFilePath(loadServiceProvider.GetService<SaveJsonFileName>(), "SaveJsonAndLoadTest.json");
            Debug.Log(loadServiceProvider.GetService<SaveJsonFileName>().FullSaveFilePath);
            
            loadServiceProvider.GetService<IWorldSaveDataLoader>().LoadOrInitialize();
            var loadWorldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            // ファイルを削除
            File.Delete(saveServiceProvider.GetService<SaveJsonFileName>().FullSaveFilePath);
            
            //追加したブロックのチェック
            var block = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            Assert.AreEqual(1, block.BlockId.AsPrimitive());
            Assert.AreEqual(block0.BlockInstanceId, block.BlockInstanceId.AsPrimitive());
            Assert.AreEqual(BlockDirection.North, loadWorldBlockDatastore.GetBlockDirection(new Vector3Int(0, 0)));
            
            block = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 1));
            Assert.AreEqual(2, block.BlockId.AsPrimitive());
            Assert.AreEqual(block1.BlockInstanceId, block.BlockInstanceId.AsPrimitive());
            Assert.AreEqual(BlockDirection.East, loadWorldBlockDatastore.GetBlockDirection(new Vector3Int(0, 1)));
            
            block = loadWorldBlockDatastore.GetBlock(new Vector3Int(30, -10));
            Assert.AreEqual(3, block.BlockId.AsPrimitive());
            Assert.AreEqual(block2.BlockInstanceId, block.BlockInstanceId.AsPrimitive());
            Assert.AreEqual(BlockDirection.West, loadWorldBlockDatastore.GetBlockDirection(new Vector3Int(30, -10)));
            
        }
        
        private void ChangeFilePath(SaveJsonFileName instance, string fileName)
        {
            // バッキングフィールドを取得する
            var fieldInfo = typeof(SaveJsonFileName).GetField("<FullSaveFilePath>k__BackingField",
                BindingFlags.Instance | BindingFlags.NonPublic);
            
            // バッキングフィールドの値を更新する
            var path = Path.Combine(Environment.CurrentDirectory, "../", "moorestech_server", fileName);
            fieldInfo.SetValue(instance, path);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/DisconnectOneElectricPoleFromSegmentService.cs
```cs
using System;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    /// <summary>
    ///     TODo ここのイベントハンドラを全部削除する
    /// </summary>
    /// <typeparam name="TSegment"></typeparam>
    /// <typeparam name="TConsumer"></typeparam>
    /// <typeparam name="TGenerator"></typeparam>
    /// <typeparam name="TTransformer"></typeparam>
    public static class DisconnectOneElectricPoleFromSegmentService<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        public static void Disconnect(IElectricTransformer removedElectricPole, EnergyServiceDependencyContainer<TSegment> container)
        {
            //必要なデータを取得
            var pos = ServerContext.WorldBlockDatastore.GetBlockPosition(removedElectricPole.BlockInstanceId);
            var removedBlock = ServerContext.WorldBlockDatastore.GetBlock(pos);
            var poleConfig = removedBlock.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            
            var removedSegment = container.WorldEnergySegmentDatastore.GetEnergySegment(removedElectricPole);
            var electricPoles = FindElectricPoleFromPeripheralService.Find(
                pos, poleConfig);
            
            if (electricPoles.Count != 1) throw new Exception("周辺の電柱が1つではありません");
            
            
            //セグメントから電柱の接続状態を解除
            removedSegment.RemoveEnergyTransformer(removedElectricPole);
            
            //周辺の機械、発電機を取得
            (var blocks, var generators) =
                FindMachineAndGeneratorFromPeripheralService.Find(pos, poleConfig);
            
            //周辺の機械、発電機を接続状態から解除する
            blocks.ForEach(removedSegment.RemoveEnergyConsumer);
            generators.ForEach(removedSegment.RemoveGenerator);
            
            
            //繋がっていた1つの電柱の周辺の機械と発電機を探索
            var connectedPos = ServerContext.WorldBlockDatastore.GetBlockPosition(electricPoles[0].BlockInstanceId);
            var connectedBlock = ServerContext.WorldBlockDatastore.GetBlock(connectedPos);
            var connectedPoleConfig = connectedBlock.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            
            (var connectedBlocks, var connectedGenerators) = FindMachineAndGeneratorFromPeripheralService.Find(connectedPos, connectedPoleConfig);
            
            //セグメントに追加する
            connectedBlocks.ForEach(removedSegment.AddEnergyConsumer);
            connectedGenerators.ForEach(removedSegment.AddGenerator);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/GroundCollisionDetector.cs
```cs
using Client.Game.InGame.BlockSystem;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class GroundCollisionDetector : MonoBehaviour
    {
        public bool IsCollision { get; private set; }
        
        private void FixedUpdate()
        {
            // なぜかExitが呼ばれないのでこの方法でリセットを行う
            IsCollision = false;
        }
        
        private void OnTriggerStay(Collider other)
        {
            if (other.gameObject.TryGetComponent<GroundGameObject>(out _))
            {
                IsCollision = true;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/DisconnectElectricSegmentTest.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    //電柱が無くなったときにセグメントが切断されるテスト
    public class DisconnectElectricSegmentTest
    {
        [Test]
        public void RemoveElectricPoleToDisconnectSegment()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            /*設置する電柱、機械、発電機の場所
             * M □  □ G □  □ M
             * P □  □ P □  □ P
             * G
             */
            
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //電柱の設置
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(3, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(6, 0), BlockDirection.North, out _);
            
            //発電機と機械の設定
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 1), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GeneratorId, new Vector3Int(0, -1), BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GeneratorId, new Vector3Int(3, 1), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(6, 1), BlockDirection.North, out _);
            
            IWorldEnergySegmentDatastore<EnergySegment> worldElectricSegment = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            //セグメントの数を確認
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            
            //右端の電柱を削除
            worldBlockDatastore.RemoveBlock(new Vector3Int(6, 0));
            //セグメントの数を確認
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            //電柱を再設置
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(6, 0), BlockDirection.North, out _);
            //セグメントの数を確認
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            
            
            //真ん中の電柱を削除
            worldBlockDatastore.RemoveBlock(new Vector3Int(3, 0));
            //セグメントが増えていることを確認する
            Assert.AreEqual(2, worldElectricSegment.GetEnergySegmentListCount());
            
            //真ん中の発電機が2つのセグメントにないことを確認する
            Assert.AreEqual(false, worldElectricSegment.GetEnergySegment(0).Generators.ContainsKey(new BlockInstanceId(5)));
            Assert.AreEqual(false, worldElectricSegment.GetEnergySegment(1).Generators.ContainsKey(new BlockInstanceId(5)));
            
            //両端の電柱が別のセグメントであることを確認する
            var segment1Block = worldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            var segment2Block = worldBlockDatastore.GetBlock(new Vector3Int(6, 0));
            var electricityTransformer1 = segment1Block.GetComponent<IElectricTransformer>();
            var electricityTransformer2 = segment2Block.GetComponent<IElectricTransformer>();
            var segment1 = worldElectricSegment.GetEnergySegment(electricityTransformer1);
            var segment2 = worldElectricSegment.GetEnergySegment(electricityTransformer2);
            
            Assert.AreNotEqual(segment1.GetHashCode(), segment2.GetHashCode());
            
            //右端の電柱を削除する
            worldBlockDatastore.RemoveBlock(new Vector3Int(6, 0));
            //セグメントが減っていることを確認する
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
        }
        
        //電柱を消してもループによって1つのセグメントになっている時のテスト
        [Test]
        public void LoopedElectricSegmentRemoveElectricPoleTest()
        {
            /*設置する電柱、機械、発電機の場所
             * P □ □ P □ □ P
             * G □ □ □ □ □ □
             * M □ □ □ □ □ M
             * P □ □ P □ □ P
             * G □ □ G
             */
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            IWorldEnergySegmentDatastore<EnergySegment> worldElectricSegment = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            
            //電柱の設置
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(3, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(6, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(0, 3), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(3, 3), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(6, 3), BlockDirection.North, out _);
            
            //発電機と機械の設定
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 1), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GeneratorId, new Vector3Int(0, -1), BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GeneratorId, new Vector3Int(3, -1), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(6, 1), BlockDirection.North, out _);
            
            
            //セグメントの数を確認
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            
            //真ん中の電柱を削除
            worldBlockDatastore.RemoveBlock(new Vector3Int(3, 0));
            //セグメント数が変わってないかチェック
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            
            //真ん中の発電機がセグメントにないことを確認する
            Assert.AreEqual(false, worldElectricSegment.GetEnergySegment(0).Generators.ContainsKey(new BlockInstanceId(105)));
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Map/MapObject/MapObjectGameObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Context;
using Client.Network.API;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Map.MapObject
{
    /// <summary>
    ///     TODO 静的なオブジェクトになってるので、サーバーからコンフィグを取得して動的に生成するようにしたい
    /// </summary>
    public class MapObjectGameObjectDatastore : MonoBehaviour
    {
        [SerializeField] private List<MapObjectGameObject> mapObjects;
        private readonly Dictionary<int, MapObjectGameObject> _allMapObjects = new();
        
        
        [Inject]
        public void Construct(InitialHandshakeResponse handshakeResponse)
        {
            //イベント登録
            ClientContext.VanillaApi.Event.SubscribeEventResponse(MapObjectUpdateEventPacket.EventTag, OnUpdateMapObject);
            
            // mapObjectの破壊状況の初期設定
            foreach (var mapObject in mapObjects) _allMapObjects.Add(mapObject.InstanceId, mapObject);
            
            foreach (var mapObjectInfo in handshakeResponse.MapObjects)
            {
                var mapObject = _allMapObjects[mapObjectInfo.InstanceId];
                if (mapObjectInfo.IsDestroyed) mapObject.DestroyMapObject();
            }
        }
        
        private void OnUpdateMapObject(byte[] payLoad)
        {
            var data = MessagePackSerializer.Deserialize<MapObjectUpdateEventMessagePack>(payLoad);
            
            switch (data.EventType)
            {
                case MapObjectUpdateEventMessagePack.DestroyEventType:
                    _allMapObjects[data.InstanceId].DestroyMapObject();
                    break;
                default:
                    throw new Exception("MapObjectUpdateEventProtocol: EventTypeが不正か実装されていません");
            }
        }
        
        public List<MapObjectGameObject> CreateMapObjectList(Guid mapObjectGuid)
        {
            return mapObjects.Where(x => x.MapObjectGuid == mapObjectGuid && !x.IsDestroyed).ToList();
        }
        
#if UNITY_EDITOR
        public List<MapObjectGameObject> MapObjects => mapObjects;
        
        public void FindMapObjects()
        {
            mapObjects = FindObjectsOfType<MapObjectGameObject>().ToList();
            mapObjects.Sort((a, b) => string.Compare(a.gameObject.name, b.gameObject.name, StringComparison.Ordinal));
        }
#endif
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailPosition.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Game.Train.RailGraph
{
    public class RailPosition
    {
        // RailNodeのリスト。インデックスが小さいほうに向かって進む。
        private List<RailNode> _railNodes;

        // 先頭の前輪が次のノードまでどれだけ離れているか
        private int _distanceToNextNode;

        // 列車の長さ
        private int _trainLength;

        public RailPosition(List<RailNode> railNodes, int trainLength, int initialDistanceToNextNode)
        {
            if (railNodes == null || railNodes.Count < 1)
            {
                throw new ArgumentException("RailNodeリストには1つ以上の要素が必要です。");
            }

            if (trainLength <= 0)
            {
                throw new ArgumentException("列車の長さは正の値である必要があります。");
            }

            _railNodes = railNodes;
            _trainLength = trainLength;
            _distanceToNextNode = initialDistanceToNextNode;

            ValidatePosition();
        }

        private void ValidatePosition()
        {
            // 現在のRailNodeリストと距離が列車の長さに収まっているかを確認
            int totalDistance = CalculateTotalDistance();

            if (totalDistance + _distanceToNextNode < _trainLength)
            {
                throw new InvalidOperationException("列車の長さが現在のルートを超えています。");
            }
        }

        private int CalculateTotalDistance()
        {
            int totalDistance = 0;
            for (int i = 0; i < _railNodes.Count - 1; i++) 
            {
                totalDistance += _railNodes[i + 1].GetDistanceToNode(_railNodes[i]);
            }
            //万が一int maxを超える場合エラー
            if (totalDistance < 0) 
            {
                throw new InvalidOperationException("列車の長さがintの最大値を超えています。");
            }   
            return totalDistance;
        }

        // 距離だけ進むメソッド
        // マイナスの距離がはいることも考慮する
        //整数で入力された距離だけ進む。ただしRailNodeを超えそうなときは、一旦RailNodeで停止し残りの進むべき距離を整数で返す
        //進んだときにリストの経路の中でいらない情報を削除する
        public int MoveForward(int distance)
        {
            // 進む距離が負なら反転してfowardで計算しまた反転する
            if (distance < 0) 
            {
                Reverse();
                var result = MoveForward(-distance);
                Reverse();
                return -result;
            }

            // あとは進む距離が正のみを考える
            if (distance <= _distanceToNextNode)
            {
                _distanceToNextNode -= distance;
                RemoveUnnecessaryNodes();
                return 0;
            }
            else 
            {
                distance -= _distanceToNextNode;
                _distanceToNextNode = 0;
                RemoveUnnecessaryNodes();
                return distance;
            }
        }

        // 列車を反転させる
        public void Reverse()
        {
            _railNodes.Reverse();
            for (int i = 0; i < _railNodes.Count; i++)
            {
                _railNodes[i] = _railNodes[i].OppositeNode; // RailNode自体の反転
            }
            //_distanceToNextNode再計算
            _distanceToNextNode = CalculateTotalDistance() - _distanceToNextNode - _trainLength;
        }

        // 今持っているリストの中でいらない情報を削除する
        // 具体的には列車が含まれる経路の全部のNodeを残したい。また前輪後輪がぴったりのっているNodeは残す
        public void RemoveUnnecessaryNodes()
        {
            //list[0]から最後尾の距離
            int distanceFromFront = _trainLength + _distanceToNextNode;
            if (distanceFromFront == 0) 
            {
                //リストは最初のindexのみ残す removeRange
                _railNodes.RemoveRange(1, _railNodes.Count - 1);
                return;
            }
            //2ノード以上にまたがっている場合
            int totalListDistance = 0;
            for (int i = 0; i < _railNodes.Count - 1; i++)
            {
                totalListDistance += _railNodes[i + 1].GetDistanceToNode(_railNodes[i]);
                //はじめてtotalListDistanceがdistanceFromFrontを超えたら
                if (totalListDistance > distanceFromFront)
                {
                    if (i + 2 == _railNodes.Count) break;
                    //それ以降の情報はいらない
                    _railNodes.RemoveRange(i + 2, _railNodes.Count - i - 2);
                    break;
                }
            }
            return;
        }

        // 現在の先頭のRailNodeを取得
        public RailNode GetNodeApproaching()
        {
            return _railNodes.FirstOrDefault();
        }

        // 次のRailNodeを取得
        public RailNode GetNodeJustPassed()
        {
            return _railNodes.Count > 1 ? _railNodes[1] : null;
        }

        
        // 現在の距離情報を取得
        public int GetDistanceToNextNode()
        {
            return _distanceToNextNode;
        }

        //_railNodesを返す関数(　テスト用)
        public List<RailNode> TestGet_railNodes() 
        {
            return _railNodes;
        }


    }
}

```

moorestech_client/Assets/Scripts/Editor/BuildPipeline.cs
```cs
using System;
using System.Linq;
using UnityEditor;
using UnityEditor.Build.Reporting;
using UnityEngine;

public class BuildPipeline
{
    private const string OutputPathKey = "WindowsBuildOutputPath";
    
    [MenuItem("moorestech/Build/WindowsBuild")]
    public static void WindowsBuild()
    {
        Pipeline(BuildTarget.StandaloneWindows64, false, true);
    }
    
    [MenuItem("moorestech/Build/MacOsBuild")]
    public static void MacOsBuild()
    {
        Pipeline(BuildTarget.StandaloneOSX, false, true);
    }
    
    [MenuItem("moorestech/Build/LinuxBuild")]
    public static void LinuxBuild()
    {
        Pipeline(BuildTarget.StandaloneLinux64, false, true);
    }
    
    private static void Pipeline(BuildTarget buildTarget, bool isErrorExit, bool isSelectOutputPath)
    {
        Debug.Log("Build Start Time : " + DateTime.Now);
        var buildStartTime = DateTime.Now;
        
        var path = "Output_" + buildTarget;
        if (isSelectOutputPath)
        {
            var playerPrefsKey = OutputPathKey + buildTarget;
            path = EditorUtility.OpenFolderPanel("Build", PlayerPrefs.GetString(playerPrefsKey, ""), "");
            
            if (path == string.Empty) return;
            
            PlayerPrefs.SetString(playerPrefsKey, path);
            PlayerPrefs.Save();
        }
        
        
        //DirectoryProcessor.CopyAndReplace(ServerConst.ServerDirectory, Path.Combine(path, ServerConst.ServerDirName));
        
        var buildOptions = new BuildPlayerOptions
        {
            target = buildTarget,
            locationPathName = path + (buildTarget == BuildTarget.StandaloneWindows64 ? "/moorestech.exe" : "/moorestech"),
            scenes = EditorBuildSettings.scenes.Select(s => s.path).ToArray(),
        };
        
        var report = UnityEditor.BuildPipeline.BuildPlayer(buildOptions);
        
        if (isSelectOutputPath) EditorUtility.RevealInFinder(path);
        
        Debug.Log("Build Result :" + report.summary.result);
        
        Debug.Log("Build Output Path :" + report.summary.outputPath);
        Debug.Log("Build Summary TotalSize :" + report.summary.totalSize);
        
        Debug.Log("Build Finish Time : " + DateTime.Now);
        //ビルドにかかった時間を hh:mm:ss で表示
        Debug.Log("Build Time : " + (DateTime.Now - buildStartTime).ToString(@"hh\:mm\:ss"));
        
        
        if (isErrorExit) EditorApplication.Exit(report.summary.result == BuildResult.Succeeded ? 0 : 1);
    }
    
    #region from Github Action
    
    public static void WindowsBuildFromGithubAction()
    {
        Pipeline(BuildTarget.StandaloneWindows64, true, false);
    }
    
    public static void MacOsBuildFromGithubAction()
    {
        Pipeline(BuildTarget.StandaloneOSX, true, false);
    }
    
    public static void LinuxBuildFromGithubAction()
    {
        Pipeline(BuildTarget.StandaloneLinux64, true, false);
    }
    
    #endregion
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ConfigOnly/mods/testConfigOnlyMod2/master/craftRecipe.json
```cs
testCraftRecipeJson1
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/BlockInventoryUpdateEventPacketTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    /// <summary>
    ///     ブロックのインベントリが更新された時、イベントのパケットが更新されているかをテストする
    /// </summary>
    public class BlockInventoryUpdateEventPacketTest
    {
        private const int PlayerId = 3;
        private const short PacketId = 16;
        
        //正しくインベントリの情報が更新されたことを通知するパケットが送られるかチェックする
        [Test]
        public void BlockInventoryUpdatePacketTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDataStore = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            Vector3Int pos = new(5, 7);
            
            //ブロックをセットアップ
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, pos, BlockDirection.North, out var block);
            var blockInventory = block.GetComponent<IBlockInventory>();
            
            
            //インベントリを開く
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), true));
            //ブロックにアイテムを入れる
            blockInventory.SetItem(1, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //パケットが送られていることをチェック
            //イベントパケットを取得
            List<List<byte>> eventPacket = packetResponse.GetPacketResponse(GetEventPacket());
            
            
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(eventPacket[0].ToArray());
            //イベントパケットをチェック
            Assert.AreEqual(1, eventMessagePack.Events.Count);
            var payLoad = eventMessagePack.Events[0].Payload;
            var data = MessagePackSerializer.Deserialize<OpenableBlockInventoryUpdateEventMessagePack>(payLoad);
            
            Assert.AreEqual(1, data.Slot); // slot id
            Assert.AreEqual(4, data.Item.Id.AsPrimitive()); // item id
            Assert.AreEqual(8, data.Item.Count); // item count
            Assert.AreEqual(5, data.Position.X); // x
            Assert.AreEqual(7, data.Position.Y); // y
            
            
            //ブロックのインベントリを閉じる
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), false));
            
            //ブロックにアイテムを入れる
            blockInventory.SetItem(2, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //パケットが送られていないことをチェック
            //イベントパケットを取得
            eventPacket = packetResponse.GetPacketResponse(GetEventPacket());
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(eventPacket[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        
        //インベントリが開けるのは１つまでであることをテストする
        [Test]
        public void OnlyOneInventoryCanBeOpenedTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDataStore = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //ブロック1をセットアップ
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(5, 7), BlockDirection.North, out var block1);
            
            //ブロック2をセットアップ
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(10, 20), BlockDirection.North, out var block2);
            
            
            //一つ目のブロックインベントリを開く
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), true));
            //二つ目のブロックインベントリを開く
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(10, 20), true));
            
            
            //一つ目のブロックインベントリにアイテムを入れる
            var block1Inventory = block1.GetComponent<VanillaMachineBlockInventoryComponent>();
            block1Inventory.SetItem(2, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //パケットが送られていないことをチェック
            List<List<byte>> response = packetResponse.GetPacketResponse(GetEventPacket());
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        
        private List<byte> OpenCloseBlockInventoryPacket(Vector3Int pos, bool isOpen)
        {
            return MessagePackSerializer
                .Serialize(new BlockInventoryOpenCloseProtocol.BlockInventoryOpenCloseProtocolMessagePack(PlayerId, pos, isOpen)).ToList();
        }
        
        private List<byte> GetEventPacket()
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(PlayerId)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/PacketHandle/PacketHandler.cs
```cs
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Server.Protocol;
using UnityEngine;

namespace Server.Boot.PacketHandle
{
    public class PacketHandler
    {
        private const int Port = 11564;
        
        public void StartServer(PacketResponseCreator packetResponseCreator)
        {
            //ソケットの作成
            var listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            //通信の受け入れ準備
            listener.Bind(new IPEndPoint(IPAddress.Any, Port));
            listener.Listen(10);
            Debug.Log("moorestechサーバー 起動完了");
            
            while (true)
            {
                //通信の確率
                var client = listener.Accept();
                Debug.Log("接続確立");
                
                var receiveThread = new Thread(() => new UserResponse(client, packetResponseCreator).StartListen());
                receiveThread.Name = "[moorestech] 受信スレッド";
                
                receiveThread.Start();
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerCrafterItemSelectModal.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Master;
using Cysharp.Threading.Tasks;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Block.ChainerCrafter
{
    public class CraftChainerCrafterItemSelectModal : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        [SerializeField] private RectTransform itemsParent;
        [SerializeField] private TMP_InputField countInputField;
        
        [SerializeField] private Button okButton;
        [SerializeField] private Button cancelButton;
        [SerializeField] private Button clearButton;
        
        private readonly List<ItemSlotObject> _itemSlotObjects = new();
        
        private ItemId _selectedItemId;
        
        public void Initialize()
        {
            gameObject.SetActive(false);
            // アイテムリストを初期化
            // Initialize item list
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemView = ClientContext.ItemImageContainer.GetItemView(itemId);
                var slotObject = Instantiate(itemSlotObjectPrefab, itemsParent);
                slotObject.OnLeftClickUp.Subscribe(ClickItem);
                slotObject.SetItem(itemView, 0);
                _itemSlotObjects.Add(slotObject);
            }
            
            countInputField.onValueChanged.AddListener(UpdateOkButton);
        }
        
        public async UniTask<(ItemId,int)> GetSelectItem(ItemId currentItemId, int currentCount)
        {
            currentCount = Mathf.Max(1, currentCount);
            _selectedItemId = currentItemId;
            SetupUI();
            
            var result = await WaitPushButton();
            
            gameObject.SetActive(false);
            return result;
            
            #region Internal
            
            void SetupUI()
            {
                gameObject.SetActive(true);
                
                foreach (var slotObject in _itemSlotObjects)
                {
                    slotObject.SetHotBarSelect(false);
                    if (slotObject.ItemViewData.ItemId == currentItemId)
                    {
                        slotObject.SetHotBarSelect(true);
                    }
                }
                
                okButton.interactable = currentItemId != ItemMaster.EmptyItemId;
                countInputField.text = currentCount.ToString();
            }
            
            async UniTask<(ItemId, int)> WaitPushButton()
            {
                var ok = okButton.OnClickAsync();
                var cancel = cancelButton.OnClickAsync();
                var clear = clearButton.OnClickAsync();
                await UniTask.WhenAny(ok, cancel, clear);
                
                if (cancel.Status == UniTaskStatus.Succeeded)
                {
                    return (currentItemId, currentCount);
                }
                if (clear.Status == UniTaskStatus.Succeeded)
                {
                    return (ItemMaster.EmptyItemId, 0);
                }
                
                if (int.TryParse(countInputField.text, out var count))
                {
                    return (_selectedItemId, count);
                }
                
                return (_selectedItemId, 1);
            }
            
  #endregion
        }
        
        private void ClickItem(ItemSlotObject itemSlotObject)
        {
            foreach (var slotObject in _itemSlotObjects)
            {
                slotObject.SetHotBarSelect(false);
            }
            
            itemSlotObject.SetHotBarSelect(true);
            _selectedItemId = itemSlotObject.ItemViewData.ItemId;
            
            UpdateOkButton(countInputField.text);
        }
        
        private void UpdateOkButton(string inputFieldText)
        {
            if (int.TryParse(inputFieldText, out var count))
            {
                okButton.interactable = 0 < count;
                return;
            }
            okButton.interactable = false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Component/BlockConnectorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.ComponentAttribute;
using Game.Context;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlockConnectInfoModule;
using UnityEngine;

namespace Game.Block.Component
{
    [DisallowMultiple]
    public class BlockConnectorComponent<TTarget> : IBlockConnectorComponent<TTarget> where TTarget : IBlockComponent
    {
        public IReadOnlyDictionary<TTarget, ConnectedInfo> ConnectedTargets => _connectedTargets;
        private readonly Dictionary<TTarget, ConnectedInfo> _connectedTargets = new();
        
        private readonly List<IDisposable> _blockUpdateEvents = new();
        
        private readonly Dictionary<Vector3Int, List<(Vector3Int position, IConnectOption targetOption)>> _inputConnectPoss; // key インプットコネクターの位置 value そのコネクターと接続できる位置
        private readonly Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)> _outputTargetToOutputConnector; // key アウトプット先の位置 value そのアウトプット先と接続するアウトプットコネクターの位置
        
        public BlockConnectorComponent(BlockConnectInfo inputConnectInfo, BlockConnectInfo outputConnectInfo, BlockPositionInfo blockPositionInfo)
        {
            var worldBlockUpdateEvent = ServerContext.WorldBlockUpdateEvent;
            
            _inputConnectPoss = BlockConnectorConnectPositionCalculator.CalculateConnectorToConnectPosList(inputConnectInfo, blockPositionInfo);
            _outputTargetToOutputConnector = BlockConnectorConnectPositionCalculator.CalculateConnectPosToConnector(outputConnectInfo, blockPositionInfo);
            
            foreach (var outputPos in _outputTargetToOutputConnector.Keys)
            {
                _blockUpdateEvents.Add(worldBlockUpdateEvent.SubscribePlace(outputPos, b => OnPlaceBlock(b.Pos)));
                _blockUpdateEvents.Add(worldBlockUpdateEvent.SubscribeRemove(outputPos, OnRemoveBlock));
                
                //アウトプット先にブロックがあったら接続を試みる
                if (ServerContext.WorldBlockDatastore.Exists(outputPos)) OnPlaceBlock(outputPos);
            }
        }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            _connectedTargets.Clear();
            _blockUpdateEvents.ForEach(x => x.Dispose());
            _blockUpdateEvents.Clear();
            IsDestroy = true;
        }
        
        /// <summary>
        ///     ブロックを接続元から接続先に接続できるなら接続する
        ///     その場所にブロックがあるか、
        ///     それぞれインプットとアウトプットの向きはあっているかを確認し、接続する TODO ここのドキュメントを書く
        /// </summary>
        private void OnPlaceBlock(Vector3Int outputTargetPos)
        {
            //接続先にBlockInventoryがなければ処理を終了
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            if (!worldBlockDatastore.TryGetBlock(outputTargetPos, out BlockConnectorComponent<TTarget> targetConnector)) return;
            if (!worldBlockDatastore.TryGetBlock<TTarget>(outputTargetPos, out var targetComponent)) return;
            
            // アウトプット先にターゲットのインプットオブジェクトがあるかどうかをチェックする
            var isConnect = false;
            IConnectOption selfOption = null;
            IConnectOption targetOption = null;
            foreach (var targetInput in targetConnector._inputConnectPoss)
            {
                // アウトプット先に、インプットのコネクターがあるかどうかをチェックする
                if (targetInput.Key != outputTargetPos) continue;
                
                // インプットがどこからでも接続できるならそのまま接続
                if (targetInput.Value == null)
                {
                    isConnect = true;
                    break;
                }
                
                // インプット先に制限がある場合、その座標にアウトプットのコネクターがあるかをチェックする
                var outputConnector = _outputTargetToOutputConnector[outputTargetPos];
                
                // インプット先にアウトプットのコネクターがある場合は接続できる
                foreach (var target in targetInput.Value)
                    if (target.position == outputConnector.position)
                    {
                        isConnect = true;
                        selfOption = outputConnector.selfOption;
                        targetOption = target.targetOption;
                        break;
                    }
            }
            
            if (!isConnect) return;
            
            //接続元ブロックと接続先ブロックを接続
            if (!_connectedTargets.ContainsKey(targetComponent))
            {
                var block = ServerContext.WorldBlockDatastore.GetBlock(outputTargetPos);
                var connectedInfo = new ConnectedInfo(selfOption, targetOption, block);
                _connectedTargets.Add(targetComponent, connectedInfo);
            }
        }
        
        private void OnRemoveBlock(BlockUpdateProperties updateProperties)
        {
            //削除されたブロックがInputConnectorComponentでない場合、処理を終了する
            if (!ServerContext.WorldBlockDatastore.TryGetBlock<TTarget>(updateProperties.Pos, out var component)) return;
            
            _connectedTargets.Remove(component);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlacePointCalculator.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPlacePointCalculator
    {
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        
        public BlockPlacePointCalculator(BlockGameObjectDataStore blockGameObjectDataStore)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
        }
        
        public List<PlaceInfo> CalculatePoint(Vector3Int startPoint, Vector3Int endPoint, bool isStartDirectionZ, BlockDirection blockDirection, BlockMasterElement holdingBlockMasterElement)
        {
            // ひとまず、XとZ方向に目的地に向かって1ずつ進む
            var startToCornerDistance = 0;
            var positions = CalcPositions();
            
            var result = CalcPlaceDirection(positions);
            result = CalcPlaceable(result);
            
            return result;
            
            #region Internal
            
            // TODO statci化
            // TODO ブロックの大きさに応じて、設置する間隔を変更する
            List<Vector3Int> CalcPositions()
            {
                // ひとまず、XとZ方向に目的地に向かって1ずつ進む
                var pointList = new List<Vector3Int>();
                var currentPoint = startPoint;
                
                // X軸とZ軸のポイントを設定する
                pointList.Add(currentPoint);
                while (currentPoint.x != endPoint.x || currentPoint.z != endPoint.z)
                {
                    // 指定された方向（X or Z）に伸ばす
                    if (isStartDirectionZ && currentPoint.z != endPoint.z)
                    {
                        currentPoint.z += endPoint.z > currentPoint.z ? 1 : -1;
                        startToCornerDistance++;
                    }
                    else if (!isStartDirectionZ && currentPoint.x != endPoint.x)
                    {
                        currentPoint.x += endPoint.x > currentPoint.x ? 1 : -1;
                        startToCornerDistance++;
                    }
                    else
                    {
                        // 直角に曲がり、もう片方の軸に向かう
                        if (currentPoint.z != endPoint.z)
                        {
                            currentPoint.z += endPoint.z > currentPoint.z ? 1 : -1;
                        }
                        else
                        {
                            currentPoint.x += endPoint.x > currentPoint.x ? 1 : -1;
                        }
                    }
                    
                    pointList.Add(currentPoint);
                }
                
                // Y軸を設定する
                // set Y axis
                
                // 同じ高さの場合はそのまま返す
                // return as it is if the same height
                if (startPoint.y == endPoint.y) return pointList;
                
                var yDelta = Mathf.Abs(startPoint.y - endPoint.y);
                var currentYDelta = yDelta;
                
                // 上がる場合
                // if going up
                if (startPoint.y < endPoint.y)
                {
                    // 逆ループしながら下がるようにY座標を設定する
                    for (var i = pointList.Count - 1; i >= 0 && currentYDelta > 0; i--)
                    {
                        var point = pointList[i];
                        point.y += currentYDelta;
                        
                        if (startToCornerDistance + 1 != i) currentYDelta--; // 角の時はY座標を下げない
                        
                        pointList[i] = point;
                    }
                    
                    return pointList;
                }
                
                // 下がる場合
                // if going down
                
                // 下がる場合は、下がり終わる地点が最後から一つ前になるので、最後のポイントはここでは設定しない
                // In case of going down, the last point is not set here because the point where it ends is one before the last.
                // TODo ドキュメント
                var minusIndex = 2;
                for (var i = pointList.Count - minusIndex; i >= 0 && currentYDelta > 0; i--)
                {
                    var point = pointList[i];
                    
                    if (startToCornerDistance != i)
                    {
                        point.y -= currentYDelta;
                        currentYDelta--; // 角の時はY座標を下げない
                    }
                    else
                    {
                        point.y -= currentYDelta;
                    }
                    
                    pointList[i] = point;
                }
                
                // 最後のポイントを設定
                // set the last point
                var lastPoint = pointList[^1];
                lastPoint.y = endPoint.y;
                pointList[^1] = lastPoint;
                
                return pointList;
            }
            
            List<PlaceInfo> CalcPlaceDirection(List<Vector3Int> placePositions)
            {
                if (placePositions.Count == 1)
                {
                    return new List<PlaceInfo>()
                    {
                        new()
                        {
                            Position = placePositions[0],
                            Direction = blockDirection,
                            VerticalDirection = BlockVerticalDirection.Horizontal,
                        }
                    };
                }
                
                var results = new List<PlaceInfo>(placePositions.Count);
                for (int i = 0; i < placePositions.Count; i++)
                {
                    BlockDirection direction;
                    BlockVerticalDirection verticalDirection;
                    var currentPoint = placePositions[i];
                    
                    
                    // TODo このロジックのドキュメント化
                    if (startPoint.y < endPoint.y)
                        //if (true)
                    {
                        // 上向きの場合
                        if (i == placePositions.Count - 1)
                        {
                            var prevPoint = placePositions[i - 1];
                            (direction, _) = GetBlockDirectionWithNextBlock(prevPoint, currentPoint);
                            verticalDirection = BlockVerticalDirection.Horizontal; // 最後のブロックは必ず水平にする
                        }
                        else
                        {
                            var nextPoint = placePositions[i + 1];
                            (direction, verticalDirection) = GetBlockDirectionWithNextBlock(currentPoint, nextPoint);
                        }
                    }
                    else
                    {
                        // 下向きの場合
                        if ((i == 0 || i == startToCornerDistance) && i != placePositions.Count - 1)
                        {
                            var nextPoint = placePositions[i + 1];
                            (direction, verticalDirection) = GetBlockDirectionWithNextBlock(currentPoint, nextPoint);
                            if (i == startToCornerDistance)
                            {
                                verticalDirection = BlockVerticalDirection.Horizontal; // 角のブロックは必ず水平にする
                            }
                        }
                        else
                        {
                            var prevPoint = placePositions[i - 1];
                            (direction, verticalDirection) = GetBlockDirectionWithNextBlock(prevPoint, currentPoint);
                        }
                    }
                    
                    results.Add(new PlaceInfo()
                    {
                        Position = currentPoint,
                        Direction = direction,
                        VerticalDirection = verticalDirection,
                    });
                }
                
                return results;
            }
            
            (BlockDirection direction, BlockVerticalDirection verticalDirection) GetBlockDirectionWithNextBlock(Vector3Int currentPoint, Vector3Int nextPoint)
            {
                var horizonDirection = BlockDirection.North;
                if (currentPoint.x == nextPoint.x)
                {
                    horizonDirection = nextPoint.z > currentPoint.z ? BlockDirection.North : BlockDirection.South;
                }
                else
                {
                    horizonDirection = nextPoint.x > currentPoint.x ? BlockDirection.East : BlockDirection.West;
                }
                
                BlockVerticalDirection verticalDirection;
                if (currentPoint.y == nextPoint.y)
                {
                    verticalDirection = BlockVerticalDirection.Horizontal;
                }
                else
                {
                    verticalDirection = currentPoint.y < nextPoint.y ? BlockVerticalDirection.Up : BlockVerticalDirection.Down;
                }
                
                return (horizonDirection, verticalDirection);
            }
            
            List<PlaceInfo> CalcPlaceable(List<PlaceInfo> infos)
            {
                foreach (var info in infos)
                {
                    //TODO ブロックの数が足りているかどうか
                    info.Placeable = IsNotExistBlock(info);
                }
                
                return infos;
            }
            
            // 設置予定地にブロックが既に存在しているかどうか
            bool IsNotExistBlock(PlaceInfo placeInfo)
            {
                // 設置の縦方向のguidを取得
                var blockId = holdingBlockMasterElement.BlockGuid.GetVerticalOverrideBlockId(placeInfo.VerticalDirection);
                
                var size = MasterHolder.BlockMaster.GetBlockMaster(blockId).BlockSize;
                var previewPositionInfo = new BlockPositionInfo(placeInfo.Position, placeInfo.Direction, size);
                
                return !_blockGameObjectDataStore.IsOverlapPositionInfo(previewPositionInfo);
            }
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/ConnectElectricPoleToElectricSegment.cs
```cs
using Game.Context;
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     電柱やそれに類する動力伝達ブロックが設置されたときに、そのブロックを中心にセグメントを探索して接続する
    /// </summary>
    public class ConnectElectricPoleToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    
    {
        private readonly IWorldEnergySegmentDatastore<TSegment> _worldEnergySegmentDatastore;
        
        
        public ConnectElectricPoleToElectricSegment(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore)
        {
            _worldEnergySegmentDatastore = worldEnergySegmentDatastore;
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlace);
        }
        
        private void OnBlockPlace(BlockUpdateProperties updateProperties)
        {
            var pos = updateProperties.Pos;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //設置されたブロックが電柱だった時の処理
            if (!worldBlockDatastore.ExistsComponent<IElectricTransformer>(pos)) return;
            
            var poleBlockParam = updateProperties.BlockData.Block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            
            //電柱と電気セグメントを接続する
            var electricSegment = GetAndConnectElectricSegment(pos, poleBlockParam, worldBlockDatastore.GetBlock<IElectricTransformer>(pos));
            
            //他の機械、発電機を探索して接続する
            ConnectMachine(pos, electricSegment, poleBlockParam);
        }
        
        /// <summary>
        ///     他の電柱を探索して接続する
        ///     範囲内の電柱をリストアップする 電柱が１つであればそれに接続、複数ならマージする
        ///     接続したセグメントを返す
        /// </summary>
        private EnergySegment GetAndConnectElectricSegment(Vector3Int pos, ElectricPoleBlockParam poleBlockParam, IElectricTransformer blockElectric)
        {
            //周りの電柱をリストアップする
            var electricPoles = FindElectricPoleFromPeripheralService.Find(pos, poleBlockParam);
            
            //接続したセグメントを取得
            var electricSegment = electricPoles.Count switch
            {
                //周りに電柱がないときは新たに電力セグメントを作成する
                0 => _worldEnergySegmentDatastore.CreateEnergySegment(),
                //周りの電柱が1つの時は、その電力セグメントを取得する
                1 => _worldEnergySegmentDatastore.GetEnergySegment(electricPoles[0]),
                //電柱が2つ以上の時はマージする
                _ => ElectricSegmentMergeService.MergeAndSetDatastoreElectricSegments(_worldEnergySegmentDatastore,
                    electricPoles),
            };
            //電柱と電力セグメントを接続する
            electricSegment.AddEnergyTransformer(blockElectric);
            
            return electricSegment;
        }
        
        /// <summary>
        ///     設置した電柱の周辺にある機械、発電機を探索して接続する
        /// </summary>
        private void ConnectMachine(Vector3Int pos, EnergySegment segment, ElectricPoleBlockParam poleParam)
        {
            (var blocks, var generators) = FindMachineAndGeneratorFromPeripheralService.Find(pos, poleParam);
            
            //機械と発電機を電力セグメントを接続する
            blocks.ForEach(segment.AddEnergyConsumer);
            generators.ForEach(segment.AddGenerator);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/ItemMaster.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Mooresmaster.Loader.ItemsModule;
using Mooresmaster.Model.ItemsModule;
using Newtonsoft.Json.Linq;
using UnitGenerator;

namespace Core.Master
{
    // アイテムId専用の方を定義
    // NOTE このIDは永続化されれることはなく、メモリ上、ネットワーク通信上でのみ使用する値
    [UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter | UnitGenerateOptions.Comparable)]
    public partial struct ItemId { }
    
    public class ItemMaster
    {
        public static readonly ItemId EmptyItemId = new(0);
        
        public readonly Items Items;
        
        private readonly Dictionary<ItemId,ItemMasterElement> _itemElementTableById; 
        private readonly Dictionary<Guid,ItemId> _itemGuidToItemId;
        
        public ItemMaster(JToken itemJToken)
        {
            // GUIDの順番にint型のItemIdを割り当てる
            Items = ItemsLoader.Load(itemJToken);
            
            // ソート優先度、GUIDの順番でソート
            var sortedItemElements = Items.Data.ToList().
                OrderBy(x => x.SortPriority ?? float.MaxValue).
                ThenBy(x => x.ItemGuid).
                ToList();
            
            _itemElementTableById = new Dictionary<ItemId,ItemMasterElement>();
            _itemGuidToItemId = new Dictionary<Guid,ItemId>();
            for (var i = 0; i < sortedItemElements.Count; i++)
            {
                var itemId = new ItemId(i+1); // アイテムID 0は空のアイテムとして予約しているので、1から始める
                _itemElementTableById.Add(itemId, sortedItemElements[i]);
                _itemGuidToItemId.Add(sortedItemElements[i].ItemGuid, itemId);
            }
        }
        
        public ItemMasterElement GetItemMaster(ItemId itemId)
        {
            if (!_itemElementTableById.TryGetValue(itemId, out var element))
            {
                throw new InvalidOperationException($"ItemElement not found. ItemId:{itemId}");
            }
            return element;
        }
        
        public ItemMasterElement GetItemMaster(Guid itemGuid)
        {
            var itemId = GetItemId(itemGuid);
            return GetItemMaster(itemId);
        }
        
        public ItemId GetItemId(Guid itemGuid)
        {
            if (itemGuid == Guid.Empty)
            {
                return EmptyItemId;
            }
            
            if (!_itemGuidToItemId.TryGetValue(itemGuid, out var itemId))
            {
                throw new InvalidOperationException($"ItemElement not found. ItemGuid:{itemGuid}");
            }
            return itemId;
        }
        
        public IEnumerable<ItemId> GetItemAllIds()
        {
            return _itemElementTableById.Keys;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/ChestBlockInventoryView.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class ChestBlockInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            
            // アイテムリストを初期化
            // Initialize item list
            var itemList = new List<IItemStack>();
            
            var param = blockGameObject.BlockMasterElement.BlockParam;
            var slotSize =  param switch
            {
                ChestBlockParam blockParam => blockParam.ChestItemSlotCount, // TODO master interfaceブロックインベントリの整理箇所
                CraftChainerProviderChestBlockParam blockParam => blockParam.ItemSlotCount,
                CraftChainerMainComputerBlockParam blockParam => blockParam.ItemSlotCount,
                _ => 0
            };
            for (var i = 0; i < slotSize; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            UpdateItemList(itemList);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/Main.cs
```cs

public class Test
{
    public void Hoge()
    {
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/ProbabilityCalculator.cs
```cs
using System;

namespace Game.Block
{
    public static class ProbabilityCalculator
    {
        public static bool DetectFromPercent(double percent)
        {
            percent *= 100;
            //小数点以下の桁数
            var digitNum = 0;
            
            //小数点以下を無くすように乱数の上限と判定の境界を上げる
            var rate = (int)Math.Pow(10, digitNum);
            
            //乱数の上限と真と判定するボーダーを設定
            var randomValueLimit = 100 * rate;
            var border = (int)(rate * percent);
            var r = new Random();
            return r.Next(0, randomValueLimit) < border;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Inventory/IOpenableInventory.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Item.Interface;
using Core.Master;

namespace Core.Inventory
{
    /// <summary>
    ///     プレイヤーが開くことができるインベントリ系のインターフェース
    ///     プレイヤーのインベントリやブロックのインベントリが該当する
    /// </summary>
    public interface IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems { get; }
        
        public IItemStack GetItem(int slot);
        void SetItem(int slot, IItemStack itemStack);
        void SetItem(int slot, ItemId itemId, int count);
        public IItemStack ReplaceItem(int slot, IItemStack itemStack);
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count);
        
        public IItemStack InsertItem(IItemStack itemStack);
        public IItemStack InsertItem(ItemId itemId, int count);
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks);
        public bool InsertionCheck(List<IItemStack> itemStacks);
        public int GetSlotSize();
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems();
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerTransporterSaveLoadTest.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerTransporterSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);

            // Transporter blockを作成
            // Create a Transporter block
            var transporterBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerTransporter, new BlockInstanceId(1), posInfo);
            var originalTransporter = transporterBlock.GetComponent<CraftChainerTransporterComponent>();

            // セーブデータを取得
            // Get the save data
            var saveState = transporterBlock.GetSaveState();

            // ブロックをロード
            // Load the block
            var loadedBlock = blockFactory.Load(transporterBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedTransporterComponent = loadedBlock.GetComponent<CraftChainerTransporterComponent>();

            // ノードIDのチェック
            // Check the node ID
            Assert.AreEqual(originalTransporter.NodeId, loadedTransporterComponent.NodeId);
        }
    }
}

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/ChangeBlockEventPacketTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Block.Interface.State;
using Game.Context;
using Game.EnergySystem;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class ChangeBlockEventPacketTest
    {
        [Test]
        public void MachineChangeStateEvent()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            Vector3Int pos = new(0, 0);
            
            //機械のブロックを作る
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, pos, BlockDirection.North, out var machine);
            //機械ブロックにアイテムを挿入するのでそのアイテムを挿入する
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var item1 = itemStackFactory.Create(new ItemId(1), 3);
            var item2 = itemStackFactory.Create(new ItemId(2), 1);
            
            var blockInventory = machine.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            blockInventory.InsertItem(item1);
            blockInventory.InsertItem(item2);
            
            
            //稼働用の電気を供給する
            var electricMachineComponent = machine.GetComponent<VanillaElectricMachineComponent>();
            electricMachineComponent.SupplyEnergy(new ElectricPower(100));
            
            //最初にイベントをリクエストして、ブロードキャストを受け取れるようにする
            packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(0));
            
            //アップデートしてステートを更新する
            GameUpdater.UpdateWithWait();
            
            
            //ステートが実行中になっているかをチェック
            List<List<byte>> response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var payLoad = eventMessagePack.Events[0].Payload;
            
            var changeStateData = MessagePackSerializer.Deserialize<BlockStateMessagePack>(payLoad);
            var stateDetail = changeStateData.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            
            Assert.AreEqual(VanillaMachineBlockStateConst.IdleState, stateDetail.PreviousStateType);
            Assert.AreEqual(VanillaMachineBlockStateConst.ProcessingState, stateDetail.CurrentStateType);
            Assert.AreEqual(0, changeStateData.Position.X);
            Assert.AreEqual(0, changeStateData.Position.Y);
            
            var detailChangeData = changeStateData.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            Assert.AreEqual(1.0f, detailChangeData.PowerRate);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetCraftChainerMainComputerRequestItemProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using Game.CraftChainer.BlockComponent.Crafter;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SetCraftChainerMainComputerRequestItemProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:setReuqestComputer";
        
        public SetCraftChainerMainComputerRequestItemProtocol(ServiceProvider serviceProvider) { }
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SetCraftChainerMainComputerRequestItemProtocolMessagePack>(payload.ToArray());
            
            var blockPos = data.BlockPos.Vector3Int;
            
            var crafterBlock = ServerContext.WorldBlockDatastore.GetBlock(blockPos);
            if (crafterBlock == null) return null;
            
            var itemId = data.ItemId;
            var count = data.Count;
            var computerComponent = crafterBlock.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
            computerComponent.StartCreateItem(itemId, count);
            
            return null;
        }
        
        [MessagePackObject]
        public class SetCraftChainerMainComputerRequestItemProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            [Key(3)] public int ItemIdInt { get; set; }
            [IgnoreMember] public ItemId ItemId => new(ItemIdInt);
            [Key(4)] public int Count { get; set; }
            
            [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
            public SetCraftChainerMainComputerRequestItemProtocolMessagePack() { }
            
            public SetCraftChainerMainComputerRequestItemProtocolMessagePack(Vector3Int blockPos, ItemId itemId, int count)
            {
                Tag = ProtocolTag;
                BlockPos = new Vector3IntMessagePack(blockPos);
                ItemIdInt = itemId.AsPrimitive();
                Count = count;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/OneClickCraftProtocolTest.cs
```cs
using System.Linq;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.OneClickCraft;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class OneClickCraftProtocolTest
    {
        private const int PlayerId = 0;
        private const int CraftRecipeId = 1;
        
        [Test]
        public void CanNotCraftTest()
        {
            //アイテムがないときにクラフトできないかのテスト
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Id.AsPrimitive());
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void CanCraftTest()
        {
            //アイテムがあるときにクラフトできるかのテスト
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            //必要なアイテムをインベントリに追加
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = ServerContext.ItemStackFactory.Create(info.ItemGuid, info.Count);
                playerInventoryData.MainOpenableInventory.SetItem(i, item);
            }
            
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            var resultItemGuid = MasterHolder.ItemMaster.GetItemId(craftElement.CraftResultItemGuid);
            Assert.AreEqual(resultItemGuid, playerInventoryData.MainOpenableInventory.GetItem(slot).Id);
            Assert.AreEqual(craftElement.CraftResultCount, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void CanNotOneItemIsMissingTest()
        {
            //アイテムが一つ足りないときにクラフトできないかのテスト
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            //必要なアイテムをインベントリに追加
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = ServerContext.ItemStackFactory.Create(info.ItemGuid, info.Count);
                playerInventoryData.MainOpenableInventory.SetItem(i, item);
            }
            
            //一つのアイテムを消費
            var oneSubItem = playerInventoryData.MainOpenableInventory.GetItem(0).SubItem(1);
            playerInventoryData.MainOpenableInventory.SetItem(0, oneSubItem);
            
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            //アイテムがクラフトされていないことをテスト
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Id.AsPrimitive());
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void ItemFullToCanNotCraftTest()
        {
            //グラブインベントリのアイテムが満杯の時にクラフトできないテスト
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInv = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var itemStackFactory = ServerContext.ItemStackFactory;
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            
            //不要なアテムを追加
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var item = itemStackFactory.Create(new ItemId(10), 100);
                playerInv.MainOpenableInventory.SetItem(i, item);
            }
            
            
            //必要なアイテムをインベントリに追加
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = itemStackFactory.Create(info.ItemGuid, info.Count);
                playerInv.MainOpenableInventory.SetItem(i, item);
            }
            
            
            //クラフト実行
            var craftGuid = craftElement.CraftRecipeGuid;
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftGuid)).ToList());
            
            //アイテムが維持されていることをテスト
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var itemId = MasterHolder.ItemMaster.GetItemId(info.ItemGuid);
                Assert.AreEqual(itemId, playerInv.MainOpenableInventory.GetItem(i).Id.AsPrimitive());
                Assert.AreEqual(info.Count, playerInv.MainOpenableInventory.GetItem(i).Count);
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/BlockSlopeDeformationType.cs
```cs
using System.Collections.Generic;

namespace Client.Game.InGame.BlockSystem
{
    public class BlockSlopeDeformationType
    {
        private static readonly List<string> deformationTypes = new()
        {
            "BeltConveyor",
        };
        
        
        /// <summary>
        ///     傾斜によって角度や大きさが変わるブロックかどうかを取得するフラグ
        ///     ベルトコンベアなど変形するものはtrue、それ以外の通常のブロックはfalse
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static bool IsDeformation(string type)
        {
            return deformationTypes.Contains(type);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailGraphDatastore.cs
```cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Game.Train.RailGraph
{
    public class RailGraphDatastore
    {
        private readonly Dictionary<RailNode, int> railIdDic;//RailNode→Id辞書。下の逆引き
        private readonly List<RailNode> railNodes;//Id→RailNode辞書。上の逆引き
        MinHeap<int> nextidQueue;//上のリストで穴開き状態をなるべく防ぐために、次使う最小Idを取得するためのキュー。そのためだけにminheapを実装している

        //以下は経路探索で使う変数
        private readonly List<List<(int, int)>> connectNodes;//ノード接続情報。connectNodes[NodeId_A]:NodeId_Aのつながる先のNodeIdリスト。(Id,距離)

        public RailGraphDatastore()
        {
            railIdDic = new Dictionary<RailNode, int>();
            railNodes = new List<RailNode>();
            nextidQueue = new MinHeap<int>();
            connectNodes = new List<List<(int, int)>>();
        }

        public void AddNode(RailNode node)
        {
            //すでにnodeが登録されている場合は何もしない
            if (railIdDic.ContainsKey(node))
                return;

            int nextid;
            if ((nextidQueue.IsEmpty) || (railNodes.Count < nextidQueue.Peek()))
                nextidQueue.Insert(railNodes.Count);
            nextid = nextidQueue.RemoveMin();//より小さいIdを使いたい
            //この時点でnextid<=railNodes.Countは確定
            if (nextid == railNodes.Count)
            {
                railNodes.Add(node);
                connectNodes.Add(new List<(int, int)>());
            }
            else
            {
                railNodes[nextid] = node;
            }

            railIdDic[node] = nextid;
        }

        //接続元RailNode、接続先RailNode、int距離
        public void ConnectNode(RailNode node, RailNode targetNode, int distance)
        {
            //nodeが辞書になければ追加
            if (!railIdDic.ContainsKey(node))
                AddNode(node);
            var nodeid = railIdDic[node];
            //targetが辞書になければ追加
            if (!railIdDic.ContainsKey(targetNode))
                AddNode(targetNode);
            var targetid = railIdDic[targetNode];
            connectNodes[nodeid].Add((targetid, distance));
        }
        //接続削除
        public void DisconnectNode(RailNode node, RailNode targetNode)
        {
            var nodeid = railIdDic[node];
            var targetid = railIdDic[targetNode];
            connectNodes[nodeid].RemoveAll(x => x.Item1 == targetid);
        }

        //ノードの削除。削除対象のノードに向かう経路の削除は別に行う必要がある
        public void RemoveNode(RailNode node)
        {
            var nodeid = railIdDic[node];
            railIdDic.Remove(node);
            railNodes[nodeid] = null;
            nextidQueue.Insert(nodeid);
            connectNodes[nodeid].Clear();
        }

        //RailNodeの入力に対しつながっているRailNodeをリスト<Nod>で返す
        //RailNodeの入力に対しRailNodeのリストで返すので少しややこしいことをしている
        public List<RailNode> GetConnectedNodes(RailNode node)
        {
            if (!railIdDic.ContainsKey(node))
                return new List<RailNode>();
            int nodeId = railIdDic[node];
            return connectNodes[nodeId].Select(x => railNodes[x.Item1]).ToList();
        }
        //RailNodeの入力に対しつながっているRailNodeをリスト<Node,距離int>で返す
        public List<(RailNode, int)> GetConnectedNodesWithDistance(RailNode node)
        {
            if (!railIdDic.ContainsKey(node))
                return new List<(RailNode, int)>();
            int nodeId = railIdDic[node];
            return connectNodes[nodeId].Select(x => (railNodes[x.Item1], x.Item2)).ToList();
        }


        //railnode2つの入力 start から target までの距離を返す。ここでは経路探索しないで直接つながっている2点間の距離を返す
        //つながっていない場合は-1を返して警告だす
        public int GetDistanceBetweenNodes(RailNode start, RailNode target)
        {
            if (!railIdDic.ContainsKey(start) || !railIdDic.ContainsKey(target)) 
            {
                Debug.LogWarning("RailNodeが登録されていません");
                return -1;
            }
            int startid = railIdDic[start];
            int targetid = railIdDic[target];
            foreach (var (neighbor, distance) in connectNodes[startid])
            {
                if (neighbor == targetid)
                    return distance;
            }
            //警告だす
            Debug.LogWarning("RailNodeがつながっていません" + startid + "to" + targetid + "");
            return -1;
        }


        /// <summary>
        /// ダイクストラ法を用いて開始ノードから目的地ノードまでの最短経路を計算します。
        /// この高速化のためにノードをintのIDで管理しています。
        /// generated by chat gpt 4o
        /// <returns>最短経路のノード順リスト</returns>
        public List<RailNode> FindShortestPath(RailNode startNode, RailNode targetNode)
        {
            return FindShortestPath(railIdDic[startNode], railIdDic[targetNode]);
        }

        public List<RailNode> FindShortestPath(int startid, int targetid)
        {
            // 優先度付きキュー（距離が小さい順）
            var priorityQueue = new PriorityQueue<int, int>();
            // 各ノードへの最短距離を記録する（初期値は無限大を表す int.MaxValue）
            List<int> distances = new List<int>();// 各ノードへの最短距離を記録する（初期値は無限大を表す int.MaxValue）
            List<int> previousNodes = new List<int>();// 各ノードの前に訪れたノード
            for (int i = 0; i < railNodes.Count; i++)
                distances.Add(int.MaxValue);
            for (int i = 0; i < railNodes.Count; i++)
                previousNodes.Add(-1);


            // 開始ノードの距離を0に設定し、優先度付きキューに追加
            distances[startid] = 0;
            priorityQueue.Enqueue(startid, 0);

            while (priorityQueue.Count > 0)
            {
                // 現在のノードを取得
                var currentNodecnt = priorityQueue.Dequeue();
                // 目的地に到達したら終了
                if (currentNodecnt == targetid)
                {
                    break;
                }

                // 現在のノードからつながる全てのノードを確認
                foreach (var (neighbor, distance) in connectNodes[currentNodecnt])
                {
                    int newDistance = distances[currentNodecnt] + distance;
                    // なにかの間違いでintがオーバーフローした場合(経路が長すぎたり)
                    if (newDistance < 0)
                        continue;
                    // より短い距離が見つかった場合
                    if (newDistance < distances[neighbor])
                    {
                        distances[neighbor] = newDistance;
                        previousNodes[neighbor] = currentNodecnt;
                        // キューに隣接ノードを追加または更新
                        priorityQueue.Enqueue(neighbor, newDistance);
                    }
                }
            }

            // 経路を逆順でたどる
            var path = new List<int>();
            var current = targetid;
            while (current != -1)
            {
                path.Add(current);
                current = previousNodes[current];
            }

            // 開始ノードまでたどり着けなかった場合は空のリストを返す
            if (path.Last() != startid)
            {
                return new List<RailNode>();
            }

            // 経路を正しい順序に並べて返す
            path.Reverse();
            var pathNodes = path.Select(id => railNodes[id]).ToList();
            return pathNodes;
        }











    }
}

```

moorestech_client/Assets/Scripts/Client.Skit/Character/BlinkSystem.cs
```cs
using DG.Tweening;
using UnityEngine;

namespace Client.Skit.Character
{
    public class BlinkSystem : MonoBehaviour
    {
        [SerializeField] private SkinnedMeshRenderer faceSkinnedMeshRenderer;
        [SerializeField] private string blinkBlendShapeName = "Blink";
        
        private int _blinkBlendShapeIndex;
        
        private float _blinkTimer;
        private bool _isBlinking;
        
        private void Start()
        {
            _blinkBlendShapeIndex = faceSkinnedMeshRenderer.sharedMesh.GetBlendShapeIndex(blinkBlendShapeName);
        }
        
        private void Update()
        {
            _blinkTimer -= Time.deltaTime;
            if (_blinkTimer <= 0)
            {
                _blinkTimer = Random.Range(2f, 4f);
                
                // DoTweenでウェイトを変更する
                DOTween.To(
                    () => faceSkinnedMeshRenderer.GetBlendShapeWeight(_blinkBlendShapeIndex),
                    x => faceSkinnedMeshRenderer.SetBlendShapeWeight(_blinkBlendShapeIndex, x),
                    100,
                    0.1f).OnComplete(() =>
                {
                    DOTween.To(
                        () => faceSkinnedMeshRenderer.GetBlendShapeWeight(_blinkBlendShapeIndex),
                        x => faceSkinnedMeshRenderer.SetBlendShapeWeight(_blinkBlendShapeIndex, x),
                        0,
                        0.1f);
                });
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerCrafterInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Block.ChainerCrafter;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class CraftChainerCrafterInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        [SerializeField] private List<ItemSlotObject> recipeInputItemSlotObjects;
        [SerializeField] private List<ItemSlotObject> recipeOutputItemSlotObjects;
        
        [SerializeField] private CraftChainerCrafterItemSelectModal itemSelectModal;
        
        private BlockGameObject _blockGameObject;
        private CancellationToken _gameObjectCancellationToken;
        
        private CraftingSolverRecipe _currentRecipe;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            _gameObjectCancellationToken = this.GetCancellationTokenOnDestroy();
            
            // アイテムリストを初期化
            // Initialize item list
            InitializeItemList();
            
            // レシピの情報を取得
            // Get recipe information
            InitializeRecipeSlots().Forget();
            
            itemSelectModal.Initialize();
            
            #region Internal
            
            void InitializeItemList()
            {
                var itemList = new List<IItemStack>();
                var param = (CraftChainerCrafterBlockParam)blockGameObject.BlockMasterElement.BlockParam;
                for (var i = 0; i < param.ItemSlotCount; i++)
                {
                    var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                    _blockItemSlotObjects.Add(slotObject);
                    itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
                }
                UpdateItemList(itemList);
            }
            
  #endregion
        }
        
        private async UniTask InitializeRecipeSlots()
        {
            _currentRecipe = await GetRecipe();
            if (_currentRecipe == null) return;
            
            SetRecipeUI(_currentRecipe);
            
            SetupRecipeSlotEvent();
            
            #region Internal
            
            async UniTask<CraftingSolverRecipe> GetRecipe()
            {
                var pos = _blockGameObject.BlockPosInfo.OriginalPos;
                var blockStates = await ClientContext.VanillaApi.Response.GetBlockState(pos, _gameObjectCancellationToken);
                if (blockStates == null) return null;
                
                var chainerState = blockStates.GetStateDetail<ChainerCrafterComponentSerializeObject>(ChainerCrafterComponentSerializeObject.StateDetailKey);
                if (chainerState == null) return null;
                
                return chainerState.Recipe.ToCraftingSolverRecipe();
            }
            
            void SetupRecipeSlotEvent()
            {
                for (var i = 0; i < recipeInputItemSlotObjects.Count; i++)
                {
                    var input = recipeInputItemSlotObjects[i];
                    var index = i;
                    input.OnLeftClickUp.Subscribe(item => ClickRecipeInputItem(item, index, true).Forget());
                }
                for (var i = 0; i < recipeOutputItemSlotObjects.Count; i++)
                {
                    var output = recipeOutputItemSlotObjects[i];
                    var index = i;
                    output.OnLeftClickUp.Subscribe(item => ClickRecipeInputItem(item, index, false).Forget());
                }
            }
            
            #endregion
        }
        
        private async UniTask ClickRecipeInputItem(ItemSlotObject itemSlotObject, int index, bool isInput)
        {
            // アイテムを選択
            // Select item
            var (resultId, resultCount) = await SelectItem();
            
            // レシピ情報を更新
            // Update recipe information
            UpdateRecipe();
            
            // UIを更新
            // Update UI
            SetRecipeUI(_currentRecipe);
            
            // レシピ情報を送信
            // Send recipe information
            SendRecipeInfo();
            
            #region Internal
            
            async UniTask<(ItemId,int)> SelectItem()
            {
                // モーダルを開いてアイテムを選択
                var currentId = itemSlotObject.ItemViewData?.ItemId ?? ItemMaster.EmptyItemId;
                var currentCount = itemSlotObject.Count;
                
                var (id, count) = await itemSelectModal.GetSelectItem(currentId, currentCount);
                
                return (id, count);
            }
            
            void UpdateRecipe()
            {
                var recipeItems = isInput ? _currentRecipe.Inputs : _currentRecipe.Outputs;
                
                if (index < recipeItems.Count)
                {
                    recipeItems[index] = new CraftingSolverItem(resultId, resultCount);
                }
                else
                {
                    for (var i = recipeItems.Count; i < index; i++)
                    {
                        recipeItems.Add(new CraftingSolverItem(ItemMaster.EmptyItemId, 0));
                    }
                    
                    recipeItems.Add(new CraftingSolverItem(resultId, resultCount));
                }
            }
            
            void SendRecipeInfo()
            {
                // 送る用に適切な形に変換
                var input = _currentRecipe.Inputs.Where(i => i.ItemId != ItemMaster.EmptyItemId).ToList();
                var output = _currentRecipe.Outputs.Where(i => i.ItemId != ItemMaster.EmptyItemId).ToList();
                
                var pos = _blockGameObject.BlockPosInfo.OriginalPos;
                ClientContext.VanillaApi.SendOnly.SetCraftChainerCrafterRecipe(pos, input, output);
            }
            
  #endregion
            
        }
        
        
        private void SetRecipeUI(CraftingSolverRecipe recipe)
        {
            SetItemSlot(recipeInputItemSlotObjects, recipe.Inputs);
            SetItemSlot(recipeOutputItemSlotObjects, recipe.Outputs);
            
            #region Internal
            
            void SetItemSlot(List<ItemSlotObject> itemSlots, List<CraftingSolverItem> items)
            {
                for (var i = 0; i < itemSlots.Count; i++)
                {
                    if (i >= items.Count)
                    {
                        itemSlots[i].SetItem(null, 0);
                        continue;
                    }
                    
                    var item = items[i];
                    var slotObject = itemSlots[i];
                    var itemView = ClientContext.ItemImageContainer.GetItemView(item.ItemId);
                    slotObject.SetItem(itemView, item.Count);
                }
            }
            
  #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/WorldBlockData.cs
```cs
using Core.Master;
using Game.Block.Interface;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    /// <summary>
    ///     TODO こういうのinterfaceにする
    /// </summary>
    public class WorldBlockData
    {
        public IBlock Block { get; }
        public BlockPositionInfo BlockPositionInfo { get; }
        
        public WorldBlockData(IBlock block, Vector3Int originalPos, BlockDirection blockDirection)
        {
            Block = block;
            var blockSize = MasterHolder.BlockMaster.GetBlockMaster(block.BlockId).BlockSize;
            BlockPositionInfo = new BlockPositionInfo(originalPos, blockDirection, blockSize);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/ItemListView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.Tutorial.UIHighlight;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Main;
using Core.Master;
using Game.CraftChainer.Util;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    public class ItemListView : MonoBehaviour
    {
        public const string ItemRecipeListHighlightKey = "itemRecipeList:{0}";
        
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        [SerializeField] private RectTransform itemListParent;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private ILocalPlayerInventory _localPlayerInventory;
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        private readonly List<ItemSlotObject> _itemListObjects = new();
        
        [Inject]
        public void Construct(ILocalPlayerInventory localPlayerInventory, ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            _localPlayerInventory = localPlayerInventory;
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;
            
            _localPlayerInventory.OnItemChange.Subscribe(OnInventoryItemChange);
            
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                
                // アイテムリストを設定
                // Set the item list
                var itemSlotObject = Instantiate(itemSlotObjectPrefab, itemListParent);
                itemSlotObject.SetItem(itemViewData, 0);
                itemSlotObject.OnLeftClickUp.Subscribe(OnClickItemList);
                _itemListObjects.Add(itemSlotObject);
                
                // ハイライトオブジェクトを設定
                // Set the highlight object
                var target = itemSlotObject.gameObject.AddComponent<UIHighlightTutorialTargetObject>();
                var itemMaster = MasterHolder.ItemMaster.GetItemMaster(itemId);
                target.Initialize(string.Format(ItemRecipeListHighlightKey, itemMaster.Name));
            }
        }
        
        private void OnClickItemList(ItemSlotObject slot)
        {
            var itemId = slot.ItemViewData.ItemId;
            var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
            _onClickItem.OnNext(itemRecipes);
        }
        
        private void OnInventoryItemChange(int slot)
        {
            var enableItem = CheckAllItemCraftable();
            foreach (var itemUI in _itemListObjects)
            {
                var isGrayOut = !enableItem.Contains(itemUI.ItemViewData.ItemId);
                itemUI.SetGrayOut(isGrayOut);
            }
            
            #region Internal
            
            HashSet<ItemId> CheckAllItemCraftable()
            {
                var itemPerCount = new Dictionary<ItemId, int>();
                foreach (var item in _localPlayerInventory)
                {
                    if (item.Id == ItemMaster.EmptyItemId) continue;
                    if (itemPerCount.ContainsKey(item.Id))
                        itemPerCount[item.Id] += item.Count;
                    else
                        itemPerCount.Add(item.Id, item.Count);
                }
                
                var result = new HashSet<ItemId>();
                
                foreach (var craftMaster in MasterHolder.CraftRecipeMaster.GetAllCraftRecipes())
                {
                    var resultItemId = MasterHolder.ItemMaster.GetItemId(craftMaster.CraftResultItemGuid);
                    if (result.Contains(resultItemId)) continue; //すでにクラフト可能なアイテムならスキップ
                    var isCraftable = true;
                    foreach (var requiredItem in craftMaster.RequiredItems)
                    {
                        var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                        if (!itemPerCount.ContainsKey(requiredItemId) || itemPerCount[requiredItemId] < requiredItem.Count)
                        {
                            isCraftable = false;
                            break;
                        }
                    }
                    
                    if (isCraftable) result.Add(resultItemId);
                }
                
                return result;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Update/GameUpdater.cs
```cs
using System;
using System.Threading;
using UniRx;

namespace Core.Update
{
    public static class GameUpdater
    {
        private static Subject<Unit> _updateSubject = new();
        
        private static DateTime _lastUpdateTime = DateTime.Now;
        public static IObservable<Unit> UpdateObservable => _updateSubject;
        
        [Obsolete("いつかアップデートシステム自体をリファクタしたい")] public static double UpdateSecondTime { get; private set; }
        
        public static void Update()
        {
            //アップデートの実行
            UpdateDeltaTime();
            _updateSubject.OnNext(Unit.Default);
        }
        
        public static void UpdateDeltaTime()
        {
            UpdateSecondTime = (DateTime.Now - _lastUpdateTime).TotalSeconds;
            _lastUpdateTime = DateTime.Now;
        }
        
        public static void ResetUpdate()
        {
            _updateSubject = new Subject<Unit>();
            UpdateSecondTime = 0;
            _lastUpdateTime = DateTime.Now;
        }
        
        public static void ResetTime()
        {
            _lastUpdateTime = DateTime.Now;
            UpdateSecondTime = 0;
        }
        
        public static void Dispose()
        {
            _updateSubject.Dispose();
        }
        
#if UNITY_EDITOR
        public static void UpdateWithWait()
        {
            //TODO ゲームループ周りの修正についてはちょっと考えたい
            Update();
            Wait();
        }
        
        public static void SpecifiedDeltaTimeUpdate(double updateSecondTime)
        {
            UpdateSecondTime = updateSecondTime;
            _updateSubject.OnNext(Unit.Default);
        }
        
        public static void Wait()
        {
            Thread.Sleep(5);
        }
#endif
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/StartServer.cs
```cs
using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Game.SaveLoad.Interface;
using Microsoft.Extensions.DependencyInjection;
using Mod.Base;
using Mod.Loader;
using Server.Boot.PacketHandle;
using UnityEngine;

namespace Server.Boot
{
    public static class StartServer
    {
        private const int ArgsCount = 1;
        
        private static string DebugServerDirectory =>
            Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, "../moorestech_client/Server"));
        
        private static string StartupFromClientFolderPath
        {
            get
            {
                var di = new DirectoryInfo(Environment.CurrentDirectory);
                return Path.Combine(di.FullName, "server", "mods");
            }
        }
        
        public static (Thread serverUpdateThread, CancellationTokenSource autoSaveTokenSource) Start(string[] args)
        {
            //カレントディレクトリを表示
#if DEBUG
            var serverDirectory = DebugServerDirectory;
#else
            var serverDirectory = Path.GetDirectoryName(Application.dataPath);
#endif
            
            Debug.Log("データをロードします　パス:" + serverDirectory);
            
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(serverDirectory);
            
            //マップをロードする
            serviceProvider.GetService<IWorldSaveDataLoader>().LoadOrInitialize();
            
            //modのOnLoadコードを実行する
            var modsResource = serviceProvider.GetService<ModsResource>();
            modsResource.Mods.ToList().ForEach(
                m => m.Value.ModEntryPoints.ForEach(
                    e =>
                    {
                        Debug.Log("Modをロードしました modId:" + m.Value + " className:" + e.GetType().Name);
                        e.OnLoad(new ServerModEntryInterface(serviceProvider, packet));
                    }));
            
            
            //サーバーの起動とゲームアップデートの開始
            var serverUpdateThread = new Thread(() => new PacketHandler().StartServer(packet));
            serverUpdateThread.Name = "[moorestech]通信受け入れスレッド";
            
            var autoSaveTaskTokenSource = new CancellationTokenSource();
            Task.Run(
                () => new AutoSaveSystem(serviceProvider.GetService<IWorldSaveDataSaver>()).AutoSave(
                    autoSaveTaskTokenSource), autoSaveTaskTokenSource.Token);
            
            return (serverUpdateThread, autoSaveTaskTokenSource);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/Input/ScreenClickableCameraController.cs
```cs
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.Control;
using Client.Input;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState.Input
{
    /// <summary>
    /// 画面上の要素をクリックできるようなとき（ブロック設置など）のカメラ操作
    /// Camera operation when elements on the screen can be clicked (e.g., block placement)
    /// </summary>
    public class ScreenClickableCameraController
    {
        private readonly InGameCameraController _inGameCameraController;
        
        private const float TargetCameraDistance = 9;
        private const float TweenDuration = 0.25f;
        
        private Vector3? _startCameraRotation;
        private float? _startCameraDistance;
        
        public ScreenClickableCameraController(InGameCameraController inGameCameraController)
        {
            _inGameCameraController = inGameCameraController;
        }
        
        public void OnEnter()
        {
            InputManager.MouseCursorVisible(true);
        }
        
        public void GetNextUpdate()
        {
            //TODO InputSystemのリファクタ対象
            if (UnityEngine.Input.GetMouseButtonDown(1))
            {
                InputManager.MouseCursorVisible(false);
                _inGameCameraController.SetControllable(true);
            }
            
            //TODO InputSystemのリファクタ対象
            if (UnityEngine.Input.GetMouseButtonUp(1))
            {
                InputManager.MouseCursorVisible(true);
                _inGameCameraController.SetControllable(false);
            }
        }
        
        public void OnExit()
        {
            if (_startCameraRotation.HasValue && _startCameraDistance.HasValue)
            {
                var startCameraRotation = _startCameraRotation.Value;
                var startCameraDistance = _startCameraDistance.Value;
                _inGameCameraController.StartTweenCamera(startCameraRotation, startCameraDistance, TweenDuration);
            }
            
            InputManager.MouseCursorVisible(false);
        }
        
        /// <summary>
        /// 上からのビューにカメラを移動させる
        /// Move the camera to a top view
        /// </summary>
        /// <returns>start camera position</returns>
        public TweenCameraInfo StartTweenFromTop()
        {
            _startCameraDistance = _inGameCameraController.CameraDistance;
            _startCameraRotation = _inGameCameraController.CameraEulerAngle;
            
            TweenCamera(new TweenCameraInfo(new Vector3(70, 0, 0), TargetCameraDistance));
            
            return new TweenCameraInfo(_inGameCameraController.CameraEulerAngle, _inGameCameraController.CameraDistance);
            
            #region Internal
            
            void TweenCamera()
            {
            }
            
            #endregion
        }
        
        public void TweenCamera(TweenCameraInfo tweenCameraInfo)
        {
            var currentRotation = _inGameCameraController.CameraEulerAngle;
            var targetCameraRotation = currentRotation;
            targetCameraRotation.x = 70f;
            targetCameraRotation.y = currentRotation.y switch
            {
                var y when y < 45 => 0,
                var y when y < 135 => 90,
                var y when y < 225 => 180,
                var y when y < 315 => 270,
                _ => 0
            };
            _inGameCameraController.StartTweenCamera(targetCameraRotation, TargetCameraDistance, TweenDuration);
        }
        
        public void TweenCamera()
        {
            
        }
    }
    
    public class TweenCameraInfo
    {
        public readonly Vector3 StartRotation;
        public readonly float StartDistance;
        
        public TweenCameraInfo(Vector3 startRotation, float startDistance)
        {
            StartRotation = startRotation;
            StartDistance = startDistance;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ItemStackTest.cs
```cs
using System;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Other
{
    public class ItemStackTest
    {
        private const int EmptyItemId = 0;
        private IItemStackFactory _itemStackFactory;
        
        [SetUp]
        public void Setup()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            _itemStackFactory = ServerContext.ItemStackFactory;
        }
        
        [TestCase(1, 1, 1, 1, 2, 0, 1, EmptyItemId)]
        [TestCase(1, 5, 1, 1, 6, 0, 1, EmptyItemId)]
        [TestCase(EmptyItemId, 0, 1, 3, 3, 0, 1, EmptyItemId)]
        [TestCase(EmptyItemId, 0, 2, 9, 9, 0, 2, EmptyItemId)]
        [TestCase(EmptyItemId, 5, 1, 1, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 1, EmptyItemId, 0, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 1, EmptyItemId, 0, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 5, EmptyItemId, 0, 5, 0, 1, EmptyItemId)]
        [TestCase(3, 1, 1, 8, 1, 8, 3, 1)]
        [TestCase(1, 1, 3, 1, 1, 1, 1, 3)]
        [TestCase(2, 5, 5, 3, 5, 3, 2, 5)]
        public void AddTest(int mid, int mamo, int rid, int ramo, int ansMAmo, int ansRAmo, int ansMid, int ansRID)
        {
            IItemStack mineItemStack;
            if (mid == EmptyItemId)
                mineItemStack = _itemStackFactory.CreatEmpty();
            else
                mineItemStack = _itemStackFactory.Create(new ItemId(mid), mamo);
            
            IItemStack receivedItemStack;
            if (rid == EmptyItemId)
                receivedItemStack = _itemStackFactory.CreatEmpty();
            else
                receivedItemStack = _itemStackFactory.Create(new ItemId(rid), ramo);
            
            var result = mineItemStack.AddItem(receivedItemStack);
            Assert.AreEqual(result.ProcessResultItemStack.Count, ansMAmo);
            Assert.AreEqual(result.RemainderItemStack.Count, ansRAmo);
            Assert.AreEqual(result.ProcessResultItemStack.Id, ansMid);
            Assert.AreEqual(result.RemainderItemStack.Id, ansRID);
        }
        
        [TestCase(1, 5, 1, 4, 1)]
        [TestCase(EmptyItemId, 5, 1, 0, EmptyItemId)]
        [TestCase(1, 5, 10, 0, EmptyItemId)]
        [TestCase(1, 8, 8, 0, EmptyItemId)]
        [TestCase(1, 8, 9, 0, EmptyItemId)]
        public void SubTest(int mid, int mamo, int subamo, int ansamo, int ansID)
        {
            IItemStack mineItemStack;
            if (mid == EmptyItemId)
                mineItemStack = _itemStackFactory.CreatEmpty();
            else
                mineItemStack = _itemStackFactory.Create(new ItemId(mid), mamo);
            
            var result = mineItemStack.SubItem(subamo);
            Assert.AreEqual(ansamo, result.Count);
            Assert.AreEqual(ansID, result.Id.AsPrimitive());
        }
        
        
        [TestCase(3, 299, 0, 0)]
        [TestCase(3, 299, 1, 0)]
        [TestCase(3, 150, 150, 0)]
        [TestCase(3, 300, 1, 1)]
        [TestCase(3, 1, 300, 1)]
        [TestCase(3, 300, 300, 300)]
        public void ItemAddToOverFlowTest(int id, int baseAmount, int addAmount, int overflowAmount)
        {
            var baseItem = _itemStackFactory.Create(new ItemId(id), baseAmount);
            
            
            var result = baseItem.AddItem(_itemStackFactory.Create(new ItemId(id), addAmount));
            Assert.True(_itemStackFactory.Create(new ItemId(id), overflowAmount).Equals(result.RemainderItemStack));
        }
        
        [TestCase(1, 100, false)]
        [TestCase(1, 1001, true)]
        [TestCase(1, 200, true)]
        public void ItemAddToOverFlowThrowTest(int id, int baseAmo, bool isthrow)
        {
            try
            {
                _itemStackFactory.Create(new ItemId(id), baseAmo);
                Assert.False(isthrow);
            }
            catch (Exception e)
            {
                Assert.True(isthrow);
            }
        }
        
        
        //関係ないオブジェクトを渡すFalseになるテスト
        [TestCase(0)]
        [TestCase(1.5)]
        [TestCase("aaa")]
        public void NotRelatedObjectPassFalseHaveTest(object obj)
        {
            var nullItem = _itemStackFactory.CreatEmpty();
            Assert.False(nullItem.Equals(obj));
            var item = _itemStackFactory.Create(new ItemId(5), 1);
            Assert.False(item.Equals(obj));
        }
        
        [Test]
        public void ToStringTest()
        {
            var item = _itemStackFactory.CreatEmpty();
            Assert.True(item.ToString() == "ID:0 Count:0");
            item = _itemStackFactory.Create(new ItemId(1), 5);
            Assert.True(item.ToString() == "ID:1 Count:5");
            item = _itemStackFactory.Create(new ItemId(13), 10);
            Assert.True(item.ToString() == "ID:13 Count:10");
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/BlockMaster.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Mooresmaster.Loader.BlocksModule;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json.Linq;
using UnitGenerator;
using UnityEngine;

namespace Core.Master
{
    // アイテムId専用の方を定義
    // NOTE このIDは永続化されれることはなく、メモリ上、ネットワーク通信上でのみ使用する値
    [UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter | UnitGenerateOptions.Comparable)]
    public partial struct BlockId
    {
    }
    
    public class BlockMaster
    {
        public readonly Blocks Blocks;
        
        private readonly Dictionary<BlockId, BlockMasterElement> _blockElementTableById;
        private readonly Dictionary<Guid, BlockId> _blockGuidToBlockId;
        
        private readonly Dictionary<ItemId, BlockId> _itemIdToBlockId;
        
        public BlockMaster(JToken blockJToken, ItemMaster itemMaster)
        {
            // GUIDの順番にint型のItemIdを割り当てる
            Blocks = BlocksLoader.Load(blockJToken);
            var sortedBlockElements = Blocks.Data.ToList().OrderBy(x => x.BlockGuid).ToList();
            
            // アイテムID 0は空のアイテムとして予約しているので、1から始める
            _blockElementTableById = new Dictionary<BlockId, BlockMasterElement>();
            _blockGuidToBlockId = new Dictionary<Guid, BlockId>();
            for (var i = 0; i < sortedBlockElements.Count; i++)
            {
                var blockId = new BlockId(i + 1); // アイテムID 0は空のアイテムとして予約しているので、1から始める
                _blockElementTableById.Add(blockId, sortedBlockElements[i]);
                _blockGuidToBlockId.Add(sortedBlockElements[i].BlockGuid, blockId);
            }
            
            // itemId to blockId
            _itemIdToBlockId = new Dictionary<ItemId, BlockId>();
            foreach (var blockElement in Blocks.Data)
            {
                var itemId = itemMaster.GetItemId(blockElement.ItemGuid);
                if (_itemIdToBlockId.TryGetValue(itemId, out var blockId))
                {
                    throw new InvalidOperationException($"Duplicate itemId. ItemId:{blockElement.ItemGuid} BlockId:{blockElement.BlockGuid}");
                }
                else
                {
                    _itemIdToBlockId.Add(itemId, _blockGuidToBlockId[blockElement.BlockGuid]);
                }
            }
        }
        
        public BlockMasterElement GetBlockMaster(BlockId blockId)
        {
            if (!_blockElementTableById.TryGetValue(blockId, out var element))
            {
                throw new InvalidOperationException($"BlockElement not found. BlockId:{blockId}");
            }
            
            return element;
        }
        
        public BlockMasterElement GetBlockMaster(Guid blockGuid)
        {
            var blockId = GetBlockId(blockGuid);
            return GetBlockMaster(blockId);
        }
        
        public BlockId GetBlockId(Guid blockGuid)
        {
            if (!_blockGuidToBlockId.TryGetValue(blockGuid, out var blockId))
            {
                throw new InvalidOperationException($"ItemElement not found. ItemGuid:{blockGuid}");
            }
            
            return blockId;
        }
        
        public List<BlockId> GetBlockIds()
        {
            return _blockElementTableById.Keys.ToList();
        }
        
        public bool IsBlock(ItemId itemId)
        {
            return _itemIdToBlockId.ContainsKey(itemId);
        }
        
        public BlockId GetBlockId(ItemId itemId)
        {
            return _itemIdToBlockId[itemId];
        }
        
        public ItemId GetItemId(BlockId blockId)
        {
            foreach (var pair in _itemIdToBlockId)
            {
                if (pair.Value == blockId)
                {
                    return pair.Key;
                }
            }
            
            throw new InvalidOperationException($"ItemElement not found. BlockId:{blockId}");
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Inventory/InventoryInsertItem.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;

namespace Core.Inventory
{
    /// <summary>
    ///     インベントリに挿入するアイテムの処理だけを行います
    /// </summary>
    internal static class InventoryInsertItem
    {
        /// <summary>
        ///     引数のインベントリ用アイテム配列に対して複数のアイテム挿入処理を行う
        /// </summary>
        /// <param name="insertItemStack">挿入したいアイテムリスト</param>
        /// <param name="inventoryItems">挿入するインベントリのアイテムリスト</param>
        /// <param name="itemStackFactory">アイテム作成用のItemStackFactory</param>
        /// <param name="onSlotUpdate">挿入後発火したいイベント</param>
        /// <returns>余ったアイテム</returns>
        internal static List<IItemStack> InsertItem(List<IItemStack> insertItemStack, List<IItemStack> inventoryItems, IItemStackFactory itemStackFactory, Action<int> onSlotUpdate = null)
        {
            var reminderItemStacks = new List<IItemStack>();
            
            foreach (var item in insertItemStack)
            {
                var remindItemStack = InsertItem(item, inventoryItems, itemStackFactory, onSlotUpdate);
                if (remindItemStack.Equals(itemStackFactory.CreatEmpty())) continue;
                
                reminderItemStacks.Add(remindItemStack);
            }
            
            return reminderItemStacks;
        }
        
        
        /// <summary>
        ///     引数のインベントリ用アイテム配列に対して挿入処理を行う
        /// </summary>
        /// <param name="insertItemStack">挿入したいアイテム</param>
        /// <param name="inventoryItems">挿入するインベントリのアイテムリスト</param>
        /// <param name="itemStackFactory">アイテム作成用のItemStackFactory</param>
        /// <param name="onSlotUpdate">挿入後発火したいイベント</param>
        /// <returns>余ったアイテム</returns>
        internal static IItemStack InsertItem(IItemStack insertItemStack, List<IItemStack> inventoryItems, IItemStackFactory itemStackFactory, Action<int> onSlotUpdate = null)
        {
            for (var i = 0; i < inventoryItems.Count; i++)
            {
                //挿入できるスロットを探索
                if (!inventoryItems[i].IsAllowedToAddWithRemain(insertItemStack)) continue;
                
                //挿入実行
                var remain = InsertionItemBySlot(i, insertItemStack, inventoryItems, itemStackFactory, onSlotUpdate);
                
                //挿入結果が空のアイテムならそのまま処理を終了
                if (remain.Equals(itemStackFactory.CreatEmpty())) return remain;
                //そうでないならあまりのアイテムを入れるまで探索
                insertItemStack = remain;
            }
            
            return insertItemStack;
        }
        
        /// <summary>
        ///     特定のスロットを優先してアイテムを挿入します
        ///     優先すべきスロットに入らない場合は、通常通り挿入処理を行います
        /// </summary>
        public static IItemStack InsertItemWithPrioritySlot(IItemStack itemStack, List<IItemStack> inventory, IItemStackFactory itemStackFactory, int[] prioritySlots, Action<int> invokeEvent)
        {
            //優先スロットに挿入を試みる
            var remainItem = itemStack;
            foreach (var prioritySlot in prioritySlots)
                remainItem = InsertionItemBySlot(prioritySlot, remainItem, inventory, itemStackFactory, invokeEvent);
            
            //優先スロットに入り切らなかったアイテムは通常のインサート処理を行う
            return InsertItem(remainItem, inventory, itemStackFactory, invokeEvent);
        }
        
        /// <summary>
        ///     指定されたスロットにアイテムを挿入する
        /// </summary>
        /// <returns>余ったアイテム 余ったアイテムがなければ空のアイテムを返す</returns>
        private static IItemStack InsertionItemBySlot(int slot, IItemStack itemStack, List<IItemStack> inventoryItems, IItemStackFactory itemStackFactory, Action<int> onSlotUpdate = null)
        {
            if (itemStack.Equals(itemStackFactory.CreatEmpty())) return itemStack;
            if (!inventoryItems[slot].IsAllowedToAddWithRemain(itemStack)) return itemStack;
            
            var result = inventoryItems[slot].AddItem(itemStack);
            
            //挿入を試した結果が今までと違う場合は入れ替えをしてイベントを発火
            if (!inventoryItems[slot].Equals(result.ProcessResultItemStack))
            {
                inventoryItems[slot] = result.ProcessResultItemStack;
                onSlotUpdate?.Invoke(slot);
            }
            
            return result.RemainderItemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailNode.cs
```cs
using Game.Train.Blocks;
using System.Collections.Generic;
/// <summary>
/// 距離はint型で表現している。理由はNotion参照
/// </summary>

namespace Game.Train.RailGraph
{
    public class RailNode
    {
        //public RailNodeId NodeId { get; }  // ノードを識別するためのユニークなID→一旦廃止。RailGraphだけが使うためのNodeIdは存在する
        //Node（このクラスのインスタンス）とIdの違いに注意。また、このクラスではIdは一切使わない


        // 駅であれば駅のコンポーネント、なければnull
        public StationComponent Station { get; private set; }
        // 自分に対応する裏表のノード
        public RailNode OppositeNode { get; private set; }
        private readonly RailGraphDatastore _railGraph; // Graph への参照


        /// なぜ IEnumerable を使うのか？
        //IEnumerable<RailNode> を使う理由には以下があります：
        //柔軟性:
        //  使用する側で foreach を使って簡単に列挙できる。
        //  必要に応じてリストや配列に変換可能。
        //遅延評価:
        //  コレクションが大きい場合でも、全体を一度にメモリに読み込む必要がない。
        //抽象化:
        //  呼び出し元に具体的なコレクションの型（List<T> や Array など）を意識させない。
        /// </summary>
        public IEnumerable<RailNode> ConnectedNodes
        {
            get
            { return _railGraph.GetConnectedNodes(this); }
        }
        public IEnumerable<(RailNode, int)> ConnectedNodesWithDistance
        {
            get
            { return _railGraph.GetConnectedNodesWithDistance(this); }
        }

        public RailNode(RailGraphDatastore railGraph, StationComponent station = null)
        {
            _railGraph = railGraph;
            Station = station;
            railGraph.AddNode(this);
        }

        //RailNode oppositeNode のset。基本的にrailComponentのコンストラクタでのみ使う
        public void SetOppositeNode(RailNode oppositeNode)
        {
            OppositeNode = oppositeNode;
        }


        //RailGraphに登録する
        public void ConnectNode(RailNode targetNode, int distance)
        {
            _railGraph.ConnectNode(this, targetNode, distance);
        }
        //自分から入力nodeまでの距離を返す
        public int GetDistanceToNode(RailNode node)
        {
            return _railGraph.GetDistanceBetweenNodes(this, node);
        }


    }

}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/AssembleSaveJsonTextTest.cs
```cs
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class AssembleSaveJsonTextTest
    {
        //ブロックを追加した時のテスト
        [Test]
        public void SimpleBlockPlacedTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            worldBlockDatastore.TryAddBlock((BlockId)1, Vector3Int.zero, BlockDirection.North, out var block0);
            worldBlockDatastore.TryAddBlock((BlockId)2, new Vector3Int(10, -15), BlockDirection.North, out var block1);
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            
            Debug.Log(json);
            
            var (_, loadServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            (loadServiceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(json);
            
            var worldLoadBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var b0 = worldLoadBlockDatastore.GetBlock(new Vector3Int(0, 0));
            Assert.AreEqual(1, b0.BlockId.AsPrimitive());
            Assert.AreEqual(block0.BlockInstanceId, b0.BlockInstanceId.AsPrimitive());
            
            var b1 = worldLoadBlockDatastore.GetBlock(new Vector3Int(10, -15));
            Assert.AreEqual(2, b1.BlockId.AsPrimitive());
            Assert.AreEqual(block1.BlockInstanceId, b1.BlockInstanceId.AsPrimitive());
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyConnectUpdaterContainer.cs
```cs
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     電柱や機械が設置されたときに、セグメントへの接続、切断を行うイベントクラスをまとめたクラス
    /// </summary>
    public class EnergyConnectUpdaterContainer<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        public EnergyConnectUpdaterContainer(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore, MaxElectricPoleMachineConnectionRange maxElectricPoleMachineConnectionRange)
        {
            new ConnectElectricPoleToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>(worldEnergySegmentDatastore);
            new ConnectMachineToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>(worldEnergySegmentDatastore, maxElectricPoleMachineConnectionRange);
            
            new DisconnectElectricPoleToFromElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>(worldEnergySegmentDatastore);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlacePreview.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Mooresmaster.Model.BlocksModule;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPlacePreview : MonoBehaviour, IBlockPlacePreview
    {
        private BlockMasterElement _previewBlockMasterElement;
        private BlockPlacePreviewObjectPool _blockPlacePreviewObjectPool;
        
        public bool IsActive => gameObject.activeSelf;
        
        
        private void Awake()
        {
            _blockPlacePreviewObjectPool = new BlockPlacePreviewObjectPool(transform);
            SetActive(false);
        }
        
        public List<bool> SetPreviewAndGroundDetect(List<PlaceInfo> placePointInfos, BlockMasterElement holdingBlockMaster)
        {
            // さっきと違うブロックだったら削除する
            if (_previewBlockMasterElement == null || _previewBlockMasterElement.BlockGuid != holdingBlockMaster.BlockGuid)
            {
                _previewBlockMasterElement = holdingBlockMaster;
                _blockPlacePreviewObjectPool.AllDestroy();
            }
            
            _blockPlacePreviewObjectPool.AllUnUse();
            
            // プレビューブロックの位置を設定
            var isGroundDetectedList = new List<bool>();
            foreach (var placeInfo in placePointInfos)
            {
                var blockId = holdingBlockMaster.BlockGuid.GetVerticalOverrideBlockId(placeInfo.VerticalDirection);
                
                var pos = SlopeBlockPlaceSystem.GetBlockPositionToPlacePosition(placeInfo.Position, placeInfo.Direction, blockId);
                var rot = placeInfo.Direction.GetRotation();
                
                var previewBlock = _blockPlacePreviewObjectPool.GetObject(blockId);
                previewBlock.SetTransform(pos,rot);
                var isGroundDetected = previewBlock.IsCollisionGround;
                isGroundDetectedList.Add(isGroundDetected);
                
                previewBlock.SetPlaceableColor(!isGroundDetected && placeInfo.Placeable);
            }
            
            return isGroundDetectedList;
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/GearNetworkTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    public class GearNetworkTest
    {
        [Test]
        //シンプルジェネレーターを設置し、簡易的な歯車NWを作り、RPM、回転方向があっているかをテスト
        //Install a simple generator, make a simple gear NW, and test if RPM and direction of rotation are correct.
        public void SimpleGeneratorAndGearRpmTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, new Vector3Int(0, 0, 0), BlockDirection.North, out var generator);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Shaft, new Vector3Int(0, 0, 1), BlockDirection.North, out var shaft);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BigGear, new Vector3Int(-1, -1, 2), BlockDirection.North, out var bigGear);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, new Vector3Int(2, 0, 2), BlockDirection.North, out var smallGear);
            
            //ネットワークをアップデート
            //Update the network
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDatastore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            //ジェネレーターの供給が正しいか
            //Is the generator supply correct?
            var generatorComponent = generator.GetComponent<IGearGenerator>();
            Assert.AreEqual(10.0f, generatorComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, generatorComponent.GenerateIsClockwise);
            
            //シャフトの回転は正しいか
            //Is the rotation of the shaft correct?
            var shaftComponent = shaft.GetComponent<GearEnergyTransformer>();
            Assert.AreEqual(10.0f, shaftComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, shaftComponent.IsCurrentClockwise);
            
            //BigGearの回転は正しいか
            //Is the rotation of BigGear correct?
            var bigGearComponent = bigGear.GetComponent<GearComponent>();
            Assert.AreEqual(10.0f, bigGearComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, bigGearComponent.IsCurrentClockwise);
            
            //SmallGearの回転は正しいか
            //Is the rotation of SmallGear correct?
            var smallGearComponent = smallGear.GetComponent<GearComponent>();
            Assert.AreEqual(20.0f, smallGearComponent.CurrentRpm.AsPrimitive()); // ギア比2:1 Gear ratio 2:1
            Assert.AreEqual(false, smallGearComponent.IsCurrentClockwise); // 回転が反転する Rotation is reversed
        }
        
        [Test]
        // ループした歯車NWを作成し、RPM、回転方向があっているかをテスト
        // Create a looped gear NW and test if RPM and direction of rotation are correct.
        public void LoopGearNetworkTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            // C - D
            // |   |
            // A - B
            //
            // A = 0,0,0
            // GeneratorはGearの下に
            
            const float rpm = 10.0f;
            
            var gearPositionA = new Vector3Int(0, 0, 0);
            var gearPositionB = new Vector3Int(1, 0, 0);
            var gearPositionC = new Vector3Int(0, 0, 1);
            var gearPositionD = new Vector3Int(1, 0, 1);
            var generatorPosition = new Vector3Int(0, 0, -1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.InfinityTorqueSimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionA, BlockDirection.North, out var smallGearABlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionB, BlockDirection.North, out var smallGearBBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionC, BlockDirection.North, out var smallGearCBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionD, BlockDirection.North, out var smallGearDBlock);
            
            var generator = generatorBlock.GetComponent<IGearGenerator>();
            var smallGearA = smallGearABlock.GetComponent<GearComponent>();
            var smallGearB = smallGearBBlock.GetComponent<GearComponent>();
            var smallGearC = smallGearCBlock.GetComponent<GearComponent>();
            var smallGearD = smallGearDBlock.GetComponent<GearComponent>();
            
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            // Generatorの回転方向とRPMのテスト
            Assert.AreEqual(rpm, generator.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, generator.IsCurrentClockwise);
            
            // smallGearAの回転方向とRPMのテスト
            Assert.AreEqual(rpm, smallGearA.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, smallGearA.IsCurrentClockwise);
            
            // smallGearBの回転方向とRPMのテスト
            Assert.AreEqual(rpm, smallGearB.CurrentRpm.AsPrimitive());
            Assert.AreEqual(false, smallGearB.IsCurrentClockwise);
            
            // smallGearCの回転方向とRPMのテスト
            Assert.AreEqual(rpm, smallGearC.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, smallGearC.IsCurrentClockwise);
            
            // smallGearDの回転方向とRPMのテスト
            Assert.AreEqual(rpm, smallGearD.CurrentRpm.AsPrimitive());
            Assert.AreEqual(false, smallGearD.IsCurrentClockwise);
        }
        
        [Test]
        // BigGearを使ってRPMを変えたSmallGearと、RPMを変えていないSmallGearを無理やりつなぎ、ロックされることをテストする
        // Using BigGear, forcibly connect SmallGear with a different RPM and SmallGear with an unchanged RPM, and test that it locks.
        public void DifferentRpmGearNetworkToRockTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPos = new Vector3Int(1, 1, 0); // 大歯車を使ってRPMを変化させた側の歯車
            var bigGearPos = new Vector3Int(0, 0, 1); // Gears on the side that changed RPM with large gears
            var smallGear1Pos = new Vector3Int(3, 1, 1);
            
            var smallGear2Pos = new Vector3Int(1, 1, 2); // RPMを変化させていない側の歯車（回転方向を変えないために2つの小歯車をつかう）
            
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPos, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BigGear, bigGearPos, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear2Pos, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear1Pos, BlockDirection.North, out var smallGear1);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear2Pos, BlockDirection.North, out var smallGear2);
            
            //RPMが違う歯車同士を強制的に接続
            //Force connection between gears with different RPM
            ForceConnectGear(smallGear1, smallGear2);
            
            // find the network
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDatastore.GearNetworks.First().Value;
            
            Assert.NotNull(gearNetwork);
            
            //ネットワークをアップデート
            //Update the network
            gearNetwork.ManualUpdate();
            
            // ネットワークがロックされているかどうかを確認する
            Assert.IsTrue(gearNetwork.GearTransformers.All(g => g.IsRocked));
            Assert.IsTrue(gearNetwork.GearGenerators.All(g => g.IsRocked));
        }
        
        [Test]
        public void DifferentDirectionGearNetworkToRockTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 0);
            
            var gearPosition3 = new Vector3Int(0, 0, -1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out var gear2);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition3, BlockDirection.North, out var gear3);
            
            //回転方向が違う歯車同士を強制的に接続
            //Forced connection of gears with different directions of rotation
            ForceConnectGear(gear2, gear3);
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            // ネットワークがロックされているかどうかを確認する
            Assert.IsTrue(gearNetwork.GearTransformers.All(g => g.IsRocked));
            Assert.IsTrue(gearNetwork.GearGenerators.All(g => g.IsRocked));
        }
        
        [Test]
        public void MultiGeneratorOverrideRpmTest()
        {
            // 複数のジェネレーターのRPMがオーバーライドされるテスト
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var fastGeneratorPosition = new Vector3Int(0, 0, 0);
            var fastGeneratorGearPosition = new Vector3Int(0, 0, 1);
            var smallGearAPosition = new Vector3Int(1, 0, 1);
            var generatorPosition = new Vector3Int(2, 0, 0);
            var generatorGearPosition = new Vector3Int(2, 0, 1);
            var smallGearBPosition = new Vector3Int(3, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleFastGearGenerator, fastGeneratorPosition, BlockDirection.North, out var fastGeneratorBlock);
            var fastGenerator = fastGeneratorBlock.GetComponent<IGearGenerator>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, fastGeneratorGearPosition, BlockDirection.North, out _);
            
            // SmallGearA
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGearAPosition, BlockDirection.North, out var smallGearABlock);
            var smallGearA = smallGearABlock.GetComponent<GearComponent>();
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            var generator = generatorBlock.GetComponent<IGearGenerator>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, generatorGearPosition, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGearBPosition, BlockDirection.North, out var smallGearBBlock);
            var smallGearB = smallGearBBlock.GetComponent<GearComponent>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(fastGenerator.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(smallGearA.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(generator.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(smallGearB.CurrentRpm.AsPrimitive(), 20f);
        }
        
        [Test]
        public void MultiGeneratorDifferentDirectionToRockTest()
        {
            // 複数のジェネレーターの回転方向が違うことでロックされるテスト
            // Gen1 - Gear1 このような構成になっている
            //        Gear2
            // Gen2 - Gear3
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generator1Position = new Vector3Int(0, 0, 0);
            var generator2Position = new Vector3Int(1, 0, 0);
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generator1Position, BlockDirection.North, out var generator1Block);
            var generator1 = generator1Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generator2Position, BlockDirection.North, out var generator2Block);
            var generator2 = generator2Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out var gear1Block);
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out var gear2Block);
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.IsTrue(generator1.IsRocked);
            Assert.IsTrue(generator2.IsRocked);
            Assert.IsTrue(gear1.IsRocked);
            Assert.IsTrue(gear2.IsRocked);
        }
        
        [Test]
        public void ServeTorqueTest()
        {
            // 機械によってトルクが消費されるテスト（正しいトルクが供給されるかのテスト
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 1);
            var gearPosition3 = new Vector3Int(2, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition1, BlockDirection.North, out var gear1Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition2, BlockDirection.North, out var gear2Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition3, BlockDirection.North, out var gear3Block);
            
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            var gear3 = gear3Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(10, gear1.CurrentPower.AsPrimitive());
            Assert.AreEqual(10, gear2.CurrentPower.AsPrimitive());
            Assert.AreEqual(10, gear3.CurrentPower.AsPrimitive());
        }
        
        [Test]
        public void ServeTorqueOverTest()
        {
            //トルクが多いとその分供給トルクが減るテスト
            // ジェネレーターは3のトルクを生成するが、6つの歯車がつながっているため、要求するトルクは6になる
            // 結果、供給されるトルクは3/6=0.5になる
            // Test that the supply torque decreases as the torque increases
            // The generator generates 3 torque, but since it is connected to 6 gears, the required torque becomes 6
            // As a result, the supplied torque becomes 3/6=0.5
            
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            var generator = generatorBlock.GetComponent<SimpleGearGeneratorComponent>();
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(0, 0, 2);
            var gearPosition3 = new Vector3Int(1, 0, 2);
            var gearPosition4 = new Vector3Int(2, 0, 2);
            var gearPosition5 = new Vector3Int(2, 0, 3);
            var gearPosition6 = new Vector3Int(3, 0, 3);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition1, BlockDirection.North, out var gear1Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth20RequireTorqueTestGear, gearPosition2, BlockDirection.North, out var gear2Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition3, BlockDirection.North, out var gear3Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition4, BlockDirection.North, out var gear4Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth20RequireTorqueTestGear, gearPosition5, BlockDirection.North, out var gear5Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition6, BlockDirection.North, out var gear6Block);
            
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            var gear3 = gear3Block.GetComponent<IGearEnergyTransformer>();
            var gear4 = gear4Block.GetComponent<IGearEnergyTransformer>();
            var gear5 = gear5Block.GetComponent<IGearEnergyTransformer>();
            var gear6 = gear6Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(5, gear1.CurrentRpm.AsPrimitive());
            Assert.AreEqual(5, gear2.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.5f, gear1.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.5f, gear2.CurrentTorque.AsPrimitive());
            
            Assert.AreEqual(10, gear3.CurrentRpm.AsPrimitive());
            Assert.AreEqual(10, gear4.CurrentRpm.AsPrimitive());
            Assert.AreEqual(10, gear5.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.25f, gear3.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.25f, gear4.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.25f, gear5.CurrentTorque.AsPrimitive());
            
            Assert.AreEqual(20, gear6.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.125f, gear6.CurrentTorque.AsPrimitive());
        }
        
        [Test]
        public void GearNetworkMergeTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            var gearPosition1 = new Vector3Int(1, 0, 0);
            var gearPosition2 = new Vector3Int(2, 0, 0);
            var gearPosition3 = new Vector3Int(3, 0, 0);
            
            // 2つのネットワークを作成
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition3, BlockDirection.North, out _);
            Assert.AreEqual(2, gearNetworkDataStore.GearNetworks.Count);
            
            // ネットワークをマージ
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out _);
            Assert.AreEqual(1, gearNetworkDataStore.GearNetworks.Count);
            
            // ネットワークの分離のテスト
            ServerContext.WorldBlockDatastore.RemoveBlock(gearPosition2);
            Assert.AreEqual(2, gearNetworkDataStore.GearNetworks.Count);
        }
        
        private static void ForceConnectGear(IBlock gear1, IBlock gear2)
        {
            BlockConnectorComponent<IGearEnergyTransformer> gear1Connector = gear1.GetComponent<BlockConnectorComponent<IGearEnergyTransformer>>();
            var gear1Transform = gear1.GetComponent<IGearEnergyTransformer>();
            
            BlockConnectorComponent<IGearEnergyTransformer> gear2Connector = gear2.GetComponent<BlockConnectorComponent<IGearEnergyTransformer>>();
            var gear2Transform = gear2.GetComponent<IGearEnergyTransformer>();
            
            
            var gear1Info = new ConnectedInfo(new GearConnectOption(true), new GearConnectOption(true), gear1);
            var gear2Info = new ConnectedInfo(new GearConnectOption(true), new GearConnectOption(true), gear2);
            
            ((Dictionary<IGearEnergyTransformer, ConnectedInfo>)gear1Connector.ConnectedTargets).Add(gear2Transform, gear2Info);
            ((Dictionary<IGearEnergyTransformer, ConnectedInfo>)gear2Connector.ConnectedTargets).Add(gear1Transform, gear1Info);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Inventory/OpenableInventoryItemDataStoreService.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Item.Interface;
using Core.Master;

namespace Core.Inventory
{
    /// <summary>
    ///     開くことができるインベントリ（プレイヤーインベントリやチェストのインベントリ）の処理を統合的に行うクラスです
    /// </summary>
    public class OpenableInventoryItemDataStoreService : IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems => _inventory;
        private readonly List<IItemStack> _inventory;
        
        public delegate void InventoryUpdate(int slot, IItemStack itemStack);
        
        private readonly IItemStackFactory _itemStackFactory;
        private readonly InventoryUpdate _onInventoryUpdate;
        
        public OpenableInventoryItemDataStoreService(InventoryUpdate onInventoryUpdate, IItemStackFactory itemStackFactory, int slotNumber)
        {
            _itemStackFactory = itemStackFactory;
            _onInventoryUpdate = onInventoryUpdate;
            
            _inventory = new List<IItemStack>();
            for (var i = 0; i < slotNumber; i++) _inventory.Add(_itemStackFactory.CreatEmpty());
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            //インベントリのアイテムをコピー
            var inventoryCopy = new List<IItemStack>(_inventory);
            //挿入を実行する
            var result = InventoryInsertItem.InsertItem(itemStacks, inventoryCopy, _itemStackFactory);
            //結果のアイテム数が0だったら挿入可能
            return result.Count == 0;
        }
        
        public int GetSlotSize()
        {
            return _inventory.Count;
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            return new(_inventory);
        }
        
        public IItemStack GetItem(int slot)
        {
            return _inventory[slot];
        }
        
        private void InvokeEvent(int slot)
        {
            _onInventoryUpdate(slot, _inventory[slot]);
        }
        
        #region Set
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            if (!_inventory[slot].Equals(itemStack))
            {
                _inventory[slot] = itemStack;
                InvokeEvent(slot);
            }
        }
        
        public void SetItemWithoutEvent(int slot, IItemStack itemStack)
        {
            _inventory[slot] = itemStack;
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            SetItem(slot, _itemStackFactory.Create(itemId, count));
        }
        
        #endregion
        
        
        #region Replace
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            //アイテムIDが同じの時はスタックして余ったものを返す
            var item = _inventory[slot];
            if (item.Id == itemStack.Id)
            {
                var result = item.AddItem(itemStack);
                _inventory[slot] = result.ProcessResultItemStack;
                InvokeEvent(slot);
                return result.RemainderItemStack;
            }
            
            //違う場合はそのまま入れ替える
            _inventory[slot] = itemStack;
            InvokeEvent(slot);
            return item;
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            return ReplaceItem(slot, _itemStackFactory.Create(itemId, count));
        }
        
        #endregion
        
        
        #region Insert
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return InventoryInsertItem.InsertItem(itemStack, _inventory, _itemStackFactory, InvokeEvent);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            return InsertItem(_itemStackFactory.Create(itemId, count));
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return InventoryInsertItem.InsertItem(itemStacks, _inventory, _itemStackFactory, InvokeEvent);
        }
        
        /// <summary>
        ///     もしそのスロットに入れられるのであれば、まずはそれらのスロットに入れてから、余ったものを返す
        /// </summary>
        public IItemStack InsertItemWithPrioritySlot(IItemStack itemStack, int[] prioritySlots)
        {
            return InventoryInsertItem.InsertItemWithPrioritySlot(itemStack, _inventory, _itemStackFactory, prioritySlots, InvokeEvent);
        }
        
        public IItemStack InsertItemWithPrioritySlot(ItemId itemId, int count, int[] prioritySlots)
        {
            return InsertItemWithPrioritySlot(_itemStackFactory.Create(itemId, count), prioritySlots);
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/ConnectElectricSegmentTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    public class ConnectElectricSegmentTest
    {
        //ブロックIDが変わったらここを変える
        private static readonly BlockId ElectricPoleId = ForUnitTestModBlockId.ElectricPoleId;
        private static readonly BlockId MachineId = ForUnitTestModBlockId.MachineId;
        private static readonly BlockId GenerateId = ForUnitTestModBlockId.GeneratorId;
        
        //電柱を設置し、電柱に接続するテスト
        [Test]
        public void PlaceElectricPoleToPlaceElectricPoleTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //範囲内の電柱
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out var pole1);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(2, 0), BlockDirection.North, out var pole2);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(3, 0), BlockDirection.North, out var pole3);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(-3, 0), BlockDirection.North, out var pole4);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 3), BlockDirection.North, out var pole5);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, -3), BlockDirection.North, out var pole6);
            
            //範囲外の電柱
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(7, 0), BlockDirection.North, out var pole7);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(-7, 0), BlockDirection.North, out var pole8);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 7), BlockDirection.North, out var pole9);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, -7), BlockDirection.North, out var pole10);
            
            IBlock[] poles =
            {
                pole1, pole2, pole3, pole4, pole5, pole6, pole7, pole8, pole9, pole10,
            };
            IBlock[] inRangePoles =
            {
                pole1,
                pole2,
                pole3,
                pole4,
                pole5,
                pole6,
            };
            IBlock[] outOfRangePoles =
            {
                pole7,
                pole8,
                pole9,
                pole10,
            };
            
            IWorldEnergySegmentDatastore<EnergySegment> worldElectricSegment = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            //セグメントの数を確認
            Assert.AreEqual(5, worldElectricSegment.GetEnergySegmentListCount());
            
            var segment = worldElectricSegment.GetEnergySegment(0);
            //電柱を取得する
            IReadOnlyDictionary<BlockInstanceId, IElectricTransformer> electricPoles = segment.EnergyTransformers;
            
            //存在する電柱の数の確認
            //存在している電柱のIDの確認
            foreach (var pole in inRangePoles) Assert.AreEqual(true, electricPoles.ContainsKey(pole.BlockInstanceId));
            
            //存在しない電柱のIDの確認
            foreach (var pole in outOfRangePoles) Assert.AreEqual(false, electricPoles.ContainsKey(pole.BlockInstanceId));
            
            //範囲外同士の接続確認
            //セグメント繋がる位置に電柱を設置
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(5, 0), BlockDirection.North, out var pole11);
            //セグメントの数を確認
            Assert.AreEqual(4, worldElectricSegment.GetEnergySegmentListCount());
            //マージ後のセグメント、電柱を取得
            segment = worldElectricSegment.GetEnergySegment(3);
            electricPoles = segment.EnergyTransformers;
            //存在する電柱の数の確認
            Assert.AreEqual(8, electricPoles.Count);
            //マージされた電柱のIDの確認
            Assert.AreEqual(true, electricPoles.ContainsKey(pole7.BlockInstanceId));
            Assert.AreEqual(true, electricPoles.ContainsKey(pole11.BlockInstanceId));
        }
        
        //電柱を設置した後に機械、発電機を設置するテスト
        [Test]
        public void PlaceElectricPoleToPlaceMachineTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //起点となる電柱の設置
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out var originElectricPole);
            
            //周りに機械を設置
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(2, 0), BlockDirection.North, out var inRangeMachine0);
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(-2, 0), BlockDirection.North, out var inRangeMachine1);
            //周りに発電機を設置
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, 2), BlockDirection.North, out var inRangeGenerator0);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -2), BlockDirection.North, out var inRangeGenerator1);
            
            //範囲外に機械を設置
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(3, 0), BlockDirection.North, out var outOfRangeMachine0);
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(-3, 0), BlockDirection.North, out var outOfRangeMachine1);
            //範囲外に発電機を設置
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, 3), BlockDirection.North, out var outOfRangeGenerator0);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -3), BlockDirection.North, out var outOfRangeGenerator1);
            
            IWorldEnergySegmentDatastore<EnergySegment> segmentDatastore = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            //範囲内の設置
            var segment = segmentDatastore.GetEnergySegment(0);
            //機械、発電機を取得する
            IReadOnlyDictionary<BlockInstanceId, IElectricConsumer> electricBlocks = segment.Consumers;
            IReadOnlyDictionary<BlockInstanceId, IElectricGenerator> powerGeneratorBlocks = segment.Generators;
            
            
            //存在する機械の数の確認
            Assert.AreEqual(2, electricBlocks.Count);
            Assert.AreEqual(2, powerGeneratorBlocks.Count);
            //存在している機械のIDの確認
            Assert.AreEqual(true, electricBlocks.ContainsKey(inRangeMachine0.BlockInstanceId));
            Assert.AreEqual(true, electricBlocks.ContainsKey(inRangeMachine1.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(inRangeGenerator0.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(inRangeGenerator1.BlockInstanceId));
            
            //範囲外の機械、発電機が繋がるように電柱を設置
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(3, 1), BlockDirection.North, out var pole1);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(1, 3), BlockDirection.North, out var pole2);
            
            segment = segmentDatastore.GetEnergySegment(0);
            electricBlocks = segment.Consumers;
            powerGeneratorBlocks = segment.Generators;
            //存在する機械の数の確認
            Assert.AreEqual(1, segmentDatastore.GetEnergySegmentListCount());
            Assert.AreEqual(3, electricBlocks.Count);
            Assert.AreEqual(3, powerGeneratorBlocks.Count);
            //追加されたIDの確認
            Assert.AreEqual(true, electricBlocks.ContainsKey(outOfRangeMachine0.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(outOfRangeGenerator0.BlockInstanceId));
        }
        
        //機械、発電機を設置した後に電柱を設置するテスト
        [Test]
        public void PlaceMachineToPlaceElectricPoleTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            
            //周りに機械を設置
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(2, 0), BlockDirection.North, out var inRangeMachine0);
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(-2, 0), BlockDirection.North, out var inRangeMachine1);
            //周りに発電機を設置
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, 2), BlockDirection.North, out var inRangeGenerator0);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -2), BlockDirection.North, out var inRangeGenerator1);
            
            //範囲外に機械を設置
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(3, 0), BlockDirection.North, out var outOfRangeMachine0);
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(-3, 0), BlockDirection.North, out var outOfRangeMachine1);
            //範囲外に発電機を設置
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, 3), BlockDirection.North, out var outOfRangeGenerator0);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -3), BlockDirection.North, out var outOfRangeGenerator1);
            
            //起点となる電柱の設置
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out var originPole);
            
            
            //範囲内の設置
            var segment = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>()
                .GetEnergySegment(0);
            //リフレクションで機械を取得する
            IReadOnlyDictionary<BlockInstanceId, IElectricConsumer> electricBlocks = segment.Consumers;
            IReadOnlyDictionary<BlockInstanceId, IElectricGenerator> powerGeneratorBlocks = segment.Generators;
            
            
            //存在する機械の数の確認
            Assert.AreEqual(2, electricBlocks.Count);
            Assert.AreEqual(2, powerGeneratorBlocks.Count);
            //存在している機械のIDの確認
            Assert.AreEqual(true, electricBlocks.ContainsKey(inRangeMachine0.BlockInstanceId));
            Assert.AreEqual(true, electricBlocks.ContainsKey(inRangeMachine1.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(inRangeGenerator0.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(inRangeGenerator1.BlockInstanceId));
        }
        
        //別々のセグメント同士を電柱でつなぐテスト
        [Test]
        public void SegmentConnectionTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //一つ目のセグメントを設置
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out _);
            //周りに機械と発電機を設置
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(2, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -2), BlockDirection.North, out _);
            
            //二つ目のセグメントを設置
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(6, 0), BlockDirection.North, out _);
            //周りに機械と発電機を設置
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(7, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(7, 1), BlockDirection.North, out _);
            
            IWorldEnergySegmentDatastore<EnergySegment> segmentDatastore = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            //セグメントの数を確認
            Assert.AreEqual(2, segmentDatastore.GetEnergySegmentListCount());
            
            //セグメント同士をつなぐ電柱を設置
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(3, 0), BlockDirection.North, out _);
            //セグメントの数を確認
            Assert.AreEqual(1, segmentDatastore.GetEnergySegmentListCount());
            //セグメントを取得
            var segment = segmentDatastore.GetEnergySegment(0);
            //機械、発電機の数を確認
            Assert.AreEqual(2, segment.Consumers.Count);
            Assert.AreEqual(2, segment.Generators.Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/PreviewOnlyObjectInspector.cs
```cs
using Client.Game.InGame.BlockSystem.PlaceSystem;
using UnityEditor;

[CustomEditor(typeof(PreviewOnlyObject))]
public class PreviewOnlyObjectInspector : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        //TODO i18n対応
        
        EditorGUILayout.HelpBox("このオブジェクトは設置プレビュー時のみオンになります", MessageType.Info);
    }
}

```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryService/InventoryItemInsertService.cs
```cs
using System;
using Core.Inventory;

namespace Server.Protocol.PacketResponse.Util.InventoryService
{
    public static class InventoryItemInsertService
    {
        public static void Insert(IOpenableInventory fromInventory, int fromSlot, IOpenableInventory toInventory,
            int count)
        {
            var insertItemId = fromInventory.GetItem(fromSlot).Id;
            //持っているアイテム以上のアイテムをinsertしないようにする
            var insertItemCount = Math.Min(fromInventory.GetItem(fromSlot).Count, count);
            
            var insertResult = toInventory.InsertItem(insertItemId, insertItemCount);
            
            //挿入した結果手元に何個アイテムが残るかを計算
            var returnItemCount = fromInventory.GetItem(fromSlot).Count - insertItemCount + insertResult.Count;
            
            fromInventory.SetItem(fromSlot, insertItemId, returnItemCount);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Inventory/InsertItemLogicTest.cs
```cs
using Core.Inventory;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Inventory
{
    /// <summary>
    ///     <see cref="InventoryInsertItem" /> をテストする
    /// </summary>
    public class InsertItemLogicTest
    {
        [Test]
        public void InsertItemWithPrioritySlotTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var toInventory = new OpenableInventoryItemDataStoreService((_, _) => { }, itemStackFactory, 10);
            
            
            // 8,9番目のスロットに優先的にアイテムを入れるようにする
            var insertItem = itemStackFactory.Create(new ItemId(1), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //8番目に入っているか確認
            Assert.AreEqual(insertItem, toInventory.GetItem(8));
            
            //ID2を入れて、9番目に入っているかを確認する
            insertItem = itemStackFactory.Create(new ItemId(2), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //9番目に入っているか確認
            Assert.AreEqual(insertItem, toInventory.GetItem(9));
            
            //ID3を入れて、8,9番目に入らないので0番目に入ることを確認する
            insertItem = itemStackFactory.Create(new ItemId(3), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //0番目に入っているか確認
            Assert.AreEqual(insertItem, toInventory.GetItem(0));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockStateDetail.cs
```cs
namespace Game.Block.Interface.Component
{
    public interface IBlockStateDetail : IBlockComponent 
    {
        /// <summary>
        /// 抽象クラスを返すのではなく具体的なクラスを返す理由は、MessagePackの変換が抽象クラスだと上手くいかないため
        /// TODO Convert.ChangeTypeを使っても良いかもしれない、、要検討
        /// The reason for returning a concrete class instead of an abstract class is that MessagePack conversions do not work with abstract classes.
        /// TODO It may be better to use Convert.ChangeType.
        /// </summary>
        /// <returns></returns>
        public BlockStateDetail GetBlockStateDetail();
    }
    
    public struct BlockStateDetail
    {
        public string Key { get; }
        public byte[] Value { get; }
        
        public BlockStateDetail(string key, byte[] value)
        {
            Key = key;
            Value = value;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerMainComputerInventoryView.cs
```cs
using System.Collections.Generic;
using System.Threading;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class CraftChainerMainComputerInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        
        [SerializeField] private Button requestButton;
        [SerializeField] private CraftChainerMainComputerSelectRequestItemModal selectRequestItemModal;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            selectRequestItemModal.Initialize();
            requestButton.onClick.AddListener(() => OnClickRequestButton().Forget());
            
            // アイテムリストを初期化
            // Initialize item list
            InitializeItemList();
            
            #region Internal
            
            void InitializeItemList()
            {
                var itemList = new List<IItemStack>();
                var param = (CraftChainerMainComputerBlockParam)blockGameObject.BlockMasterElement.BlockParam;
                for (var i = 0; i < param.ItemSlotCount; i++)
                {
                    var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                    _blockItemSlotObjects.Add(slotObject);
                    itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
                }
                UpdateItemList(itemList);
            }
            
  #endregion
        }
        
        private async UniTask OnClickRequestButton()
        {
            var (itemId, count) = await selectRequestItemModal.GetRequestItem();
            if (itemId == ItemMaster.EmptyItemId) return;
            
            var pos = _blockGameObject.BlockPosInfo.OriginalPos;
            ClientContext.VanillaApi.SendOnly.SetCraftChainerMainComputerRequestItem(pos, itemId, count);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/InventoryItemInsertServiceTest.cs
```cs
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util.InventoryService;
using Tests.Module.TestMod;

namespace Tests.CombinedTest.Game
{
    public class InventoryItemInsertServiceTest
    {
        /// <summary>
        ///     通常のinsert処理
        /// </summary>
        [Test]
        public void InsertTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).MainOpenableInventory;
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            
            //インベントリの設定
            mainInventory.SetItem(PlayerInventoryConst.HotBarSlotToInventorySlot(0), new ItemId(1), 10);
            grabInventory.SetItem(0, new ItemId(1), 10);
            
            //グラブからメインにid 1のアイテムを移す
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 5);
            
            Assert.AreEqual(15, mainInventory.GetItem(PlayerInventoryConst.HotBarSlotToInventorySlot(0)).Count);
            Assert.AreEqual(5, grabInventory.GetItem(0).Count);
        }
        
        
        /// <summary>
        ///     アイテムがいっぱいの時はinsertされないテスト
        /// </summary>
        [Test]
        public void FullItemInsert()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).MainOpenableInventory;
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            
            var id1MaxStack = MasterHolder.ItemMaster.GetItemMaster(new ItemId(1)).MaxStack;
            
            //インベントリをアイテムで満たす
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++) mainInventory.SetItem(i, new ItemId(1), id1MaxStack);
            //グラブインベントリの設定
            grabInventory.SetItem(0, new ItemId(1), 10);
            
            //グラブからメインにid 1のアイテムを移す
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 5);
            //挿入されてないことをテスト
            Assert.AreEqual(10, grabInventory.GetItem(0).Count);
            
            
            //挿入した一部が帰ってくるテスト
            //下準備としてスロットのアイテム数を5引く
            mainInventory.SetItem(0, new ItemId(1), id1MaxStack - 5);
            //グラブからメインにid 1のアイテムを全て移す
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 10);
            //挿入されていることをテスト
            Assert.AreEqual(5, grabInventory.GetItem(0).Count);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ItemShooterSaveLoadTest.cs
```cs
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.ItemShooter;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ItemShooterSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var itemShooter = blockFactory.Create(ForUnitTestModBlockId.StraightItemShooter, new BlockInstanceId(1), posInfo);
            
            var shooter = itemShooter.GetComponent<ItemShooterComponent>();
            //リフレクションで_inventoryItemsを取得
            var inventoryItemsField = typeof(ItemShooterComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (ShooterInventoryItem[])inventoryItemsField.GetValue(shooter);
            
            //アイテムを設定
            var item1Speed = 1.5f;
            var item2Speed = 2.2f;
            var item3Speed = 5f;
            var item1RemainingPercent = 0.5f;
            var item2RemainingPercent = 0.3f;
            var item3RemainingPercent = 0.0f;
            inventoryItems[0] = new ShooterInventoryItem(new ItemId(1), new ItemInstanceId(0), item1Speed);
            inventoryItems[0].RemainingPercent = item1RemainingPercent;
            inventoryItems[2] = new ShooterInventoryItem(new ItemId(2), new ItemInstanceId(0), item2Speed);
            inventoryItems[2].RemainingPercent = item2RemainingPercent;
            inventoryItems[3] = new ShooterInventoryItem(new ItemId(5), new ItemInstanceId(0), item3Speed);
            inventoryItems[3].RemainingPercent = item3RemainingPercent;
            
            
            //セーブデータ取得
            var str = shooter.GetSaveState();
            var states = new Dictionary<string, string>() { { shooter.SaveKey, str } };
            Debug.Log(str);
            
            //セーブデータをロード
            var newShooter = blockFactory.Load(itemShooter.BlockMasterElement.BlockGuid, new BlockInstanceId(0), states, posInfo).GetComponent<ItemShooterComponent>();
            var newInventoryItems = (ShooterInventoryItem[])inventoryItemsField.GetValue(newShooter);
            
            //アイテムが一致するかチェック
            Assert.AreEqual(inventoryItems.Length, newInventoryItems.Length);
            
            Assert.AreEqual(1, newInventoryItems[0].ItemId.AsPrimitive());
            Assert.AreEqual(item1Speed, newInventoryItems[0].CurrentSpeed);
            Assert.AreEqual(item1RemainingPercent, newInventoryItems[0].RemainingPercent);
            
            Assert.IsTrue(newInventoryItems[1] == null);
            
            Assert.AreEqual(2, newInventoryItems[2].ItemId.AsPrimitive());
            Assert.AreEqual(item2Speed, newInventoryItems[2].CurrentSpeed);
            Assert.AreEqual(item2RemainingPercent, newInventoryItems[2].RemainingPercent);
            
            Assert.AreEqual(5, newInventoryItems[3].ItemId.AsPrimitive());
            Assert.AreEqual(item3Speed, newInventoryItems[3].CurrentSpeed);
            Assert.AreEqual(item3RemainingPercent, newInventoryItems[3].RemainingPercent);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CommonBlockInventoryViewBase.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    /// <summary>
    /// インベントリを持つ基本的なブロックのクラスです。通常のインベントリを持つようなブロックであればこれを継承して実装してください。
    /// クラスの肥大化防止の為、専用処理を書かないといけなくなったときは<see cref="IBlockInventoryView"/>を実装した新たなクラスを作成してください。
    /// This is the class of the basic block with inventory. If you have a block that has a normal inventory, you can implement it by inheriting from this class.
    /// If you need to write dedicated processing to prevent class bloat, create a new class that implements <see cref="IBlockInventoryView"/>.
    /// </summary>
    public abstract class CommonBlockInventoryViewBase : MonoBehaviour, IBlockInventoryView
    {
        public IReadOnlyList<ItemSlotObject> SubInventorySlotObjects => _blockItemSlotObjects;
        public int Count => _blockItemSlotObjects.Count;
        protected readonly List<ItemSlotObject> _blockItemSlotObjects = new();
        public List<IItemStack> SubInventory { get; } = new();
        public ItemMoveInventoryInfo ItemMoveInventoryInfo { get; protected set; }
        
        public virtual void Initialize(BlockGameObject blockGameObject)
        {
            ItemMoveInventoryInfo = new ItemMoveInventoryInfo(ItemMoveInventoryType.BlockInventory, blockGameObject.BlockPosInfo.OriginalPos);
        }
        
        public void UpdateItemList(List<IItemStack> response)
        {
            SubInventory.Clear();
            SubInventory.AddRange(response);
        }
        public void UpdateInventorySlot(int slot, IItemStack item)
        {
            if (SubInventory.Count <= slot)
            {
                //TODO ログ基盤にいれる
                Debug.LogError($"インベントリのサイズを超えています。item:{item} slot:{slot}");
                return;
            }
            
            SubInventory[slot] = item;
        }
        public void DestroyUI()
        {
            Destroy(gameObject);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/PlayerInventoryConst.cs
```cs
using System;

namespace Game.PlayerInventory.Interface
{
    public static class PlayerInventoryConst
    {
        public const int MainInventoryColumns = 9;
        public const int MainInventoryRows = 5;
        public const int MainInventorySize = MainInventoryColumns * MainInventoryRows;
        
        /// <summary>
        ///     ホットバーとなるインベントリのスロット
        /// </summary>
        public static readonly int[] HotBarSlots =
        {
            HotBarSlotToInventorySlot(0),
            HotBarSlotToInventorySlot(1),
            HotBarSlotToInventorySlot(2),
            HotBarSlotToInventorySlot(3),
            HotBarSlotToInventorySlot(4),
            HotBarSlotToInventorySlot(5),
            HotBarSlotToInventorySlot(6),
            HotBarSlotToInventorySlot(7),
            HotBarSlotToInventorySlot(8),
        };
        
        
        /// <summary>
        ///     0〜8までのホットバーのIDをインベントリのスロットに変換します
        /// </summary>
        /// <exception cref="Exception">0〜8以外だとスローします</exception>
        public static int HotBarSlotToInventorySlot(int slot)
        {
            if (slot < 0 || MainInventoryColumns <= slot)
                throw new Exception("ホットバーは0～8までです");
            //インベントリの一番したがホットバーとなる
            return (MainInventoryRows - 1) * MainInventoryColumns + slot;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/ProviderChest/CraftChainerProviderChestBlockInventoryInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.Context;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent.ProviderChest
{
    /// <summary>
    /// CraftChainerネットワークへのアイテムの供給リクエストを受け、InsertItemがそれに合致しているアイテムをCraftChainerネットワークに供給する
    /// InsertItemメソッドはチェスト等から毎フレーム叩かれているため、明示的にInsertを呼び出すと言ったことはしない。
    ///
    /// Receive a request to supply an item to the CraftChainer network, and InsertItem will supply the matching item to the CraftChainer network.
    /// The InsertItem method is hit every frame from the chest, etc., so it does not explicitly call Insert.
    /// </summary>
    public class CraftChainerProviderChestBlockInventoryInserter : IBlockInventoryInserter
    {
        private readonly CraftChainerNodeId _providerChestNodeId;
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        public CraftChainerProviderChestBlockInventoryInserter(CraftChainerNodeId providerChestNodeId, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _providerChestNodeId = providerChestNodeId;
            _blockConnectorComponent = blockConnectorComponent;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var context = CraftChainerMainComputerManager.Instance.GetChainerNetworkContext(_providerChestNodeId);
            if (context == null)
            {
                return itemStack;
            }
            
            // 1個ずつアイテムを挿入し、それを返すため、1個分のアイテムを作成
            // Insert items one by one and return them, so create an item for one item
            var oneItem = ServerContext.ItemStackFactory.Create(itemStack.Id, 1);
            
            var insertResult = context.InsertNodeNetworkNextBlock(oneItem, _providerChestNodeId, _blockConnectorComponent);
            
            // アイテムが消失しないように、1個ひいたアイテムと、挿入結果のアイテムを合成して返す
            // To prevent the item from disappearing, return a composite of the item with one item subtracted and the inserted item
            var subOneItem = itemStack.SubItem(1);
            return insertResult.AddItem(subOneItem).ProcessResultItemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MasterJsonFileContainer.cs
```cs
using System.Collections.Generic;
using System.Linq;

namespace Core.Master
{
    public class MasterJsonFileContainer
    {        /// <summary>
        ///     ブロックのコンフィグが入っている
        ///     Key modId : Value ConfigJson
        /// </summary>
        public readonly Dictionary<string, string> BlockConfigs = new();
        
        /// <summary>
        ///     アイテムのコンフィグが入っている
        ///     Key modId : Value ConfigJson
        /// </summary>
        public readonly Dictionary<string, string> ItemConfigs = new();
        
        public readonly List<string> SortedChallengeConfigJsonList = new();
        
        public readonly List<string> SortedCraftRecipeConfigJsonList = new();
        
        public readonly List<string> SortedMachineRecipeConfigJsonList = new();
        
        public readonly List<string> SortedMapObjectConfigJsonList = new();
        public readonly List<string> SortedModIds;
        
        public readonly List<MasterJsonCpntens> ConfigJsons;
        
        public MasterJsonFileContainer(Dictionary<string, MasterJsonCpntens> configs)
        {
            ConfigJsons = configs.Values.ToList();
            
            var keys = configs.Keys.ToList();
            keys.Sort();
            SortedModIds = keys;
            
            foreach (var key in keys)
            {
                if (configs[key].ItemConfigJson != string.Empty) ItemConfigs.Add(key, configs[key].ItemConfigJson);
                if (configs[key].BlockConfigJson != string.Empty) BlockConfigs.Add(key, configs[key].BlockConfigJson);
                if (configs[key].CraftRecipeConfigJson != string.Empty) SortedCraftRecipeConfigJsonList.Add(configs[key].CraftRecipeConfigJson);
                if (configs[key].MachineRecipeConfigJson != string.Empty) SortedMachineRecipeConfigJsonList.Add(configs[key].MachineRecipeConfigJson);
                if (configs[key].MapObjectConfigJson != string.Empty) SortedMapObjectConfigJsonList.Add(configs[key].MapObjectConfigJson);
                if (configs[key].ChallengeConfigJson != string.Empty) SortedChallengeConfigJsonList.Add(configs[key].ChallengeConfigJson);
            }
        }
        
    }
}
```

moorestech_server/Assets/Scripts/Core.Const/AlphaMod.cs
```cs
using System;

namespace Core.Const
{
    public static class AlphaMod
    {
        [Obsolete("TODO これもAlpha2.0が終わったら消す")] public const string ModId = "sakastudio:moorestechAlphaMod";
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/Implementation/NullItemStack.cs
```cs
#nullable enable
using System;
using Core.Const;
using Core.Item.Interface;
using Core.Master;

namespace Core.Item.Implementation
{
    internal class NullItemStack : IItemStack
    {
        public ItemId Id => ItemMaster.EmptyItemId;
        public int Count => 0;
        public long ItemHash => 0;
        public ItemInstanceId ItemInstanceId { get; }
        
        public ItemProcessResult AddItem(IItemStack receiveItemStack)
        {
            //そのまま足すとインスタスIDが同じになってベルトコンベアなどで運ぶときに問題が生じるので、新しいインスタンスを生成する
            var tmpItem = InternalItemContext.ItemStackFactory.Create(receiveItemStack.Id, receiveItemStack.Count);
            var empty = InternalItemContext.ItemStackFactory.CreatEmpty();
            return new ItemProcessResult(tmpItem, empty);
        }
        
        public IItemStack SubItem(int subCount)
        {
            return this;
        }
        
        public bool IsAllowedToAdd(IItemStack item)
        {
            return true;
        }
        
        public bool IsAllowedToAddWithRemain(IItemStack item)
        {
            return true;
        }
        
        public ItemStackMetaData GetMeta(string key)
        {
            //TODO ログに入れる
            throw new InvalidOperationException("空のアイテムにメタデータは存在しません");
        }
        
        public bool TryGetMeta(string key, out ItemStackMetaData value)
        {
            throw new InvalidOperationException("空のアイテムにメタデータは存在しません");
        }
        
        public IItemStack SetMeta(string key, ItemStackMetaData value)
        {
            throw new InvalidOperationException("空のアイテムにメタデータは入れられません");
        }
        
        public IItemStack Clone()
        {
            return InternalItemContext.ItemStackFactory.CreatEmpty();
        }
        
        public override bool Equals(object? obj)
        {
            if (typeof(NullItemStack) != obj?.GetType()) return false;
            return ((NullItemStack)obj).Id == Id && ((NullItemStack)obj).Count == Count;
        }
        
        protected bool Equals(NullItemStack other)
        {
            return ItemInstanceId == other.ItemInstanceId;
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(ItemInstanceId);
        }
        
        public override string ToString()
        {
            return $"ID:{Id} Count:{Count}";
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/InventoryItemMoveServiceTest.cs
```cs
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util.InventoryService;
using Tests.Module.TestMod;

namespace Tests.CombinedTest.Game
{
    public class InventoryItemMoveServiceTest
    {
        [Test]
        public void MoveTest()
        {
            var playerId = 1;
            
            //初期設定----------------------------------------------------------
            
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //プレイヤーのインベントリの設定
            var playerInventoryData =
                serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(playerId);
            
            
            //アイテムの設定
            var inventory = playerInventoryData.MainOpenableInventory;
            inventory.SetItem(0, itemStackFactory.Create(new ItemId(1), 5));
            inventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            inventory.SetItem(2, itemStackFactory.Create(new ItemId(2), 1));
            
            
            //実際に移動させてテスト
            //全てのアイテムを移動させるテスト
            InventoryItemMoveService.Move(inventory,
                0, inventory, 3, 5);
            Assert.AreEqual(inventory.GetItem(0), itemStackFactory.CreatEmpty());
            Assert.AreEqual(inventory.GetItem(3), itemStackFactory.Create(new ItemId(1), 5));
            
            //一部のアイテムを移動させるテスト
            InventoryItemMoveService.Move(inventory,
                3, inventory, 0, 3);
            Assert.AreEqual(inventory.GetItem(0), itemStackFactory.Create(new ItemId(1), 3));
            Assert.AreEqual(inventory.GetItem(3), itemStackFactory.Create(new ItemId(1), 2));
            
            //一部のアイテムを移動しようとするが他にスロットがあるため失敗するテスト
            InventoryItemMoveService.Move(inventory,
                0, inventory, 2, 1);
            Assert.AreEqual(inventory.GetItem(0), itemStackFactory.Create(new ItemId(1), 3));
            Assert.AreEqual(inventory.GetItem(2), itemStackFactory.Create(new ItemId(2), 1));
            
            //全てのアイテムを移動させるテスト
            InventoryItemMoveService.Move(inventory,
                0, inventory, 2, 3);
            Assert.AreEqual(inventory.GetItem(0), itemStackFactory.Create(new ItemId(2), 1));
            Assert.AreEqual(inventory.GetItem(2), itemStackFactory.Create(new ItemId(1), 3));
            
            //アイテムを加算するテスト
            InventoryItemMoveService.Move(inventory,
                2, inventory, 1, 3);
            Assert.AreEqual(inventory.GetItem(2), itemStackFactory.CreatEmpty());
            Assert.AreEqual(inventory.GetItem(1), itemStackFactory.Create(new ItemId(1), 4));
            
            
            //全てのアイテムを同じスロットにアイテムを移動させるテスト
            InventoryItemMoveService.Move(inventory,
                1, inventory, 1, 4);
            Assert.AreEqual(inventory.GetItem(1), itemStackFactory.Create(new ItemId(1), 4));
        }
    }
}
```

schema/ref/blockConnectInfo.json
```cs
{
  "$id": "blockConnectInfo",

  "type": "array",
  "overrideCodeGeneratePropertyName": "blockConnectInfoElement",

  "items": {
    "type": "object",

    "properties": {

      "connectType": {
        "type": "string",
        "enum": ["Inventory", "Gear"],
        "description": "TODO これは後々外部（上位スキーマ？）から設定できるようにする"
      },

      "offset": {
        "type": "array",
        "pattern": "@vector3Int",
        "items": {
          "type": "integer"
        },
        "default": [
          0,
          0,
          0
        ]
      },

      "directions": {
        "type": "array",
        "optional": true,
        "items": {
          "type": "array",
          "pattern": "@vector3Int",
          "items": {
            "type": "integer"
          },
          "default": [
            0,
            0,
            0
          ]
        }
      },

      "connectOption": {
        "oneOf": [
          {
            "if": {
              "properties": {
                "connectType": { "const": "Inventory" }
              }
            },
            "then": {
              "type": "object",
              "optional": true,
              "properties": {
                "inventoryOptions" :{
                  "type": "array",
                  "optional": true,
                  
                  "items": {
                    "type": "object",
                    "properties": {
                      
                      "inventoryConnectOptionType": {
                        "type": "string",
                        "enum": ["CraftChainerCrafter"]
                      },
                      
                      "inventoryConnectOptionParam": {
                        "oneOf": [
                          {
                            "if": {
                              "properties": {
                                "inventoryConnectOptionType": { "const": "CraftChainerCrafter" }
                              }
                            },
                            "then": {
                              "type": "object",
                              "properties": {

                                "connectType": {
                                  "type": "string",
                                  "enum": ["Network", "Factory"]
                                }
                              }
                            }
                            
                          }
                        ]
                      }
                      
                    }
                  }
                  
                }
              }
            }
          },

          {
            "if": {
              "properties": {
                "connectType": { "const": "Gear" }
              }
            },
            "then": {
              "type": "object",
              "properties": {

                "isReverse": {
                  "type": "boolean",
                  "default": true
                }
              }
            }
          }

        ]
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ConfigOnly/mods/testConfigOnlyMod2/master/machineRecipe.json
```cs
testMachineRecipeJson1
```

moorestech_server/Assets/Scripts/Mod.Config/ModJsonStringLoader.cs
```cs
using System.Collections.Generic;
using System.IO;
using Core.Master;
using Mod.Loader;

namespace Mod.Config
{
    public class ModJsonStringLoader
    {
        //TODO こういうコンフィグ類を、パスを追加するだけでいい感じに管理できるようにしたい
        private const string ItemConfigPath = "config/item.json";
        private const string BlockConfigPath = "config/block.json";
        private const string MachineRecipeConfigPath = "config/machineRecipe.json";
        private const string CraftRecipeConfigPath = "config/craftRecipe.json";
        private const string MapObjectConfigPath = "config/mapObject.json";
        private const string ChallengeConfigPath = "config/challenge.json";
        
        public static Dictionary<string, MasterJsonCpntens> GetConfigString(ModsResource modResource)
        {
            // TODO 上が不要になったら下のコードを使うようにする
            var configs = new List<MasterJsonCpntens>();
            
            //展開済みzipファイルの中身のjsonファイルを読み込む
            foreach (var mod in modResource.Mods)
            {
                var modId = new ModId(mod.Value.ModMetaJson.ModId);
                var extractedPath = mod.Value.ExtractedPath;
                
                // master/ 以下のjsonファイルをすべて取得する
                var masterJsonContents = new Dictionary<JsonFileName, string>();
                foreach (var masterJsonPath in Directory.GetFiles(extractedPath, "master/*.json"))
                {
                    var fileName = new JsonFileName(Path.GetFileNameWithoutExtension(masterJsonPath));
                    var jsonContents = File.ReadAllText(masterJsonPath);
                    masterJsonContents.Add(fileName, jsonContents);
                }
                configs.Add(new MasterJsonCpntens(modId,masterJsonContents));
            }
            
            //TODO 下のコードが不要になったらこのreturnを使う return configs;
            
            // -------------下は旧コード------------
            
            
            var configDict = new Dictionary<string, MasterJsonCpntens>();
            
            //zipファイルの中身のjsonファイルを読み込む
            foreach (var mod in modResource.Mods)
            {
                var modIdStr = mod.Value.ModMetaJson.ModId;
                var extractedPath = mod.Value.ExtractedPath;
                
                var itemConfigJson = LoadConfigFile(extractedPath, ItemConfigPath);
                var blockConfigJson = LoadConfigFile(extractedPath, BlockConfigPath);
                var machineRecipeConfigJson = LoadConfigFile(extractedPath, MachineRecipeConfigPath);
                var craftRecipeConfigJson = LoadConfigFile(extractedPath, CraftRecipeConfigPath);
                var mapObjectConfigJson = LoadConfigFile(extractedPath, MapObjectConfigPath);
                var challengeConfigJson = LoadConfigFile(extractedPath, ChallengeConfigPath);
                
                
                
                
                var modId = new ModId(mod.Value.ModMetaJson.ModId);
                
                // master/ 以下のjsonファイルをすべて取得する
                var masterJsonContents = new Dictionary<JsonFileName, string>();
                foreach (var masterJsonPath in Directory.GetFiles(extractedPath, "master/*.json"))
                {
                    var fileName = new JsonFileName(Path.GetFileNameWithoutExtension(masterJsonPath));
                    var jsonContents = File.ReadAllText(masterJsonPath);
                    masterJsonContents.Add(fileName, jsonContents);
                }
                configs.Add(new MasterJsonCpntens(modId,masterJsonContents));
                
                
                configDict.Add(modIdStr, new MasterJsonCpntens(itemConfigJson,
                    blockConfigJson,
                    machineRecipeConfigJson,
                    craftRecipeConfigJson,
                    mapObjectConfigJson,
                    challengeConfigJson,modId, masterJsonContents));
            }
            
            return configDict;
        }
        
        private static string LoadConfigFile(string extractedPath, string configPath)
        {
            var fullPath = Path.Combine(extractedPath, configPath);
            
            return !File.Exists(fullPath) ? string.Empty : File.ReadAllText(fullPath);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/PriorityQueue.cs
```cs
//Unity C#にはプライオリティーキューがないので自前実装する必要がある
//generated by Chat GPT 4o
using System;
using System.Collections.Generic;

namespace Game.Train.RailGraph 
{ 
    public class PriorityQueue<TElement, TPriority> where TPriority : IComparable<TPriority>
    {
        private List<(TElement Element, TPriority Priority)> _heap = new();

        public int Count => _heap.Count;

        public void Enqueue(TElement element, TPriority priority)
        {
            _heap.Add((element, priority));
            HeapifyUp(_heap.Count - 1);
        }

        public TElement Dequeue()
        {
            if (_heap.Count == 0)
            {
                throw new InvalidOperationException("The priority queue is empty.");
            }

            TElement element = _heap[0].Element;
            _heap[0] = _heap[^1]; // Move the last element to the root
            _heap.RemoveAt(_heap.Count - 1);
            if (_heap.Count > 0)
            {
                HeapifyDown(0);
            }
            return element;
        }

        public TElement Peek()
        {
            if (_heap.Count == 0)
            {
                throw new InvalidOperationException("The priority queue is empty.");
            }
            return _heap[0].Element;
        }

        private void HeapifyUp(int index)
        {
            while (index > 0)
            {
                int parentIndex = (index - 1) / 2;
                if (_heap[index].Priority.CompareTo(_heap[parentIndex].Priority) >= 0)
                {
                    break;
                }
                Swap(index, parentIndex);
                index = parentIndex;
            }
        }

        private void HeapifyDown(int index)
        {
            while (index < _heap.Count)
            {
                int leftChildIndex = 2 * index + 1;
                int rightChildIndex = 2 * index + 2;
                int smallestIndex = index;

                if (leftChildIndex < _heap.Count && _heap[leftChildIndex].Priority.CompareTo(_heap[smallestIndex].Priority) < 0)
                {
                    smallestIndex = leftChildIndex;
                }

                if (rightChildIndex < _heap.Count && _heap[rightChildIndex].Priority.CompareTo(_heap[smallestIndex].Priority) < 0)
                {
                    smallestIndex = rightChildIndex;
                }

                if (smallestIndex == index)
                {
                    break;
                }

                Swap(index, smallestIndex);
                index = smallestIndex;
            }
        }

        private void Swap(int indexA, int indexB)
        {
            (_heap[indexA], _heap[indexB]) = (_heap[indexB], _heap[indexA]);
        }
    }

}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearNetworkDatastore.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Update;
using Game.Block.Interface;
using UniRx;
using Random = System.Random;

namespace Game.Gear.Common
{
    public class GearNetworkDatastore
    {
        // TODO これってなんでstaticにしたんだっけ？こういうのは全般的にサービスロケーターにしたほうが良いような気がしてきた
        private static GearNetworkDatastore _instance;
        
        private readonly Dictionary<BlockInstanceId, GearNetwork> _blockEntityToGearNetwork; // key ブロックのEntityId value そのブロックが所属するNW
        private readonly Dictionary<GearNetworkId, GearNetwork> _gearNetworks = new();
        private readonly Random _random = new(215180);
        
        public GearNetworkDatastore()
        {
            _instance = this;
            _blockEntityToGearNetwork = new Dictionary<BlockInstanceId, GearNetwork>();
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        public IReadOnlyDictionary<GearNetworkId, GearNetwork> GearNetworks => _gearNetworks;
        
        public static void AddGear(IGearEnergyTransformer gear)
        {
            _instance.AddGearInternal(gear);
        }
        
        private void AddGearInternal(IGearEnergyTransformer gear)
        {
            var connectedNetworkIds = new HashSet<GearNetworkId>();
            foreach (var connectedGear in gear.GetGearConnects())
                //新しく設置された歯車に接続している歯車は、すべて既存のNWに接続している前提
                if (_blockEntityToGearNetwork.ContainsKey(connectedGear.Transformer.BlockInstanceId))
                {
                    var networkId = _blockEntityToGearNetwork[connectedGear.Transformer.BlockInstanceId].NetworkId;
                    connectedNetworkIds.Add(networkId);
                }
            
            //接続しているNWが1つもない場合は新規NWを作成
            switch (connectedNetworkIds.Count)
            {
                case 0:
                    CreateNetwork();
                    break;
                case 1:
                    ConnectNetwork();
                    break;
                default:
                    MergeNetworks();
                    break;
            }
            
            #region Internal
            
            void CreateNetwork()
            {
                var networkId = GearNetworkId.CreateNetworkId();
                var network = new GearNetwork(networkId);
                network.AddGear(gear);
                _blockEntityToGearNetwork.Add(gear.BlockInstanceId, network);
                _gearNetworks.Add(networkId, network);
            }
            
            void ConnectNetwork()
            {
                var networkId = connectedNetworkIds.First();
                var network = _gearNetworks[networkId];
                network.AddGear(gear);
                _blockEntityToGearNetwork.Add(gear.BlockInstanceId, network);
            }
            
            void MergeNetworks()
            {
                // マージのために歯車を取得
                var transformers = new List<IGearEnergyTransformer>();
                var generators = new List<IGearGenerator>();
                
                foreach (var networkId in connectedNetworkIds.ToList())
                {
                    var network = _gearNetworks[networkId];
                    transformers.AddRange(network.GearTransformers);
                    generators.AddRange(network.GearGenerators);
                    _gearNetworks.Remove(networkId);
                }
                
                var newNetworkId = GearNetworkId.CreateNetworkId();
                var newNetwork = new GearNetwork(newNetworkId);
                
                foreach (var transformer in transformers) newNetwork.AddGear(transformer);
                foreach (var generator in generators) newNetwork.AddGear(generator);
                
                transformers.Add(gear);
                newNetwork.AddGear(gear);
                _blockEntityToGearNetwork[gear.BlockInstanceId] = newNetwork;
                
                // マージしたNWに所属する歯車のNWを更新
                for (var i = 0; i < _blockEntityToGearNetwork.Keys.Count; i++)
                {
                    var pair = _blockEntityToGearNetwork.ElementAt(i);
                    if (connectedNetworkIds.Contains(pair.Value.NetworkId)) _blockEntityToGearNetwork[pair.Key] = newNetwork;
                }
                
                _gearNetworks.Add(newNetworkId, newNetwork);
                foreach (var removeNetworkId in connectedNetworkIds) _gearNetworks.Remove(removeNetworkId);
            }
            
            #endregion
        }
        
        public static void RemoveGear(IGearEnergyTransformer gear)
        {
            // 自身をnetworkから削除
            var network = _instance._blockEntityToGearNetwork[gear.BlockInstanceId];
            network.RemoveGear(gear);
            _instance._blockEntityToGearNetwork.Remove(gear.BlockInstanceId);
            
            //削除する歯車以外の元々接続していたブロックをすべて取得
            var transformers = new List<IGearEnergyTransformer>();
            transformers.AddRange(network.GearTransformers);
            transformers.AddRange(network.GearGenerators);
            
            //接続していた歯車ネットワークをデータベースから破棄
            _instance._gearNetworks.Remove(network.NetworkId);
            
            //gearに接続されている全てのgearをblockEntityToGearNetworkから削除
            foreach (var transformer in transformers)
            {
                _instance._blockEntityToGearNetwork.Remove(transformer.BlockInstanceId);
            }
            
            // 歯車を再追加する。重くなったらアルゴリズムを変える。
            foreach (var transformer in transformers) AddGear(transformer);
        }
        
        private void Update()
        {
            foreach (var gearNetwork in _gearNetworks.Values) // TODO パフォーマンスがやばくなったらやめる
                gearNetwork.ManualUpdate();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Player/PlayerObjectController.cs
```cs
using Client.Game.InGame.BlockSystem;
using Client.Network.API;
using StarterAssets;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Player
{
    public interface IPlayerObjectController
    {
        public Vector3 Position { get; }
        public void SetPlayerPosition(Vector3 playerPos);
        public void SetActive(bool active);
        
        public void SetAnimationState(string state);
    }
    
    public class PlayerAnimationState
    {
        public const string IdleWalkRunBlend = "Idle Walk Run Blend";
        public const string JumpStart = "JumpStart";
        public const string JumpInAir = "JumpInAir";
        public const string JumpLand = "JumpLand";
        public const string Axe = "Axe";
    }
    
    public class PlayerObjectController : MonoBehaviour, IPlayerObjectController
    {
        public Vector3 Position => transform.position;
        public Vector2 Position2d => new(transform.position.x, transform.position.z);
        
        [SerializeField] private ThirdPersonController controller;
        [SerializeField] private Animator animator;
        
        [Inject]
        public void Construct(InitialHandshakeResponse initialHandshakeResponse)
        {
            controller.Initialize();
            SetPlayerPosition(initialHandshakeResponse.PlayerPos);
        }
        
        private void LateUpdate()
        {
            if (transform.localPosition.y < -10)
            {
                var height = SlopeBlockPlaceSystem.GetGroundPoint(transform.position).y;
                SetPlayerPosition(new Vector3(transform.localPosition.x, height, transform.localPosition.z));
            }
        }
        
        /// <summary>
        ///     注意：アップデートのタイミングによってはThirdPersonController.csによる戻しが発生する可能性がある
        ///     セットしても位置が変わらなかった時はThirdPersonController.csをオフにして位置がセットできているか試してください
        /// </summary>
        /// <param name="playerPos"></param>
        public void SetPlayerPosition(Vector3 playerPos)
        {
            controller.Warp(playerPos);
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        public void SetAnimationState(string state)
        {
            animator.Play(state);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/InitialaizePipeline.cs
```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Define;
using Client.Mod.Texture;
using Client.Network;
using Client.Network.API;
using Client.Network.Settings;
using Core.Master;
using Cysharp.Threading.Tasks;
using Server.Boot;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using BlockObjectInfo = Client.Game.InGame.Context.BlockObjectInfo;
using Debug = UnityEngine.Debug;

namespace Client.Starter
{
    /// <summary>
    ///     シーンのロード、アセットのロード、サーバーとの接続を行う
    ///     TODO 何かが失敗したらそのログを出すようにする
    /// </summary>
    public class InitializeScenePipeline : MonoBehaviour
    {
        [SerializeField] private BlockIconImagePhotographer blockIconImagePhotographer;
        [SerializeField] private BlockGameObject missingBlockIdObject;
        
        [SerializeField] private TMP_Text loadingLog;
        [SerializeField] private Button backToMainMenuButton;
        
        private InitializeProprieties _proprieties;
        
        private void Awake()
        {
            backToMainMenuButton.onClick.AddListener(() => SceneManager.LoadScene(SceneConstant.MainMenuSceneName));
        }
        
        private void Start()
        {
            Initialize().Forget();
        }
        
        private async UniTask Initialize()
        {
            var loadingStopwatch = new Stopwatch();
            loadingStopwatch.Start();
            
            _proprieties ??= new InitializeProprieties(false, null, ServerConst.LocalServerIp, ServerConst.LocalServerPort, ServerConst.DefaultPlayerId);
            
            // DIコンテナによるServerContextの作成
            new MoorestechServerDIContainerGenerator().Create(ServerConst.ServerDirectory);
            
            //Vanilla APIのロードに必要なものを作成
            var playerConnectionSetting = new PlayerConnectionSetting(_proprieties.PlayerId);
            VanillaApi vanillaApi = null;
            
            //セットされる変数
            BlockGameObjectContainer blockGameObjectContainer = null;
            ItemImageContainer itemImageContainer = null;
            AsyncOperation sceneLoadTask = null;
            InitialHandshakeResponse handshakeResponse = null;
            
            //各種ロードを並列実行
            try
            {
                await UniTask.WhenAll(CreateAndStartVanillaApi(), LoadBlockAndItemAssets(), MainGameSceneLoad());
            }
            catch (Exception e)
            {
                Debug.LogError($"初期化処理中にエラーが発生しました: {e.Message}\n{e.StackTrace}");
                // 初期化に失敗した場合はメインメニューへ戻る
                SceneManager.LoadScene(SceneConstant.MainMenuSceneName);
                return;
            }
            
            //staticアクセスできるコンテキストの作成
            var clientContext = new ClientContext(blockGameObjectContainer, itemImageContainer, playerConnectionSetting, vanillaApi);
            
            //シーンに遷移し、初期データを渡す
            SceneManager.sceneLoaded += MainGameSceneLoaded;
            sceneLoadTask.allowSceneActivation = true;
            
            
            #region Internal
            
            //初期データを渡す処理
            void MainGameSceneLoaded(Scene scene, LoadSceneMode mode)
            {
                SceneManager.sceneLoaded -= MainGameSceneLoaded;
                var starter = FindObjectOfType<MainGameStarter>();
                var resolver = starter.StartGame(handshakeResponse);
                var diContainer = new DIContainer(resolver);
                clientContext.SetDIContainer(diContainer);
            }
            
            async UniTask CreateAndStartVanillaApi()
            {
                //サーバーとの接続を確立
                var serverCommunicator = await ConnectionToServer();
                
                loadingLog.text += $"\nサーバーとの接続完了  {loadingStopwatch.Elapsed}";
                
                //データの受付開始
                var packetSender = new PacketSender(serverCommunicator);
                var exchangeManager = new PacketExchangeManager(packetSender);
                Task.Run(() => serverCommunicator.StartCommunicat(exchangeManager));
                
                //Vanilla APIの作成
                vanillaApi = new VanillaApi(exchangeManager, packetSender, serverCommunicator, playerConnectionSetting, _proprieties.LocalServerProcess);
                
                //最初に必要なデータを取得
                handshakeResponse = await vanillaApi.Response.InitialHandShake(playerConnectionSetting.PlayerId, default);
                
                loadingLog.text += $"\n初期データ取得完了  {loadingStopwatch.Elapsed}";
            }
            
            async UniTask<ServerCommunicator> ConnectionToServer()
            {
                var serverConfig = new ConnectionServerConfig(_proprieties.ServerIp, _proprieties.ServerPort);
                try
                {
                    // 10秒以内にサーバー接続できなければタイムアウト
                    var serverCommunicator = await ServerCommunicator.CreateConnectedInstance(serverConfig)
                        .Timeout(TimeSpan.FromSeconds(10));
                    
                    Debug.Log("接続完了");
                    return serverCommunicator;
                }
                catch (TimeoutException)
                {
                    Debug.LogError("サーバーへの接続がタイムアウトしました");
                    loadingLog.text += "\nサーバーへの接続がタイムアウトしました。メインメニューに戻ります。";
                    await UniTask.Delay(2000);
                    SceneManager.LoadScene(SceneConstant.MainMenuSceneName);
                    throw; // 再度スローして後続処理中断
                }
                catch (Exception e)
                {
                    Debug.LogError($"サーバーへの接続に失敗しました: {e.Message}");
                    loadingLog.text += "\nサーバーへの接続に失敗しました。メインメニューに戻ります。";
                    await UniTask.Delay(2000);
                    SceneManager.LoadScene(SceneConstant.MainMenuSceneName);
                    throw;
                }
            }
            
            async UniTask LoadBlockAndItemAssets()
            {
                // ブロックとアイテムのアセットをロード
                await UniTask.WhenAll(LoadBlockAssets(), LoadItemAssets());
                
                // アイテム画像がロードされていないブロックのアイテム画像をロードする
                await TakeBlockItemImage();
            }
            
            async UniTask LoadBlockAssets()
            {
                // TODo この辺も必要な時に必要なだけロードする用にしたいなぁ
                blockGameObjectContainer = await BlockGameObjectContainer.CreateAndLoadBlockGameObjectContainer(missingBlockIdObject);
                loadingLog.text += $"\nブロックアセットロード完了  {loadingStopwatch.Elapsed}";
            }
            
            async UniTask LoadItemAssets()
            {
                //通常のアイテム画像をロード
                //TODO 非同期で実行できるようにする
                itemImageContainer = ItemImageContainer.CreateAndLoadItemImageContainer(ServerConst.ServerModsDirectory);
                loadingLog.text += $"\nアイテム画像ロード完了  {loadingStopwatch.Elapsed}";
            }
            
            async UniTask TakeBlockItemImage()
            {
                // スクリーンショットを取る必要があるブロックを集める
                // Collect the blocks that need to be screenshot.
                var takeBlockInfos = new List<BlockObjectInfo>();
                var itemIds = new List<ItemId>();
                foreach (var blockId in MasterHolder.BlockMaster.GetBlockIds())
                {
                    var itemId = MasterHolder.BlockMaster.GetItemId(blockId);
                    var itemViewData = itemImageContainer.GetItemView(itemId);
                    
                    if (itemViewData.ItemImage != null || !blockGameObjectContainer.BlockObjects.TryGetValue(blockId, out var blockObjectInfo)) continue;
                    
                    itemIds.Add(itemId);
                    takeBlockInfos.Add(blockObjectInfo);
                }
                
                // アイコンを設定
                // Set the icon.
                var texture2Ds = await blockIconImagePhotographer.TakeBlockIconImages(takeBlockInfos);
                for (var i = 0; i < itemIds.Count; i++)
                {
                    var itemViewData = new ItemViewData(texture2Ds[i], MasterHolder.ItemMaster.GetItemMaster(itemIds[i]));
                    itemImageContainer.AddItemView(itemIds[i], itemViewData);
                }
                
                loadingLog.text += $"\nブロックスクリーンショット完了  {loadingStopwatch.Elapsed}";
            }
            
            async UniTask MainGameSceneLoad()
            {
                sceneLoadTask = SceneManager.LoadSceneAsync(SceneConstant.MainGameSceneName, LoadSceneMode.Single);
                sceneLoadTask.allowSceneActivation = false;
                
                var sceneLoadCts = new CancellationTokenSource();
                
                try
                {
                    await sceneLoadTask.ToUniTask(Progress.Create<float>(
                            x =>
                            {
                                if (x < 0.9f) return;
                                sceneLoadCts.Cancel(); //シーンの読み込みが完了したら終了 allowSceneActivationがfalseの時は0.9fで止まる
                            })
                        , cancellationToken: sceneLoadCts.Token);
                }
                catch (OperationCanceledException)
                {
                    // シーンロード完了
                }
                
                loadingLog.text += $"\nシーンロード完了  {loadingStopwatch.Elapsed}";
            }
            
            #endregion
        }
        
        
        public void SetProperty(InitializeProprieties proprieties)
        {
            _proprieties = proprieties;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Entity/ItemEntityObject.cs
```cs
using Client.Common.Server;
using UnityEngine;

namespace Client.Game.InGame.Entity
{
    public class ItemEntityObject : MonoBehaviour, IEntityObject
    {
        [SerializeField] private MeshRenderer meshRenderer;
        [SerializeField] private Material itemMaterial;
        private float _linerTime;
        private Vector3 _previousPosition;
        
        private Vector3 _targetPosition;
        
        private void Awake()
        {
            _targetPosition = transform.position;
            _previousPosition = transform.position;
        }
        
        //Linerでポジションを補完させる
        private void Update()
        {
            //補完する
            var rate = _linerTime / NetworkConst.UpdateIntervalSeconds;
            rate = Mathf.Clamp01(rate);
            transform.position = Vector3.Lerp(_previousPosition, _targetPosition, rate);
            _linerTime += Time.deltaTime;
        }
        
        public void SetDirectPosition(Vector3 position)
        {
            _targetPosition = position;
            _previousPosition = position;
            transform.position = position;
        }
        
        public void SetInterpolationPosition(Vector3 position)
        {
            _previousPosition = transform.position;
            _targetPosition = position;
            _linerTime = 0;
        }
        
        public void Destroy()
        {
            Destroy(gameObject);
        }
        
        public void SetTexture(Texture texture)
        {
            var material = new Material(itemMaterial) { mainTexture = texture };
            meshRenderer.material = material;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerComponent.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using Newtonsoft.Json;

namespace Game.CraftChainer.BlockComponent.Computer
{
    public class CraftChainerMainComputerComponent : ICraftChainerNode
    {
        public readonly CraftChainerNetworkContext CraftChainerNetworkContext;
        
        public CraftChainerNodeId NodeId { get; } = CraftChainerNodeId.Create();
        
        public CraftChainerMainComputerComponent(BlockConnectorComponent<IBlockInventory> mainComputerConnector)
        {
            CraftChainerNetworkContext = new CraftChainerNetworkContext(mainComputerConnector, this);
        }
        
        public CraftChainerMainComputerComponent(Dictionary<string, string> componentStates, BlockConnectorComponent<IBlockInventory> mainComputerConnector) : this(mainComputerConnector)
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerMainComputerComponentJsonObject>(state);
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        /// <summary>
        /// アイテムのクラフトをリクエストする
        /// Request to create an item
        /// </summary>
        /// <returns>
        /// クラフトリクエストが成功したかどうか
        /// Whether the craft request was successful
        /// </returns>
        public bool StartCreateItem(ItemId itemId, int count)
        {
            var (recipes, initialInventory, targetItem) = CreateInitialData();
            
            var solverResult = CraftChainerCraftingSolver.Solve(recipes, initialInventory, targetItem);
            
            // アイテムは作成できなかった
            // The item could not be created
            if (solverResult == null)
            {
                return false;
            }
            
            CraftChainerNetworkContext.SetCraftChainRecipeQue(solverResult, targetItem);
            return true;
            
            #region Internal
            
            (List<CraftingSolverRecipe> recipes, Dictionary<ItemId, int> initialInventory, CraftingSolverItem targetItem) CreateInitialData()
            {
                var recipeResults = new List<CraftingSolverRecipe>();
                foreach (var crafterComponent in CraftChainerNetworkContext.CrafterComponents)
                {
                    recipeResults.Add(crafterComponent.CraftingSolverRecipe);
                }
                
                var initialInventoryResults = new Dictionary<ItemId, int>();
                foreach (var chest in CraftChainerNetworkContext.ProviderChests)
                {
                    foreach (var item in chest.Inventory)
                    {
                        if (initialInventoryResults.ContainsKey(item.Id))
                        {
                            initialInventoryResults[item.Id] += item.Count;
                        }
                        else
                        {
                            initialInventoryResults[item.Id] = item.Count;
                        }
                    }
                }
                
                var target = new CraftingSolverItem(itemId, count);
                
                return (recipeResults, initialInventoryResults, target);
            }
            
  #endregion
        }
        
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        public string SaveKey { get; } = typeof(CraftChainerMainComputerComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerMainComputerComponentJsonObject(this));
        }
    }
    
    public class ChainerMainComputerComponentJsonObject
    {
        [JsonProperty("nodeId")] public int NodeId { get; set; }
        
        public ChainerMainComputerComponentJsonObject(){}
        public ChainerMainComputerComponentJsonObject(CraftChainerMainComputerComponent component)
        {
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/CraftInventoryView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Main;
using Core.Master;
using Game.CraftChainer.Util;
using Mooresmaster.Model.CraftRecipesModule;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    //TODO CraftITemViewにリネーム
    public class CraftInventoryView : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform craftMaterialParent;
        [SerializeField] private RectTransform craftResultParent;
        
        [SerializeField] private CraftButton craftButton;
        [SerializeField] private Button nextRecipeButton;
        [SerializeField] private Button prevRecipeButton;
        
        [SerializeField] private TMP_Text itemNameText;
        [SerializeField] private TMP_Text recipeCountText;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private readonly List<ItemSlotObject> _craftMaterialSlotList = new();
        private ItemSlotObject _craftResultSlot;
        private ILocalPlayerInventory _localPlayerInventory;
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        
        private int CraftRecipeCount => _currentItemRecipes.CraftRecipes.Count;
        private RecipeViewerItemRecipes _currentItemRecipes;
        private int _currentIndex;
        
        [Inject]
        public void Construct(ILocalPlayerInventory localPlayerInventory, ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;
            _localPlayerInventory = localPlayerInventory;
            _localPlayerInventory.OnItemChange.Subscribe(_ =>
            {
                if (_currentItemRecipes != null && _currentIndex < CraftRecipeCount)
                {
                    UpdateCraftButton(_currentItemRecipes.CraftRecipes[_currentIndex]);
                }
            });
            
            nextRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex++;
                if (CraftRecipeCount <= _currentIndex) _currentIndex = 0;
                DisplayRecipe(_currentIndex);
            });
            
            prevRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex--;
                if (_currentIndex < 0) _currentIndex = CraftRecipeCount - 1;
                DisplayRecipe(_currentIndex);
            });
            
            craftButton.OnCraftFinish.Subscribe(_ =>
            {
                if (_currentItemRecipes == null || CraftRecipeCount == 0)
                {
                    return;
                }
                
                var currentCraftGuid = _currentItemRecipes.CraftRecipes[_currentIndex].CraftRecipeGuid;
                ClientContext.VanillaApi.SendOnly.Craft(currentCraftGuid);
            }).AddTo(this);
        }
        
        private void UpdateCraftButton(CraftRecipeMasterElement craftRecipe)
        {
            craftButton.SetInteractable(IsCraftable(craftRecipe));
        }
        
        public void SetRecipes(RecipeViewerItemRecipes recipeViewerItemRecipes)
        {
            _currentItemRecipes = recipeViewerItemRecipes;
            _currentIndex = 0;
        }
        
        public void DisplayRecipe(int index)
        {
            var craftRecipe = _currentItemRecipes.CraftRecipes[index];
            
            ClearSlotObject();
            
            SetMaterialSlot();
            
            SetResultSlot();
            
            UpdateButtonAndText();
            
            #region InternalMethod
            
            void ClearSlotObject()
            {
                foreach (var materialSlot in _craftMaterialSlotList) Destroy(materialSlot.gameObject);
                _craftMaterialSlotList.Clear();
                if (_craftResultSlot != null) Destroy(_craftResultSlot.gameObject);
            }
            
            void SetMaterialSlot()
            {
                foreach (var requiredItem in craftRecipe.RequiredItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, craftMaterialParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _craftMaterialSlotList.Add(itemSlotObject);
                    
                    // 原材料をクリックしたときにそのレシピを表示するようにする
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetResultSlot()
            {
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(craftRecipe.CraftResultItemGuid);
                _craftResultSlot = Instantiate(itemSlotObjectPrefab, craftResultParent);
                _craftResultSlot.SetItem(itemViewData, craftRecipe.CraftResultCount);
            }
            
            void UpdateButtonAndText()
            {
                prevRecipeButton.interactable = CraftRecipeCount != 1;
                nextRecipeButton.interactable = CraftRecipeCount != 1;
                recipeCountText.text = $"{_currentIndex + 1} / {CraftRecipeCount}";
                craftButton.SetCraftTime(craftRecipe.CraftTime);
                UpdateCraftButton(craftRecipe);
                
                var itemName = MasterHolder.ItemMaster.GetItemMaster(craftRecipe.CraftResultItemGuid).Name;
                itemNameText.text = itemName;
            }
            
            void OnClickMaterialItem(ItemSlotObject itemSlotObject)
            {
                var itemId = itemSlotObject.ItemViewData.ItemId;
                var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
                _onClickItem.OnNext(itemRecipes);
            }
            
            #endregion
        }
        
        /// <summary>
        ///     そのレシピがクラフト可能かどうかを返す
        ///     この処理はある1つのレシピに対してのみ使い、一気にすべてのアイテムがクラフト可能かチェックするには<see cref="IsAllItemCraftable" />を用いる
        /// </summary>
        private bool IsCraftable(CraftRecipeMasterElement craftRecipeMasterElement)
        {
            var itemPerCount = new Dictionary<ItemId, int>();
            foreach (var item in _localPlayerInventory)
            {
                if (item.Id == ItemMaster.EmptyItemId) continue;
                if (itemPerCount.ContainsKey(item.Id))
                    itemPerCount[item.Id] += item.Count;
                else
                    itemPerCount.Add(item.Id, item.Count);
            }
            
            foreach (var requiredItem in craftRecipeMasterElement.RequiredItems)
            {
                var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (!itemPerCount.ContainsKey(itemId)) return false;
                if (itemPerCount[itemId] < requiredItem.Count) return false;
            }
            
            return true;
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryMoveUtil/ItemMoveInventoryInfo.cs
```cs
using UnityEngine;

namespace Server.Protocol.PacketResponse.Util.InventoryMoveUtil
{
    public class ItemMoveInventoryInfo
    {
        public readonly ItemMoveInventoryType ItemMoveInventoryType;
        public readonly Vector3Int Pos; // TODO こういうところをポジションベースからinstance idベースにする
        
        /// <summary>
        ///     アイテム移動用のパラメータクラスです
        /// </summary>
        /// <param name="itemMoveInventoryType">移動元のインベントリタイプ</param>
        /// <param name="x">ブロックインベントリの時は座標を指定する</param>
        /// <param name="y">ブロックインベントリの時は座標を指定する</param>
        public ItemMoveInventoryInfo(ItemMoveInventoryType itemMoveInventoryType, Vector3Int blockPos = default)
        {
            ItemMoveInventoryType = itemMoveInventoryType;
            Pos = blockPos;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/PlayerInventoryState.cs
```cs
using System.Threading;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.Inventory.RecipeViewer;
using Client.Input;
using Client.Network.API;
using Cysharp.Threading.Tasks;
using Game.PlayerInventory.Interface;

namespace Client.Game.InGame.UI.UIState
{
    public class PlayerInventoryState : IUIState
    {
        private readonly RecipeViewerView _recipeViewerView;
        private readonly LocalPlayerInventoryController _localPlayerInventoryController;
        private readonly PlayerInventoryViewController _playerInventoryViewController;
        
        private CancellationTokenSource _cancellationTokenSource;
        
        public PlayerInventoryState(RecipeViewerView recipeViewerView,PlayerInventoryViewController playerInventoryViewController, LocalPlayerInventoryController localPlayerInventoryController, InitialHandshakeResponse handshakeResponse)
        {
            _recipeViewerView = recipeViewerView;
            _playerInventoryViewController = playerInventoryViewController;
            _localPlayerInventoryController = localPlayerInventoryController;
            
            _playerInventoryViewController.SetActive(false); //TODO この辺のオンオフをまとめたい
            _recipeViewerView.SetActive(false);
            
            //インベントリの初期設定
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var item = handshakeResponse.Inventory.MainInventory[i];
                _localPlayerInventoryController.SetMainItem(i, item);
            }
            
            _localPlayerInventoryController.SetGrabItem(handshakeResponse.Inventory.GrabItem);
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.CloseUI.GetKeyDown || InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.GameScreen;
            
            return UIStateEnum.Current;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            _recipeViewerView.SetActive(true);
            _playerInventoryViewController.SetActive(true);
            _playerInventoryViewController.SetSubInventory(new EmptySubInventory());
            
            _cancellationTokenSource = new CancellationTokenSource();
            UpdatePlayerInventory(_cancellationTokenSource.Token).Forget();
            
            InputManager.MouseCursorVisible(true);
        }
        
        public void OnExit()
        {
            _cancellationTokenSource.Cancel();
            _cancellationTokenSource = null;
            
            _recipeViewerView.SetActive(false);
            _playerInventoryViewController.SetActive(false);
        }
        
        /// <summary>
        ///     基本的にプレイヤーのインベントリはイベントによって逐次更新データが送られてくるため、これをする必要がない
        ///     ただ、更新データが何らかの原因で送られてこなかったり、適用できなかった時のために、バックアップとしてインベントリが開いた際は更新をかけるようにしている
        /// </summary>
        private async UniTask UpdatePlayerInventory(CancellationToken ct)
        {
            var invResponse = await ClientContext.VanillaApi.Response.GetMyPlayerInventory(ct);
            
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var item = invResponse.MainInventory[i];
                _localPlayerInventoryController.SetMainItem(i, item);
            }
            
            _localPlayerInventoryController.SetGrabItem(invResponse.GrabItem);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/IItemStack.cs
```cs
using Core.Master;

namespace Core.Item.Interface
{
    public interface IItemStack
    {
        ItemId Id { get; }
        int Count { get; }
        
        /// <summary>
        ///     アイテムを識別するID
        ///     新しいインスタンスが生成されるたびにかわる
        ///     基本的にメモリ上でアイテムをエンティティとして扱うために使われるID、「今のところ」保存しなくてよい
        /// </summary>
        ItemInstanceId ItemInstanceId { get; }
        
        ItemProcessResult AddItem(IItemStack receiveItemStack);
        IItemStack SubItem(int subCount);
        
        /// <summary>
        ///     アイテムを追加できるときtrueを返す
        ///     あまりがある時はfalceを返す
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        bool IsAllowedToAdd(IItemStack item);
        
        /// <summary>
        ///     アイテムを追加できるが、余りが発生する場合trueを返します
        ///     あまりが発生しない場合でも追加ができるならtrueを返します
        ///     IDが違うことで追加ができない場合はfalseを返します
        /// </summary>
        /// <returns>あまりが出ても追加できるときはtrue</returns>
        bool IsAllowedToAddWithRemain(IItemStack item);
        
        // ひとまず追加はしたが、用途がないので放置。 moddingとかに使うかもしれないので取っておいてはいるが、動作はサポートしていないです。
        // I added it for the time being, but left it alone because I have no use for it. I'm keeping it because I might use it for modding or something, but I don't support its operation.
        public ItemStackMetaData GetMeta(string key);
        public bool TryGetMeta(string key, out ItemStackMetaData value); 
        public IItemStack SetMeta(string key, ItemStackMetaData value);
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryService/InventoryItemMoveService.cs
```cs
using System;
using Core.Inventory;
using Game.Context;
using UnityEngine;

namespace Server.Protocol.PacketResponse.Util.InventoryService
{
    public static class InventoryItemMoveService
    {
        public static void Move(IOpenableInventory fromInventory, int fromSlot, IOpenableInventory toInventory, int toSlot, int itemCount)
        {
            try
            {
                ExecuteMove(fromInventory, fromSlot, toInventory, toSlot, itemCount);
            }
            catch (ArgumentOutOfRangeException e)
            {
                //TODO ログ基盤に入れる
                var fromInventoryName = fromInventory.GetType().Name;
                var toInventoryName = toInventory.GetType().Name;
                Debug.Log(
                    $"InventoryItemMoveService.Move: \n {e.Message} \n fromInventory={fromInventoryName} fromSlot={fromSlot} toInventory={toInventoryName} toSlot={toSlot} itemCount={itemCount}  \n {e.StackTrace}");
            }
            catch (Exception e)
            {
                Debug.Log(e);
            }
        }
        
        private static void ExecuteMove(IOpenableInventory fromInventory, int fromSlot, IOpenableInventory toInventory, int toSlot, int itemCount)
        {
            //移動元と移動先のスロットが同じ場合は移動しない
            if (fromInventory.GetHashCode() == toInventory.GetHashCode() && fromSlot == toSlot) return;
            
            
            //移動元からアイテムを取得
            var originItem = fromInventory.GetItem(fromSlot);
            //移動アイテム数が本来のアイテムより多い時は、本来のアイテム数に修正する
            if (originItem.Count < itemCount) itemCount = originItem.Count;
            
            //実際に移動するアイテムインスタンスの作成
            var moveItem = ServerContext.ItemStackFactory.Create(originItem.Id, itemCount);
            
            var destinationInventoryItem = toInventory.GetItem(toSlot);
            
            //移動先アイテムがなかった時はそのまま入れかえる
            //移動先と同じIDの時は移動先スロットに加算し、余ったアイテムを移動元インベントリに入れる
            if (destinationInventoryItem.Count == 0 || originItem.Id == destinationInventoryItem.Id)
            {
                //移動先インベントリにアイテムを移動
                var replaceItem = toInventory.ReplaceItem(toSlot, moveItem);
                
                //移動元インベントリに残るアイテムを計算
                //ゼロの時は自動でNullItemになる
                var playerItemCount = originItem.Count - itemCount;
                var addItem = ServerContext.ItemStackFactory.Create(originItem.Id, playerItemCount);
                var remainItem = replaceItem.AddItem(addItem).ProcessResultItemStack;
                
                //移動元インベントリに残りのアイテムをセット
                fromInventory.SetItem(fromSlot, remainItem);
            }
            //移動元と移動先のIDが異なる時、移動元インベントリのアイテムをすべて入れ替える時にのみ入れ替えを実行する
            //一部入れ替え時は入れ替え作業は実行しない
            else if (itemCount == originItem.Count)
            {
                toInventory.SetItem(toSlot, originItem);
                fromInventory.SetItem(fromSlot, destinationInventoryItem);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ConnectingInventoryListPriorityInsertItemServiceTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks.Service;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Other
{
    public class ConnectingInventoryListPriorityInsertItemServiceTest
    {
        /// <summary>
        ///     アイテムを挿入の優先度がループしてるかテストする
        /// </summary>
        [Test]
        public void Test()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var inventoryList = new List<IBlockInventory>();
            
            //インベントリ1はインベントリのサイズを1にして、インベントリ2に入るか確認する
            var inventory1 = new DummyBlockInventory(1, 1);
            var inventory2 = new DummyBlockInventory();
            var inventory3 = new DummyBlockInventory();
            inventoryList.Add(inventory1);
            inventoryList.Add(inventory2);
            inventoryList.Add(inventory3);
            
            var componentPos = new BlockPositionInfo(Vector3Int.zero, BlockDirection.North, Vector3Int.one);
            var inputConnectorComponent = new BlockConnectorComponent<IBlockInventory>(null, null, componentPos);
            
            var targets = (Dictionary<IBlockInventory, ConnectedInfo>)inputConnectorComponent.ConnectedTargets;
            
            foreach (var inventory in inventoryList) targets.Add(inventory, new ConnectedInfo());
            
            var service = new ConnectingInventoryListPriorityInsertItemService(inputConnectorComponent);
            
            service.InsertItem(itemStackFactory.Create(new ItemId(1), 4));
            service.InsertItem(itemStackFactory.Create(new ItemId(2), 3));
            service.InsertItem(itemStackFactory.Create(new ItemId(3), 2));
            service.InsertItem(itemStackFactory.Create(new ItemId(4), 1));
            
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 4), inventory1.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 3), inventory2.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), inventory3.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(4), 1), inventory2.InsertedItems[1]);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MasterHolder.cs
```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class MasterHolder
    {
        public static ItemMaster ItemMaster { get; private set; }
        public static BlockMaster BlockMaster { get; private set; }
        public static ChallengeMaster ChallengeMaster { get; private set; }
        public static CraftRecipeMaster CraftRecipeMaster { get; private set; }
        public static MachineRecipesMaster MachineRecipesMaster { get; private set; }
        public static MapObjectMaster MapObjectMaster { get; private set; }
        
        public static void Load(MasterJsonFileContainer masterJsonFileContainer)
        {
            ItemMaster = new ItemMaster(GetJson(masterJsonFileContainer, new JsonFileName("items")));
            BlockMaster = new BlockMaster(GetJson(masterJsonFileContainer, new JsonFileName("blocks")), ItemMaster);
            ChallengeMaster = new ChallengeMaster(GetJson(masterJsonFileContainer, new JsonFileName("challenges")));
            
            CraftRecipeMaster = new CraftRecipeMaster(GetJson(masterJsonFileContainer, new JsonFileName("craftRecipes")));
            
            MachineRecipesMaster = new MachineRecipesMaster(GetJson(masterJsonFileContainer, new JsonFileName("machineRecipes")));
            MapObjectMaster = new MapObjectMaster(GetJson(masterJsonFileContainer, new JsonFileName("mapObjects")));
        }
        
        private static JToken GetJson(MasterJsonFileContainer masterJsonFileContainer, JsonFileName jsonFileName)
        {
            var index = 0; // TODO 現状はとりあえず一つのmodのみロードする。今後は複数のjsonファイルをロードできるようにする。
            var jsonContent = masterJsonFileContainer.ConfigJsons[index].JsonContents[jsonFileName];
            
            return (JToken)JsonConvert.DeserializeObject(jsonContent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Blocks/RailComponent.cs
```cs
using Game.Block.Interface.Component;
using Game.Train.RailGraph;

namespace Game.Train.Blocks
{
    /// <summary>
    /// レールの基本構成要素を表すクラス。
    /// レールに関連する機能を提供。
    /// </summary>
    public class RailComponent : IBlockComponent
    {
        // レールが破壊されたかどうかを示すフラグ
        public bool IsDestroy { get; private set; }

        // このレールに関連付けられているRailNode（表と裏）
        public RailNode FrontNode { get; private set; }
        public RailNode BackNode { get; private set; }

        // コンストラクタ
        public RailComponent(RailGraphDatastore railGraph)
        {
            // RailGraphにノードを登録
            FrontNode = new RailNode(railGraph);
            BackNode = new RailNode(railGraph);
            FrontNode.SetOppositeNode(BackNode);
            BackNode.SetOppositeNode(FrontNode);
        }

        /// <summary>
        /// このレールを破壊する処理
        /// </summary>
        public void Destroy()
        {
            IsDestroy = true;
        }

    }
}

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/RequestBlockInventoryTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.BlockInventoryRequestProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class RequestBlockInventoryTest
    {
        private const int InputSlotNum = 2;
        private const int OutPutSlotNum = 3;
        
        //通常の機械のテスト
        [Test]
        public void MachineInventoryRequest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(5, 10), BlockDirection.North, out var machineBlock);
            var machineComponent = machineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            machineComponent.SetItem(0, itemStackFactory.Create(new ItemId(1), 2));
            machineComponent.SetItem(2, itemStackFactory.Create(new ItemId(4), 5));
            
            //レスポンスの取得
            var data = MessagePackSerializer.Deserialize<BlockInventoryResponseProtocolMessagePack>(packet.GetPacketResponse(RequestBlock(new Vector3Int(5, 10)))[0].ToArray());
            
            Assert.AreEqual(InputSlotNum + OutPutSlotNum, data.Items.Length); // slot num
            
            
            Assert.AreEqual(ForUnitTestModBlockId.MachineId, data.BlockId); // block id
            
            Assert.AreEqual(1, data.Items[0].Id.AsPrimitive()); // item id
            Assert.AreEqual(2, data.Items[0].Count); // item count
            
            Assert.AreEqual(0, data.Items[1].Id.AsPrimitive());
            Assert.AreEqual(0, data.Items[1].Count);
            
            Assert.AreEqual(4, data.Items[2].Id.AsPrimitive());
            Assert.AreEqual(5, data.Items[2].Count);
        }
        
        private List<byte> RequestBlock(Vector3Int pos)
        {
            return MessagePackSerializer.Serialize(new RequestBlockInventoryRequestProtocolMessagePack(pos)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/PowerGenerator/VanillaElectricGeneratorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Core.Const;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Event;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json;

namespace Game.Block.Blocks.PowerGenerator
{
    public class VanillaElectricGeneratorComponent : IElectricGenerator, IBlockInventory, IOpenableInventory, IBlockSaveState, IUpdatableBlockComponent
    {
        private readonly BlockComponentManager _blockComponentManager = new();
        private readonly Dictionary<ItemId, FuelItemsElement> _fuelSettings;
        
        private readonly ElectricPower _infinityPower;
        private readonly bool _isInfinityPower;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        private ItemId _currentFuelItemId = ItemMaster.EmptyItemId;
        private double _remainingFuelTime;
        
        public VanillaElectricGeneratorComponent(VanillaPowerGeneratorProperties data)
        {
            BlockPositionInfo = data.BlockPositionInfo;
            BlockInstanceId = data.BlockInstanceId;
            _fuelSettings = data.FuelSettings;
            _isInfinityPower = data.IsInfinityPower;
            _infinityPower = data.InfinityPower;
            
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, data.FuelItemSlot);
            
            _blockComponentManager.AddComponent(data.InventoryInputConnectorComponent);
        }
        
        public VanillaElectricGeneratorComponent(Dictionary<string, string> componentStates, VanillaPowerGeneratorProperties data) : this(data)
        {
            var saveData = JsonConvert.DeserializeObject<VanillaElectricGeneratorSaveJsonObject>(componentStates[SaveKey]);
            
            var itemId = MasterHolder.ItemMaster.GetItemId(saveData.CurrentFuelItemGuid);
            _currentFuelItemId = itemId;
            _remainingFuelTime = saveData.RemainingFuelTime;
            
            for (var i = 0; i < saveData.Items.Count; i++)
            {
                _itemDataStoreService.SetItem(i, saveData.Items[i].ToItemStack());
            }
        }
        public BlockPositionInfo BlockPositionInfo { get; }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemStack);
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _itemDataStoreService.GetSlotSize();
        }
        
        public string SaveKey { get; } = typeof(VanillaElectricGeneratorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var itemGuid = MasterHolder.ItemMaster.GetItemMaster(_currentFuelItemId).ItemGuid;
            var saveData = new VanillaElectricGeneratorSaveJsonObject
            {
                CurrentFuelItemGuidStr = itemGuid.ToString(),
                RemainingFuelTime = _remainingFuelTime,
                Items = _itemDataStoreService.InventoryItems.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
            };
            
            return JsonConvert.SerializeObject(saveData);
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        
        public bool IsDestroy { get; private set; }
        
        public ElectricPower OutputEnergy()
        {
            BlockException.CheckDestroy(this);
            
            if (_isInfinityPower) return _infinityPower;
            if (_fuelSettings.TryGetValue(_currentFuelItemId, out var fuelSetting))
            {
                return (ElectricPower)fuelSetting.Power;
            }
            
            return new ElectricPower(0);
        }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        public IReadOnlyList<IItemStack> InventoryItems => _itemDataStoreService.InventoryItems;
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            return _itemDataStoreService.CreateCopiedItems();
        }
        
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.ReplaceItem(slot, itemId, count);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemId, count);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertionCheck(itemStacks);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            _itemDataStoreService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.ReplaceItem(slot, itemStack);
        }
        
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            //現在燃料を消費しているか判定
            //燃料が在る場合は燃料残り時間をUpdate時間分減らす
            if (_currentFuelItemId != ItemMaster.EmptyItemId)
            {
                _remainingFuelTime -= GameUpdater.UpdateSecondTime;
                
                //残り時間が0以下の時は燃料の設定をNullItemIdにする
                if (_remainingFuelTime <= 0) _currentFuelItemId = ItemMaster.EmptyItemId;
                
                return;
            }
            
            //燃料がない場合はスロットに燃料が在るか判定する
            //スロットに燃料がある場合は燃料の設定し、アイテムを1個減らす
            for (var i = 0; i < _itemDataStoreService.GetSlotSize(); i++)
            {
                //スロットに燃料がある場合
                var slotItemId = _itemDataStoreService.InventoryItems[i].Id;
                if (!_fuelSettings.ContainsKey(slotItemId)) continue;
                
                //ID、残り時間を設定
                _currentFuelItemId = MasterHolder.ItemMaster.GetItemId(_fuelSettings[slotItemId].ItemGuid);
                _remainingFuelTime = _fuelSettings[slotItemId].Time;
                
                //アイテムを1個減らす
                _itemDataStoreService.SetItem(i, _itemDataStoreService.InventoryItems[i].SubItem(1));
                return;
            }
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            var blockInventoryUpdate = (BlockOpenableInventoryUpdateEvent)ServerContext.BlockOpenableInventoryUpdateEvent;
            var properties = new BlockOpenableInventoryUpdateEventProperties(BlockInstanceId, slot, itemStack);
            blockInventoryUpdate.OnInventoryUpdateInvoke(properties);
        }
    }
    
    public class VanillaElectricGeneratorSaveJsonObject
    {
        [JsonProperty("currentFuelItemGuid")]
        public string CurrentFuelItemGuidStr;
        [JsonIgnore] public Guid CurrentFuelItemGuid => Guid.Parse(CurrentFuelItemGuidStr);
        
        [JsonProperty("inventory")]
        public List<ItemStackSaveJsonObject> Items;
        
        [JsonProperty("remainingFuelTime")]
        public double RemainingFuelTime;
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerCrafterSaveLoadTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerCrafterSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);

            // クラフターを作成
            // Create a Crafter block
            var crafterBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerCrafter, new BlockInstanceId(1), posInfo);

            // レシピを設定
            // Set the recipe
            var originalCrafter = crafterBlock.GetComponent<CraftCraftChainerCrafterComponent>();
            var inputItems = new List<CraftingSolverItem>
            {
                new(new ItemId(1), 10),
                new(new ItemId(2), 5)
            };

            var outputItems = new List<CraftingSolverItem>
            {
                new(new ItemId(3), 15)
            };

            originalCrafter.SetRecipe(inputItems, outputItems);
            
            // セーブデータを取得
            // Get the save data
            var saveState = crafterBlock.GetSaveState();
            
            // ブロックをロード
            // Load the block
            var loadedBlock = blockFactory.Load( crafterBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedCrafterComponent = loadedBlock.GetComponent<CraftCraftChainerCrafterComponent>();

            // ノードIDのチェック
            // Check the node ID
            Assert.AreEqual(originalCrafter.NodeId, loadedCrafterComponent.NodeId);

            // レシピの設定をチェック
            // Check the recipe settings
            Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs.Count, loadedCrafterComponent.CraftingSolverRecipe.Inputs.Count);
            Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs.Count, loadedCrafterComponent.CraftingSolverRecipe.Outputs.Count);

            for (int i = 0; i < originalCrafter.CraftingSolverRecipe.Inputs.Count; i++)
            {
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs[i].ItemId, loadedCrafterComponent.CraftingSolverRecipe.Inputs[i].ItemId);
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs[i].Count, loadedCrafterComponent.CraftingSolverRecipe.Inputs[i].Count);
            }

            for (int i = 0; i < originalCrafter.CraftingSolverRecipe.Outputs.Count; i++)
            {
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs[i].ItemId, loadedCrafterComponent.CraftingSolverRecipe.Outputs[i].ItemId);
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs[i].Count, loadedCrafterComponent.CraftingSolverRecipe.Outputs[i].Count);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/IElectricGenerator.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;

namespace Game.EnergySystem
{
    /// <summary>
    ///     何らかのエネルギーを生産するモノ
    /// </summary>
    public interface IElectricGenerator : IBlockComponent
    {
        public BlockInstanceId BlockInstanceId { get; }
        ElectricPower OutputEnergy();
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/MainGameStarter.cs
```cs
using System.Diagnostics;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.Control;
using Client.Game.InGame.Electric;
using Client.Game.InGame.Entity;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Mining;
using Client.Game.InGame.Player;
using Client.Game.InGame.Presenter.Command;
using Client.Game.InGame.Presenter.PauseMenu;
using Client.Game.InGame.Presenter.Player;
using Client.Game.InGame.Tutorial;
using Client.Game.InGame.Tutorial.UIHighlight;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.Inventory.RecipeViewer;
using Client.Game.InGame.UI.Inventory.Sub;
using Client.Game.InGame.UI.UIState;
using Client.Game.InGame.UI.UIState.UIObject;
using Client.Game.InGame.World;
using Client.Game.Sequence;
using Client.Game.Skit;
using Client.Game.Skit.Starter;
using Client.Network.API;
using Game.CraftChainer.Util;
using UnityEngine;
using VContainer;
using VContainer.Unity;

namespace Client.Starter
{
    /// <summary>
    ///     ゲームの起動と依存解決を行うクラス
    ///     誰かこの最初に全部依存を解決する方法じゃない方法で、いい感じに依存解決できる方法あったら教えてください
    /// </summary>
    public class MainGameStarter : LifetimeScope
    {
        // Hierarchy上にある依存解決が必要なものをまとめたところ
        //TODO regionでちゃんと分類分けしたい
        
        [Header("InHierarchy")] [SerializeField]
        private Camera mainCamera;
        
        [SerializeField] private BlockGameObjectDataStore blockGameObjectDataStore;
        [SerializeField] private MapObjectGameObjectDatastore mapObjectGameObjectDatastore;
        
        [SerializeField] private CommandUIInput commandUIInput;
        [SerializeField] private HotBarView hotBarView;
        [SerializeField] private PlayerObjectController playerObjectController;
        [SerializeField] private MapObjectMiningController mapObjectMiningController;
        
        [SerializeField] private EntityObjectDatastore entityObjectDatastore;
        
        [SerializeField] private UIStateControl uIStateControl;
        [SerializeField] private PauseMenuObject pauseMenuObject;
        [SerializeField] private DeleteBarObject deleteBarObject;
        [SerializeField] private PlayerInventoryViewController playerInventoryViewController;
        [SerializeField] private CraftInventoryView craftInventoryView;
        [SerializeField] private MachineRecipeView machineRecipeView;
        [SerializeField] private RecipeViewerView recipeViewerView;
        [SerializeField] private ItemListView itemListView;
        
        [SerializeField] private MapObjectPin mapObjectPin;
        [SerializeField] private UIHighlightTutorialManager uiHighlightTutorialManager;
        [SerializeField] private KeyControlTutorialManager keyControlTutorialManager;
        
        [SerializeField] private BlockPlacePreview blockPlacePreview;
        [SerializeField] private SaveButton saveButton;
        [SerializeField] private BackToMainMenu backToMainMenu;
        [SerializeField] private NetworkDisconnectPresenter networkDisconnectPresenter;
        [SerializeField] private ChallengeManager challengeManager;
        
        [SerializeField] private PlayerSkitStarterDetector playerSkitStarterDetector;
        [SerializeField] private SkitManager skitManager;
        
        [SerializeField] private DisplayEnergizedRange displayEnergizedRange;
        
        [SerializeField] private InGameCameraController inGameCameraController;
        
        
        private IObjectResolver _resolver;
        private string IPAddress = ServerConst.LocalServerIp;
        
        private bool isLocal;
        private Process localServerProcess;
        
        private int PlayerId = ServerConst.DefaultPlayerId;
        private int Port = ServerConst.LocalServerPort;
        
        protected override void OnDestroy()
        {
            _resolver?.Dispose();
        }
        
        public IObjectResolver StartGame(InitialHandshakeResponse initialHandshakeResponse)
        {
            var builder = new ContainerBuilder();
            
            //最初に取得したデータを登録
            // register initial data
            builder.RegisterInstance(initialHandshakeResponse);
            
            //インベントリのUIコントロール
            // register inventory UI control
            builder.Register<LocalPlayerInventoryController>(Lifetime.Singleton);
            builder.Register<ILocalPlayerInventory, LocalPlayerInventory>(Lifetime.Singleton);
            builder.RegisterEntryPoint<NetworkEventInventoryUpdater>();
            
            //プレゼンターアセンブリ
            // register presenter assembly
            builder.RegisterEntryPoint<CommonMachineBlockStateChangeProcessor>();
            builder.RegisterEntryPoint<WorldDataHandler>();
            builder.RegisterEntryPoint<PlayerPositionSender>();
            builder.RegisterEntryPoint<BlockStateEventHandler>();
            builder.RegisterEntryPoint<BlockPlaceSystem>().AsSelf();
            
            
            //UIコントロール
            // register UI control
            builder.Register<UIStateDictionary>(Lifetime.Singleton);
            builder.Register<BlockInventoryState>(Lifetime.Singleton);
            builder.Register<GameScreenState>(Lifetime.Singleton);
            builder.Register<PauseMenuState>(Lifetime.Singleton);
            builder.Register<PlayerInventoryState>(Lifetime.Singleton);
            builder.Register<DeleteBlockState>(Lifetime.Singleton);
            builder.Register<SkitState>(Lifetime.Singleton);
            builder.Register<PlaceBlockState>(Lifetime.Singleton);
            builder.Register<ItemRecipeViewerDataContainer>(Lifetime.Singleton);
            
            // チュートリアル関連
            // register tutorial
            builder.Register<TutorialManager>(Lifetime.Singleton);
            
            //Hierarchy上にあるcomponent
            // register component on hierarchy
            builder.RegisterComponent(blockGameObjectDataStore);
            builder.RegisterComponent(mapObjectGameObjectDatastore);
            
            builder.RegisterComponent(mainCamera);
            builder.RegisterComponent(commandUIInput);
            builder.RegisterComponent(hotBarView);
            
            builder.RegisterComponent(uIStateControl);
            builder.RegisterComponent(pauseMenuObject);
            builder.RegisterComponent(deleteBarObject);
            builder.RegisterComponent(saveButton);
            builder.RegisterComponent(backToMainMenu);
            builder.RegisterComponent(networkDisconnectPresenter);
            builder.RegisterComponent(mapObjectMiningController);
            
            builder.RegisterComponent(displayEnergizedRange);
            builder.RegisterComponent(entityObjectDatastore);
            builder.RegisterComponent(playerInventoryViewController);
            builder.RegisterComponent(challengeManager);
            builder.RegisterComponent(craftInventoryView);
            builder.RegisterComponent(machineRecipeView);
            builder.RegisterComponent(recipeViewerView);
            builder.RegisterComponent(itemListView);
            
            builder.RegisterComponent(mapObjectPin);
            builder.RegisterComponent(uiHighlightTutorialManager);
            builder.RegisterComponent(keyControlTutorialManager);
            
            builder.RegisterComponent(playerSkitStarterDetector);
            builder.RegisterComponent(skitManager);
            
            builder.RegisterComponent(inGameCameraController);
            
            builder.RegisterComponent<IPlayerObjectController>(playerObjectController).AsSelf();
            builder.RegisterComponent<IBlockPlacePreview>(blockPlacePreview);
            
            builder.RegisterBuildCallback(objectResolver => { });
            
            //依存関係を解決
            // resolve dependency
            _resolver = builder.Build();
            _resolver.Resolve<BlockGameObjectDataStore>();
            _resolver.Resolve<CommandUIInput>();
            _resolver.Resolve<UIStateControl>();
            _resolver.Resolve<DisplayEnergizedRange>();
            _resolver.Resolve<EntityObjectDatastore>();
            _resolver.Resolve<ChallengeManager>();
            
            return _resolver;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/PlayerInventoryViewController.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using ClassLibrary;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Input;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Main
{
    /// <summary>
    ///     TODO フラグ管理をステートベースに変換する
    /// </summary>
    public class PlayerInventoryViewController : MonoBehaviour
    {
        [SerializeField] private GameObject mainInventoryObject;
        
        [SerializeField] private List<ItemSlotObject> mainInventorySlotObjects;
        [SerializeField] private ItemSlotObject grabInventorySlotObject;
        
        public Transform SubInventoryParent => subInventoryParent.transform;
        [SerializeField] private Transform subInventoryParent;
        
        //現在スプリットドラッグしているスロットのリスト
        private readonly List<ItemSplitDragSlot> _itemSplitDraggedSlots = new();
        
        private readonly List<IDisposable> _subInventorySlotUIEventUnsubscriber = new();
        
        //ドラッグ中のアイテムをドラッグする前のGrabインベントリ
        private IItemStack _grabInventoryBeforeDrag;
        private bool _isItemOneDragging;
        private bool _isItemSplitDragging;
        
        private LocalPlayerInventoryController _playerInventory;
        
        private ISubInventory _subInventory;
        
        private bool IsGrabItem => _playerInventory.GrabInventory.Id != ItemMaster.EmptyItemId;
        
        private void Awake()
        {
            foreach (var mainInventorySlotObject in mainInventorySlotObjects) mainInventorySlotObject.OnPointerEvent.Subscribe(ItemSlotUIEvent);
        }
        
        
        private void Update()
        {
            InventoryViewUpdate();
        }
        
        [Inject]
        public void Construct(LocalPlayerInventoryController playerInventory)
        {
            _playerInventory = playerInventory;
        }
        
        public void SetSubInventory(ISubInventory subInventory)
        {
            foreach (var disposable in _subInventorySlotUIEventUnsubscriber) disposable.Dispose();
            
            _subInventorySlotUIEventUnsubscriber.Clear();
            _subInventory = subInventory;
            _playerInventory.SetSubInventory(subInventory);
            foreach (var sub in _subInventory.SubInventorySlotObjects) _subInventorySlotUIEventUnsubscriber.Add(sub.OnPointerEvent.Subscribe(ItemSlotUIEvent));
        }
        
        private void ItemSlotUIEvent((ItemSlotObject slotObject, ItemUIEventType itemUIEvent) eventProperty)
        {
            var (slotObject, itemUIEvent) = eventProperty;
            var index = mainInventorySlotObjects.IndexOf(slotObject);
            if (index == -1)
                index = mainInventorySlotObjects.Count + _subInventory.SubInventorySlotObjects.IndexOf(slotObject);
            
            if (index == -1) throw new Exception("slot index not found");
            switch (itemUIEvent)
            {
                case ItemUIEventType.LeftClickDown:
                    LeftClickDown(index);
                    break;
                case ItemUIEventType.RightClickDown:
                    RightClickDown(index);
                    break;
                case ItemUIEventType.LeftClickUp:
                    LeftClickUp(index);
                    break;
                case ItemUIEventType.RightClickUp:
                    RightClickUp(index);
                    break;
                case ItemUIEventType.CursorEnter:
                    CursorEnter(index);
                    break;
                case ItemUIEventType.DoubleClick:
                    DoubleClick(index);
                    break;
                case ItemUIEventType.CursorExit: break;
                case ItemUIEventType.CursorMove: break;
                default: throw new ArgumentOutOfRangeException(nameof(itemUIEvent), itemUIEvent, null);
            }
        }
        
        
        private void DoubleClick(int slotIndex)
        {
            if (_isItemSplitDragging || _isItemOneDragging) return;
            
            
            IItemStack collectTargetItem;
            LocalMoveInventoryType fromType;
            int fromSlot;
            if (IsGrabItem)
            {
                collectTargetItem = _playerInventory.GrabInventory;
                fromType = LocalMoveInventoryType.Grab;
                fromSlot = 0;
            }
            else
            {
                collectTargetItem = _playerInventory.LocalPlayerInventory[slotIndex];
                fromType = LocalMoveInventoryType.MainOrSub;
                fromSlot = slotIndex;
            }
            
            var collectTargetSotIndex = _playerInventory.LocalPlayerInventory.Select((item, index) => new { item, index }).Where(i => i.item.Id == collectTargetItem.Id).OrderBy(i => i.item.Count).Select(i => i.index).ToList();
            
            //一つのスロットに集める場合は集める先のスロットのインデックスをターゲットから除外する
            if (!IsGrabItem) collectTargetSotIndex.Remove(slotIndex);
            
            foreach (var index in collectTargetSotIndex)
            {
                var added = collectTargetItem.AddItem(_playerInventory.LocalPlayerInventory[index]);
                
                //アイテムを何個移したのかを計算
                var collectItemCount = _playerInventory.LocalPlayerInventory[index].Count - added.RemainderItemStack.Count;
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, index, fromType, fromSlot, collectItemCount);
                
                collectTargetItem = added.ProcessResultItemStack;
                
                //足したあまりがあるということはスロットにそれ以上入らないということなので、ここで処理を終了する
                if (added.RemainderItemStack.Count != 0) break;
            }
        }
        
        private void CursorEnter(int slotIndex)
        {
            if (_isItemSplitDragging)
                SplitDraggingItem(slotIndex, false);
            else if (_isItemOneDragging)
                //ドラッグ中の時はマウスカーソルが乗ったスロットをドラッグされたと判定する
                PlaceOneItem(slotIndex);
        }
        
        private void RightClickUp(int slotIndex)
        {
            if (_isItemOneDragging) _isItemOneDragging = false;
        }
        
        private void LeftClickUp(int slotIndex)
        {
            //左クリックを離したときはドラッグ中のスロットを解除する
            if (_isItemSplitDragging)
            {
                SplitDraggingItem(slotIndex, true);
                _itemSplitDraggedSlots.Clear();
                _isItemSplitDragging = false;
            }
        }
        
        
        private void RightClickDown(int slotIndex)
        {
            if (IsGrabItem)
            {
                //アイテムを持っている時に右クリックするとアイテム1個だけ置く処理
                PlaceOneItem(slotIndex);
                _isItemOneDragging = true;
            }
            else
            {
                //アイテムを持ってない時に右クリックするとアイテムを半分とる処理
                
                //空スロットの時はアイテムを持たない
                var item = _playerInventory.LocalPlayerInventory[slotIndex];
                if (item.Id == ItemMaster.EmptyItemId) return;
                
                var halfItemCount = item.Count / 2;
                
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.Grab, 0, halfItemCount);
            }
        }
        
        private void LeftClickDown(int slotIndex)
        {
            if (IsGrabItem)
            {
                var isSlotEmpty = _playerInventory.LocalPlayerInventory[slotIndex].Id == ItemMaster.EmptyItemId;
                
                if (isSlotEmpty)
                {
                    //アイテムを持っている時に左クリックするとアイテムを置くもしくは置き換える処理
                    _isItemSplitDragging = true;
                    _grabInventoryBeforeDrag = _playerInventory.GrabInventory;
                    SplitDraggingItem(slotIndex, false);
                }
                else
                {
                    _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, slotIndex, _playerInventory.GrabInventory.Count);
                }
                
                return;
            }
            
            if (InputManager.UI.ItemDirectMove.GetKey)
            {
                //シフト（デフォルト）＋クリックでメイン、サブのアイテム移動を直接やる処理
                DirectMove(slotIndex);
            }
            else
            {
                var slotItemCount = _playerInventory.LocalPlayerInventory[slotIndex].Count;
                //アイテムを持ってない時に左クリックするとアイテムを取る処理
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.Grab, 0, slotItemCount);
            }
        }
        
        
        private void PlaceOneItem(int slotIndex)
        {
            var oneItem = ServerContext.ItemStackFactory.Create(_playerInventory.GrabInventory.Id, 1);
            var currentItem = _playerInventory.LocalPlayerInventory[slotIndex];
            
            //追加できない場合はスキップ
            if (!currentItem.IsAllowedToAdd(oneItem)) return;
            
            //アイテムを追加する
            _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, slotIndex, 1);
            
            //Grabインベントリがなくなったらドラッグを終了する
            if (_playerInventory.GrabInventory.Count == 0)
                _isItemOneDragging = false;
        }
        
        private void SplitDraggingItem(int slotIndex, bool isMoveSendData)
        {
            if (!_playerInventory.LocalPlayerInventory[slotIndex].IsAllowedToAddWithRemain(_playerInventory.GrabInventory)) return;
            
            // まだスロットをドラッグしてない時
            var doNotDragging = !_itemSplitDraggedSlots.Exists(i => i.Slot == slotIndex);
            // アイテムがない時か、同じアイテムがあるとき
            var isNotSlotOrSameItem = _playerInventory.LocalPlayerInventory[slotIndex].Id == ItemMaster.EmptyItemId || _playerInventory.LocalPlayerInventory[slotIndex].Id == _grabInventoryBeforeDrag.Id;
            
            // まだスロットをドラッグしてない時 か アイテムがない時か、同じアイテムがあるとき
            if (doNotDragging && isNotSlotOrSameItem)
            {
                //ドラッグ中のアイテムに設定
                _itemSplitDraggedSlots.Add(new ItemSplitDragSlot(slotIndex, _playerInventory.LocalPlayerInventory[slotIndex]));
            }
            
            //一度Grabインベントリをリセットする
            _playerInventory.SetGrabItem(_grabInventoryBeforeDrag);
            foreach (var itemSplit in _itemSplitDraggedSlots) _playerInventory.SetMainItem(itemSplit.Slot, itemSplit.BeforeDragItem);
            
            //1スロットあたりのアイテム数
            var grabItem = _playerInventory.GrabInventory;
            var dragItemCount = grabItem.Count / _itemSplitDraggedSlots.Count;
            //余っているアイテム数
            var remainItemNum = grabItem.Count - dragItemCount * _itemSplitDraggedSlots.Count;
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            foreach (var dragSlot in _itemSplitDraggedSlots)
            {
                //ドラッグ中のスロットにアイテムを加算する
                var addedItem = dragSlot.BeforeDragItem.AddItem(itemStackFactory.Create(grabItem.Id, dragItemCount));
                var moveItemCount = addedItem.ProcessResultItemStack.Count - dragSlot.BeforeDragItem.Count;
                
                _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, dragSlot.Slot, moveItemCount, isMoveSendData);
                //余ったアイテムを加算する
                remainItemNum += addedItem.RemainderItemStack.Count;
            }
            
            //あまりのアイテムをGrabインベントリに設定する
            _playerInventory.SetGrabItem(itemStackFactory.Create(grabItem.Id, remainItemNum));
        }
        
        
        private void DirectMove(int slotIndex)
        {
            //そのスロットがメインインベントリかサブインベントリを判定する
            var isMain = slotIndex < PlayerInventoryConst.MainInventorySize;
            
            var startIndex = isMain ? 0 : PlayerInventoryConst.MainInventorySize;
            var endIndex = isMain ? PlayerInventoryConst.MainInventorySize : PlayerInventoryConst.MainInventorySize + _subInventory.Count;
            for (var i = startIndex; i < endIndex; i++)
            {
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.MainOrSub, i, _playerInventory.LocalPlayerInventory[slotIndex].Count);
                //アイテムがなくなったら終了する
                if (_playerInventory.LocalPlayerInventory[slotIndex].Count == 0) break;
            }
        }
        
        public void SetActive(bool isActive)
        {
            mainInventoryObject.SetActive(isActive);
        }
        
        private void InventoryViewUpdate()
        {
            for (var i = 0; i < _playerInventory.LocalPlayerInventory.Count; i++)
            {
                var item = _playerInventory.LocalPlayerInventory[i];
                var itemView = ClientContext.ItemImageContainer.GetItemView(item.Id);
                
                if (i < mainInventorySlotObjects.Count)
                {
                    mainInventorySlotObjects[i].SetItem(itemView, item.Count);
                }
                else
                {
                    var subIndex = i - mainInventorySlotObjects.Count;
                    _subInventory.SubInventorySlotObjects[subIndex].SetItem(itemView, item.Count);
                }
            }
            
            grabInventorySlotObject.SetActive(IsGrabItem);
            var garbItemView = ClientContext.ItemImageContainer.GetItemView(_playerInventory.GrabInventory.Id);
            grabInventorySlotObject.SetItem(garbItemView, _playerInventory.GrabInventory.Count);
        }
    }
    
    public class ItemSplitDragSlot
    {
        public ItemSplitDragSlot(int slot, IItemStack beforeDragItem)
        {
            Slot = slot;
            BeforeDragItem = beforeDragItem;
        }
        
        public int Slot { get; }
        public IItemStack BeforeDragItem { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/CraftChain/CraftChainerCraftingSolver.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;

namespace Game.CraftChainer.CraftChain
{
    public static class CraftChainerCraftingSolver
    {
        public static Dictionary<CraftingSolverRecipeId, int> Solve(
            List<CraftingSolverRecipe> recipes,
            Dictionary<ItemId, int> initialInventory,
            CraftingSolverItem targetItem)
        {
            // Step 1: Build a mapping from items to the recipes that produce them
            // ステップ1：アイテムからそれを生産するレシピへのマッピングを構築する
            var itemsProducedByRecipe = BuildItemsProducedByRecipe(recipes);
            
            // Step 2: Initialize the initial state for BFS
            // ステップ2：BFSのための初期状態を初期化する
            var initialState = InitializeState(initialInventory, targetItem.ItemId, targetItem.Count);
            
            // Step 3: Prepare BFS structures
            // ステップ3：BFSの構造を準備する
            var (queue, visitedStates, bestState) = InitializeBFS(initialState);
            
            // Step 4: Perform BFS to find the optimal crafting solution
            // ステップ4：最適なクラフト解を見つけるためにBFSを実行する
            while (queue.Count > 0)
            {
                // Dequeue the next state from the queue to explore
                // 探索するためにキューから次の状態を取り出す
                var currentState = queue.Dequeue();
                
                // If the current state has already been visited, skip processing it
                // 現在の状態がすでに訪問済みであれば、処理をスキップする
                if (IsStateVisited(currentState, visitedStates))
                    continue;
                
                // Mark the current state as visited to avoid revisiting it
                // 再度訪問しないよう、現在の状態を訪問済みとしてマークする
                MarkStateAsVisited(currentState, visitedStates);
                
                // If the goal state is reached, update the best solution and continue
                // 目標状態に到達した場合、最適な解を更新して次の反復へ進む
                if (IsGoalState(currentState))
                {
                    bestState = UpdateBestState(currentState, bestState);
                    continue;
                }
                
                // Find an item that is still needed; if none are found, continue
                // まだ必要とされているアイテムを探す。見つからなければ次へ進む
                var neededItem = FindNeededItem(currentState);
                if (neededItem == null)
                    continue;
                
                // Try to fulfill the needed item from existing inventory; if successful, continue
                // 既存の在庫から必要なアイテムを満たせるか試みる。成功したら次へ進む
                if (TryFulfillNeedFromInventory(currentState, neededItem, queue))
                    continue;
                
                // Expand the current state by applying recipes to produce the needed item
                // 必要なアイテムを生産するレシピを適用して、現在の状態を展開する
                ExpandState(currentState, neededItem, itemsProducedByRecipe, queue);
            }

            
            // Step 5: Return the best solution found
            // ステップ5：見つかった最適な解を返す
            return bestState?.RecipesUsed;
        }
        
        private static Dictionary<ItemId, List<CraftingSolverRecipe>> BuildItemsProducedByRecipe(List<CraftingSolverRecipe> recipes)
        {
            var itemsProduced = new Dictionary<ItemId, List<CraftingSolverRecipe>>();
            foreach (var recipe in recipes)
            {
                foreach (var output in recipe.Outputs)
                {
                    if (!itemsProduced.ContainsKey(output.ItemId))
                        itemsProduced[output.ItemId] = new List<CraftingSolverRecipe>();
                    itemsProduced[output.ItemId].Add(recipe);
                }
            }
            return itemsProduced;
        }
        
        private static CraftingSolverState InitializeState(Dictionary<ItemId, int> inventory, ItemId targetItem, int targetQty)
        {
            var state = new CraftingSolverState
            {
                Inventory = new Dictionary<ItemId, int>(inventory),
                RecipesUsed = new Dictionary<CraftingSolverRecipeId, int>(),
                MaterialUsed = 0
            };
            
            if (!state.Inventory.ContainsKey(targetItem))
                state.Inventory[targetItem] = 0;
            state.Inventory[targetItem] -= targetQty; // Negative quantity indicates a need
            
            return state;
        }
        
        private static (Queue<CraftingSolverState>, HashSet<string>, CraftingSolverState) InitializeBFS(CraftingSolverState initialState)
        {
            var queue = new Queue<CraftingSolverState>();
            queue.Enqueue(initialState);
            
            var visitedStates = new HashSet<string>();
            CraftingSolverState bestState = null;
            
            return (queue, visitedStates, bestState);
        }
        
        private static bool IsStateVisited(CraftingSolverState state, HashSet<string> visitedStates)
        {
            var key = GenerateStateKey(state);
            return visitedStates.Contains(key);
        }
        
        private static void MarkStateAsVisited(CraftingSolverState state, HashSet<string> visitedStates)
        {
            var key = GenerateStateKey(state);
            visitedStates.Add(key);
        }
        
        private static bool IsGoalState(CraftingSolverState state)
        {
            return state.Inventory.Values.All(quantity => quantity >= 0);
        }
        
        private static CraftingSolverState UpdateBestState(CraftingSolverState currentState, CraftingSolverState bestState)
        {
            if (bestState == null || currentState.MaterialUsed < bestState.MaterialUsed)
                return currentState;
            return bestState;
        }
        
        private static KeyValuePair<ItemId, int>? FindNeededItem(CraftingSolverState state)
        {
            foreach (var kvp in state.Inventory)
            {
                if (kvp.Value < 0)
                    return kvp;
            }
            return null;
        }
        
        private static bool TryFulfillNeedFromInventory(CraftingSolverState state, KeyValuePair<ItemId, int>? neededItem, Queue<CraftingSolverState> queue)
        {
            var itemId = neededItem.Value.Key;
            int quantityNeeded = -neededItem.Value.Value;
            
            if (state.Inventory.TryGetValue(itemId, out int available) && available > 0)
            {
                int used = Math.Min(available, quantityNeeded);
                var newState = CloneState(state);
                newState.Inventory[itemId] -= used; // Consume from inventory
                newState.Inventory[itemId] += quantityNeeded; // Fulfill the need
                queue.Enqueue(newState);
                return true;
            }
            return false;
        }
        
        private static void ExpandState(
            CraftingSolverState state,
            KeyValuePair<ItemId, int>? neededItem,
            Dictionary<ItemId, List<CraftingSolverRecipe>> itemsProducedByRecipe,
            Queue<CraftingSolverState> queue)
        {
            var itemId = neededItem.Value.Key;
            
            if (itemsProducedByRecipe.TryGetValue(itemId, out var producingRecipes))
            {
                var maxRunsList = producingRecipes.Select(_ => 10).ToList(); // Limit runs to prevent infinite loops
                
                var combinations = GenerateRecipeCombinations(producingRecipes, maxRunsList, state, itemId);
                
                foreach (var combination in combinations)
                {
                    var newState = ApplyRecipeCombination(state, producingRecipes, combination);
                    if (IsStateValid(newState))
                        queue.Enqueue(newState);
                }
            }
        }
        
    #region Internal
        
        private static List<int[]> GenerateRecipeCombinations(
            List<CraftingSolverRecipe> recipes,
            List<int> maxRunsList,
            CraftingSolverState state,
            ItemId itemId)
        {
            var combinations = new List<int[]>();
            int recipeCount = recipes.Count;
            int[] currentRuns = new int[recipeCount];
            
            void RecursiveGenerate(int index)
            {
                if (index == recipeCount)
                {
                    int totalProduced = state.Inventory.TryGetValue(itemId, out int existing) && existing > 0 ? existing : 0;
                    
                    for (int i = 0; i < recipeCount; i++)
                    {
                        var output = recipes[i].Outputs.FirstOrDefault(o => o.ItemId == itemId);
                        if (output != null)
                            totalProduced += currentRuns[i] * output.Count;
                    }
                    
                    if (totalProduced >= -state.Inventory[itemId])
                        combinations.Add((int[])currentRuns.Clone());
                    return;
                }
                
                for (int run = 0; run <= maxRunsList[index]; run++)
                {
                    currentRuns[index] = run;
                    RecursiveGenerate(index + 1);
                }
            }
            
            RecursiveGenerate(0);
            return combinations;
        }
        
        private static CraftingSolverState ApplyRecipeCombination(
            CraftingSolverState state,
            List<CraftingSolverRecipe> recipes,
            int[] combination)
        {
            var newState = CloneState(state);
            
            for (int i = 0; i < recipes.Count; i++)
            {
                int runs = combination[i];
                if (runs == 0) continue;
                
                var recipe = recipes[i];
                if (!newState.RecipesUsed.ContainsKey(recipe.CraftingSolverRecipeId))
                    newState.RecipesUsed[recipe.CraftingSolverRecipeId] = 0;
                newState.RecipesUsed[recipe.CraftingSolverRecipeId] += runs;
                
                foreach (var output in recipe.Outputs)
                {
                    int produced = output.Count * runs;
                    if (!newState.Inventory.ContainsKey(output.ItemId))
                        newState.Inventory[output.ItemId] = 0;
                    newState.Inventory[output.ItemId] += produced;
                }
                
                foreach (var input in recipe.Inputs)
                {
                    int required = input.Count * runs;
                    if (!newState.Inventory.ContainsKey(input.ItemId))
                        newState.Inventory[input.ItemId] = 0;
                    newState.Inventory[input.ItemId] -= required; // Negative indicates a need
                }
            }
            
            return newState;
        }
        
        private static bool IsStateValid(CraftingSolverState state)
        {
            return state.Inventory.Values.All(quantity => quantity >= -1000);
        }
        
        private static string GenerateStateKey(CraftingSolverState state)
        {
            var inventoryKey = string.Join(",", state.Inventory.OrderBy(kvp => kvp.Key).Select(kvp => $"{kvp.Key}:{kvp.Value}"));
            var recipesKey = string.Join(",", state.RecipesUsed.OrderBy(kvp => kvp.Key).Select(kvp => $"{kvp.Key}:{kvp.Value}"));
            return $"{inventoryKey}|{recipesKey}|{state.MaterialUsed}";
        }
        
        private static CraftingSolverState CloneState(CraftingSolverState state)
        {
            return new CraftingSolverState
            {
                Inventory = new Dictionary<ItemId, int>(state.Inventory),
                RecipesUsed = new Dictionary<CraftingSolverRecipeId, int>(state.RecipesUsed),
                MaterialUsed = state.MaterialUsed
            };
        }
        
    #endregion
    }
    
    public class CraftingSolverState
    {
        public int MaterialUsed;
        public Dictionary<ItemId, int> Inventory; // Negative values indicate needs
        public Dictionary<CraftingSolverRecipeId, int> RecipesUsed;
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/DebugSheet/ItemGetDebugSheet.cs
```cs
using System.Collections;
using Client.Game.InGame.Context;
using Core.Master;
using UnityDebugSheet.Runtime.Core.Scripts;

namespace Client.DebugSystem
{
    public class ItemGetDebugSheet : DefaultDebugPageBase
    {
        protected override string Title => "Get Item";
        
        public override IEnumerator Initialize()
        {
            var itemIds = MasterHolder.ItemMaster.GetItemAllIds();
            foreach (var itemId in itemIds)
            {
                var itemElement = MasterHolder.ItemMaster.GetItemMaster(itemId);
                //TODO: あとでItemImageContainer.GetItemViewの引数をItemIdにする
                var itemImage = ClientContext.ItemImageContainer.GetItemView(itemId); 
                var subText = $"Count:{itemElement.MaxStack}";
                
                AddButton(itemImage.ItemName, subText, icon: itemImage.ItemImage, clicked: () =>
                {
                    var playerId = ClientContext.PlayerConnectionSetting.PlayerId;
                    var command = $"give {playerId} {itemId} {itemElement.MaxStack}";
                    ClientContext.VanillaApi.SendOnly.SendCommand(command);
                });
            }
            
            yield break;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/MachineRecipeView.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Sub;
using Core.Master;
using Game.CraftChainer.Util;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class MachineRecipeView : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform inputParent;
        [SerializeField] private RectTransform outputParent;
        
        [SerializeField] private Button nextRecipeButton;
        [SerializeField] private Button prevRecipeButton;
        
        [SerializeField] private TMP_Text itemNameText;
        [SerializeField] private TMP_Text recipeCountText;
        [SerializeField] private ItemSlotObject machineObject;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private readonly List<ItemSlotObject> _inputSlotList = new();
        private readonly List<ItemSlotObject> _outputSlotList = new();
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        
        private int MachineRecipeCount => _currentItemRecipes.MachineRecipes[_currentBlockId].Count;
        private RecipeViewerItemRecipes _currentItemRecipes;
        private BlockId _currentBlockId;
        private int _currentIndex;
        

        [Inject]
        public void Construct(ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            machineObject.SetFrame(ItemSlotFrameType.MachineSlot);
            machineObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;

            
            nextRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex++;
                if (MachineRecipeCount <= _currentIndex) _currentIndex = 0;
                DisplayRecipe(_currentIndex);
            });
            
            prevRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex--;
                if (_currentIndex < 0) _currentIndex = MachineRecipeCount - 1;
                DisplayRecipe(_currentIndex);
            });
        }
        
        public void SetRecipes(RecipeViewerItemRecipes recipeViewerItemRecipes)
        {
            _currentItemRecipes = recipeViewerItemRecipes;
            _currentIndex = 0;
            if (recipeViewerItemRecipes.MachineRecipes.Count != 0)
            {
                _currentBlockId = recipeViewerItemRecipes.MachineRecipes.First().Key;
            }
        }
        
        public void SetBlockId(BlockId blockId)
        {
            _currentBlockId = blockId;
            _currentIndex = 0;
            DisplayRecipe(_currentIndex);
        }
        
        public void DisplayRecipe(int index)
        {
            var machineRecipes = _currentItemRecipes.MachineRecipes[_currentBlockId][index];
            
            ClearSlotObject();
            
            SetInputSlot();
            SetOutputSlot();
            SetMachineSlot();
            
            UpdateButtonAndText();
            
            #region InternalMethod
            
            void ClearSlotObject()
            {
                foreach (var materialSlot in _inputSlotList) Destroy(materialSlot.gameObject);
                _inputSlotList.Clear();
                foreach (var resultSlot in _outputSlotList) Destroy(resultSlot.gameObject);
                _outputSlotList.Clear();
            }
            
            void SetInputSlot()
            {
                foreach (var requiredItem in machineRecipes.InputItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, inputParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _inputSlotList.Add(itemSlotObject);
                    
                    // 原材料をクリックしたときにそのレシピを表示するようにする
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetOutputSlot()
            {
                foreach (var requiredItem in machineRecipes.OutputItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, outputParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _outputSlotList.Add(itemSlotObject);
                    
                    // 原材料をクリックしたときにそのレシピを表示するようにする
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetMachineSlot()
            {
                var blockItemId = MasterHolder.BlockMaster.GetItemId(_currentBlockId);
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(blockItemId);
                machineObject.SetItem(itemViewData, 0);
            }
            
            void UpdateButtonAndText()
            {
                prevRecipeButton.interactable = MachineRecipeCount != 1;
                nextRecipeButton.interactable = MachineRecipeCount != 1;
                recipeCountText.text = $"{_currentIndex + 1} / {MachineRecipeCount}";
                
                var itemName = MasterHolder.ItemMaster.GetItemMaster(_currentItemRecipes.ResultItemId).Name;
                itemNameText.text = itemName;
            }
            
            #endregion
        }
        
        private void OnClickMaterialItem(ItemSlotObject itemSlotObject)
        {
            var itemId = itemSlotObject.ItemViewData.ItemId;
            var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
            _onClickItem.OnNext(itemRecipes);
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/PowerGeneratorSaveLoadTest.cs
```cs
using System.Collections.Generic;
using System.Reflection;
using Core.Inventory;
using Core.Master;
using Game.Block.Blocks.PowerGenerator;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class PowerGeneratorSaveLoadTest
    {
        
        [Test]
        public void PowerGeneratorTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var fuelSlotCount = (MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GeneratorId).BlockParam as ElectricGeneratorBlockParam).FuelItemSlotCount;
            var generatorPosInfo = new BlockPositionInfo(Vector3Int.zero, BlockDirection.North, Vector3Int.one);
            var powerGeneratorBlock = blockFactory.Create(ForUnitTestModBlockId.GeneratorId, new BlockInstanceId(10), generatorPosInfo);
            var powerGenerator = powerGeneratorBlock.GetComponent<VanillaElectricGeneratorComponent>();
            
             var fuelItemId = new ItemId(5);
            const int remainingFuelTime = 567;
            
            //検証元の発電機を作成
            var type = typeof(VanillaElectricGeneratorComponent);
            type.GetField("_currentFuelItemId", BindingFlags.NonPublic | BindingFlags.Instance)
                .SetValue(powerGenerator, fuelItemId);
            type.GetField("_remainingFuelTime", BindingFlags.NonPublic | BindingFlags.Instance)
                .SetValue(powerGenerator, remainingFuelTime);
            var fuelItemStacks = (OpenableInventoryItemDataStoreService)type
                .GetField("_itemDataStoreService", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(powerGenerator);
            fuelItemStacks.SetItem(0, itemStackFactory.Create(new ItemId(1), 5));
            fuelItemStacks.SetItem(2, itemStackFactory.Create(new ItemId(3), 5));
            
            
            //セーブのテキストを取得
            var saveText = powerGenerator.GetSaveState();
            var states = new Dictionary<string, string>() { { powerGenerator.SaveKey, saveText } };
            Debug.Log(saveText);
            
            
            var blockGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GeneratorId).BlockGuid;
            //発電機を再作成
            var loadedPowerGeneratorBlock = blockFactory.Load(blockGuid, new BlockInstanceId(10), states, generatorPosInfo);
            var loadedPowerGenerator = loadedPowerGeneratorBlock.GetComponent<VanillaElectricGeneratorComponent>();
            //発電機を再作成した結果を検証
            var loadedFuelItemId = (ItemId)type.GetField("_currentFuelItemId", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadedPowerGenerator);
            Assert.AreEqual(fuelItemId, loadedFuelItemId);
            
            var loadedRemainingFuelTime = (double)type
                .GetField("_remainingFuelTime", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadedPowerGenerator);
            Assert.AreEqual(remainingFuelTime, loadedRemainingFuelTime);
            
            var loadedFuelItemStacks = (OpenableInventoryItemDataStoreService)type
                .GetField("_itemDataStoreService", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadedPowerGenerator);
            
            //燃料スロットの検証
            Assert.AreEqual(fuelItemStacks.GetSlotSize(), loadedFuelItemStacks.GetSlotSize());
            for (var i = 0; i < fuelSlotCount; i++)
                Assert.AreEqual(fuelItemStacks.InventoryItems[i], loadedFuelItemStacks.InventoryItems[i]);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/BlockGameObjectContainer.cs
```cs
using System.Collections.Generic;
using Client.Common.Asset;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;


namespace Client.Game.InGame.Context
{
    /// <summary>
    ///     Unityに表示されるブロックの実際のGameObjectを管理するクラス
    ///     最初にブロックを生成しておき、必要なブロックを複製するためのクラス
    /// </summary>
    public class BlockGameObjectContainer
    {
        public IReadOnlyDictionary<BlockId, BlockObjectInfo> BlockObjects => _blockObjects;
        private readonly Dictionary<BlockId, BlockObjectInfo> _blockObjects;
        private readonly BlockGameObject _missingBlockIdObject;
        
        public BlockGameObjectContainer(BlockGameObject missingBlockIdObject, Dictionary<BlockId, BlockObjectInfo> blockObjects)
        {
            _missingBlockIdObject = missingBlockIdObject;
            _blockObjects = blockObjects;
        }
        
        public static async UniTask<BlockGameObjectContainer> CreateAndLoadBlockGameObjectContainer(BlockGameObject missingBlockIdObject)
        {
            var blocks = new Dictionary<BlockId, BlockObjectInfo>();
            var tasks = new List<UniTask<BlockObjectInfo>>();
            foreach (var blockId in MasterHolder.BlockMaster.GetBlockIds())
            {
                tasks.Add(LoadBlockGameObject(blockId));
            }
            
            var results = await UniTask.WhenAll(tasks);
            foreach (var result in results)
            {
                if (result == null) continue;
                blocks.Add(result.BlockId, result);
            }
            
            return new BlockGameObjectContainer(missingBlockIdObject, blocks);
        }
        
        private static async UniTask<BlockObjectInfo> LoadBlockGameObject(BlockId blockId)
        {
            var masterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            if (masterElement.BlockPrefabAddressablesPath == null)
            {
                Debug.LogWarning($"ブロックのパスの設定がありません。 Name:{masterElement.Name} GUID:{masterElement.BlockGuid}");
                return null;
            }
            
            var blockAsset = await AddressableLoader.LoadAsync<GameObject>(masterElement.BlockPrefabAddressablesPath);
            if (blockAsset == null)
            {
                //TODO ログ基盤に入れる
                Debug.LogError($"ブロックのアセットが見つかりません。Name:{masterElement.Name} Path:{masterElement.BlockPrefabAddressablesPath} GUID:{masterElement.BlockGuid} ");
                return null;
            }
            
            return new BlockObjectInfo(blockId, blockAsset.Asset, masterElement);
        }
        
        public BlockGameObject CreateBlock(BlockId blockId, Vector3 position, Quaternion rotation, Transform parent, Vector3Int blockPosition, BlockDirection direction)
        {
            if (!_blockObjects.TryGetValue(blockId, out var blockObjectInfo))
            {
                //ブロックIDがないのでない時用のブロックを作る
                return CreateMissingIdBlock();
            }
            
            //ブロックの作成とセットアップをして返す
            return CreateBlockObject();
            
            #region Internal
            
            BlockGameObject CreateMissingIdBlock()
            {
                var missingIdBlock = Object.Instantiate(_missingBlockIdObject, position, rotation, parent);
                var missingPosInfo = new BlockPositionInfo(blockPosition, direction, Vector3Int.one);
                
                //TODO nullのblock masterを入れる
                //missingIdBlock.Initialize(blockConfig, missingPosInfo, new NullBlockStateChangeProcessor());
                
                return missingIdBlock.GetComponent<BlockGameObject>();
            }
            
            BlockGameObject CreateBlockObject()
            {
                //ブロックIDは1から始まるので、オブジェクトのリストインデックスマイナス１する
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                
                //ブロックの作成とセットアップをして返す
                var block = Object.Instantiate(blockObjectInfo.BlockObjectPrefab, position, rotation, parent);
                
                //コンポーネントの設定
                if (!block.TryGetComponent(out BlockGameObject blockObj))
                {
                    blockObj = block.AddComponent<BlockGameObject>();
                }
                
                //子要素のコンポーネントの設定
                foreach (var mesh in blockObj.GetComponentsInChildren<MeshRenderer>())
                {
                    mesh.gameObject.AddComponent<BlockGameObjectChild>();
                    mesh.gameObject.AddComponent<MeshCollider>();
                }
                
                blockObj.gameObject.SetActive(true);
                var blockType = blockMasterElement.BlockType;
                //ブロックが開けるものの場合はそのコンポーネントを付与する
                if (IsOpenableInventory(blockType)) block.gameObject.AddComponent<OpenableInventoryBlock>();
                // 機械の場合はそのプロセッサを付与する
                if (IsCommonMachine(blockType)) block.gameObject.AddComponent<CommonMachineBlockStateChangeProcessor>();
                
                // 初期化
                var posInfo = new BlockPositionInfo(blockPosition, direction, blockMasterElement.BlockSize);
                blockObj.Initialize(blockMasterElement, posInfo);
                
                return blockObj;
            }
            
            
            // todo ブロックコンフィグのロードのdynamicを辞める時に一緒にこれに対応したシステムを構築する
            bool IsOpenableInventory(string type)
            {
                return type is
                    BlockTypeConst.Chest or
                    BlockTypeConst.ElectricGenerator or
                    BlockTypeConst.ElectricMiner or
                    BlockTypeConst.ElectricMachine or
                    BlockTypeConst.GearMachine or
                    BlockTypeConst.GearMiner;
            }
            
            bool IsCommonMachine(string type)
            {
                return type is
                    BlockTypeConst.ElectricGenerator or
                    BlockTypeConst.ElectricMiner or
                    BlockTypeConst.ElectricMachine or
                    BlockTypeConst.GearMachine or
                    BlockTypeConst.GearMiner;
            }
            
            #endregion
        }
        
        public BlockPreviewObject CreatePreviewBlock(BlockId blockId)
        {
            if (!_blockObjects.TryGetValue(blockId, out var blockObjectInfo))
            {
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                throw new System.Exception($"ブロックの登録がありません。Name:{blockMasterElement.Name} GUID:{blockMasterElement.BlockGuid}");
            }
            
            //ブロックの作成とセットアップをして返す
            var block = Object.Instantiate(blockObjectInfo.BlockObjectPrefab, Vector3.zero, Quaternion.identity);
            block.SetActive(true);
            
            var previewGameObject = block.AddComponent<BlockPreviewObject>();
            previewGameObject.SetTriggerCollider(true);
            previewGameObject.Initialize(blockId);
            
            return previewGameObject;
        }
    }
    
    public class BlockObjectInfo
    {
        public readonly BlockId BlockId;
        public readonly BlockMasterElement BlockMasterElement;
        public readonly GameObject BlockObjectPrefab;
        
        public BlockObjectInfo(BlockId blockId, GameObject blockObjectPrefab, BlockMasterElement blockMasterElement)
        {
            BlockObjectPrefab = blockObjectPrefab;
            BlockMasterElement = blockMasterElement;
            BlockId = blockId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/Dummy.cs
```cs

// このコードはCore.Masterアセンブリを再コンパイルするためのスクリプトです。gitignoreに設定しています。
// This code is a script to recompile the Core.Master assembly. It is set in gitignore.
public class Dummy
{
    private const string dummyText = "2024/12/28 15:36:19";
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearNetwork.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface;
using UnityEngine;

namespace Game.Gear.Common
{
    public class GearNetwork
    {
        public IReadOnlyList<IGearEnergyTransformer> GearTransformers => _gearTransformers;
        public IReadOnlyList<IGearGenerator> GearGenerators => _gearGenerators;
        
        private readonly Dictionary<BlockInstanceId, GearRotationInfo> _checkedGearComponents = new();
        private readonly List<IGearGenerator> _gearGenerators = new();
        private readonly List<IGearEnergyTransformer> _gearTransformers = new();
        public readonly GearNetworkId NetworkId;
        
        public GearNetwork(GearNetworkId networkId)
        {
            NetworkId = networkId;
        }
        
        public void AddGear(IGearEnergyTransformer gear)
        {
            switch (gear)
            {
                case IGearGenerator generator:
                    _gearGenerators.Add(generator);
                    break;
                default:
                    _gearTransformers.Add(gear);
                    break;
            }
        }
        
        public void RemoveGear(IGearEnergyTransformer gear)
        {
            switch (gear)
            {
                case IGearGenerator generator:
                    _gearGenerators.Remove(generator);
                    break;
                default:
                    _gearTransformers.Remove(gear);
                    break;
            }
        }
        
        public void ManualUpdate()
        {
            //もっとも早いジェネレーターを選定し、そのジェネレーターを起点として、各歯車コンポーネントのRPMと回転方向を計算していく
            IGearGenerator fastestOriginGenerator = null;
            foreach (var gearGenerator in GearGenerators)
            {
                if (fastestOriginGenerator == null)
                {
                    fastestOriginGenerator = gearGenerator;
                    continue;
                }
                
                if (gearGenerator.GenerateRpm > fastestOriginGenerator.GenerateRpm) fastestOriginGenerator = gearGenerator;
            }
            
            if (fastestOriginGenerator == null)
            {
                //ジェネレーターがない場合はすべてにゼロを供給して終了
                foreach (var transformer in GearTransformers) transformer.SupplyPower(new RPM(0), new Torque(0), true);
                return;
            }
            
            //そのジェネレータと接続している各歯車コンポーネントを深さ優先度探索でたどり、RPMと回転方向を計算していく
            _checkedGearComponents.Clear();
            var generatorGearRotationInfo = new GearRotationInfo(fastestOriginGenerator.GenerateRpm, fastestOriginGenerator.GenerateIsClockwise, fastestOriginGenerator);
            _checkedGearComponents.Add(fastestOriginGenerator.BlockInstanceId, generatorGearRotationInfo);
            var rocked = false;
            foreach (var connect in fastestOriginGenerator.GetGearConnects())
            {
                rocked = CalcGearInfo(connect, generatorGearRotationInfo);
                //ロックを検知したので処理を終了
                if (rocked) break;
            }
            
            if (rocked)
            {
                SetRocked();
                return;
            }
            
            //すべてのジェネレーターから生成GPを取得し、合算する
            DistributeGearPower();
            
            #region Internal
            
            bool CalcGearInfo(GearConnect gearConnect, GearRotationInfo connectGearRotationInfo)
            {
                var transformer = gearConnect.Transformer;
                
                //RPMと回転方向を計算する
                var isReverseRotation = IsReverseRotation(gearConnect);
                var isClockwise = isReverseRotation ? !connectGearRotationInfo.IsClockwise : connectGearRotationInfo.IsClockwise;
                RPM rpm;
                if (transformer is IGear gear &&
                    connectGearRotationInfo.EnergyTransformer is IGear connectGear &&
                    isReverseRotation)
                {
                    var gearRate = (float)connectGear.TeethCount / gear.TeethCount;
                    rpm = connectGearRotationInfo.Rpm * gearRate;
                }
                else
                {
                    rpm = connectGearRotationInfo.Rpm;
                }
                
                // もし既に計算済みの場合、新たな計算と一致するかを計算し、一致しない場合はロックフラグを立てる
                if (_checkedGearComponents.TryGetValue(transformer.BlockInstanceId, out var info))
                {
                    if (info.IsClockwise != isClockwise || // 回転方向が一致しない場合
                        Math.Abs((info.Rpm - rpm).AsPrimitive()) > 0.1f) // RPMが一致しない場合
                        return true;
                    
                    // 深さ優先度探索でループになったのでこの探索は終了
                    return false;
                }
                
                if (transformer is IGearGenerator generator
                    && generator.GenerateIsClockwise != isClockwise // もしこれがジェネレーターである場合、回転方向が合っているかを確認
                    && fastestOriginGenerator.BlockInstanceId != transformer.BlockInstanceId // 上記が一番早い起点となるジェネレーターでない場合はロックをする
                   )
                    return true;
                
                // 計算済みとして登録
                var gearRotationInfo = new GearRotationInfo(rpm, isClockwise, transformer);
                _checkedGearComponents.Add(transformer.BlockInstanceId, gearRotationInfo);
                
                // この歯車が接続している歯車を再帰的に計算する
                foreach (var connect in transformer.GetGearConnects())
                {
                    var isRocked = CalcGearInfo(connect, gearRotationInfo);
                    //ロックを検知したので処理を終了
                    if (isRocked) return true;
                }
                
                return false;
            }
            
            bool IsReverseRotation(GearConnect connect)
            {
                return connect.Self.IsReverse && connect.Target.IsReverse;
            }
            
            void SetRocked()
            {
                foreach (var transformer in GearTransformers) transformer.Rocked();
                foreach (var generator in GearGenerators) generator.Rocked();
            }
            
            void DistributeGearPower()
            {
                var totalGenerateTorque = new Torque(0);
                foreach (var gearGenerator in GearGenerators) totalGenerateTorque += gearGenerator.GenerateTorque;
                
                // 起点となるジェネレーターのRPM
                var originRpm = fastestOriginGenerator.GenerateRpm;
                //すべてのコンシューマーの必要トルクを取得し、生成トルクから割って分配率を計算する
                var totalRequiredTorquePerOriginRpm = 0f;
                
                foreach (var gearConsumer in GearTransformers)
                {
                    var info = _checkedGearComponents[gearConsumer.BlockInstanceId];
                    
                    var rpm = info.Rpm;
                    var isClockwise = info.IsClockwise;
                    
                    // このコンシューマーに供給できる最大のトルク
                    // このコンシューマーが要求するトルク
                    var requiredTorque = gearConsumer.GetRequiredTorque(rpm, isClockwise);
                    info.RequiredTorque = requiredTorque;
                    
                    // RPMの比によって供給するトルクを調整する
                    // RPMが倍であれば、その歯車に必要なトルクは倍になるし、RPMが半分であれば、その歯車に必要なトルクは半分になる
                    var distributeTorque = rpm.AsPrimitive() / originRpm.AsPrimitive() * requiredTorque.AsPrimitive();
                    totalRequiredTorquePerOriginRpm += distributeTorque;
                }
                
                // 分配率をもとに、供給するGPを算出し、RPMから供給トルクを計算する
                // 歯車とトルク両方に分配するため、平方根を取る
                var distributeGearPowerRate = Mathf.Sqrt(Mathf.Min(1, totalGenerateTorque.AsPrimitive() / totalRequiredTorquePerOriginRpm));
                
                foreach (var gearConsumer in GearTransformers)
                {
                    var info = _checkedGearComponents[gearConsumer.BlockInstanceId];
                    
                    var ratedDistributeTorque = new Torque(info.RequiredTorque.AsPrimitive() * distributeGearPowerRate * (originRpm / info.Rpm).AsPrimitive());
                    var ratedDistributionRpm = info.Rpm * distributeGearPowerRate;
                    
                    gearConsumer.SupplyPower(ratedDistributionRpm, ratedDistributeTorque, info.IsClockwise);
                }
                
                foreach (var generator in _gearGenerators)
                {
                    var info = _checkedGearComponents[generator.BlockInstanceId];
                    
                    var ratedDistributeTorque = new Torque(info.RequiredTorque.AsPrimitive() * distributeGearPowerRate);
                    var ratedDistributionRpm = info.Rpm * distributeGearPowerRate;
                    
                    generator.SupplyPower(ratedDistributionRpm, ratedDistributeTorque, info.IsClockwise);
                }
            }
            
            #endregion
        }
    }
    
    public class GearRotationInfo
    {
        public readonly IGearEnergyTransformer EnergyTransformer;
        public readonly bool IsClockwise;
        public readonly RPM Rpm;
        
        public GearRotationInfo(RPM rpm, bool isClockwise, IGearEnergyTransformer energyTransformer)
        {
            Rpm = rpm;
            IsClockwise = isClockwise;
            EnergyTransformer = energyTransformer;
        }
        
        public Torque RequiredTorque { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/IElectricConsumer.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;

namespace Game.EnergySystem
{
    /// <summary>
    ///     エネルギーを消費するモノ
    /// </summary>
    public interface IElectricConsumer : IBlockComponent
    {
        public BlockInstanceId BlockInstanceId { get; }
        public ElectricPower RequestEnergy { get; }
        void SupplyEnergy(ElectricPower power);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Electric/DisplayEnergizedRange.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.UIState;
using Core.Master;
using Game.PlayerInventory.Interface;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;
using VContainer;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Client.Game.InGame.Electric
{
    /// <summary>
    ///     TODO 各データにアクセスしやすいようなアクセッサを作ってそっちに乗り換える
    /// </summary>
    public class DisplayEnergizedRange : MonoBehaviour
    {
        [SerializeField] private EnergizedRangeObject rangePrefab;
        private readonly List<EnergizedRangeObject> rangeObjects = new();
        
        private BlockGameObjectDataStore _blockGameObjectDataStore;
        private HotBarView _hotBarView;
        private ILocalPlayerInventory _localPlayerInventory;
        
        private bool isBlockPlaceState;
        
        [Inject]
        public void Construct(HotBarView hotBarView, UIStateControl uiStateControl, BlockGameObjectDataStore blockGameObjectDataStore, ILocalPlayerInventory localPlayerInventory)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            
            _localPlayerInventory = localPlayerInventory;
            _hotBarView = hotBarView;
            
            hotBarView.OnSelectHotBar += OnSelectHotBar;
            uiStateControl.OnStateChanged += OnStateChanged;
            blockGameObjectDataStore.OnBlockPlaced.Subscribe(OnPlaceBlock);
        }
        
        private void OnSelectHotBar(int index)
        {
            ResetRangeObject();
            CreateRangeObject();
        }
        
        private void OnStateChanged(UIStateEnum state)
        {
            if (isBlockPlaceState && state != UIStateEnum.GameScreen)
            {
                isBlockPlaceState = false;
                ResetRangeObject();
                return;
            }
            
            if (state != UIStateEnum.GameScreen) return;
            isBlockPlaceState = true;
            
            CreateRangeObject();
        }
        
        private void OnPlaceBlock(BlockGameObject blockGameObject)
        {
            if (!isBlockPlaceState) return;
            
            ResetRangeObject();
            CreateRangeObject();
        }
        
        
        private void ResetRangeObject()
        {
            foreach (var rangeObject in rangeObjects) Destroy(rangeObject.gameObject);
            rangeObjects.Clear();
        }
        
        
        private void CreateRangeObject()
        {
            var (isElectricalBlock, isPole) = IsDisplay();
            //電気ブロックでも電柱でもない
            if (!isElectricalBlock && !isPole) return;
            
            //電気系のブロックなので電柱の範囲を表示する
            foreach (var electricalPole in GetElectricalPoles())
            {
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(electricalPole.BlockId);
                var electricPoleParam = (ElectricPoleBlockParam)blockMasterElement.BlockParam;
                var range = isElectricalBlock ? electricPoleParam.MachineConnectionRange : electricPoleParam.PoleConnectionRange;
                
                var rangeObject = Instantiate(rangePrefab, electricalPole.transform.position, Quaternion.identity, transform);
                rangeObject.SetRange(range);
                rangeObjects.Add(rangeObject);
            }
            
            #region Internal
            
            (bool isElectricalBlock, bool isPole) IsDisplay()
            {
                var hotBarSlot = _hotBarView.SelectIndex;
                var id = _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(hotBarSlot)].Id;
                
                if (id == ItemMaster.EmptyItemId) return (false, false);
                

                if (!MasterHolder.BlockMaster.IsBlock(id)) return (false, false);
                
                var blockId = MasterHolder.BlockMaster.GetBlockId(id);
                var blockMaster = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                
                return (IsElectricalBlock(blockMaster.BlockType), IsPole(blockMaster.BlockType));
            }
            
            List<BlockGameObject> GetElectricalPoles()
            {
                var resultBlocks = new List<BlockGameObject>();
                foreach (var blocks in _blockGameObjectDataStore.BlockGameObjectDictionary)
                {
                    var blockMaster = MasterHolder.BlockMaster.GetBlockMaster(blocks.Value.BlockId);
                    if (blockMaster.BlockType != BlockTypeConst.ElectricPole) continue;
                    
                    resultBlocks.Add(blocks.Value);
                }
                
                return resultBlocks;
            }
            
            //TODO 電気系のブロックかどうか判定するロジック
            bool IsElectricalBlock(string type)
            {
                return type is BlockTypeConst.ElectricGenerator or BlockTypeConst.ElectricMachine or BlockTypeConst.ElectricMiner;
            }
            
            bool IsPole(string type)
            {
                return type is BlockTypeConst.ElectricPole;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/ItemShooterTest.cs
```cs
using System;
using Core.Const;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.ItemShooter;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    public class ItemShooterTest
    {
        [Test]
        public void ShooterTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemFactory = ServerContext.ItemStackFactory;
            
            // アイテムシューターのテストは、以下のように、一度下がり、再び上がるような構造になっている
            // Item shooter tests are structured to drop once and then rise again as follows
            // ↓ チェスト Chest
            // □ ＿ 
            //     ＼         ＿ ＿ → アイテムの流れ Item flow
            //        ＼ ＿ ／
            //   ↑  ↑ アイテムシューター ItemShooter
            var chestPosition = new Vector3Int(0, 0, 0);
            var horizonShooter1 = new Vector3Int(0, 0, 1);
            var downShooter1 = new Vector3Int(0, -1, 2);
            var downShooter2 = new Vector3Int(0, -2, 3);
            var horizonShooter2 = new Vector3Int(0, -2, 4);
            var upShooter = new Vector3Int(0, -2, 5);
            var horizonShooter3 = new Vector3Int(0, -1, 6);
            var horizonShooter4 = new Vector3Int(0, -1, 7);
            
            var chest = AddBlock(ForUnitTestModBlockId.ChestId, chestPosition).GetComponent<VanillaChestComponent>();
            var shooter1 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter1).GetComponent<ItemShooterComponent>();
            var down1 = AddBlock(ForUnitTestModBlockId.DownItemShooter, downShooter1).GetComponent<ItemShooterComponent>();
            var down2 = AddBlock(ForUnitTestModBlockId.DownItemShooter, downShooter2).GetComponent<ItemShooterComponent>();
            var shooter2 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter2).GetComponent<ItemShooterComponent>();
            var up = AddBlock(ForUnitTestModBlockId.UpItemShooter, upShooter).GetComponent<ItemShooterComponent>();
            var shooter3 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter3).GetComponent<ItemShooterComponent>();
            var shooter4 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter4).GetComponent<ItemShooterComponent>();
            
            chest.InsertItem(itemFactory.Create(new ItemId(1), 1));
            
            // チェストのUpdateを呼び出し
            // Call the Update of the chest
            chest.Update();
            
            // デフォルトでインサートされる速度の検証
            // Verification of the speed inserted by default
            var shooterItem1 = GetShooterItem(shooter1);
            Assert.AreEqual(1, shooterItem1.ItemId.AsPrimitive());
            Assert.AreEqual(1, shooterItem1.CurrentSpeed);
            Assert.AreEqual(1, shooterItem1.RemainingPercent);
            
            // 個々の値は実際の値をみて検証し、極端にかわってなければOKとする
            // Verify each value by looking at the actual value and OK if it is not extremely different
            var shootedItem = WaitInsertItem(down1, "1");
            Assert.IsTrue(0.7f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 0.8f);
            
            shootedItem = WaitInsertItem(down2, "Down1");
            Assert.IsTrue(1.2f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.5f);
            
            shootedItem = WaitInsertItem(shooter2, "Down2");
            Assert.IsTrue(1.7f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 2.0f);
            
            shootedItem = WaitInsertItem(up, "2");
            Assert.IsTrue(1.4f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.8f);
            
            shootedItem = WaitInsertItem(shooter3, "Up", up);
            Assert.IsTrue(0.9f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.3f);
            
            shootedItem = WaitInsertItem(shooter4, "3");
            Assert.IsTrue(0.6f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.1f);
        }
        
        private ShooterInventoryItem WaitInsertItem(ItemShooterComponent waitTarget, string tag, ItemShooterComponent waitFrom = null)
        {
            var currentTime = DateTime.Now;
            while (true)
            {
                var item = waitTarget.GetItem(0);
                if (item.Id != ItemMaster.EmptyItemId)
                {
                    // アイテム挿入時間を出力
                    var shooterItem = GetShooterItem(waitTarget);
                    var totalSeconds = (DateTime.Now - currentTime).TotalSeconds;
                    var currentSpeed = shooterItem.CurrentSpeed;
                    // 下2桁表示
                    Debug.Log($"{tag} Time: {totalSeconds:F2} Speed: {currentSpeed:F2}");
                    return shooterItem;
                }
                GameUpdater.Update();
                
                // 5秒経過したら失敗
                if ((DateTime.Now - currentTime).TotalSeconds > 5)
                {
                    Assert.Fail("インサートができていません");
                }
            }
        }
        
        private ShooterInventoryItem GetShooterItem(ItemShooterComponent target)
        {
            var item = target.BeltConveyorItems[0];
            return item as ShooterInventoryItem;
        }
        
        private IBlock AddBlock(BlockId blockId, Vector3Int position)
        {
            var world = ServerContext.WorldBlockDatastore;
            
            world.TryAddBlock(blockId, position, BlockDirection.North, out var block);
            
            return block;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/OpenableBlockInventoryUpdateEventPacket.cs
```cs
using System;
using Core.Item.Interface;
using Game.Block.Interface.Event;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Event.EventReceive
{
    /// <summary>
    ///     TODO これいる？どうせステートの変更を送るんだから、そこに入れたらいいんじゃないの？
    /// </summary>
    public class OpenableBlockInventoryUpdateEventPacket
    {
        public const string EventTag = "va:event:blockInvUpdate";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        private readonly IBlockInventoryOpenStateDataStore _inventoryOpenStateDataStore;
        
        private DateTime _now = DateTime.Now;
        
        public OpenableBlockInventoryUpdateEventPacket(EventProtocolProvider eventProtocolProvider, IBlockInventoryOpenStateDataStore inventoryOpenStateDataStore)
        {
            _eventProtocolProvider = eventProtocolProvider;
            _inventoryOpenStateDataStore = inventoryOpenStateDataStore;
            ServerContext.BlockOpenableInventoryUpdateEvent.Subscribe(InventoryUpdateEvent);
        }
        
        
        private void InventoryUpdateEvent(BlockOpenableInventoryUpdateEventProperties properties)
        {
            //そのブロックを開いているプレイヤーをリストアップ
            var playerIds = _inventoryOpenStateDataStore.GetBlockInventoryOpenPlayers(properties.BlockInstanceId);
            if (playerIds.Count == 0) return;
            
            var pos = ServerContext.WorldBlockDatastore.GetBlockPosition(properties.BlockInstanceId);
            var messagePack = new OpenableBlockInventoryUpdateEventMessagePack(pos, properties.Slot, properties.ItemStack);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            //プレイヤーごとにイベントを送信
            foreach (var id in playerIds) _eventProtocolProvider.AddEvent(id, EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class OpenableBlockInventoryUpdateEventMessagePack
    {
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public OpenableBlockInventoryUpdateEventMessagePack()
        {
        }
        
        public OpenableBlockInventoryUpdateEventMessagePack(Vector3Int pos, int slot, IItemStack item)
        {
            Position = new Vector3IntMessagePack(pos);
            Slot = slot;
            Item = new ItemMessagePack(item.Id, item.Count);
        }
        
        [Key(0)] public Vector3IntMessagePack Position { get; set; }
        
        [Key(1)] public int Slot { get; set; }
        
        [Key(2)] public ItemMessagePack Item { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/ConnectMachineToElectricSegment.cs
```cs
using Core.Master;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     電力を生産もしくは消費するブロックが設置されたときに、そのブロックを電柱に接続する
    /// </summary>
    public class ConnectMachineToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        private readonly int _maxMachineConnectionRange;
        private readonly IWorldEnergySegmentDatastore<TSegment> _worldEnergySegmentDatastore;
        
        
        public ConnectMachineToElectricSegment(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore, MaxElectricPoleMachineConnectionRange maxElectricPoleMachineConnectionRange)
        {
            _worldEnergySegmentDatastore = worldEnergySegmentDatastore;
            _maxMachineConnectionRange = maxElectricPoleMachineConnectionRange.Get();
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlace);
        }
        
        private void OnBlockPlace(BlockUpdateProperties updateProperties)
        {
            //設置されたブロックが電柱だった時の処理
            var pos = updateProperties.Pos;
            var x = updateProperties.Pos.x;
            var y = updateProperties.Pos.y;
            
            //設置されたブロックが発電機か機械以外はスルー処理
            if (!IsElectricMachine(pos)) return;
            
            //最大の電柱の接続範囲を取得探索して接続する
            var startMachineX = x - _maxMachineConnectionRange / 2;
            var startMachineY = y - _maxMachineConnectionRange / 2;
            for (var i = startMachineX; i < startMachineX + _maxMachineConnectionRange; i++)
            for (var j = startMachineY; j < startMachineY + _maxMachineConnectionRange; j++)
            {
                var polePos = new Vector3Int(i, j);
                if (!ServerContext.WorldBlockDatastore.ExistsComponent<IElectricTransformer>(polePos)) continue;
                
                //範囲内に電柱がある場合
                //電柱に接続
                ConnectToElectricPole(polePos, pos);
            }
        }
        
        private bool IsElectricMachine(Vector3Int pos)
        {
            return ServerContext.WorldBlockDatastore.ExistsComponent<TGenerator>(pos) ||
                   ServerContext.WorldBlockDatastore.ExistsComponent<TConsumer>(pos);
        }
        
        
        /// <summary>
        ///     電柱のセグメントに機械を接続する
        /// </summary>
        private void ConnectToElectricPole(Vector3Int polePos, Vector3Int machinePos)
        {
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            
            //電柱を取得
            var block = ServerContext.WorldBlockDatastore.GetBlock(polePos);
            var pole = block.GetComponent<TTransformer>();
            //その電柱のコンフィグを取得
            var configParam = block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            var range = configParam.MachineConnectionRange;
            
            //その電柱から見て機械が範囲内に存在するか確認
            var poleX = polePos.x;
            var poleY = polePos.y;
            if (poleX - range / 2 > poleX || poleX > poleX + range / 2 || poleY - range / 2 > poleY ||
                poleY > poleY + range / 2) return;
            
            //在る場合は発電機か機械かを判定して接続
            //発電機を電力セグメントに追加
            var segment = _worldEnergySegmentDatastore.GetEnergySegment(pole);
            if (worldBlockDatastore.ExistsComponent<TGenerator>(machinePos))
                segment.AddGenerator(worldBlockDatastore.GetBlock<TGenerator>(machinePos));
            else if (worldBlockDatastore.ExistsComponent<TConsumer>(machinePos))
                segment.AddEnergyConsumer(worldBlockDatastore.GetBlock<TConsumer>(machinePos));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/IElectricTransformer.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;

namespace Game.EnergySystem
{
    /// <summary>
    ///     エネルギーを伝達するモノ
    /// </summary>
    public interface IElectricTransformer : IBlockComponent
    {
        public BlockInstanceId BlockInstanceId { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;

namespace Game.CraftChainer.BlockComponent.Computer
{
    /// <summary>
    /// メインコンピューターはアイテムを外に出さないので、そのためのクラス
    /// The main computer does not take items out, so this class is for that
    /// </summary>
    public class CraftChainerMainComputerInserter : IBlockInventoryInserter
    {
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return itemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaGearMachineComponent.cs
```cs
using Game.Block.Blocks.Gear;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.Block.Blocks.Machine
{
    /// <summary>
    ///     歯車機械を表すクラス
    /// </summary>
    public class VanillaGearMachineComponent : IBlockComponent
    {
        private readonly GearEnergyTransformer _gearEnergyTransformer;
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        private readonly GearMachineBlockParam _gearMachineBlockParam;
        
        public VanillaGearMachineComponent(VanillaMachineProcessorComponent vanillaMachineProcessorComponent, GearEnergyTransformer gearEnergyTransformer, GearMachineBlockParam gearMachineBlockParam)
        {
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
            _gearEnergyTransformer = gearEnergyTransformer;
            _gearMachineBlockParam = gearMachineBlockParam;
            
            _gearEnergyTransformer.OnGearUpdate.Subscribe(OnGearUpdate);
        }
        
        private void OnGearUpdate(GearUpdateType gearUpdateType)
        {
            var requiredRpm = new RPM(_gearMachineBlockParam.RequiredRpm);
            var requireTorque = new Torque(_gearMachineBlockParam.RequireTorque);
            
            var currentElectricPower = _gearEnergyTransformer.CalcMachineSupplyPower(requiredRpm, requireTorque);
            _vanillaMachineProcessorComponent.SupplyPower(currentElectricPower);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            BlockException.CheckDestroy(this);
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Util/MachineCurrentPowerToSubSecond.cs
```cs
using Core.Update;
using Game.EnergySystem;

namespace Game.Block.Blocks.Util
{
    /// <summary>
    ///     機械の現在の電力量から、機械のプロセス（例えば採掘やアイテムの加工など）をどれくらい進めるかを計算する
    /// </summary>
    public static class MachineCurrentPowerToSubSecond
    {
        public static double GetSubSecond(ElectricPower currentPower, ElectricPower requiredPower)
        {
            //必要電力が0の時はそのフレームの時間を返す
            if (requiredPower.AsPrimitive() == 0) return GameUpdater.UpdateSecondTime;
            //現在の電力量を必要電力で割った割合で、そのフレームの時間を返す
            //例えば、必要電力が100、現在の電力が50だったら、そのフレームの半分の時間を返すことで、機械の速度を半分にする
            return GameUpdater.UpdateSecondTime * (currentPower.AsPrimitive() / (double)requiredPower.AsPrimitive());
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Miner/VanillaMinerProcessorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.Service;
using Game.Block.Blocks.Util;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Block.Interface.State;
using Game.Context;
using Game.EnergySystem;
using Game.Map.Interface.Vein;
using MessagePack;
using Mooresmaster.Model.MineSettingsModule;
using Newtonsoft.Json;
using UniRx;

namespace Game.Block.Blocks.Miner
{
    public class VanillaMinerProcessorComponent : IOpenableBlockInventoryComponent, IBlockSaveState, IBlockStateObservable, IBlockStateDetail, IUpdatableBlockComponent
    {
        public bool IsDestroy { get; private set; }
        public ElectricPower RequestEnergy { get; }
        public IObservable<Unit> OnChangeBlockState => _blockStateChangeSubject;
        private Subject<Unit> _blockStateChangeSubject = new();
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly ConnectingInventoryListPriorityInsertItemService _connectInventoryService;
        private readonly List<IItemStack> _miningItems = new();
        
        private readonly OpenableInventoryItemDataStoreService _openableInventoryItemDataStoreService;
        private readonly BlockInstanceId _blockInstanceId;
        
        private ElectricPower _currentPower;
        
        private float _defaultMiningTime = float.MaxValue;
        private double _remainingSecond = double.MaxValue;
        
        private VanillaMinerState _lastMinerState;
        private VanillaMinerState _currentState = VanillaMinerState.Idle;
        
        public VanillaMinerProcessorComponent(BlockInstanceId blockInstanceId, ElectricPower requestPower, int outputSlotCount, BlockOpenableInventoryUpdateEvent openableInventoryUpdateEvent, BlockConnectorComponent<IBlockInventory> inputConnectorComponent, BlockPositionInfo blockPositionInfo, MineSettings mineSettings)
        {
            _blockInstanceId = blockInstanceId;
            RequestEnergy = requestPower;
            
            _blockInventoryUpdate = openableInventoryUpdateEvent;
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            _openableInventoryItemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, itemStackFactory, outputSlotCount);
            _connectInventoryService = new ConnectingInventoryListPriorityInsertItemService(inputConnectorComponent);
            
            SetMiningItem();
            
            #region Internal
            
            void SetMiningItem()
            {
                List<IMapVein> veins = ServerContext.MapVeinDatastore.GetOverVeins(blockPositionInfo.OriginalPos);
                foreach (var vein in veins) _miningItems.Add(itemStackFactory.Create(vein.VeinItemId, 1));
                if (veins.Count == 0) return;
                
                foreach (var miningSetting in mineSettings.items)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(miningSetting.ItemGuid);
                    if (itemId != veins[0].VeinItemId) continue;
                    _defaultMiningTime = miningSetting.Time;
                    _remainingSecond = _defaultMiningTime;
                    break;
                }
            }
            
            #endregion
        }
        
        public VanillaMinerProcessorComponent(Dictionary<string, string> componentStates, BlockInstanceId blockInstanceId, ElectricPower requestPower, int outputSlotCount, BlockOpenableInventoryUpdateEvent openableInventoryUpdateEvent, BlockConnectorComponent<IBlockInventory> inputConnectorComponent, BlockPositionInfo blockPositionInfo, MineSettings mineSettings)
            : this(blockInstanceId, requestPower, outputSlotCount, openableInventoryUpdateEvent, inputConnectorComponent, blockPositionInfo, mineSettings)
        {
            var saveJsonObject = JsonConvert.DeserializeObject<VanillaElectricMinerSaveJsonObject>(componentStates[SaveKey]);
            for (var i = 0; i < saveJsonObject.Items.Count; i++)
            {
                var itemStack = saveJsonObject.Items[i].ToItemStack();
                _openableInventoryItemDataStoreService.SetItem(i, itemStack);
            }
            
            _remainingSecond = saveJsonObject.RemainingSecond;
        }
        
        public void SupplyPower(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            
            _currentPower = power;
        }
        
        public string SaveKey { get; } = typeof(VanillaMinerProcessorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var saveData = new VanillaElectricMinerSaveJsonObject
            {
                RemainingSecond = _remainingSecond,
                Items = _openableInventoryItemDataStoreService.InventoryItems.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
            };
            
            return JsonConvert.SerializeObject(saveData);
        }
        
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            MinerProgressUpdate();
            CheckStateAndInvokeEventUpdate();
            
            #region Internal
            
            void MinerProgressUpdate()
            {
                var subTime = MachineCurrentPowerToSubSecond.GetSubSecond(_currentPower, RequestEnergy);
                if (subTime <= 0)
                {
                    //電力の都合で処理を進められないのでreturn
                    _currentState = VanillaMinerState.Idle;
                    return;
                }
                
                //insertできるかチェック
                if (!_openableInventoryItemDataStoreService.InsertionCheck(_miningItems))
                {
                    //挿入できないのでreturn
                    _currentState = VanillaMinerState.Idle;
                    return;
                }
                
                _currentState = VanillaMinerState.Mining;
                
                _remainingSecond -= subTime;
                
                if (_remainingSecond <= 0)
                {
                    _remainingSecond = _defaultMiningTime;
                    
                    //空きスロットを探索し、あるならアイテムを挿入
                    _openableInventoryItemDataStoreService.InsertItem(_miningItems);
                }
                
                _currentPower = new ElectricPower(0);
                InsertConnectInventory();
            }
            
            void CheckStateAndInvokeEventUpdate()
            {
                if (_lastMinerState == VanillaMinerState.Mining && _currentState == VanillaMinerState.Idle)
                {
                    //Miningからidleに切り替わったのでイベントを発火
                    InvokeChangeStateEvent();
                    _lastMinerState = _currentState;
                    return;
                }
                
                if (_currentState == VanillaMinerState.Idle)
                    //Idle中は発火しない
                    return;
                
                //マイニング中 この時は常にイベントを発火
                InvokeChangeStateEvent();
            }
            
            void InvokeChangeStateEvent()
            {
                BlockException.CheckDestroy(this);
                
                _blockStateChangeSubject.OnNext(Unit.Default);
            }
            
            
            void InsertConnectInventory()
            {
                BlockException.CheckDestroy(this);
                
                for (var i = 0; i < _openableInventoryItemDataStoreService.InventoryItems.Count; i++)
                {
                    var insertedItem = _connectInventoryService.InsertItem(_openableInventoryItemDataStoreService.InventoryItems[i]);
                    _openableInventoryItemDataStoreService.SetItem(i, insertedItem);
                }
            }
            
            #endregion
        }
        
        
        public BlockStateDetail GetBlockStateDetail()
        {
            var processingRate = 1 - (float)_remainingSecond / _defaultMiningTime;
            var stateDetail = new CommonMachineBlockStateDetail(_currentPower.AsPrimitive(), RequestEnergy.AsPrimitive(), processingRate, _currentState.ToStr(), _lastMinerState.ToStr());
            var stateDetailBytes = MessagePackSerializer.Serialize(stateDetail);
            return new BlockStateDetail(CommonMachineBlockStateDetail.BlockStateDetailKey, stateDetailBytes);
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(_blockInstanceId, slot, itemStack));
        }
        
        #region Implimantion IOpenableInventory
        
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _openableInventoryItemDataStoreService.SetItem(slot, itemStack);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _openableInventoryItemDataStoreService.GetSlotSize();
        }
        
        
        public IReadOnlyList<IItemStack> InventoryItems => _openableInventoryItemDataStoreService.InventoryItems;
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.ReplaceItem(slot, itemId, count);
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemStack);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemId, count);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertionCheck(itemStacks);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            _openableInventoryItemDataStoreService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.ReplaceItem(slot, itemStack);
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            return _openableInventoryItemDataStoreService.CreateCopiedItems();
        }
        
        #endregion
        
        public void Destroy()
        {
            IsDestroy = true;
            _blockStateChangeSubject.Dispose();
            _blockStateChangeSubject = null;
        }
    }
    
    public enum VanillaMinerState
    {
        Idle,
        Mining,
    }
    
    public static class ProcessStateExtension
    {
        /// <summary>
        ///     <see cref="ProcessState" />をStringに変換します。
        ///     EnumのToStringを使わない理由はアロケーションによる速度低下をなくすためです。
        /// </summary>
        public static string ToStr(this VanillaMinerState state)
        {
            return state switch
            {
                VanillaMinerState.Idle => "idle",
                VanillaMinerState.Mining =>"mining",
                _ => throw new ArgumentOutOfRangeException(nameof(state), state, null),
            };
        }
    }
    
    public class VanillaElectricMinerSaveJsonObject
    {
        [JsonProperty("items")]
        public List<ItemStackSaveJsonObject> Items;
        [JsonProperty("remainingSecond")]
        public double RemainingSecond;
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/MoorestechServerDIContainerGenerator.cs
```cs
using System.IO;
using Core.Item;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Event;
using Game.Block.Factory;
using Game.Block.Interface;
using Game.Block.Interface.Event;
using Game.Challenge;
using Game.Context;
using Game.CraftChainer;
using Game.CraftChainer.CraftNetwork;
using Game.CraftChainer.Util;
using Game.Crafting.Interface;
using Game.EnergySystem;
using Game.Entity;
using Game.Entity.Interface;
using Game.Gear.Common;
using Game.Map;
using Game.Map.Interface.Json;
using Game.Map.Interface.MapObject;
using Game.Map.Interface.Vein;
using Game.PlayerInventory;
using Game.PlayerInventory.Event;
using Game.PlayerInventory.Interface;
using Game.PlayerInventory.Interface.Event;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.Train.RailGraph;
using Game.World;
using Game.World.DataStore;
using Game.World.DataStore.WorldSettings;
using Game.World.EventHandler.EnergyEvent;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using Mod.Config;
using Mod.Loader;
using Newtonsoft.Json;
using Server.Event;
using Server.Event.EventReceive;
using Server.Protocol;

namespace Server.Boot
{
    public class MoorestechServerDIContainerGenerator
    {
        //TODO セーブファイルのディレクトリもここで指定できるようにする
        public (PacketResponseCreator, ServiceProvider) Create(string serverDirectory)
        {
            GameUpdater.ResetUpdate();
            
            //必要な各種インスタンスを手動で作成
            var modDirectory = Path.Combine(serverDirectory, "mods");
            
            // マスターをロード
            var modResource = new ModsResource(modDirectory);
            var configJsons = ModJsonStringLoader.GetConfigString(modResource);
            var configJsonFileContainer = new MasterJsonFileContainer(configJsons);
            MasterHolder.Load(configJsonFileContainer);
            
            var initializerCollection = new ServiceCollection();
            initializerCollection.AddSingleton(configJsonFileContainer);
            initializerCollection.AddSingleton<IItemStackFactory, ItemStackFactory>();
            initializerCollection.AddSingleton<VanillaIBlockTemplates, VanillaIBlockTemplates>();
            initializerCollection.AddSingleton<IBlockFactory, BlockFactory>();
            
            initializerCollection.AddSingleton<IWorldBlockDatastore, WorldBlockDatastore>();
            initializerCollection.AddSingleton<IWorldBlockUpdateEvent, WorldBlockUpdateEvent>();
            initializerCollection.AddSingleton<IBlockOpenableInventoryUpdateEvent, BlockOpenableInventoryUpdateEvent>();
            initializerCollection.AddSingleton<GearNetworkDatastore>();
            initializerCollection.AddSingleton<RailGraphDatastore>();

            var mapPath = Path.Combine(serverDirectory, "map", "map.json");
            initializerCollection.AddSingleton(JsonConvert.DeserializeObject<MapInfoJson>(File.ReadAllText(mapPath)));
            initializerCollection.AddSingleton<IMapVeinDatastore, MapVeinDatastore>();
            
            var initializerProvider = initializerCollection.BuildServiceProvider();
            var serverContext = new ServerContext(initializerProvider);
            
            
            //コンフィグ、ファクトリーのインスタンスを登録
            var services = new ServiceCollection();
            
            //ゲームプレイに必要なクラスのインスタンスを生成
            services.AddSingleton<EventProtocolProvider, EventProtocolProvider>();
            services.AddSingleton<IWorldSettingsDatastore, WorldSettingsDatastore>();
            services.AddSingleton<IPlayerInventoryDataStore, PlayerInventoryDataStore>();
            services.AddSingleton<IBlockInventoryOpenStateDataStore, BlockInventoryOpenStateDataStore>();
            services.AddSingleton<IWorldEnergySegmentDatastore<EnergySegment>, WorldEnergySegmentDatastore<EnergySegment>>();
            services.AddSingleton<MaxElectricPoleMachineConnectionRange, MaxElectricPoleMachineConnectionRange>();
            services.AddSingleton<IEntitiesDatastore, EntitiesDatastore>();
            services.AddSingleton<IEntityFactory, EntityFactory>(); // TODO これを削除してContext側に加える？
            services.AddSingleton<GearNetworkDatastore>();
            services.AddSingleton<RailGraphDatastore>();

            services.AddSingleton<ItemRecipeViewerDataContainer>();
            
            services.AddSingleton<IMapObjectDatastore, MapObjectDatastore>();
            services.AddSingleton<IMapObjectFactory, MapObjectFactory>();
            
            services.AddSingleton(configJsonFileContainer);
            services.AddSingleton<ChallengeDatastore, ChallengeDatastore>();
            services.AddSingleton<ChallengeEvent, ChallengeEvent>();
            
            //JSONファイルのセーブシステムの読み込み
            services.AddSingleton(modResource);
            services.AddSingleton<IWorldSaveDataSaver, WorldSaverForJson>();
            services.AddSingleton<IWorldSaveDataLoader, WorldLoaderFromJson>();
            services.AddSingleton(new SaveJsonFileName("save_1.json"));
            services.AddSingleton(JsonConvert.DeserializeObject<MapInfoJson>(File.ReadAllText(mapPath)));
            
            //イベントを登録
            services.AddSingleton<IMainInventoryUpdateEvent, MainInventoryUpdateEvent>();
            services.AddSingleton<IGrabInventoryUpdateEvent, GrabInventoryUpdateEvent>();
            services.AddSingleton<CraftEvent, CraftEvent>();
            
            //イベントレシーバーを登録
            services.AddSingleton<ChangeBlockStateEventPacket>();
            services.AddSingleton<MainInventoryUpdateEventPacket>();
            services.AddSingleton<OpenableBlockInventoryUpdateEventPacket>();
            services.AddSingleton<GrabInventoryUpdateEventPacket>();
            services.AddSingleton<PlaceBlockEventPacket>();
            services.AddSingleton<RemoveBlockToSetEventPacket>();
            services.AddSingleton<CompletedChallengeEventPacket>();
            
            services.AddSingleton<EnergyConnectUpdaterContainer<EnergySegment, IElectricConsumer, IElectricGenerator, IElectricTransformer>>();
            
            services.AddSingleton<MapObjectUpdateEventPacket>();
            
            //データのセーブシステム
            services.AddSingleton<AssembleSaveJsonText, AssembleSaveJsonText>();
            
            
            var serviceProvider = services.BuildServiceProvider();
            var packetResponse = new PacketResponseCreator(serviceProvider);
            
            //イベントレシーバーをインスタンス化する
            //TODO この辺を解決するDIコンテナを探す VContinerのRegisterEntryPoint的な
            serviceProvider.GetService<MainInventoryUpdateEventPacket>();
            serviceProvider.GetService<OpenableBlockInventoryUpdateEventPacket>();
            serviceProvider.GetService<GrabInventoryUpdateEventPacket>();
            serviceProvider.GetService<PlaceBlockEventPacket>();
            serviceProvider.GetService<RemoveBlockToSetEventPacket>();
            serviceProvider.GetService<CompletedChallengeEventPacket>();
            
            serviceProvider.GetService<GearNetworkDatastore>();
            serviceProvider.GetService<RailGraphDatastore>();
            serviceProvider.GetService<EnergyConnectUpdaterContainer<EnergySegment, IElectricConsumer, IElectricGenerator, IElectricTransformer>>();
            
            serviceProvider.GetService<ChangeBlockStateEventPacket>();
            serviceProvider.GetService<MapObjectUpdateEventPacket>();
            
            serverContext.SetMainServiceProvider(serviceProvider);
            
            // CraftChainerの初期化
            CraftChainerEntryPoint.Entry();
            
            // アップデート時間をリセット
            GameUpdater.ResetTime();
            
            return (packetResponse, serviceProvider);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/BeltConveyorSaveLoadTest.cs
```cs
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class BeltConveyorSaveLoadTest
    {
        [Test]
        public void NormalSaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var beltPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(1), beltPosInfo);
            
            var belt = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            //リフレクションで_inventoryItemsを取得
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(belt);
            
            //アイテムを設定
            inventoryItems[0] = new VanillaBeltConveyorInventoryItem(new ItemId(1), new ItemInstanceId(0))
            {
                RemainingPercent = 0.3f,
            };
            inventoryItems[2] = new VanillaBeltConveyorInventoryItem(new ItemId(2), new ItemInstanceId(0))
            {
                RemainingPercent = 0.5f,
            };
            inventoryItems[3] = new VanillaBeltConveyorInventoryItem(new ItemId(5), new ItemInstanceId(0))
            {
                RemainingPercent = 1f,
            };
            
            
            //セーブデータ取得
            var str = belt.GetSaveState();
            var states = new Dictionary<string, string>() { { belt.SaveKey, str } };
            Debug.Log(str);
            
            
            //セーブデータをロード
            var blockConnector = new BlockConnectorComponent<IBlockInventory>(null, null, beltPosInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(blockConnector);
            
            var newBelt = new VanillaBeltConveyorComponent(states, 4, 4000, beltConveyorConnector, BeltConveyorSlopeType.Straight);
            var newInventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(newBelt);
            
            //アイテムが一致するかチェック
            Assert.AreEqual(inventoryItems.Length, newInventoryItems.Length);
            Assert.AreEqual(1, newInventoryItems[0].ItemId.AsPrimitive());
            Assert.AreEqual(0.3f, newInventoryItems[0].RemainingPercent);
            Assert.AreEqual(2, newInventoryItems[2].ItemId.AsPrimitive());
            Assert.AreEqual(0.5f, newInventoryItems[2].RemainingPercent);
            Assert.AreEqual(5, newInventoryItems[3].ItemId.AsPrimitive());
            Assert.AreEqual(1f, newInventoryItems[3].RemainingPercent);
        }
        
        [Test]
        public void GearSaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var beltPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.GearBeltConveyor, new BlockInstanceId(1), beltPosInfo);
            
            var belt = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            //リフレクションで_inventoryItemsを取得
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(belt);
            
            //アイテムを設定
            inventoryItems[0] = new VanillaBeltConveyorInventoryItem(new ItemId(1), new ItemInstanceId(0))
            {
                RemainingPercent = 0.3f,
            };
            inventoryItems[2] = new VanillaBeltConveyorInventoryItem(new ItemId(2), new ItemInstanceId(0))
            {
                RemainingPercent = 0.5f,
            };
            inventoryItems[3] = new VanillaBeltConveyorInventoryItem(new ItemId(5), new ItemInstanceId(0))
            {
                RemainingPercent = 1f,
            };
            
            
            //セーブデータ取得
            var str = belt.GetSaveState();
            var states = new Dictionary<string, string>() { { belt.SaveKey, str } };
            Debug.Log(str);
            
            
            //セーブデータをロード
            var blockConnector = new BlockConnectorComponent<IBlockInventory>(null, null, beltPosInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(blockConnector); 
            
            var newBelt = new VanillaBeltConveyorComponent(states, 4, 4000, beltConveyorConnector, BeltConveyorSlopeType.Straight);
            var newInventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(newBelt);
            
            //アイテムが一致するかチェック
            Assert.AreEqual(inventoryItems.Length, newInventoryItems.Length);
            Assert.AreEqual(1, newInventoryItems[0].ItemId.AsPrimitive());
            Assert.AreEqual(0.3f, newInventoryItems[0].RemainingPercent);
            Assert.AreEqual(2, newInventoryItems[2].ItemId.AsPrimitive());
            Assert.AreEqual(0.5f, newInventoryItems[2].RemainingPercent);
            Assert.AreEqual(5, newInventoryItems[3].ItemId.AsPrimitive());
            Assert.AreEqual(1f, newInventoryItems[3].RemainingPercent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/CraftChainer/CraftChainerSolverTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;

namespace Tests.UnitTest.Game.CraftChainer
{
    /// <summary>
    /// 凡例 legend
    /// 
    /// recipesStr
    /// レシピ番号:アウトプットアイテム名 数量, アウトプットアイテム名 数量 ← インプットアイテム名 数量, インプットアイテム名 数量
    /// RecipeId:OutputItemName Count, OutputItemName Count ← InputItemName Count, InputItemName Count
    ///
    /// initialInventoryStr
    /// アイテム名 数量
    /// ItemName Count
    ///
    /// targetItemStr
    /// アイテム名 数量
    /// ItemName Count
    ///
    /// expectedStr
    /// レシピ番号:使用レシピ回数
    /// RecipeId:UseRecipeCount
    /// 
    /// </summary>
    public class CraftChainerSolverTest
    {
        [Test]
        public void TestCase01()
        {
            var recipesStr = @"
1:A 1 ← B 1, C 2
2:B 1 ← C 2";
            var initialInventoryStr = @"
B 1";
            var targetItem = "A 1";
            var expectedStr = @""; // 解が存在しない場合、期待される結果は空文字列
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase02()
        {
            var recipesStr = @"
1:A 1 ← B 1, C 2
2:B 1 ← C 2";
            var initialInventoryStr = @""; // 初期在庫なし
            var targetItem = "A 1";
            var expectedStr = @""; // 解が存在しない
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase03()
        {
            var recipesStr = @"
1:D 1 ← E 8
2:E 4 ← F 2
3:E 4 ← G 2";
            var initialInventoryStr = @""; // 初期在庫なし
            var targetItem = "D 1";
            var expectedStr = @""; // 解が存在しない
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase04()
        {
            var recipesStr = @"
1:A 1 ← B 2
2:A 1 ← B 4";
            var initialInventoryStr = @"
B 3";
            var targetItem = "A 1";
            var expectedStr = @"
1:1"; // レシピ1を1回使用
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase05()
        {
            var recipesStr = @"
1:A 1 ← B 3
2:B 1 ← C 2
3:B 1 ← D 2
4:D 1 ← E 1";
            var initialInventoryStr = @"
C 4
D 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:2
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase06()
        {
            var recipesStr = @"
1:A 1 ← B 2, C 2
2:C 1 ← D 1
3:B 1, C 1 ← D 3";
            var initialInventoryStr = @"
B 1
D 10";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
3:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase07()
        {
            var recipesStr = @"
1:X 1 ← Y 1, Z 1
2:Y 1 ← W 5
3:Z 1 ← W 10";
            var initialInventoryStr = @"
W 15";
            var targetItem = "X 1";
            var expectedStr = @"
1:1
2:1
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase08()
        {
            var recipesStr = @"
1:A 1 ← B 2, C 1
2:A 1 ← B 1, D 2
3:B 1 ← E 3
4:C 1 ← E 2
5:D 1 ← E 1";
            var initialInventoryStr = @"
E 10";
            var targetItem = "A 2";
            var expectedStr = @"
2:2
3:2
5:4";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase09()
        {
            var recipesStr = @"
1:A 1 ← B 10
2:B 1 ← C 5
3:C 1 ← D 2
4:D 1 ← E 1";
            var initialInventoryStr = @"
C 2
E 10";
            var targetItem = "A 1";
            var expectedStr = @""; // 解が存在しない
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase10()
        {
            var recipesStr = @"
1:A 1 ← B 1
2:B 3 ← C 2
3:C 5 ← D 1";
            var initialInventoryStr = @"
D 1";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:1
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase11()
        {
            var recipesStr = @"
1:A 1 ← B 1, C 2
2:B 1 ← D 3
3:C 1 ← D 2
4:D 1 ← E 1
5:B 1 ← F 1
6:C 1 ← G 1";
            var initialInventoryStr = @"
D 1
F 1
G 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
5:1
6:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase12()
        {
            var recipesStr = @"
1:A 1 ← B 1, C 1
2:B 1 ← C 2
3:C 1 ← E 1
4:E 1 ← B 1
5:B 1 ← D 1";
            var initialInventoryStr = @"
D 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
3:1
4:1
5:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase13()
        {
            var recipesStr = @"
1:A 1 ← B1 1, B2 1, B3 1, B4 1
2:B1 1 ← C1 1
3:B2 1 ← C2 1
4:B3 1 ← C3 1
5:B4 1 ← C4 1
6:C1 1 ← D 1
7:C2 1 ← D 1
8:C3 1 ← D 1
9:C4 1 ← D 1";
            var initialInventoryStr = @"
D 5";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:1
3:1
4:1
5:1
6:1
7:1
8:1
9:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase14()
        {
            var recipesStr = @"
1:A 1 ← B 2
2:B 1 ← C 2
3:B 1 ← D 1";
            var initialInventoryStr = @"
C 1
D 1";
            var targetItem = "A 1";
            var expectedStr = @""; // 解が存在しない
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        
        private void ExecuteTest(
            string recipesStr,
            string initialInventoryStr,
            string targetItemStr,
            string expectedStr)
        {
            var (recipes, initialInventory, targetItem, expected) = ParseInput(recipesStr, initialInventoryStr, targetItemStr, expectedStr);
            var actual = CraftChainerCraftingSolver.Solve(recipes, initialInventory, targetItem);
            
            if (expected == null)
            {
                Assert.IsNull(actual);
                return;
            }
            
            Assert.IsNotNull(actual);
            Assert.AreEqual(expected.Count, actual.Count);
            
            foreach (var kvp in expected)
            {
                Assert.IsTrue(actual.ContainsKey(kvp.Key));
                Assert.AreEqual(kvp.Value, actual[kvp.Key]);
            }
        }
        
        private (List<CraftingSolverRecipe> recipes, Dictionary<ItemId, int> initialInventory, CraftingSolverItem targetItem, Dictionary<CraftingSolverRecipeId, int> expected) ParseInput(
            string recipesStr,
            string initialInventoryStr,
            string targetItemStr,
            string expectedStr)
        {
            var recipes = ParseRecipes();
            var initialInventory = ParseInitialInventory();
            var targetItem = ParseTargetItem();
            var expected = ParseExpected();
            
            return (recipes, initialInventory, targetItem, expected);
            
            #region Internal
            
            List<CraftingSolverRecipe> ParseRecipes()
            {
                var result = new List<CraftingSolverRecipe>();
                
                var recipeLines = recipesStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x));
                foreach (var recipeLine in recipeLines)
                {
                    var recipeId = new CraftingSolverRecipeId(int.Parse(recipeLine.Split(':')[0]));
                    var inputItemsStr = recipeLine.Split(':')[1].Split('←')[1].Trim();
                    var outputItemStr = recipeLine.Split(':')[1].Split('←')[0].Trim();
                    
                    var inputItems = ParseRecipeItems(inputItemsStr);
                    var outputItems = ParseRecipeItems(outputItemStr);
                    
                    result.Add(new CraftingSolverRecipe(recipeId, inputItems, outputItems));
                }
                
                return result;
            }
            
            Dictionary<ItemId, int> ParseInitialInventory()
            {
                var result = new Dictionary<ItemId, int>();
                
                var inventoryLines = initialInventoryStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x));
                foreach (var inventoryLine in inventoryLines)
                {
                    var itemName = inventoryLine.Split(' ')[0];
                    var itemId = new ItemId(GetItemId(itemName));
                    var quantity = int.Parse(inventoryLine.Split(' ')[1]);
                    
                    result.Add(itemId, quantity);
                }
                
                return result;
            }
            
            CraftingSolverItem ParseTargetItem()
            {
                var itemName = targetItemStr.Split(' ')[0];
                var itemId = new ItemId(GetItemId(itemName));
                var quantity = int.Parse(targetItemStr.Split(' ')[1]);
                
                return new CraftingSolverItem(itemId, quantity);
            }
            
            Dictionary<CraftingSolverRecipeId, int> ParseExpected()
            {
                var result = new Dictionary<CraftingSolverRecipeId, int>();
                
                var expectedLines = expectedStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x)).ToList();
                if (expectedLines.Count == 0)
                {
                    return null;
                }
                
                foreach (var expectedLine in expectedLines)
                {
                    var recipeId = new CraftingSolverRecipeId(int.Parse(expectedLine.Split(':')[0]));
                    var quantity = int.Parse(expectedLine.Split(':')[1]);
                    
                    result.Add(recipeId, quantity);
                }
                
                return result;
            }
            
            List<CraftingSolverItem> ParseRecipeItems(string itemRecipes)
            {
                var result = new List<CraftingSolverItem>();
                foreach (var item in itemRecipes.Split(','))
                {
                    var trimItem = item.Trim();
                    var itemName = trimItem.Split(' ')[0];
                    var itemId = new ItemId(GetItemId(itemName));
                    var quantity = int.Parse(trimItem.Split(' ')[1]);
                    
                    result.Add(new CraftingSolverItem(itemId, quantity));
                }
                return result;
            }
            
  #endregion
        }
        
        private int _nextItemId = 1;
        private Dictionary<string, int> _itemNameToId = new();
        
        private int GetItemId(string itemName)
        {
            // アイテム名をユニークなIDにマッピングするメソッド
            // ここでは簡単のために静的な辞書を使用
            if (!_itemNameToId.TryGetValue(itemName, out var itemId))
            {
                itemId = _nextItemId++;
                _itemNameToId[itemName] = itemId;
            }
            return itemId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/PowerGeneratorTest.cs
```cs
using System;
using System.Reflection;
using Core.Const;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.PowerGenerator;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class PowerGeneratorTest
    {
        private const int FuelItem1Id = 0;
        private const int FuelItem2Id = 1;
        
        [Test]
        public void UseFuelTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one);
            var powerGenerator = blockFactory.Create(ForUnitTestModBlockId.GeneratorId, new BlockInstanceId(10), posInfo);
            var generatorComponent = powerGenerator.GetComponent<VanillaElectricGeneratorComponent>();
            var generatorConfigParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GeneratorId).BlockParam as ElectricGeneratorBlockParam;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var fuelItem1 = itemStackFactory.Create(generatorConfigParam.FuelItems[FuelItem1Id].ItemGuid, 1);
            var fuelItem2 = itemStackFactory.Create(generatorConfigParam.FuelItems[FuelItem2Id].ItemGuid, 1);
            
            
            //燃料の燃焼時間ループする
            var endTime1 = DateTime.Now.AddSeconds(generatorConfigParam.FuelItems[FuelItem1Id].Time);
            
            //燃料を挿入
            generatorComponent.InsertItem(fuelItem1);
            
            //1回目のループ
            GameUpdater.UpdateWithWait();
            
            //供給電力の確認
            Assert.AreEqual(generatorConfigParam.FuelItems[FuelItem1Id].Power, generatorComponent.OutputEnergy().AsPrimitive());
            
            //燃料の枯渇までループ
            while (endTime1.AddSeconds(0.1).CompareTo(DateTime.Now) == 1)
            {
                GameUpdater.UpdateWithWait();
            }
            
            //燃料が枯渇しているか確認
            //リフレクションで現在の燃料を取得
            var fuelItemId = (ItemId)typeof(VanillaElectricGeneratorComponent).GetField("_currentFuelItemId",
                    BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(generatorComponent);
            Assert.AreEqual(ItemMaster.EmptyItemId, fuelItemId);
            
            //燃料を2個挿入
            generatorComponent.InsertItem(fuelItem1);
            generatorComponent.InsertItem(fuelItem2);
            
            //燃料の1個目の枯渇までループ
            endTime1 = DateTime.Now.AddSeconds(generatorConfigParam.FuelItems[FuelItem1Id].Time);
            while (endTime1.AddSeconds(0.3).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //2個の燃料が入っていることを確認
            fuelItemId = (ItemId)typeof(VanillaElectricGeneratorComponent).GetField("_currentFuelItemId",
                    BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(generatorComponent);
            var fuelItemId2 = MasterHolder.ItemMaster.GetItemId(generatorConfigParam.FuelItems[FuelItem2Id].ItemGuid);
            Assert.AreEqual(fuelItemId2, fuelItemId);
            
            //燃料の2個目の枯渇までループ
            var endTime2 = DateTime.Now.AddSeconds(generatorConfigParam.FuelItems[FuelItem2Id].Time);
            while (endTime2.AddSeconds(0.1).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //2個目の燃料が枯渇しているか確認
            fuelItemId = (ItemId)typeof(VanillaElectricGeneratorComponent).GetField("_currentFuelItemId",
                    BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(generatorComponent);
            Assert.AreEqual(ItemMaster.EmptyItemId, fuelItemId);
        }
        
        [Test]
        public void InfinityGeneratorTet()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one);
            var powerGenerator = blockFactory.Create(ForUnitTestModBlockId.InfinityGeneratorId, new BlockInstanceId(10), posInfo);
            var generatorComponent = powerGenerator.GetComponent<VanillaElectricGeneratorComponent>();
            
            var generatorConfigParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.InfinityGeneratorId).BlockParam as ElectricGeneratorBlockParam;
            
            //1回目のループ
            GameUpdater.UpdateWithWait();
            
            //供給電力の確認
            Assert.AreEqual(generatorConfigParam.InfinityPower, generatorComponent.OutputEnergy().AsPrimitive());
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/VanillaIBlockTemplates.cs
```cs
using System.Collections.Generic;
using Game.Block.Event;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface.Event;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Game.Block.Factory
{
    /// <summary>
    ///     バニラのブロックの全てのテンプレートを作るクラス
    /// </summary>
    public class VanillaIBlockTemplates
    {
        public readonly Dictionary<string, IBlockTemplate> BlockTypesDictionary;
        
        public VanillaIBlockTemplates(IBlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            var blockInventoryEvent = blockInventoryUpdateEvent as BlockOpenableInventoryUpdateEvent;
            
            //TODO 動的に構築するようにする
            BlockTypesDictionary = new Dictionary<string, IBlockTemplate>();
            BlockTypesDictionary.Add(BlockTypeConst.Block, new VanillaDefaultBlock());
            BlockTypesDictionary.Add(BlockTypeConst.BeltConveyor, new VanillaBeltConveyorTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.ElectricPole, new VanillaElectricPoleTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.Chest, new VanillaChestTemplate());
            
            BlockTypesDictionary.Add(BlockTypeConst.ElectricMachine, new VanillaMachineTemplate(blockInventoryEvent));
            BlockTypesDictionary.Add(BlockTypeConst.ElectricGenerator, new VanillaPowerGeneratorTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.ElectricMiner, new VanillaMinerTemplate(blockInventoryEvent));
            
            BlockTypesDictionary.Add(BlockTypeConst.ItemShooter, new VanillaItemShooterTemplate());
            
            BlockTypesDictionary.Add(BlockTypeConst.Gear, new VanillaGearTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.Shaft, new VanillaShaftTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.SimpleGearGenerator, new VanillaSimpleGearGeneratorTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.GearMiner, new VanillaGearMinerTemplate(blockInventoryEvent));
            BlockTypesDictionary.Add(BlockTypeConst.GearMachine, new VanillaGearMachineTemplate(blockInventoryEvent));
            BlockTypesDictionary.Add(BlockTypeConst.GearBeltConveyor, new VanillaGearBeltConveyorTemplate());
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/BlockPlaceToConnectionBlockTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    /// <summary>
    ///     ブロックが設置された時ブロック同士が接続するテスト
    /// </summary>
    public class BlockPlaceToConnectionBlockTest
    {
        /// <summary>
        ///     機械にベルトコンベアが自動でつながるかをテストする
        ///     機械にアイテムを入れる向きでベルトコンベアのテストを行う
        /// </summary>
        [Test]
        public void BeltConveyorConnectMachineTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            //北向きにベルトコンベアを設置した時、機械とつながるかをテスト
            BlockPlaceToGetMachineIdAndConnectorId(
                0, 10,
                0, 9, BlockDirection.North, blockFactory, world);
            
            //東向きにベルトコンベアを設置した時、機械とつながるかをテスト
            BlockPlaceToGetMachineIdAndConnectorId(
                10, 0,
                9, 0, BlockDirection.East, blockFactory, world);
            
            //南向きにベルトコンベアを設置した時、機械とつながるかをテスト
            BlockPlaceToGetMachineIdAndConnectorId(
                0, -10,
                0, -9, BlockDirection.South, blockFactory, world);
            
            //西向きにベルトコンベアを設置した時、機械とつながるかをテスト
            BlockPlaceToGetMachineIdAndConnectorId(
                -10, 0,
                -9, 0, BlockDirection.West, blockFactory, world);
        }
        
        private void BlockPlaceToGetMachineIdAndConnectorId(
            int machineX, int machineZ,
            int conveyorX, int conveyorZ,
            BlockDirection direction, IBlockFactory blockFactory, IWorldBlockDatastore world)
        {
            //機械の設置
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(machineX, 0, machineZ), direction, out var vanillaMachine);
            
            //ベルトコンベアの設置
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(conveyorX, 0, conveyorZ), direction, out var beltConveyor);
            
            //繋がっているコネクターを取得
            var connectedMachine = (VanillaMachineBlockInventoryComponent)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets.First().Key;
            
            //繋がっているかを検証
            var machineInventory = vanillaMachine.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            Assert.IsTrue(connectedMachine == machineInventory);
        }
        
        /// <summary>
        ///     機械がベルトコンベアに自動でつながるかをテストする
        ///     機械をあらかじめ設置しておき、後に機械からアイテムが出る方向でベルトコンベアをおく
        ///     ブロックが削除されたらつながるベルトコンベアが消えるので、それをテストする
        /// </summary>
        [Test]
        public void MachineConnectToBeltConveyorTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            //機械の設置
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var vanillaMachine);
            
            //機械から4方向にベルトコンベアが出るように配置
            var beltConveyorTransforms = new List<(Vector3Int, BlockDirection)>
            {
                (new Vector3Int(1, 0, 0), BlockDirection.North),
                (new Vector3Int(0, 0, 1), BlockDirection.East),
                (new Vector3Int(-1, 0, 0), BlockDirection.South),
                (new Vector3Int(0, 0, -1), BlockDirection.West),
            };
            foreach (var (position, direction) in beltConveyorTransforms) world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, position, direction, out _);
            
            //繋がっているコネクターを取得
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)vanillaMachine.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            Assert.AreEqual(4, connectInventory.Count);
            
            //ベルトコンベアを削除する
            world.RemoveBlock(new Vector3Int(1, 0, 0));
            world.RemoveBlock(new Vector3Int(-1, 0, 0));
            //接続しているコネクターが消えているか確認
            Assert.AreEqual(2, connectInventory.Count);
            world.RemoveBlock(new Vector3Int(0, 0, 1));
            world.RemoveBlock(new Vector3Int(0, 0, -1));
            
            //接続しているコネクターが消えているか確認
            Assert.AreEqual(0, connectInventory.Count);
        }
        
        
        /// <summary>
        ///     ベルトコンベアを設置した後チェストを設置する
        ///     ベルトコンベアのコネクターが正しく設定されているかをチェックする
        /// </summary>
        [Test]
        public void BeltConveyorToChestConnectTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            //チェストの設置
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 0), BlockDirection.North, out var vanillaChest);
            
            
            //北向きにベルトコンベアを設置してチェック
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(0, 0, -1), BlockDirection.North, vanillaChest);
            
            //東向きにベルトコンベアを設置してチェック
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(-1, 0, 0), BlockDirection.East, vanillaChest);
            
            //南向きにベルトコンベアを設置してチェック
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(0, 0, 1), BlockDirection.South, vanillaChest);
            
            //西向きにベルトコンベアを設置してチェック
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(1, 0, 0), BlockDirection.West, vanillaChest);
        }
        
        private void BeltConveyorPlaceAndCheckConnector(Vector3Int beltConveyorPos, BlockDirection direction, IBlock targetChest)
        {
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, beltConveyorPos, direction, out var northBeltConveyor);
            
            var connector = (VanillaChestComponent)northBeltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets.First().Key;
            
            Assert.AreEqual(targetChest.BlockInstanceId, connector.BlockInstanceId);
        }
        
        /// <summary>
        ///     接続できないブロック(機械とチェスト)同士が接続していないテスト
        /// </summary>
        [Test]
        public void NotConnectableBlockTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            
            //機械とチェストを設置
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var machine);
            world.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 1), BlockDirection.North, out var chest);
            
            //機械のコネクターを取得
            var machineConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)machine.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            //接続されていないことをチェック
            Assert.AreEqual(0, machineConnectInventory.Count);
            
            //チェストのコネクターを取得
            var chestConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)chest.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            //接続されていないことをチェック
            Assert.AreEqual(0, chestConnectInventory.Count);
        }
        
        
        /// <summary>
        ///     大きさが1x1x1以上のブロックで複数のコネクターがある場合、正しく接続されるかをテスト
        /// </summary>
        [Test]
        public void MultiBlockConnectTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            
            //ベルトコンベアを設置
            
            //接続するベルトコンベア
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(2, 0, 3), BlockDirection.North, out _);
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(2, 0, -1), BlockDirection.South, out _);
            
            //接続されないベルトコンベア
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(3, 0, 3), BlockDirection.North, out _);
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(1, 0, -1), BlockDirection.South, out _);
            
            //マルチブロックを設置
            world.TryAddBlock(ForUnitTestModBlockId.MultiBlockGeneratorId, new Vector3Int(0, 0), BlockDirection.North, out var multiBlock);
            
            // マルチブロックのコネクターを取得
            var connector = (Dictionary<IBlockInventory, ConnectedInfo>)multiBlock.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            // ベルトコンベアが正しく接続されているかをチェック
            Assert.AreEqual(2, connector.Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlaceSystem.cs
```cs
using System;
using System.Collections.Generic;
using ClassLibrary;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Player;
using Client.Game.InGame.SoundEffect;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Input;
using Core.Master;
using Game.Block.Interface;
using Game.PlayerInventory.Interface;
using Server.Protocol.PacketResponse;
using UnityEngine;
using UnityEngine.EventSystems;
using VContainer.Unity;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    /// <summary>
    ///     マウスで地面をクリックしたときに発生するイベント
    /// </summary>
    public class BlockPlaceSystem : IPostTickable
    {
        public static BlockPlaceSystem Instance;
        
        private const float PlaceableMaxDistance = 100f;
        private readonly IBlockPlacePreview _blockPlacePreview;
        private readonly HotBarView _hotBarView;
        private readonly ILocalPlayerInventory _localPlayerInventory;
        private readonly Camera _mainCamera;
        private readonly PlayerObjectController _playerObjectController;
        private readonly BlockPlacePointCalculator _blockPlacePointCalculator;
        
        private BlockDirection _currentBlockDirection = BlockDirection.North;
        private Vector3Int? _clickStartPosition;
        private int _clickStartHeightOffset;
        private int _baseHeight;
        private bool? _isStartZDirection;
        private List<PlaceInfo> _currentPlaceInfos = new();
        
        private bool _enableBlockPlace;
        
        private int _heightOffset;
        
        public BlockPlaceSystem(
            Camera mainCamera,
            HotBarView hotBarView,
            IBlockPlacePreview blockPlacePreview,
            ILocalPlayerInventory localPlayerInventory,
            BlockGameObjectDataStore blockGameObjectDataStore,
            PlayerObjectController playerObjectController
        )
        {
            Instance = this;
            _hotBarView = hotBarView;
            _mainCamera = mainCamera;
            _blockPlacePreview = blockPlacePreview;
            _localPlayerInventory = localPlayerInventory;
            _playerObjectController = playerObjectController;
            _blockPlacePointCalculator = new BlockPlacePointCalculator(blockGameObjectDataStore);
        }
        
        public static void SetEnableBlockPlace(bool enable)
        {
            if (Instance == null) return;
            
            Instance._enableBlockPlace = enable;
            
            if (enable)
            {
                Instance._clickStartHeightOffset = -1;
                Instance._baseHeight = Mathf.RoundToInt(Instance._playerObjectController.Position.y);
            }
            else
            {
                Instance._blockPlacePreview.SetActive(false);
            }
        }
        
        public void PostTick()
        {
            if (!_enableBlockPlace) return;
            
            UpdateHeightOffset();
            BlockDirectionControl();
            GroundClickControl();
            
            #region Internal
            
            void UpdateHeightOffset()
            {
                if (UnityEngine.Input.GetKeyDown(KeyCode.Q)) //TODO InputManagerに移す
                    _heightOffset--;
                else if (UnityEngine.Input.GetKeyDown(KeyCode.E)) _heightOffset++;
            }
            
            void BlockDirectionControl()
            {
                if (InputManager.Playable.BlockPlaceRotation.GetKeyDown)
                    // 東西南北の向きを変更する
                    _currentBlockDirection = _currentBlockDirection.HorizonRotation();
                
                //TODo シフトはインプットマネージャーに入れる
                if (UnityEngine.Input.GetKey(KeyCode.LeftShift) && InputManager.Playable.BlockPlaceRotation.GetKeyDown)
                    _currentBlockDirection = _currentBlockDirection.VerticalRotation();
            }
            
            #endregion
        }
        
        private int _lastSelectedIndex = -1;
        
        private void GroundClickControl()
        {
            var selectIndex = _hotBarView.SelectIndex;
            if (selectIndex != _lastSelectedIndex)
            {
                _clickStartPosition = null;
                _lastSelectedIndex = selectIndex;
                _clickStartHeightOffset = _heightOffset;
            }
            
            var itemId = _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(selectIndex)].Id;
            var hitPoint = Vector3.zero;
            
            //基本はプレビュー非表示
            _blockPlacePreview.SetActive(false);
            
            if (!MasterHolder.BlockMaster.IsBlock(itemId)) return; // 置けるブロックかどうか
            if (!TryGetRayHitPosition(out hitPoint, out var boundingBoxSurface)) return; // ブロック設置用のrayが当たっているか
            
            //設置座標計算 calculate place point
            var blockId = MasterHolder.BlockMaster.GetBlockId(itemId);
            var holdingBlockMaster = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            var placePoint = CalcPlacePoint();
            
            if (!IsBlockPlaceableDistance(PlaceableMaxDistance)) return; // 設置可能な距離かどうか
            
            _blockPlacePreview.SetActive(true);
            
            //クリックされてたらUIがゲームスクリーンの時にホットバーにあるブロックの設置
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && !EventSystem.current.IsPointerOverGameObject())
            {
                _clickStartPosition = placePoint;
                _clickStartHeightOffset = _heightOffset;
            }
            
            //プレビュー表示と地面との接触を取得する
            //display preview and get collision with ground
            var groundDetects = new List<bool>();
            if (_clickStartPosition.HasValue)
            {
                if (_clickStartPosition.Value == placePoint)
                {
                    _isStartZDirection = null;
                }
                else if (!_isStartZDirection.HasValue)
                {
                    _isStartZDirection = Mathf.Abs(placePoint.z - _clickStartPosition.Value.z) > Mathf.Abs(placePoint.x - _clickStartPosition.Value.x);
                }
                
                _currentPlaceInfos = _blockPlacePointCalculator.CalculatePoint(_clickStartPosition.Value, placePoint, _isStartZDirection ?? true, _currentBlockDirection, holdingBlockMaster);
                groundDetects = _blockPlacePreview.SetPreviewAndGroundDetect(_currentPlaceInfos, holdingBlockMaster);
            }
            else
            {
                _isStartZDirection = null;
                _currentPlaceInfos = _blockPlacePointCalculator.CalculatePoint(placePoint, placePoint, true, _currentBlockDirection, holdingBlockMaster);
                groundDetects = _blockPlacePreview.SetPreviewAndGroundDetect(_currentPlaceInfos, holdingBlockMaster);
            }
            
            // Placeableの更新
            // update placeable
            for (var i = 0; i < groundDetects.Count; i++)
            {
                // 地面と接触していたら設置不可
                // if collision with ground, cannot place
                if (groundDetects[i])
                {
                    _currentPlaceInfos[i].Placeable = false;
                }
            }
            
            // 設置するブロックをサーバーに送信
            // send block place info to server
            if (InputManager.Playable.ScreenLeftClick.GetKeyUp)
            {
                _heightOffset = _clickStartHeightOffset;
                _clickStartPosition = null;
                ClientContext.VanillaApi.SendOnly.PlaceHotBarBlock(_currentPlaceInfos, selectIndex);
                SoundEffectManager.Instance.PlaySoundEffect(SoundEffectType.PlaceBlock);
            }
            
            #region Internal
            
            bool IsBlockPlaceableDistance(float maxDistance)
            {
                var placePosition = (Vector3)placePoint;
                var playerPosition = _playerObjectController.transform.position;
                
                return Vector3.Distance(playerPosition, placePosition) <= maxDistance;
            }
            
            Vector3Int CalcPlacePoint()
            {
                var rotateAction = _currentBlockDirection.GetCoordinateConvertAction();
                var rotatedSize = rotateAction(holdingBlockMaster.BlockSize).Abs();
                
                if (boundingBoxSurface == null)
                {
                    var point = Vector3Int.zero;
                    point.x = Mathf.FloorToInt(hitPoint.x + (rotatedSize.x % 2 == 0 ? 0.5f : 0));
                    point.z = Mathf.FloorToInt(hitPoint.z + (rotatedSize.z % 2 == 0 ? 0.5f : 0));
                    point.y = Mathf.FloorToInt(hitPoint.y);
                    
                    point += new Vector3Int(0, _heightOffset, 0);
                    point -= new Vector3Int(rotatedSize.x, 0, rotatedSize.z) / 2;
                    
                    return point;
                }
                
                switch (boundingBoxSurface.PreviewSurfaceType)
                {
                    case PreviewSurfaceType.YX_Origin:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z) - Mathf.RoundToInt(rotatedSize.z / 2f)
                        );
                    case PreviewSurfaceType.YX_Z:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z) + Mathf.RoundToInt(rotatedSize.z / 2f)
                        );
                    case PreviewSurfaceType.YZ_Origin:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x) - Mathf.RoundToInt(rotatedSize.x / 2f),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z)
                        );
                    case PreviewSurfaceType.YZ_X:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x) + Mathf.RoundToInt(rotatedSize.x / 2f),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z)
                        );
                    
                    case PreviewSurfaceType.XZ_Origin:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x),
                            Mathf.FloorToInt(hitPoint.y) - rotatedSize.y,
                            Mathf.FloorToInt(hitPoint.z)
                        );
                    case PreviewSurfaceType.XZ_Y:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z)
                        );
                    
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
            
            #endregion
        }
        
        
        private bool TryGetRayHitPosition(out Vector3 pos,out BlockPreviewBoundingBoxSurface surface)
        {
            surface = null;
            pos = Vector3Int.zero;
            var ray = _mainCamera.ScreenPointToRay(UnityEngine.Input.mousePosition);
            
            //画面からのrayが何かにヒットしているか
            if (!Physics.Raycast(ray, out var hit, float.PositiveInfinity, LayerConst.Without_Player_MapObject_Block_LayerMask)) return false;
            //そのrayが地面のオブジェクトかブロックのバウンディングボックスにヒットしてるか
            if (
                !hit.transform.TryGetComponent<GroundGameObject>(out _) &&
                !hit.transform.TryGetComponent(out surface)
            )
            {
                return false;
            }
            
            //基本的にブロックの原点は0,0なので、rayがヒットした座標を基準にブロックの原点を計算する
            pos = hit.point;
            
            return true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaMachineProcessorComponent.cs
```cs
using System;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Blocks.Util;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.EnergySystem;
using MessagePack;
using Mooresmaster.Model.MachineRecipesModule;
using UniRx;

namespace Game.Block.Blocks.Machine
{
    public class VanillaMachineProcessorComponent : IBlockStateObservable, IUpdatableBlockComponent
    {
        public ProcessState CurrentState { get; private set; } = ProcessState.Idle;
        
        public double RemainingSecond { get; private set; }
        
        public Guid RecipeGuid => _processingRecipe?.MachineRecipeGuid ?? Guid.Empty;
        public IObservable<Unit> OnChangeBlockState => _changeState;
        private readonly Subject<Unit> _changeState = new();
        
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        
        public readonly ElectricPower RequestPower;
        
        private ElectricPower _currentPower;
        private ProcessState _lastState = ProcessState.Idle;
        private MachineRecipeMasterElement _processingRecipe;
        
        
        public VanillaMachineProcessorComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            MachineRecipeMasterElement machineRecipe, ElectricPower requestPower)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            _processingRecipe = machineRecipe;
            RequestPower = requestPower;
            
            //TODO コンポーネント化する
        }
        
        public VanillaMachineProcessorComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            ProcessState currentState, double remainingSecond, MachineRecipeMasterElement processingRecipe,
            ElectricPower requestPower)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            
            _processingRecipe = processingRecipe;
            RequestPower = requestPower;
            RemainingSecond = remainingSecond;
            
            CurrentState = currentState;
        }
        
        
        public BlockStateDetail GetBlockStateDetail()
        {
            BlockException.CheckDestroy(this);
            
            var processingRate = _processingRecipe != null ? 1 - (float)RemainingSecond / _processingRecipe.Time : 0;
            var stateDetail = new CommonMachineBlockStateDetail(_currentPower.AsPrimitive(), RequestPower.AsPrimitive(), processingRate, CurrentState.ToStr(), _lastState.ToStr());
            var currentState = MessagePackSerializer.Serialize(stateDetail);
            return new BlockStateDetail(CommonMachineBlockStateDetail.BlockStateDetailKey, currentState);
        }
        
        public void SupplyPower(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            _currentPower = power;
        }
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            switch (CurrentState)
            {
                case ProcessState.Idle:
                    Idle();
                    break;
                case ProcessState.Processing:
                    Processing();
                    break;
            }
            
            //ステートの変化を検知した時か、ステートが処理中の時はイベントを発火させる
            if (_lastState != CurrentState || CurrentState == ProcessState.Processing)
            {
                _changeState.OnNext(Unit.Default);
                _lastState = CurrentState;
            }
        }
        
        private void Idle()
        {
            var isGetRecipe = _vanillaMachineInputInventory.TryGetRecipeElement(out var recipe);
            var isStartProcess = CurrentState == ProcessState.Idle && isGetRecipe &&
                   _vanillaMachineInputInventory.IsAllowedToStartProcess() &&
                   _vanillaMachineOutputInventory.IsAllowedToOutputItem(recipe);
            
            if (isStartProcess)
            {
                CurrentState = ProcessState.Processing;
                _processingRecipe = recipe;
                _vanillaMachineInputInventory.ReduceInputSlot(_processingRecipe);
                RemainingSecond = _processingRecipe.Time;
            }
        }
        
        private void Processing()
        {
            RemainingSecond -= MachineCurrentPowerToSubSecond.GetSubSecond(_currentPower, RequestPower);
            if (RemainingSecond <= 0)
            {
                CurrentState = ProcessState.Idle;
                _vanillaMachineOutputInventory.InsertOutputSlot(_processingRecipe);
            }
            
            //電力を消費する
            _currentPower = new ElectricPower(0);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
    
    public static class ProcessStateExtension
    {
        /// <summary>
        ///     <see cref="ProcessState" />をStringに変換します。
        ///     EnumのToStringを使わない理由はアロケーションによる速度低下をなくすためです。
        /// </summary>
        public static string ToStr(this ProcessState state)
        {
            return state switch
            {
                ProcessState.Idle => VanillaMachineBlockStateConst.IdleState,
                ProcessState.Processing => VanillaMachineBlockStateConst.ProcessingState,
                _ => throw new ArgumentOutOfRangeException(nameof(state), state, null),
            };
        }
    }
    
    public enum ProcessState
    {
        Idle,
        Processing,
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/EnergySegment.cs
```cs
using System.Collections.Generic;
using Core.Update;
using Game.Block.Interface;
using UniRx;

namespace Game.EnergySystem
{
    /// <summary>
    ///     そのエネルギーの供給、配分を行うシステム
    /// </summary>
    public class EnergySegment
    {
        private readonly Dictionary<BlockInstanceId, IElectricConsumer> _consumers = new();
        private readonly Dictionary<BlockInstanceId, IElectricTransformer> _energyTransformers = new();
        private readonly Dictionary<BlockInstanceId, IElectricGenerator> _generators = new();
        
        public EnergySegment()
        {
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        public IReadOnlyDictionary<BlockInstanceId, IElectricConsumer> Consumers => _consumers;
        
        public IReadOnlyDictionary<BlockInstanceId, IElectricGenerator> Generators => _generators;
        
        public IReadOnlyDictionary<BlockInstanceId, IElectricTransformer> EnergyTransformers => _energyTransformers;
        
        private void Update()
        {
            //供給されてる合計エネルギー量の算出
            var powers = new ElectricPower(0);
            foreach (var key in _generators.Keys) powers += _generators[key].OutputEnergy();
            
            //エネルギーの需要量の算出
            var requester = new ElectricPower(0);
            foreach (var key in _consumers.Keys) requester += _consumers[key].RequestEnergy;
            
            //エネルギー供給の割合の算出
            var powerRate = powers / requester;
            if (1 < powerRate.AsPrimitive()) powerRate = new ElectricPower(1);
            
            //エネルギーを供給
            foreach (var key in _consumers.Keys)
                _consumers[key].SupplyEnergy(_consumers[key].RequestEnergy * powerRate);
        }
        
        public void AddEnergyConsumer(IElectricConsumer electricConsumer)
        {
            if (_consumers.ContainsKey(electricConsumer.BlockInstanceId)) return;
            _consumers.Add(electricConsumer.BlockInstanceId, electricConsumer);
        }
        
        public void RemoveEnergyConsumer(IElectricConsumer electricConsumer)
        {
            if (!_consumers.ContainsKey(electricConsumer.BlockInstanceId)) return;
            _consumers.Remove(electricConsumer.BlockInstanceId);
        }
        
        public void AddGenerator(IElectricGenerator generator)
        {
            if (_generators.ContainsKey(generator.BlockInstanceId)) return;
            _generators.Add(generator.BlockInstanceId, generator);
        }
        
        public void RemoveGenerator(IElectricGenerator generator)
        {
            if (!_generators.ContainsKey(generator.BlockInstanceId)) return;
            _generators.Remove(generator.BlockInstanceId);
        }
        
        public void AddEnergyTransformer(IElectricTransformer electricTransformer)
        {
            if (_energyTransformers.ContainsKey(electricTransformer.BlockInstanceId)) return;
            _energyTransformers.Add(electricTransformer.BlockInstanceId, electricTransformer);
        }
        
        public void RemoveEnergyTransformer(IElectricTransformer electricTransformer)
        {
            if (!_energyTransformers.ContainsKey(electricTransformer.BlockInstanceId)) return;
            _energyTransformers.Remove(electricTransformer.BlockInstanceId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Template/CraftChainerTransporterTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.CraftChainer.BlockComponent.Template
{
    public class CraftChainerTransporterTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var transporterParam = blockMasterElement.BlockParam as CraftChainerTransporterBlockParam;
            
            var transporterComponent = componentStates == null ?
                new CraftChainerTransporterComponent() :
                new CraftChainerTransporterComponent(componentStates);
            
            var slopeType = transporterParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            var connectorComponent = BlockTemplateUtil.CreateInventoryConnector(transporterParam.InventoryConnectors, blockPositionInfo);
            var beltConveyorConnector = new CraftChainerTransporterInserter(connectorComponent, transporterComponent.NodeId);
            var itemCount = transporterParam.TransporterConveyorItemCount;
            var time = transporterParam.TimeOfItemEnterToExit;
            
            var beltComponent = componentStates == null ?
                new VanillaBeltConveyorComponent(itemCount, time, beltConveyorConnector, slopeType) :
                new VanillaBeltConveyorComponent(componentStates, itemCount, time, beltConveyorConnector, slopeType);
            
            var components = new List<IBlockComponent>
            {
                beltComponent,
                connectorComponent,
                transporterComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/Generate/GeneratedJson.cs
```cs
using System.IO;
using System.Runtime.Serialization.Json;
using NUnit.Framework;
using UnityEngine;

namespace Tests.CombinedTest.Core.Generate
{
    /// <summary>
    ///     レシピファイル生成をする
    /// </summary>
    public class GeneratedJson
    {
        [Test]
        public void Json()
        {
            var seed = 2119350917;
            var recipeNum = 40;
            var recipe = RecipeGenerate.MakeRecipe(seed, recipeNum);
            
            // データをJSON形式にシリアル化して、メモリーストリームに出力する。
            var st = new MemoryStream(); // メモリーストリームを作成
            var serializer = new DataContractJsonSerializer(typeof(Recipe)); // シリアライザーを作成
            serializer.WriteObject(st, recipe); // シリアライザーで出力
            
            // メモリーストリームの内容をコンソールに出力する。
            st.Position = 0;
            var reader = new StreamReader(st);
            Debug.Log(reader.ReadToEnd());
            
            
            Assert.True(true);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/MachineRecipeMaster.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.MachineRecipesModule;

namespace Core.Master
{
    public static class MachineRecipeMasterUtil
    {
        public static bool TryGetRecipeElement(BlockId blockId, IReadOnlyList<IItemStack> inputSlot,out MachineRecipeMasterElement recipe)
        {
            var itemIds = new List<ItemId>(inputSlot.Count);
            foreach (var inputItem in inputSlot)
            {
                if (inputItem.Id == ItemMaster.EmptyItemId) continue;
                itemIds.Add(inputItem.Id);
            }
            
            return MasterHolder.MachineRecipesMaster.TryGetRecipeElement(blockId, itemIds, out recipe);
        }
        
        public static bool RecipeConfirmation(this MachineRecipeMasterElement recipe, BlockId blockId, IReadOnlyList<IItemStack> inputSlot)
        {
            var recipeBlockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            if (recipeBlockId != blockId) return false;
            
            // アイテムが十分な数満たされている数が、必要とする数と一致するか
            var okCnt = 0;
            foreach (var slot in inputSlot)
            {
                if (slot.Id == ItemMaster.EmptyItemId )
                { 
                  continue;  
                }
                var slotGuid = MasterHolder.ItemMaster.GetItemMaster(slot.Id).ItemGuid;
                okCnt += recipe.InputItems.Count(input => slotGuid == input.ItemGuid && input.Count <= slot.Count);
            }
            
            return okCnt == recipe.InputItems.Length;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/CraftChainerTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.CraftChainer.BlockComponent;
using Game.CraftChainer.BlockComponent.Computer;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Tests.Module.TestMod.ForUnitTestModBlockId;

namespace Tests.CombinedTest.Game
{
    public class CraftChainerTest
    {
        public ItemId ItemAId;
        public ItemId ItemBId;
        public ItemId ItemCId;
        
        [SetUp]
        public void SetupCraftChainerTest()
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            Guid itemAGuid = new("189672cb-6811-4080-bde1-1f9ff0ec63ff");
            Guid itemBGuid = new("547791fe-bfd8-4748-aafa-c7449391eca5");
            Guid itemCGuid = new("c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627");
            ItemAId = MasterHolder.ItemMaster.GetItemId(itemAGuid);
            ItemBId = MasterHolder.ItemMaster.GetItemId(itemBGuid);
            ItemCId = MasterHolder.ItemMaster.GetItemId(itemCGuid);
        }
        
        [Test]
        public void CreateItemA1ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 5),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 1, true);
        }
        
        [Test]
        public void CreateItemA2ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 10),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 2, true);
        }
        
        [Test]
        public void CreateItemA3ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 15),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 3, true);
        }
        
        [Test]
        public void CreateItemBTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 2),
            };
            ExecuteChainerCraftTest(chestItems, ItemBId, 1, true);
        }
        
        [Test]
        public void NoneItemFailCraftTest()
        {
            ExecuteChainerCraftTest(new List<(ItemId id,int count)>(), ItemAId, 1, false);
        }
        
        [Test]
        public void OneItemIsNotEnoughFailCraftTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 4),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 1, false);
        }
        
        public void ExecuteChainerCraftTest(List<(ItemId id,int count)> materials, ItemId targetId, int targetCount, bool isSuccess)
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            // ネットワークの作成
            // Create a network
            var network = CreateNetwork();
            
            // 供給チェストにアイテム設定
            // Set items in the provider chest
            var materialItemStacks = new List<IItemStack>();
            foreach (var (id, count) in materials)
            {
                var item = ServerContext.ItemStackFactory.Create(id, count);
                materialItemStacks.Add(item);
            }
            network.SetProviderChestItem(materialItemStacks);
            
            // メインコンピュータにアイテム作成リクエスト
            // Item creation request to the main computer
            var success = network.SetRequestMainComputer(targetId, targetCount);
            Assert.AreEqual(isSuccess, success);
            
            // 失敗が正しい場合はテストを終了
            if (!isSuccess)
            {
                return;
            }
            
            // 10秒たってもクラフトされない場合は失敗
            // Fail if not crafted after 10 seconds
            var now = DateTime.Now;
            
            while (true)
            {
                try
                {
                    GameUpdater.UpdateWithWait();
                }
                catch (Exception e)
                {
                    ExportItemLog();
                    Debug.LogException(e);
                    throw;
                }
                
                if (network.OnMainComputerItemExist(targetId, targetCount))
                {
                    Debug.Log("Success Time:" + (DateTime.Now - now).TotalSeconds);
                    Assert.Pass();
                    break;
                }
                
                if (DateTime.Now - now > TimeSpan.FromSeconds(10))
                {
                    ExportItemLog();
                    var block = ServerContext.WorldBlockDatastore.GetBlock(new Vector3Int(2, 0, 1));
                    Assert.Fail("Failed to create item");
                }
            }
        }
        
        
        private void ExportItemLog()
        {
            foreach (var blocks in ServerContext.WorldBlockDatastore.BlockMasterDictionary.Values)
            {
                if (!blocks.Block.ComponentManager.TryGetComponent<IBlockInventory>(out var blockComponent))
                {
                    continue;
                }
                
                var slotSize = blockComponent.GetSlotSize();
                for (int i = 0; i < slotSize; i++)
                {
                    var item = blockComponent.GetItem(i);
                    if (item.Id == ItemMaster.EmptyItemId)
                    {
                        continue;
                    }
                    
                    var pos = blocks.BlockPositionInfo.OriginalPos;
                    var type = blocks.Block.BlockMasterElement.BlockType;
                    var itemName = MasterHolder.ItemMaster.GetItemMaster(item.Id).Name;
                    Debug.Log($"Type:{type} {pos} Slot:{i}, ItemName: \"{itemName}\" Count: {item.Count}");
                }
            }
        }
        
        private CraftChainerTestNetworkContainer CreateNetwork()
        {
            //イメージ図
            // Image diagram
            // https://miro.com/app/board/uXjVOPclBmk=/?moveToWidget=3458764607209547942&cot=10

            // クラフトチェイナーの部分
            // Parts of the craft chainer
            AddBlock(CraftChainerTransporter, 1, 0, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 0, 1, BlockDirection.South);
            AddBlock(CraftChainerTransporter, 1, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 2, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 3, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 3, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 4, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 4, 0, BlockDirection.South);
            AddBlock(CraftChainerTransporter, 4, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 3, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 2, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 1, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 0, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, -1, -1, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 0, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 1, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 2, BlockDirection.East);
            var providerChest = AddBlock(CraftChainerProviderChest, 0, 2, BlockDirection.North);
            var crafter1 = AddBlock(CraftChainerCrafter, 2, 2, BlockDirection.North); // C -> B
            var crafter2 = AddBlock(CraftChainerCrafter, 4, 2, BlockDirection.North); // B + C -> A
            var mainComputer = AddBlock(CraftChainerMainComputer, 0, 0, BlockDirection.North);
            
            // 工場の部分
            // Parts of the factory
            AddBlock(CraftChainerBeltConveyor, 2, 3, BlockDirection.North);
            AddBlock(CraftChainerBeltConveyor, 4, 3, BlockDirection.North);
            
            AddBlock(CraftChainerBeltConveyor, 0, 5, BlockDirection.South);
            AddBlock(CraftChainerBeltConveyor, 1, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 2, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 3, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 4, 5, BlockDirection.West);
            
            AddBlock(CraftChainerBeltConveyor, 0, 4, BlockDirection.South);
            AddBlock(CraftChainerBeltConveyor, 0, 3, BlockDirection.South);
            AddBlock(CraftChainerMachine1, 2, 4, BlockDirection.North); // C -> B
            AddBlock(CraftChainerMachine2, 4, 4, BlockDirection.North); // B + C -> A
            
            var container = new CraftChainerTestNetworkContainer(mainComputer, crafter1, crafter2, providerChest);
            
            // レシピの設定
            // Recipe setting
            var inputItem1 = new List<CraftingSolverItem>
            {
                new(ItemCId, 2),
            };
            var outputItem1 = new List<CraftingSolverItem>
            {
                new(ItemBId, 1),
            };
            container.SetCrafter1Recipe(inputItem1, outputItem1);
            
            var inputItem2 = new List<CraftingSolverItem>
            {
                new(ItemBId, 2),
                new(ItemCId, 1),
            };
            var outputItem2 = new List<CraftingSolverItem>
            {
                new(ItemAId, 1),
            };
            container.SetCrafter2Recipe(inputItem2, outputItem2);
            
            // assert chain network
            var computerComputer = mainComputer.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
            Assert.AreEqual(computerComputer.CraftChainerNetworkContext.CrafterComponents.Count, 2);
            Assert.AreEqual(computerComputer.CraftChainerNetworkContext.ProviderChests.Count, 1);
            
            
            return container;
        }
        
        private IBlock AddBlock(BlockId blockId, int x, int z, BlockDirection direction)
        {
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            worldBlockDatastore.TryAddBlock(blockId, new Vector3Int(x, 0, z), direction, out var block);
            
            return block;
        }
        
        public class CraftChainerTestNetworkContainer
        {
            public readonly IBlock MainComputer;
            public readonly IBlock Crafter1;
            public readonly IBlock Crafter2;
            public readonly IBlock ProviderChest;
            public CraftChainerTestNetworkContainer(IBlock mainComputer, IBlock crafter1, IBlock crafter2, IBlock providerChest)
            {
                MainComputer = mainComputer;
                Crafter1 = crafter1;
                Crafter2 = crafter2;
                ProviderChest = providerChest;
            }
            
            public void SetCrafter1Recipe(List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                SetCrafterRecipe(Crafter1, inputItems, outputItem);
            }
            public void SetCrafter2Recipe(List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                SetCrafterRecipe(Crafter2, inputItems, outputItem);
            }
            
            private void SetCrafterRecipe(IBlock crafter, List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                var crafterComponent = crafter.ComponentManager.GetComponent<CraftCraftChainerCrafterComponent>();
                crafterComponent.SetRecipe(inputItems, outputItem);
            }
            
            public void SetProviderChestItem(List<IItemStack> items)
            {
                var chestComponent = ProviderChest.ComponentManager.GetComponent<VanillaChestComponent>();
                chestComponent.InsertItem(items);
            }
            
            public bool SetRequestMainComputer(ItemId item, int count)
            {
                var mainComputerComponent = MainComputer.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
                return mainComputerComponent.StartCreateItem(item, count);
            }
            
            public bool OnMainComputerItemExist(ItemId targetItem, int count)
            {
                var chest = MainComputer.ComponentManager.GetComponent<VanillaChestComponent>();
                
                var existCount = 0;
                foreach (var item in chest.InventoryItems)
                {
                    if (item.Id == targetItem)
                    {
                        existCount += item.Count;
                    }
                }
                
                return existCount >= count;
            }
        }
    }
    
}
```

moorestech_server/Assets/Scripts/Game.Train/Blocks/StationComponent.cs
```cs
using Game.Block.Interface.Component;
using Game.Train.Train;
namespace Game.Train.Blocks
{
    public class StationComponent : IBlockComponent
    {
        public string StationName { get; }

        // 駅の長さ（何両分か）
        private int _stationLength;

        // 現在使用中の列車単位
        private TrainUnit _currentTrain;

        // IBlockComponentからのメンバ
        public bool IsDestroy { get; private set; }

        public StationComponent(int stationLength, string stationName = "DefaultStation")
        {
            _stationLength = stationLength;
            _currentTrain = null;
            IsDestroy = false;
            StationName = stationName;
        }


        // 列車が駅に到着したときの処理
        public bool TrainArrived(TrainUnit train)
        {
            // すでに列車がいる場合は何もしない
            if (_currentTrain != null)
            {
                return false;
            }

            // 列車が駅に入る
            _currentTrain = train;
            return true;
        }

        // 列車が駅から出発したときの処理
        public bool TrainDeparted(TrainUnit train)
        {
            // 列車がいない場合は何もしない
            if (_currentTrain == null)
            {
                return false;
            }

            // 列車が駅から出る
            _currentTrain = null;
            return true;
        }


        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Transporter/CraftChainerTransporterInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent
{
    /// <summary>
    /// そのアイテムがどのクラフトノードに挿入されるべきかを判断し、挿入するためのクラス
    /// Class for determining which craft node the item should be inserted into and inserting it
    /// </summary>
    public class CraftChainerTransporterInserter : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        private readonly CraftChainerNodeId _startChainerNodeId;
        
        public CraftChainerTransporterInserter(BlockConnectorComponent<IBlockInventory> blockConnectorComponent, CraftChainerNodeId startChainerNodeId)
        {
            _blockConnectorComponent = blockConnectorComponent;
            _startChainerNodeId = startChainerNodeId;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var context = CraftChainerMainComputerManager.Instance.GetChainerNetworkContext(_startChainerNodeId);
            if (context == null)
            {
                return itemStack;
            }
            
            // transporterの場合は既に1個になっているアイテムを挿入する想定
            // In the case of a transporter, it is assumed that the item has already been reduced to one
            return context.InsertNodeNetworkNextBlock(itemStack, _startChainerNodeId, _blockConnectorComponent);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Define/ItemObjectContainer.cs
```cs
using System;
using Client.Common;
using Core.Const;
using Core.Master;
using UnityEngine;

namespace Client.Game.InGame.Define
{
    /// <summary>
    ///     TODO このコードはalpha2.0以降で消す
    /// </summary>
    [Obsolete("Alpha2.0用のコンテナ")]
    [CreateAssetMenu(fileName = "ItemObjectContainer", menuName = "moorestech/ItemObjectContainer", order = 0)]
    public class ItemObjectContainer : ScriptableObject
    {
        [SerializeField] private ItemObjectData[] itemObjects;
        
        public ItemObjectData GetItemPrefab(ItemId itemId)
        {
            var itemGuid = MasterHolder.ItemMaster.GetItemMaster(itemId).ItemGuid;
            foreach (var itemObject in itemObjects)
            {
                if (itemObject.ItemGuid == itemGuid)
                {
                    return itemObject;
                }
            }
            
            return null;
        }
    }
    
    [Serializable]
    public class ItemObjectData
    {
        public Guid ItemGuid => Guid.Parse(itemGuid);
        public GameObject ItemPrefab => itemPrefab;
        public Vector3 Position => position;
        public Vector3 Rotation => rotation;
        
        [SerializeField] private string itemGuid;
        [SerializeField] private GameObject itemPrefab;
        [SerializeField] private Vector3 position;
        [SerializeField] private Vector3 rotation;
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/Generate/RecipeGenerate.cs
```cs
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Tests.CombinedTest.Core.Generate
{
    public static class RecipeGenerate
    {
        public static Recipe MakeRecipe(int seed, int recipeNum)
        {
            var random = new Random(seed);
            var recipes = new List<Recipes>();
            for (var i = 0; i < recipeNum; i++) recipes.Add(new Recipes(random));
            
            return new Recipe(recipes.ToArray());
        }
    }
    
    [DataContract]
    public class Recipe
    {
        [DataMember(Name = "recipes")] public Recipes[] Recipes;
        
        public Recipe(Recipes[] recipes)
        {
            Recipes = recipes;
        }
    }
    
    [DataContract]
    public class Recipes
    {
        [DataMember(Name = "BlockID")] public int BlockID;
        [DataMember(Name = "input")] public InputItem[] Input;
        [DataMember(Name = "output")] public OutputItem[] Output;
        [DataMember(Name = "time")] public int Time;
        
        public Recipes(Random r)
        {
            var inputNumber = r.Next(1, 11);
            var tmpInput = new List<InputItem>();
            for (var i = 0; i < inputNumber; i++)
            {
                //IDが重複するときはIDを変更
                int id;
                do
                {
                    id = r.Next(1, 1001);
                }
                while (tmpInput.Find(x => x.ID == id) != null);
                
                tmpInput.Add(new InputItem(id, r.Next(1, 101)));
            }
            
            Input = tmpInput.ToArray();
            
            
            var outputnum = r.Next(1, 11);
            var tmpOutput = new List<OutputItem>();
            for (var i = 0; i < outputnum; i++)
            {
                //IDが重複するときはIDを変更
                var id = r.Next(1, 1001);
                while (tmpOutput.Find(x => x.ID == id) != null) id = r.Next(1, 1001);
                
                tmpOutput.Add(new OutputItem(id, r.Next(1, 101), 1));
            }
            
            Output = tmpOutput.ToArray();
            
            
            BlockID = r.Next(0, 101);
            Time = r.Next(1, 4) * 1000;
        }
    }
    
    [DataContract]
    public class InputItem
    {
        [DataMember(Name = "count")] public int Count;
        [DataMember(Name = "id")] public int ID;
        
        public InputItem(int id, int count)
        {
            ID = id;
            Count = count;
        }
    }
    
    [DataContract]
    public class OutputItem
    {
        [DataMember(Name = "count")] public int Count;
        [DataMember(Name = "id")] public int ID;
        [DataMember(Name = "percent")] public double Percent;
        
        public OutputItem(int id, int count, double percent)
        {
            ID = id;
            Count = count;
            Percent = percent;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BlockSystem.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Core.Update;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.Block.Blocks
{
    public class BlockSystem : IBlock
    {
        public BlockInstanceId BlockInstanceId { get; }
        public BlockId BlockId { get; }
        public Guid BlockGuid => BlockMasterElement.BlockGuid;
        public BlockMasterElement BlockMasterElement { get; }
        public IBlockComponentManager ComponentManager => _blockComponentManager;
        private readonly BlockComponentManager _blockComponentManager = new();
        public BlockPositionInfo BlockPositionInfo { get; }
        public IObservable<BlockState> BlockStateChange => _onBlockStateChange;
        private readonly Subject<BlockState> _onBlockStateChange = new();
        
        
        
        private readonly IDisposable _blockUpdateDisposable;
        
        private readonly List<IUpdatableBlockComponent> _updatableComponents;
        private readonly List<IBlockStateDetail> _blockStateDetails;
        
        
        public BlockSystem(BlockInstanceId blockInstanceId, Guid blockGuid, List<IBlockComponent> blockComponents, BlockPositionInfo blockPositionInfo)
        {
            BlockInstanceId = blockInstanceId;
            BlockPositionInfo = blockPositionInfo;
            BlockId = MasterHolder.BlockMaster.GetBlockId(blockGuid);
            BlockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(BlockId);
            
            _blockComponentManager = new BlockComponentManager();
            _blockComponentManager.AddComponents(blockComponents);
            
            // 各コンポーネントのステートの変化を検知
            foreach (var blockState in _blockComponentManager.GetComponents<IBlockStateObservable>())
            {
                blockState.OnChangeBlockState.Subscribe(_ => { _onBlockStateChange.OnNext(GetBlockState()); });
            }
            
            // NOTE 他の場所からコンポーネントを追加するようになったら、このリストに追加するようにする
            _updatableComponents = _blockComponentManager.GetComponents<IUpdatableBlockComponent>();
            _blockStateDetails = _blockComponentManager.GetComponents<IBlockStateDetail>();
            
            _blockUpdateDisposable = GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        public BlockState GetBlockState()
        {
            var detailStates = new Dictionary<string, byte[]>();
            foreach (var component in _blockStateDetails)
            {
                var detailState = component.GetBlockStateDetail();
                detailStates.Add(detailState.Key, detailState.Value);
            }
            
            return new BlockState(detailStates);
        }
        
        public Dictionary<string,string> GetSaveState()
        {
            var result = new Dictionary<string, string>();
            
            var components = _blockComponentManager.GetComponents<IBlockSaveState>();
            foreach (var component in components)
            {
                var key = component.SaveKey;
                var value = component.GetSaveState();
                
                result.Add(key, value);
            }
            
            return result;
        }
        
        private void Update()
        {
            foreach (var component in _updatableComponents)
            {
                component.Update();
            }
        }
        
        public void Destroy()
        {
            _blockUpdateDisposable.Dispose();
            
            try
            {
                _blockComponentManager.Destroy();
            }
            catch (Exception e)
            {
                Debug.LogError("ブロックの破壊に失敗しました。");
                Debug.LogException(e);
                throw;
            }
        }
        
        public bool Equals(IBlock other)
        {
            if (other is null) return false;
            return BlockInstanceId == other.BlockInstanceId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/MachineRecipeConfigTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Block
{
    public class MachineRecipeConfigTest
    {
        /// <summary>
        ///     レシピがある時のテスト
        /// </summary>
        [TestCase(1, new int[2] { 1, 2 }, 3, 1)]
        [TestCase(1, new int[2] { 2, 1 }, 3, 1)]
        [TestCase(3, new int[3] { 1, 2, 3 }, 5, 1)]
        [TestCase(3, new int[3] { 2, 1, 3 }, 5, 1)]
        public void RecipeInputItemBlockIdTest(int BlocksId, int[] items, int output0Id, double output0Percent)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var input = new List<IItemStack>();
            items.ToList().ForEach(i => input.Add(itemStackFactory.Create(new ItemId(i), 1)));
            
            MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)BlocksId, input, out var ans);
            
            Assert.AreEqual(output0Id, MasterHolder.ItemMaster.GetItemId(ans.OutputItems[0].ItemGuid).AsPrimitive());
            Assert.AreEqual(output0Percent, ans.OutputItems[0].Percent);
        }
        
        [TestCase(3, new int[4] { 2, 1, 0, 5 }, 0)] //レシピが存在しない時のテスト
        [TestCase(0, new int[3] { 2, 1, 0 }, 0)] // not exist test
        [TestCase(3, new int[3] { 4, 1, 0 }, 0)]
        [TestCase(10, new int[1] { 2 }, 0)]
        [TestCase(0, new int[0], 0)]
        [TestCase(1, new int[2] { 2, 1 }, 1)] //存在するときのテストケース exist test
        public void NullRecipeTest(int BlocksId, int[] items, int outputLength)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var input = new List<IItemStack>();
            items.ToList().ForEach(i => input.Add(itemStackFactory.Create(new ItemId(i), 1)));
            
            var ans = MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)BlocksId, input, out _);
            Assert.AreEqual(outputLength == 1, ans);
        }
        
        [TestCase(1, new int[2] { 1, 2 }, new int[2] { 3, 1 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 3 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 30 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 1 }, false)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 2, 3, 4 }, true)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 4, 6, 8 }, true)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 4, 6, 1 }, false)]
        [TestCase(3, new int[3] { 2, 1, 3 }, new int[3] { 3, 2, 4 }, true)]
        [TestCase(3, new int[3] { 2, 1, 3 }, new int[3] { 3, 1, 4 }, false)]
        [TestCase(3, new int[4] { 2, 1, 0, 5 }, new int[4] { 3, 1, 4, 5 }, false)]
        public void RecipeConfirmationTest(int blocksId, int[] items, int[] itemcount, bool ans)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var itemStacks = new List<IItemStack>();
            for (var i = 0; i < items.Length; i++)
            {
                var itemId = new ItemId(items[i]);
                itemStacks.Add(itemStackFactory.Create(itemId, itemcount[i]));
            }
            
            MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)blocksId, itemStacks, out var machineRecipeElement);
            
            if (!ans && machineRecipeElement == null)
            {
                Assert.Pass();
                return;
            }
            
            var a = machineRecipeElement.RecipeConfirmation((BlockId)blocksId, itemStacks);
            Assert.AreEqual(ans, a);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Service/ConnectingInventoryListPriorityInsertItemService.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;

namespace Game.Block.Blocks.Service
{
    /// <summary>
    /// 順番にアイテムに入れ続けるシステム
    /// A system that keeps putting items in order.
    /// </summary>
    public class ConnectingInventoryListPriorityInsertItemService : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        private int _index = -1;
        
        public ConnectingInventoryListPriorityInsertItemService(BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockConnectorComponent = blockConnectorComponent;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            IReadOnlyList<IBlockInventory> inventories = _blockConnectorComponent.ConnectedTargets.Keys.ToArray();
            
            for (var i = 0; i < inventories.Count && itemStack.Id != ItemMaster.EmptyItemId; i++)
                lock (inventories)
                {
                    AddIndex();
                    itemStack = inventories[_index].InsertItem(itemStack);
                }
            
            return itemStack;
        }
        
        private void AddIndex()
        {
            _index++;
            if (_blockConnectorComponent.ConnectedTargets.Count <= _index) _index = 0;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/State/CommonMachineBlockStateDetail.cs
```cs
using System;
using MessagePack;

namespace Game.Block.Interface.State
{
    /// <summary>
    ///     機械、採掘機など基本的な機械のステートの詳細なデータ
    /// </summary>
    [Serializable]
    [MessagePackObject]
    public class CommonMachineBlockStateDetail
    {
        public const string BlockStateDetailKey = "CommonMachine";
        
        /// <summary>
        ///     現在のステートの種類
        /// </summary>
        [Key(0)] public string CurrentStateType;
        
        /// <summary>
        ///     以前のステートの種類
        /// </summary>
        [Key(1)] public string PreviousStateType;
        
        /// <summary>
        ///     必要な電力に対してどの程度電力が来ているかを表す
        ///     アニメーションを再生する速度に利用する
        /// </summary>
        [Key(2)] public float PowerRate;
        
        /// <summary>
        ///     アイテムの作成がどれくらい進んでいるかを表す
        /// </summary>
        [Key(3)] public float ProcessingRate;
        
        public CommonMachineBlockStateDetail(float currentPower, float requestPower, float processingRate, string currentStateType, string previousStateType)
        {
            PowerRate = requestPower == 0 ? 1.0f : currentPower / requestPower;
            this.ProcessingRate = processingRate;
            CurrentStateType = currentStateType;
            PreviousStateType = previousStateType;
        }
        
        [Obsolete("デシリアライズ用のコンストラクタです。基本的に使用しないでください。")]
        public CommonMachineBlockStateDetail()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearBeltConveyorTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearBeltConveyorTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private static BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var gearBeltParam = blockMasterElement.BlockParam as GearBeltConveyorBlockParam;
            
            var gearEnergyTransformerConnector = new BlockConnectorComponent<IGearEnergyTransformer>(
                gearBeltParam.Gear.GearConnects,
                gearBeltParam.Gear.GearConnects,
                blockPositionInfo
            );
            var inventoryConnector = BlockTemplateUtil.CreateInventoryConnector(gearBeltParam.InventoryConnectors, blockPositionInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(inventoryConnector); 
            
            var slopeType = gearBeltParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            var itemCount = gearBeltParam.BeltConveyorItemCount;
            
            // 歯車ベルトコンベアはRPMによって速度が変わるため、デフォルトは0となる
            // Gear belt conveyors have different speeds depending on the RPM, so the default is 0
            var time = 0;
            
            var vanillaBeltConveyorComponent = componentStates == null ? 
                    new VanillaBeltConveyorComponent(itemCount, time, beltConveyorConnector, slopeType) :
                    new VanillaBeltConveyorComponent(componentStates, itemCount, time, beltConveyorConnector,slopeType);
            
            var gearBeltConveyorComponent = new GearBeltConveyorComponent(vanillaBeltConveyorComponent, blockInstanceId, gearBeltParam.BeltConveyorSpeed, (Torque)gearBeltParam.RequireTorque, gearEnergyTransformerConnector);
            
            var blockComponents = new List<IBlockComponent>
            {
                gearBeltConveyorComponent,
                vanillaBeltConveyorComponent,
                gearEnergyTransformerConnector,
                inventoryConnector
            };
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, blockComponents, blockPositionInfo);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/SlopeBlockPlaceSystem.cs
```cs
using System;
using System.Collections.Generic;
using Client.Common;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem
{
    public class SlopeBlockPlaceSystem
    {
        public static readonly int GroundLayerMask = LayerMask.GetMask("Ground");
        
        /// <summary>
        ///     TODO ここの定義の場所を変える
        /// </summary>
        public static Vector3 GetBlockPositionToPlacePosition(Vector3Int blockPosition, BlockDirection blockDirection, BlockId blockId)
        {
            // 大きさをBlockDirection系に変換
            var blockSize = MasterHolder.BlockMaster.GetBlockMaster(blockId).BlockSize;
            var originPos = blockDirection.GetBlockModelOriginPos(blockPosition, blockSize);
            
            return originPos;
        }
        
        [Obsolete("一応残してある")]
        public static (Vector3 position, Quaternion rotation, Vector3 scale) GetSlopeBeltConveyorTransform(string blockType, Vector3Int blockPosition, BlockDirection blockDirection, Vector3Int blockSize)
        {
            //実際のブロックのモデルは+0.5した値が中心になる
            var blockObjectPos = blockPosition.AddBlockPlaceOffset(); //TODo ←システムが変わったのでおそらくこの行は不要
            
            var frontPoint = GetGroundPoint(GetBlockFrontRayOffset(blockDirection) + blockObjectPos);
            var backPoint = GetGroundPoint(-GetBlockFrontRayOffset(blockDirection) + blockObjectPos);
            
            //斜辺の長さを求める
            var hypotenuse = Vector3.Distance(frontPoint, backPoint);
            //高さを求める
            var height = Mathf.Abs(frontPoint.y - backPoint.y);
            var blockY = GetBlockFourCornerMaxHeight(blockPosition, blockDirection, blockSize);
            //角度を求める
            var blockAngle = Mathf.Asin(height / hypotenuse) * Mathf.Rad2Deg;
            
            
            var resultBlockPos = new Vector3(blockObjectPos.x, blockY + 0.3f, blockObjectPos.y);
            var blockRotation = GetRotation(blockDirection, blockAngle, frontPoint.y > backPoint.y);
            var blockScale = new Vector3(1, 1, hypotenuse);
            
            if (!BlockSlopeDeformationType.IsDeformation(blockType))
            {
                blockRotation = blockDirection.GetRotation();
                blockScale = Vector3.one;
            }
            
            return (resultBlockPos, blockRotation, blockScale);
        }
        
        public static Vector3 GetGroundPoint(Vector3 pos, Color debugRayColor = default)
        {
            var checkRay = new Ray(new Vector3(pos.x, 1000, pos.z), Vector3.down);
            Debug.DrawRay(checkRay.origin, checkRay.direction * 1000, debugRayColor, 3);
            
            if (!Physics.Raycast(checkRay, out var checkHit, 1500, GroundLayerMask)) throw new Exception("地面が見つかりませんでした pos:" + pos + " layer:" + GroundLayerMask);
            return checkHit.point;
        }
        
        public static float GetBlockFourCornerMaxHeight(Vector3Int blockPos, BlockDirection blockDirection, Vector3Int blockSize)
        {
            var (minPos, maxPos) = blockPos.GetWorldBlockBoundingBox(blockDirection, blockSize);
            var heights = new List<float>
            {
                GetGroundPoint(new Vector2(minPos.x, minPos.y), Color.red).y,
                GetGroundPoint(new Vector2(minPos.x, maxPos.y), Color.magenta).y,
                GetGroundPoint(new Vector2(maxPos.x, minPos.y), Color.cyan).y,
                GetGroundPoint(new Vector2(maxPos.x, maxPos.y), Color.blue).y,
            };
            
            return Mathf.Max(heights.ToArray());
        }
        
        private static Vector3 GetBlockFrontRayOffset(BlockDirection blockDirection)
        {
            return blockDirection switch
            {
                BlockDirection.North => new Vector3(0, 0, 0.5f),
                BlockDirection.East => new Vector3(0.5f, 0, 0),
                BlockDirection.South => new Vector3(0, 0, -0.5f),
                BlockDirection.West => new Vector3(-0.5f, 0, 0),
                _ => throw new ArgumentOutOfRangeException(nameof(blockDirection), blockDirection, null),
            };
        }
        
        private static Quaternion GetRotation(BlockDirection blockDirection, float blockAngle, bool isFrontUp)
        {
            blockAngle = isFrontUp ? -blockAngle : blockAngle;
            var defaultAngle = blockDirection.GetRotation().eulerAngles;
            return Quaternion.Euler(blockAngle, defaultAngle.y, defaultAngle.z);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/MinerBlockInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class MinerBlockInventoryView : CommonBlockInventoryViewBase 
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private ItemSlotObject minerResourceSlot;
        [SerializeField] private RectTransform minerResultsParent;
        
        [SerializeField] private ProgressArrowView minerProgressArrow;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            
            var itemList = new List<IItemStack>();
            var param = blockGameObject.BlockMasterElement.BlockParam;
            var outputCount = param switch
            {
                ElectricMinerBlockParam blockParam => blockParam.OutputItemSlotCount, // TODO master interfaceブロックインベントリの整理箇所
                GearMinerBlockParam blockParam => blockParam.OutputItemSlotCount,
                _ => 0
            };
            
            for (var i = 0; i < outputCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, minerResultsParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            UpdateItemList(itemList);
        }
        
        private void Update()
        {
            // ここが重かったら検討
            var commonProcessor = (CommonMachineBlockStateChangeProcessor)_blockGameObject.BlockStateChangeProcessors.FirstOrDefault(x => x as CommonMachineBlockStateChangeProcessor);
            if (commonProcessor == null) return;
            
            minerProgressArrow.SetProgress(commonProcessor.CurrentMachineState?.ProcessingRate ?? 0.0f);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearMachineTemplate.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearMachineTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdateEvent;
        
        public VanillaGearMachineTemplate(BlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            _blockInventoryUpdateEvent = blockInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var machineParam = blockMasterElement.BlockParam as GearMachineBlockParam;
            var inventoryConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(machineParam.InventoryConnectors, blockPositionInfo);
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            var (input, output) = BlockTemplateUtil.GetMachineIOInventory(blockId, blockInstanceId, machineParam, inventoryConnectorComponent, _blockInventoryUpdateEvent);
            
            var connectSetting = machineParam.Gear.GearConnects;
            var gearConnector = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var requiredTorque = new Torque(machineParam.RequireTorque);
            var gearEnergyTransformer = new GearEnergyTransformer(requiredTorque, blockInstanceId, gearConnector);
            
            var requirePower = new ElectricPower(machineParam.RequireTorque * machineParam.RequiredRpm);
            
            // パラメーターをロードするか、新規作成する
            // Load the parameters or create new ones
            var processor = componentStates == null ? 
                new VanillaMachineProcessorComponent(input, output, null, requirePower) :
                BlockTemplateUtil.MachineLoadState(componentStates, input, output, requirePower);
            
            var blockInventory = new VanillaMachineBlockInventoryComponent(input, output);
            var machineSave = new VanillaMachineSaveComponent(input, output, processor);
            
            var machineComponent = new VanillaGearMachineComponent(processor, gearEnergyTransformer, machineParam);
            
            var components = new List<IBlockComponent>
            {
                blockInventory,
                machineSave,
                processor,
                machineComponent,
                inventoryConnectorComponent,
                gearConnector,
                gearEnergyTransformer,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/MinerMiningTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Update;
using Game.Block.Blocks.Miner;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using Game.Map.Interface.Vein;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class MinerMiningTest
    {
        //一定時間たったら鉱石が出るテスト
        [Test]
        public void MiningTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //手動で鉱石の設定を行う
            var (mapVein, pos) = GetMapVein();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricMinerId, pos, BlockDirection.North, out _);
            var miner = worldBlockDatastore.GetBlock(pos);
            var minerComponent = miner.GetComponent<VanillaMinerProcessorComponent>();
            
            var miningItems = (List<IItemStack>)typeof(VanillaMinerProcessorComponent).GetField("_miningItems", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(minerComponent);
            var miningItemId = miningItems[0].Id;
            var miningTime = (float)typeof(VanillaMinerProcessorComponent).GetField("_defaultMiningTime", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(minerComponent);
            
            
            var dummyInventory = new DummyBlockInventory();
            //接続先ブロックの設定
            //本当はダメなことしているけどテストだから許してヒヤシンス
            var minerConnectors = (Dictionary<IBlockInventory, ConnectedInfo>)miner.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            minerConnectors.Add(dummyInventory, new ConnectedInfo());
            
            //電力の設定
            var segment = new EnergySegment();
            segment.AddEnergyConsumer(miner.GetComponent<IElectricConsumer>());
            segment.AddGenerator(new TestElectricGenerator(new ElectricPower(10000), new BlockInstanceId(10)));
            
            var mineEndTime = DateTime.Now.AddSeconds(miningTime);
            
            
            //テストコードの準備完了
            //鉱石1個分の採掘時間待機
            while (mineEndTime.AddSeconds(0.05).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //鉱石1個が出力されているかチェック
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id);
            Assert.AreEqual(1, dummyInventory.InsertedItems[0].Count);
            
            //コネクターを外す
            minerConnectors.Remove(dummyInventory);
            
            //鉱石2個分の採掘時間待機
            mineEndTime = DateTime.Now.AddSeconds(miningTime * 2);
            while (mineEndTime.AddSeconds(0.05).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //鉱石2個が残っているかチェック
            var outputSlot = miner.GetComponent<VanillaMinerProcessorComponent>().InventoryItems[0];
            Assert.AreEqual(miningItemId, outputSlot.Id);
            Assert.AreEqual(2, outputSlot.Count);
            
            //またコネクターをつなげる
            minerConnectors.Add(dummyInventory, new ConnectedInfo());
            
            //コネクターにアイテムを入れるためのアップデート
            GameUpdater.UpdateWithWait();
            
            //アイテムがさらに2個追加で入っているかチェック
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id);
            Assert.AreEqual(3, dummyInventory.InsertedItems[0].Count);
        }
        
        public static (IMapVein mapVein, Vector3Int pos) GetMapVein()
        {
            var pos = new Vector3Int(0, 0);
            for (var i = 0; i < 500; i++)
            for (var j = 0; j < 500; j++)
            {
                List<IMapVein> veins = ServerContext.MapVeinDatastore.GetOverVeins(new Vector3Int(i, j));
                if (veins.Count == 0) continue;
                
                return (veins[0], new Vector3Int(i, j));
            }
            
            return (null, pos);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineBlockInventoryComponent.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;

namespace Game.Block.Blocks.Machine.Inventory
{
    public class VanillaMachineBlockInventoryComponent : IOpenableBlockInventoryComponent
    {
        public IReadOnlyList<IItemStack> InventoryItems
        {
            get
            {
                BlockException.CheckDestroy(this);
                var items = new List<IItemStack>();
                items.AddRange(_vanillaMachineInputInventory.InputSlot);
                items.AddRange(_vanillaMachineOutputInventory.OutputSlot);
                return items;
            }
        }
        
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        
        public VanillaMachineBlockInventoryComponent(VanillaMachineInputInventory vanillaMachineInputInventory, VanillaMachineOutputInventory vanillaMachineOutputInventory)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            return ReplaceItem(slot, item);
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //アイテムをインプットスロットに入れた後、プロセス開始できるなら開始
            var item = _vanillaMachineInputInventory.InsertItem(itemStack);
            return item;
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            return _vanillaMachineInputInventory.InsertItem(item);
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
                return _vanillaMachineInputInventory.InputSlot[slot];
            
            slot -= _vanillaMachineInputInventory.InputSlot.Count;
            return _vanillaMachineOutputInventory.OutputSlot[slot];
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
            {
                _vanillaMachineInputInventory.SetItem(slot, itemStack);
            }
            else
            {
                slot -= _vanillaMachineInputInventory.InputSlot.Count;
                _vanillaMachineOutputInventory.SetItem(slot, itemStack);
            }
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            SetItem(slot, item);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            
            return _vanillaMachineInputInventory.InputSlot.Count + _vanillaMachineOutputInventory.OutputSlot.Count;
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            
            var items = new List<IItemStack>();
            items.AddRange(_vanillaMachineInputInventory.InputSlot);
            items.AddRange(_vanillaMachineOutputInventory.OutputSlot);
            return new ReadOnlyCollection<IItemStack>(items);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            //アイテムをインプットスロットに入れた後、プロセス開始できるなら開始
            return _vanillaMachineInputInventory.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _vanillaMachineInputInventory.InsertionCheck(itemStacks);
        }
        
        /// <summary>
        ///     アイテムの置き換えを実行しますが、同じアイテムIDの場合はそのまま現在のアイテムにスタックされ、スタックしきらなかったらその分を返します。
        /// </summary>
        /// <param name="slot"></param>
        /// <param name="itemStack"></param>
        /// <returns></returns>
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            ItemProcessResult result;
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
            {
                //アイテムIDが同じの時はスタックして余ったものを返す
                var item = _vanillaMachineInputInventory.InputSlot[slot];
                if (item.Id == itemStack.Id)
                {
                    result = item.AddItem(itemStack);
                    _vanillaMachineInputInventory.SetItem(slot, result.ProcessResultItemStack);
                    return result.RemainderItemStack;
                }
                
                //違う場合はそのまま入れ替える
                _vanillaMachineInputInventory.SetItem(slot, itemStack);
                return item;
            }
            else
            {
                //アウトプットスロットのインデックスに変換する
                slot -= _vanillaMachineInputInventory.InputSlot.Count;
                
                var item = _vanillaMachineOutputInventory.OutputSlot[slot];
                
                if (item.Id == itemStack.Id)
                {
                    result = item.AddItem(itemStack);
                    _vanillaMachineOutputInventory.SetItem(slot, result.ProcessResultItemStack);
                    return result.RemainderItemStack;
                }
                
                _vanillaMachineOutputInventory.SetItem(slot, itemStack);
                return item;
            }
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/CollectBeltConveyorItems.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Entity.Interface;
using Game.Entity.Interface.EntityInstance;
using Game.World.Interface.DataStore;
using UnityEngine;


namespace Server.Protocol.PacketResponse.Util
{
    /// <summary>
    ///     ベルトコンベアにあるアイテムを収集し、エンティティに変換して返す
    /// </summary>
    public static class CollectBeltConveyorItems
    {
        public const float DefaultBeltConveyorHeight = 0.3f;
        
        public static List<IEntity> CollectItem(IEntityFactory entityFactory)
        {
            var result = new List<IEntity>();
            result.AddRange(CollectItemFromWorld(entityFactory));
            
            return result;
        }
        
        public static List<IEntity> CollectItemFromWorld(IEntityFactory entityFactory)
        {
            var result = new List<IEntity>();
            
            //TODO 個々のパフォーマンス問題を何とかする
            foreach (KeyValuePair<BlockInstanceId, WorldBlockData> blockMaster in ServerContext.WorldBlockDatastore.BlockMasterDictionary)
            {
                var block = blockMaster.Value.Block;
                var pos = blockMaster.Value.BlockPositionInfo.OriginalPos;
                // TODO 重かったら考える
                if (!block.TryGetComponent<IItemCollectableBeltConveyor>(out var component))
                {
                    continue;
                }
                
                var direction = ServerContext.WorldBlockDatastore.GetBlockDirection(pos);
                result.AddRange(CollectItemFromBeltConveyor(entityFactory, component, pos, direction));
            }
            
            return result;
        }
        
        static Dictionary<ItemInstanceId,float> _itemInstanceIdToPercent = new Dictionary<ItemInstanceId, float>();
        
        private static List<IEntity> CollectItemFromBeltConveyor(IEntityFactory entityFactory, IItemCollectableBeltConveyor beltConveyor, Vector3Int pos, BlockDirection blockDirection)
        {
            var result = new List<IEntity>();
            for (var i = 0; i < beltConveyor.BeltConveyorItems.Count; i++)
            {
                var beltConveyorItem = beltConveyor.BeltConveyorItems[i];
                if (beltConveyorItem == null) continue;
                if (beltConveyorItem.ItemId == ItemMaster.EmptyItemId) continue;
                
                //残り時間をどこまで進んだかに変換するために 1- する
                var percent = 1f - (float)beltConveyorItem.RemainingPercent;
                
                var last = _itemInstanceIdToPercent.GetValueOrDefault(beltConveyorItem.ItemInstanceId);
                _itemInstanceIdToPercent[beltConveyorItem.ItemInstanceId] = percent;
                
                var diff = percent - last;
                var instanceId = beltConveyorItem.ItemInstanceId;
                UnityEngine.Debug.Log($"CollectItemFrom Last:{last:F3} Current:{percent:F3} Diff:{diff:F3} {instanceId}");
                
                float entityX = pos.x;
                float entityZ = pos.z;
                switch (blockDirection)
                {
                    case BlockDirection.North:
                        entityX += 0.5f; //ベルトコンベアの基準座標は中心なので0.5を他してアイテムを中心に持ってくる
                        entityZ += percent;
                        break;
                    case BlockDirection.South:
                        entityX += 0.5f;
                        entityZ += 1 - percent; //北とは逆向きなので1を引いて逆向きにする
                        break;
                    case BlockDirection.East:
                        entityX += percent;
                        entityZ += 0.5f;
                        break;
                    case BlockDirection.West:
                        entityX += 1 - percent;
                        entityZ += 0.5f;
                        break;
                }
                
                //この0.3という値は仮
                var y = pos.y + DefaultBeltConveyorHeight;
                
                if (beltConveyor.SlopeType == BeltConveyorSlopeType.Up)
                {
                    y += percent;
                    y += 0.1f;
                }
                else if (beltConveyor.SlopeType == BeltConveyorSlopeType.Down)
                {
                    y -= percent;
                    y += 0.1f;
                    y++;
                }
                
                var position = new Vector3(entityX, y, entityZ);
                var itemEntity = (ItemEntity)entityFactory.CreateEntity(VanillaEntityType.VanillaItem, new EntityInstanceId(beltConveyorItem.ItemInstanceId.AsPrimitive()), position);
                itemEntity.SetState(beltConveyorItem.ItemId, 1);
                
                result.Add(itemEntity);
            }
            
            return result;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/FastBeltConveyorTest.cs
```cs
using Core.Master;
using Core.Update;
using Game.Block.Interface;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class FastBeltConveyorTest
    {
        /// <summary>
        /// TODO 1フレームで3ブロック進むベルトコンベアのテスト
        /// TODO Testing a conveyor belt that moves 3 blocks per frame
        /// </summary>
        public void OneFramePer3BlockBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            //PlaceBlock(ForUnitTestModBlockId.FastBeltConveyor, new Vector3Int(0, 0, 0));
            //PlaceBlock(ForUnitTestModBlockId.FastBeltConveyor, new Vector3Int(0, 0, 1));
            //PlaceBlock(ForUnitTestModBlockId.FastBeltConveyor, new Vector3Int(0, 0, 2));
            
            GameUpdater.SpecifiedDeltaTimeUpdate(1);
        }
        
        IBlock PlaceBlock(BlockId blockId, Vector3Int position)
        {
            var world = ServerContext.WorldBlockDatastore;
            
            world.TryAddBlock(blockId, position, BlockDirection.North, out var block);
            return block;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestElectricGenerator.cs
```cs
using Game.Block.Interface;
using Game.EnergySystem;

namespace Tests.Module
{
    //デバック用で無限に電力を供給できる
    public class TestElectricGenerator : IElectricGenerator
    {
        private readonly ElectricPower _power;
        
        public TestElectricGenerator(ElectricPower power, BlockInstanceId blockInstanceId)
        {
            _power = power;
            BlockInstanceId = blockInstanceId;
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        
        public ElectricPower OutputEnergy()
        {
            return _power;
        }
        
        public bool IsDestroy { get; }
        
        public void Destroy()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerNetworkContext.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.BlockComponent.ProviderChest;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using UnityEngine;

namespace Game.CraftChainer.BlockComponent.Computer
{
    public class CraftChainerNetworkContext
    {
        // チェインネットワークに関する情報
        // Information about the chain network
        public IReadOnlyList<CraftChainerProviderChestComponent> ProviderChests => _providerChests;
        private readonly List<CraftChainerProviderChestComponent> _providerChests = new();
        public IReadOnlyList<CraftCraftChainerCrafterComponent> CrafterComponents => _crafterComponents;
        private readonly List<CraftCraftChainerCrafterComponent> _crafterComponents = new();
        private readonly Dictionary<CraftChainerNodeId, ICraftChainerNode> _nodes = new();
        
        // このコンテキストを保持するメインコンピューターの情報
        // Information about the main computer that holds this context
        private readonly BlockConnectorComponent<IBlockInventory> _mainComputerConnector; 
        private readonly ICraftChainerNode _mainComputerNode;
        
        // 現在クラフト中のアイテム情報
        // Information about the item currently being crafted
        private readonly Dictionary<ItemInstanceId,CraftChainerNodeId> _requestedMoveItems = new();
        // アイテムごとにどのノードに何個アイテムを入れなければならないか
        // How many items of each item type must be placed in each node?
        private Dictionary<ItemId,Dictionary<CraftChainerNodeId,int>> _craftChainRecipeQue = new();
        
        public CraftChainerNetworkContext(BlockConnectorComponent<IBlockInventory> mainComputerConnector, ICraftChainerNode mainComputerNode)
        {
            _mainComputerConnector = mainComputerConnector;
            _mainComputerNode = mainComputerNode;
        }
        
        public bool IsExistNode(CraftChainerNodeId nodeId)
        {
            return _nodes.ContainsKey(nodeId);
        }
        
        public void SetCraftChainRecipeQue(Dictionary<CraftingSolverRecipeId, int> solvedResults, CraftingSolverItem targetItem)
        {
            var craftRecipeIdMap = GetCraftRecipeIdMap();
            
            _craftChainRecipeQue = CreateRecipeQue(solvedResults, craftRecipeIdMap);
            // ターゲットのアイテムをコンピューターに移動するようにリクエストを追加しておく
            _craftChainRecipeQue.Add(targetItem.ItemId, new Dictionary<CraftChainerNodeId, int> {{_mainComputerNode.NodeId, targetItem.Count}});
            
            #region Internal
            
            Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent> GetCraftRecipeIdMap()
            {
                var map = new Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent>();
                foreach (var crafter in _crafterComponents)
                {
                    var recipeId = crafter.CraftingSolverRecipe.CraftingSolverRecipeId;
                    if (recipeId != CraftingSolverRecipeId.InvalidId)
                    {
                        map[recipeId] = crafter;
                    }
                }
                return map;
            }
            
            Dictionary<ItemId, Dictionary<CraftChainerNodeId,int>> CreateRecipeQue(Dictionary<CraftingSolverRecipeId, int> solved, Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent> recipes)
            {
                var result = new Dictionary<ItemId, Dictionary<CraftChainerNodeId,int>>();
                foreach (var solvedResult in solved)
                {
                    var crafter = recipes[solvedResult.Key];
                    var recipe = crafter.CraftingSolverRecipe;
                    foreach (var inputItems in recipe.Inputs)
                    {
                        var count = inputItems.Count * solvedResult.Value;
                        if (result.TryGetValue(inputItems.ItemId, out var que))
                        {
                            if (!que.TryAdd(crafter.NodeId,count))
                            {
                                que[crafter.NodeId] += count;
                            }
                        }
                        else
                        {
                            result[inputItems.ItemId] = new Dictionary<CraftChainerNodeId, int>()
                            {
                                { crafter.NodeId, count }
                            };
                        }
                    }
                }
                
                return result;
            }
            
            #endregion
        }
        
        /// <summary>
        /// クラフトチェインのネットワークを再検索する
        /// Re-search the network of the craft chain
        /// </summary>
        public void ReSearchNetwork()
        {
            _providerChests.Clear();
            _crafterComponents.Clear();
            _nodes.Clear();
            
            _nodes.Add(_mainComputerNode.NodeId, _mainComputerNode);
            
            // 単純に深さ優先探索で探索し、途中にあったチェストをリストに追加
            // Simply search by depth-first search and add the chests found on the way to the list
            Search(_mainComputerConnector);
            
            #region Internal
            
            void Search(BlockConnectorComponent<IBlockInventory> connector)
            {
                foreach (var connectedTarget in connector.ConnectedTargets)
                {
                    var targetBlock = connectedTarget.Value.TargetBlock;
                    if (!targetBlock.TryGetComponent<ICraftChainerNode>(out var node))
                    {
                        continue;
                    }
                    if (!_nodes.TryAdd(node.NodeId, node))
                    {
                        continue;
                    }
                    
                    if (targetBlock.TryGetComponent<CraftChainerProviderChestComponent>(out var chest))
                    {
                        _providerChests.Add(chest);
                    }
                    if (targetBlock.TryGetComponent<CraftCraftChainerCrafterComponent>(out var crafter))
                    {
                        _crafterComponents.Add(crafter);
                    }
                    if (targetBlock.TryGetComponent<BlockConnectorComponent<IBlockInventory>>(out var nextConnector))
                    {
                        Search(nextConnector);
                    }
                }
            }
            
            #endregion
        }
        
        /// <summary>
        /// アイテムのIDとつながっているコネクターから、次にインサートすべきブロックを取得し、インサート出来る場合はインサートする
        /// Get the next block to insert from the item ID and connected connector, and insert it if possible
        /// </summary>
        public IItemStack InsertNodeNetworkNextBlock(IItemStack item, CraftChainerNodeId startChainerNodeId, BlockConnectorComponent<IBlockInventory> blockConnector)
        {
            if (item.Id == ItemMaster.EmptyItemId) return item;
            
            // ターゲットとなるノードがあるか
            var targetNodeId = GetTargetNodeId(item);
            if (targetNodeId == CraftChainerNodeId.Invalid)
            {
                return item;
            }
            
            // たどり着けるか
            var result = ExecuteBfs(targetNodeId);
            if (result == null || result.Count == 0)
            {
                return item;
            }
            
            // 次のインベントリにアイテムを入れられるか
            var nextInventory = result[0].Item2;
            if (!nextInventory.InsertionCheck(new List<IItemStack> {item}))
            {
                return item;
            }
            
            // アイテムを入れられるのでキューの情報を更新する
            DebugExportCraftChainRecipeQueLog();
            UpdateCraftQue();
            
            // 次のインベントリにアイテムを入れる
            return nextInventory.InsertItem(item);
            
            #region Internal
            
            CraftChainerNodeId GetTargetNodeId(IItemStack item)
            {
                // 移動先が既に指定されている場合はそのまま返す
                // If the destination is already specified, return it as it is
                if (_requestedMoveItems.TryGetValue(item.ItemInstanceId, out var nodeId))
                {
                    return nodeId;
                }
                
                // 現在のアイテムがクラフト対象の材料かどうかをチェック
                // Check if the current item is a crafting target material
                if (!_craftChainRecipeQue.TryGetValue(item.Id, out var craftQue))
                {
                    return CraftChainerNodeId.Invalid;
                }
                
                // クラフト対象の材料なのでそのうちの一つを取得
                // It is a crafting target material, so get one of them
                foreach (var nodeReminder in craftQue)
                {
                    return nodeReminder.Key;
                }
                
                // 移動先が特に指定されていない場合はInvalidを返す
                // If no destination is specified, return Invalid
                return CraftChainerNodeId.Invalid;
            }
            
            List<(CraftChainerNodeId,IBlockInventory)> ExecuteBfs(CraftChainerNodeId targetNode)
            {
                var idToConnector = new Dictionary<CraftChainerNodeId, (BlockConnectorComponent<IBlockInventory> connector, IBlockInventory blockInventory)>();
                var searchQueue = new Queue<CraftChainerNodeId>();
                var searched = new HashSet<CraftChainerNodeId>();
                var reverseSearch = new Dictionary<CraftChainerNodeId, CraftChainerNodeId>();
                var stepLog = new Dictionary<CraftChainerNodeId, int>();
                var isFound = false;
                
                searchQueue.Enqueue(startChainerNodeId);
                searched.Add(startChainerNodeId);
                idToConnector[startChainerNodeId] = (blockConnector, null);
                stepLog[startChainerNodeId] = 0;
                
                // キューがなくなるまでループ
                // Loop until the queue is empty
                while (0 < searchQueue.Count)
                {
                    var searchingId = searchQueue.Dequeue();
                    if (searchingId == targetNode)
                    {
                        isFound = true;
                        break;
                    }
                    
                    var step = stepLog[searchingId] + 1;
                    foreach (var connectedTarget in idToConnector[searchingId].connector.ConnectedTargets)
                    {
                        var targetBlock = connectedTarget.Value.TargetBlock;
                        var next = GetNext(targetBlock);
                        
                        // 接続先がChainerNodeではないので無視
                        // Ignore if the connection destination is not a ChainerNode
                        if (!next.HasValue) continue;
                        
                        var (nodeId, nextConnector, blockInventory) = next.Value;
                        
                        // すでに探索済みの場合は無視
                        // Ignore if already searched
                        if (searched.Contains(nodeId)) continue;
                        
                        searched.Add(nodeId); // Mark as searched before enqueuing
                        reverseSearch[nodeId] = searchingId;
                        idToConnector[nodeId] = (nextConnector, blockInventory);
                        stepLog[nodeId] = step;
                        searchQueue.Enqueue(nodeId);
                    }
                }
                
                if (!isFound)
                {
                    return null;
                }
                
                // 経路をたどっていく
                // Follow the path
                var result = new List<(CraftChainerNodeId,IBlockInventory)>();
                var current = targetNode;
                while (current != startChainerNodeId)
                {
                    result.Add((current,idToConnector[current].blockInventory));
                    current = reverseSearch[current];
                }
                
                result.Reverse();
                return result;
            }
            
            (CraftChainerNodeId nodeId, BlockConnectorComponent<IBlockInventory> connector, IBlockInventory blockInventory)? GetNext(IBlock block)
            {
                if (!block.TryGetComponent<ICraftChainerNode>(out var node)) return null;
                if (node.NodeId == startChainerNodeId) return null;
                if (!block.TryGetComponent<BlockConnectorComponent<IBlockInventory>>(out var connector)) return null;
                if (!block.TryGetComponent<IBlockInventory>(out var inventory)) return null;
                
                return (node.NodeId, connector, inventory);
            }
            
            void UpdateCraftQue()
            {
                // 新しく挿入されたアイテムのみ更新を行うので、既に移動先が指定されているアイテムは無視
                // Only newly inserted items are updated, so items that already have a destination specified are ignored
                if (_requestedMoveItems.ContainsKey(item.ItemInstanceId))
                {
                    return;
                }
                
                // クラフトキューの情報をアップデート
                // Update the craft queue information
                var craftQue = _craftChainRecipeQue[item.Id];
                var reminder = craftQue[targetNodeId];
                reminder--;
                if (reminder <= 0)
                {
                    craftQue.Remove(targetNodeId);
                }
                else
                {
                    craftQue[targetNodeId] = reminder;
                }
                
                // 計算したアイテムの移動先を保持
                // Keep the destination of the calculated item
                _requestedMoveItems[item.ItemInstanceId] = targetNodeId;
            }
            
            void DebugExportCraftChainRecipeQueLog()
            {
                // 使う場合はこのreturnを取る
                // If you want to use it, remove this return
                return;
                
                var str = "";
                
                foreach (var ques in _craftChainRecipeQue)
                {
                    foreach (var que in ques.Value)
                    {
                        var crafter = _crafterComponents.Find(c => c.NodeId == que.Key);
                        if (crafter != null)
                        {
                            var outputId = crafter.CraftingSolverRecipe.Outputs[0].ItemId;
                            var outItemName = MasterHolder.ItemMaster.GetItemMaster(outputId).Name;
                            var itemName = MasterHolder.ItemMaster.GetItemMaster(ques.Key).Name;
                            
                            str += $"Id {itemName} Count {que.Value} Output {outItemName},  ";
                        }
                    }
                }
                
                Debug.Log(str);
            }
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SimpleTrainTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Context;
using Game.Train.RailGraph;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    public class SimpleTrainTest
    {
        [Test]
        // レールに乗っている列車が指定された駅に向かって移動するテスト
        // A test in which a train on rails moves towards a designated station
        public void SimpleTrainMoveTest()
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            // TODO レールブロック1を設置
            // TODO レールブロック2を設置
            // TODO レールブロック同士がつながっていることを確認

            // TODO レールの両端に駅を設置

            // TODO レールに動力車1台を設置
            // TODO 列車に指定された駅に行くように指示

            // TODO 列車が駅に到着するまで待つ

            // TODO 列車が駅に到着すればpass、指定時間以内に到着しなければfail
            //
        }

        [Test]
        //ダイクストラ法が正しく動いているか 0-1-2-3
        public void DijkstraTest0()
        {

            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //railGraphDatastoreに登録
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            var node0 = new RailNode(railGraphDatastore);
            var node1 = new RailNode(railGraphDatastore);
            var node2 = new RailNode(railGraphDatastore);
            var node3 = new RailNode(railGraphDatastore);
            node0.ConnectNode(node1, 1);
            node1.ConnectNode(node2, 1);
            node2.ConnectNode(node3, 1);

            //ダイクストラ法を実行 node0からnode3までの最短経路を求める
            var outListPath = railGraphDatastore.FindShortestPath(node0, node3);

            //結果が正しいか
            Assert.AreEqual(4, outListPath.Count);
            Assert.AreEqual(node0, outListPath[0]);
            Assert.AreEqual(node1, outListPath[1]);
            Assert.AreEqual(node2, outListPath[2]);
            Assert.AreEqual(node3, outListPath[3]);
        }


        [Test]
        //ダイクストラ法が正しく動いているか、分岐あり 0=(1,2)=3
        public void DijkstraTest1()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //railGraphDatastoreに登録
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            var node0 = new RailNode(railGraphDatastore);
            var node1 = new RailNode(railGraphDatastore);
            var node2 = new RailNode(railGraphDatastore);
            var node3 = new RailNode(railGraphDatastore);
            node0.ConnectNode(node1, 123);
            node0.ConnectNode(node2, 345);
            node1.ConnectNode(node3, 400);
            node2.ConnectNode(node3, 1);

            //ダイクストラ法を実行 node0からnode3までの最短経路を求める
            var outListPath = railGraphDatastore.FindShortestPath(node0, node3);

            //結果が正しいか
            Assert.AreEqual(3, outListPath.Count);
            Assert.AreEqual(node0, outListPath[0]);
            Assert.AreEqual(node2, outListPath[1]);
            Assert.AreEqual(node3, outListPath[2]);
        }


        [Test]
        //ダイクストラ法が正しく動いているか、複雑
        public void DijkstraTest2()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            //10000個のノードを作成し、それぞれが10つのノードにつながる。距離は1
            const int nodenum_powerexponent = 4;
            int nodenum = (int)System.Math.Pow(10, nodenum_powerexponent);
            Debug.Log(nodenum);

            RailNode[] nodeList = new RailNode[nodenum];
            for (int i = 0; i < nodenum; i++)
            {
                nodeList[i] = new RailNode(railGraphDatastore);
            }
            //つながる規則は桁シフト(*10)して下位桁の数字を0-9とし、そのノードに対してつながる
            for (int i = 0; i < nodenum; i++)
            {
                for (int j = 0; j < 10; j++)
                {
                    var next = (i * 10) % nodenum + j;
                    nodeList[i].ConnectNode(nodeList[next], 1);
                }
            }

            //ダイクストラ法を実行、ランダムに。必ず距離4以内に任意のノードにつながるはず
            //例 1145から1419までの最短経路を求める
            //1145①→1451②
            //1451②→4514③
            //4514③→5141④
            //5141④→1419⑤
            int testnum = 1234;//1234567でも大丈夫なことを確認
            for (int i = 0; i < testnum; i++)
            {
                int rand0 = Random.Range(0, nodenum);
                int rand1 = Random.Range(0, nodenum);
                var node_start = nodeList[rand0];
                var node_end = nodeList[rand1];
                var outListPath = railGraphDatastore.FindShortestPath(node_start, node_end);
                //結果が正しいか outListPathは4+1以内のはず
                if (outListPath.Count > 5)
                {
                    Debug.Log(rand0);
                    Debug.Log(rand1);
                }
                Assert.LessOrEqual(outListPath.Count, nodenum_powerexponent + 1);
            }
        }





        [Test]
        //Yの字の形に設置して、ノードが正しくつながっているかチェック
        public void Y_NodeCheck()
        {
            //Notionの図を参照
            //Yの字の左上がA、右上がB、真ん中がC1とC2、下がD1とD2
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //railGraphDatastoreに登録
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            var nodeA = new RailNode(railGraphDatastore);
            var nodeB = new RailNode(railGraphDatastore);
            var nodeC1 = new RailNode(railGraphDatastore);
            var nodeC2 = new RailNode(railGraphDatastore);
            var nodeD1 = new RailNode(railGraphDatastore);
            var nodeD2 = new RailNode(railGraphDatastore);
            nodeA.ConnectNode(nodeC1, 3782);
            nodeB.ConnectNode(nodeC1, 67329);
            nodeC1.ConnectNode(nodeD1, 71894);
            nodeD2.ConnectNode(nodeC2, 17380);
            nodeC2.ConnectNode(nodeA, 28973);
            nodeC2.ConnectNode(nodeB, 718);

            //上から下
            //ダイクストラ法を実行 nodeAからnodeDまでの最短経路を求める
            var outListPath = railGraphDatastore.FindShortestPath(nodeA, nodeD1);

            //結果が正しいか
            Assert.AreEqual(3, outListPath.Count);
            Assert.AreEqual(nodeA, outListPath[0]);
            Assert.AreEqual(nodeC1, outListPath[1]);
            Assert.AreEqual(nodeD1, outListPath[2]);

            //下から上
            outListPath = railGraphDatastore.FindShortestPath(nodeD2, nodeA);

            //結果が正しいか
            Assert.AreEqual(3, outListPath.Count);
            Assert.AreEqual(nodeD2, outListPath[0]);
            Assert.AreEqual(nodeC2, outListPath[1]);
            Assert.AreEqual(nodeA, outListPath[2]);

            //AからBは繋がらない
            outListPath = railGraphDatastore.FindShortestPath(nodeA, nodeB);
            Assert.AreEqual(0, outListPath.Count);

            //ここでD1とD2を繋げると
            nodeD1.ConnectNode(nodeD2, 721);
            outListPath = railGraphDatastore.FindShortestPath(nodeA, nodeB);
            Assert.AreEqual(6, outListPath.Count);
            Assert.AreEqual(nodeA, outListPath[0]);
            Assert.AreEqual(nodeC1, outListPath[1]);
            Assert.AreEqual(nodeD1, outListPath[2]);
            Assert.AreEqual(nodeD2, outListPath[3]);
            Assert.AreEqual(nodeC2, outListPath[4]);
            Assert.AreEqual(nodeB, outListPath[5]);
        }



        //RailGraphDatastoreに実装したGetConnectedNodesのテスト
        [Test]
        public void ConnectedNodesTest()
        {
            //Yの字の左上がA、右上がB、真ん中がC1とC2、下がD1とD2
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //railGraphDatastoreに登録
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            var nodeA = new RailNode(railGraphDatastore);
            var nodeB = new RailNode(railGraphDatastore);
            var nodeC = new RailNode(railGraphDatastore);

            nodeA.ConnectNode(nodeB, 10);
            nodeA.ConnectNode(nodeC, 20);

            var connectedNodes = nodeA.ConnectedNodes.ToList();

            Assert.AreEqual(2, connectedNodes.Count);
            Assert.IsTrue(connectedNodes.Contains(nodeB));
            Assert.IsTrue(connectedNodes.Contains(nodeC));
        }

        //RailPositionのmoveForwardのテストその1
        [Test]
        public void MoveForward_LongTrain_MovesAcrossMultipleNodes()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var railGraph = serviceProvider.GetService<RailGraphDatastore>();

            // ノードを準備
            var nodeA = new RailNode(railGraph);
            var nodeB = new RailNode(railGraph);
            var nodeC = new RailNode(railGraph);
            var nodeD = new RailNode(railGraph);
            var nodeE = new RailNode(railGraph);

            // ノードを接続
            nodeB.ConnectNode(nodeA, 10);//9から列車
            nodeC.ConnectNode(nodeB, 15);//列車
            nodeD.ConnectNode(nodeC, 20);//列車
            nodeE.ConnectNode(nodeD, 25);//14まで列車

            // 長い列車（列車長50）をノードAからEにまたがる状態に配置
            var nodes = new List<RailNode> { nodeA, nodeB, nodeC, nodeD, nodeE };
            var railPosition = new RailPosition(nodes, 50, 9); // 先頭はノードAとBの間の9地点

            //進む
            var remainingDistance = railPosition.MoveForward(6); // 6進む（ノードAに近づく）
            // Assert
            Assert.AreEqual(0, remainingDistance); // ノードAに到達するまでに残り3

            //地道に全部チェック。ノードEの情報はまだ消えてない
            var list = railPosition.TestGet_railNodes();
            Assert.AreEqual(nodeA, list[0]);
            Assert.AreEqual(nodeB, list[1]);
            Assert.AreEqual(nodeC, list[2]);
            Assert.AreEqual(nodeD, list[3]);
            Assert.AreEqual(nodeE, list[4]);

            //進む、残りの進むべき距離
            remainingDistance = railPosition.MoveForward(4); // 3進んでAで停止、残り1
            // Assert
            Assert.AreEqual(nodeA, railPosition.GetNodeApproaching()); // 
            Assert.AreEqual(1, remainingDistance); //
            Assert.AreEqual(nodeB, railPosition.GetNodeJustPassed()); // 
        }

        //RailPositionのmoveForwardのテストその2
        [Test]
        public void MoveBackward_LongTrain_MovesAcrossMultipleNodes()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var railGraph = serviceProvider.GetService<RailGraphDatastore>();

            // ノードを準備
            // 表
            var nodeA1 = new RailNode(railGraph);
            var nodeB1 = new RailNode(railGraph);
            var nodeC1 = new RailNode(railGraph);
            var nodeD1 = new RailNode(railGraph);
            var nodeE1 = new RailNode(railGraph);
            // 裏
            var nodeA2 = new RailNode(railGraph);
            var nodeB2 = new RailNode(railGraph);
            var nodeC2 = new RailNode(railGraph);
            var nodeD2 = new RailNode(railGraph);
            var nodeE2 = new RailNode(railGraph);

            // ノードを接続
            nodeB1.ConnectNode(nodeA1, 10);//5から列車
            nodeC1.ConnectNode(nodeB1, 15);//列車
            nodeD1.ConnectNode(nodeC1, 20);//列車
            nodeE1.ConnectNode(nodeD1, 25);//10まで列車

            nodeD2.ConnectNode(nodeE2, 25);
            nodeC2.ConnectNode(nodeD2, 20);
            nodeB2.ConnectNode(nodeC2, 15);
            nodeA2.ConnectNode(nodeB2, 10);

            nodeA1.SetOppositeNode(nodeA2);//ここは本来RailConmponentのコンストラクタでやる
            nodeB1.SetOppositeNode(nodeB2);
            nodeC1.SetOppositeNode(nodeC2);
            nodeD1.SetOppositeNode(nodeD2);
            nodeE1.SetOppositeNode(nodeE2);
            nodeA2.SetOppositeNode(nodeA1);
            nodeB2.SetOppositeNode(nodeB1);
            nodeC2.SetOppositeNode(nodeC1);
            nodeD2.SetOppositeNode(nodeD1);
            nodeE2.SetOppositeNode(nodeE1);
            {  //Reverseを使ってMoveForward(マイナス)を使わないパターン
                var nodes = new List<RailNode> { nodeA1, nodeB1, nodeC1, nodeD1, nodeE1 };
                var railPosition = new RailPosition(nodes, 50, 5); // 先頭はノードAとBの間の5地点
                railPosition.Reverse();//ノードEまで15になる
                //地道に全部チェック。ノードEの情報はまだ消えてない
                var list = railPosition.TestGet_railNodes();
                Assert.AreEqual(nodeE2, list[0]);
                Assert.AreEqual(nodeD2, list[1]);
                Assert.AreEqual(nodeC2, list[2]);
                Assert.AreEqual(nodeB2, list[3]);
                Assert.AreEqual(nodeA2, list[4]);
                Assert.AreEqual(15, railPosition.GetDistanceToNextNode());
                var remainingDistance = railPosition.MoveForward(6); // 6すすむ（ノードEに近づく）
                Assert.AreEqual(9, railPosition.GetDistanceToNextNode());
                Assert.AreEqual(0, remainingDistance);

                list = railPosition.TestGet_railNodes();//後輪が完全にB-C間にいるためノードAの情報は削除される
                Assert.AreEqual(4, list.Count);
                Assert.AreEqual(nodeE2, list[0]);
                Assert.AreEqual(nodeD2, list[1]);
                Assert.AreEqual(nodeC2, list[2]);
                Assert.AreEqual(nodeB2, list[3]);
            }

            { //MoveForward(マイナス)を使うパターン
                // 長い列車（列車長50）をノードAからEにまたがる状態に配置
                var nodes = new List<RailNode> { nodeA1, nodeB1, nodeC1, nodeD1, nodeE1 };
                var railPosition = new RailPosition(nodes, 50, 5); // 先頭はノードAとBの間の5地点

                //進む、残りの進むべき距離
                var remainingDistance = railPosition.MoveForward(-11); // 11後退（ノードEに近づく）

                Assert.AreEqual(6, railPosition.GetDistanceToNextNode()); //
                Assert.AreEqual(nodeB1, railPosition.GetNodeApproaching()); // nodeAまで5のところから11後退してる
                Assert.AreEqual(nodeC1, railPosition.GetNodeJustPassed()); // 

                var list = railPosition.TestGet_railNodes(); Assert.AreEqual(4, list.Count);
                Assert.AreEqual(nodeB1, list[0]);
                Assert.AreEqual(nodeC1, list[1]);
                Assert.AreEqual(nodeD1, list[2]);
                Assert.AreEqual(nodeE1, list[3]);
            }
        }

    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaElectricMachineComponent.cs
```cs
using Game.Block.Interface;
using Game.EnergySystem;

namespace Game.Block.Blocks.Machine
{
    /// <summary>
    ///     機械を表すクラス
    /// </summary>
    public class VanillaElectricMachineComponent : IElectricConsumer
    {
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        
        public VanillaElectricMachineComponent(BlockInstanceId blockInstanceId, VanillaMachineProcessorComponent vanillaMachineProcessorComponent)
        {
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
            BlockInstanceId = blockInstanceId;
        }
        public BlockInstanceId BlockInstanceId { get; }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        #region IBlockElectric implementation
        
        public ElectricPower RequestEnergy => _vanillaMachineProcessorComponent.RequestPower;
        
        public void SupplyEnergy(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            
            _vanillaMachineProcessorComponent.SupplyPower(power);
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs
```cs
using System.Collections.Generic;

namespace Game.Train.Train
{
    /// <summary>
    /// 列車一編成を表すクラス
    /// 現在地はRailPositionという抽象的なクラスで表すことに注意
    /// 
    /// </summary>
    public class TrainUnit
    {
        // 列車の編成
        private List<TrainCar> _trainFormation;
        private int _currentSpeed;
        private bool _isRunning;

        // 車両を追加
        public void AddTrainCar(TrainCar trainCar)
        {
        }

        // 列車全体の速度を計算
        public void CalcSpeed(int speed)
        {
            _currentSpeed = speed;
        }

    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/OpenableInventoryBlock.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.BlockSystem
{
    //todo これをオミットしてIDからチェックできるようにする
    public class OpenableInventoryBlock : MonoBehaviour
    {
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/ChestLogicTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Blocks.Chest;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Random = System.Random;

namespace Tests.CombinedTest.Core
{
    public class ChestLogicTest
    {
        //ベルトコンベアからアイテムを搬入する
        [Test]
        public void BeltConveyorInsertChestLogicTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var random = new Random(4123);
            
            var id = new ItemId(random.Next(1, 11));
            var count = 1;
            var item = itemStackFactory.Create(id, count);
            
            var chest = blockFactory.Create(ForUnitTestModBlockId.ChestId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var chestComponent = chest.GetComponent<VanillaChestComponent>();
            
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            beltConveyorComponent.InsertItem(item);
            
            var beltConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            beltConnectInventory.Add(chestComponent, new ConnectedInfo());
            
            
            while (!chestComponent.GetItem(0).Equals(item)) GameUpdater.UpdateWithWait();
            
            Assert.True(chestComponent.GetItem(0).Equals(item));
        }
        
        [Test]
        public void BeltConveyorOutputChestLogicTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            
            var chest = blockFactory.Create(ForUnitTestModBlockId.ChestId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var chestComponent = chest.GetComponent<VanillaChestComponent>();
            
            var beltconveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltconveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            chestComponent.SetItem(0, new ItemId(1), 1);
            
            var chestConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)chest.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            chestConnectInventory.Add(beltConveyorComponent, new ConnectedInfo());
            GameUpdater.UpdateWithWait();
            
            
            Assert.AreEqual(chestComponent.GetItem(0).Count, 0);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/MachineBlockInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class MachineBlockInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform machineInputItemParent;
        [SerializeField] private RectTransform machineOutputItemParent;
        [SerializeField] private TMP_Text machineBlockNameText;
        
        [SerializeField] private ProgressArrowView machineProgressArrow;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            
            var itemList = new List<IItemStack>();
            
            // GearMachineParamとElectricMachineParamを共通して使える
            var param = blockGameObject.BlockMasterElement.BlockParam as IMachineParam;
            
            
            for (var i = 0; i < param.InputSlotCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, machineInputItemParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            for (var i = 0; i < param.OutputSlotCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, machineOutputItemParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            machineBlockNameText.text = blockGameObject.BlockMasterElement.Name;
            UpdateItemList(itemList);
        }
        
        private void Update()
        {
            // ここが重かったら検討
            var commonProcessor = (CommonMachineBlockStateChangeProcessor)_blockGameObject.BlockStateChangeProcessors.FirstOrDefault(x => x as CommonMachineBlockStateChangeProcessor);
            if (commonProcessor == null) return;
            
            machineProgressArrow.SetProgress(commonProcessor.CurrentMachineState?.ProcessingRate ?? 0.0f);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/ItemShooter/ItemShooterComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Block.Blocks.ItemShooter
{
    public class ItemShooterComponent : IItemCollectableBeltConveyor, IBlockInventory, IBlockSaveState, IUpdatableBlockComponent
    {
        public BeltConveyorSlopeType SlopeType { get; }
        public IReadOnlyList<IOnBeltConveyorItem> BeltConveyorItems => _inventoryItems;
        private readonly ShooterInventoryItem[] _inventoryItems;
        
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        private readonly ItemShooterBlockParam _itemShooterBlockParam;
        private const float InsertItemInterval = 1f; // TODO to master
        
        private float _lastInsertElapsedTime = float.MaxValue;
        
        public ItemShooterComponent(BlockConnectorComponent<IBlockInventory> blockConnectorComponent, ItemShooterBlockParam itemShooterBlockParam)
        {
            _blockConnectorComponent = blockConnectorComponent;
            _itemShooterBlockParam = itemShooterBlockParam;
            SlopeType = itemShooterBlockParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            
            _inventoryItems = new ShooterInventoryItem[_itemShooterBlockParam.InventoryItemNum];
        }
        
        public ItemShooterComponent(Dictionary<string, string> componentStates, BlockConnectorComponent<IBlockInventory> blockConnectorComponent, ItemShooterBlockParam itemShooterBlockParam) :
            this(blockConnectorComponent, itemShooterBlockParam)
        {
            var items = JsonConvert.DeserializeObject<List<ItemShooterItemJsonObject>>(componentStates[SaveKey]);
            for (var i = 0; i < items.Count; i++)
            {
                var item = items[i];
                if (item.ItemStackSave == null) continue;
                
                var id = MasterHolder.ItemMaster.GetItemId(item.ItemStackSave.ItemGuid);
                _inventoryItems[i] = new ShooterInventoryItem(id, ItemInstanceId.Create(), (float)item.CurrentSpeed)
                {
                    RemainingPercent = (float)items[i].RemainingPercent
                };
            }
        }
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            _lastInsertElapsedTime += (float)GameUpdater.UpdateSecondTime;
            var count = _inventoryItems.Length;
            
            for (var i = 0; i < count; i++)
            {
                var item = _inventoryItems[i];
                if (item == null) continue;
                
                if (item.RemainingPercent <= 0)
                {
                    var insertItem = ServerContext.ItemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
                    
                    if (_blockConnectorComponent.ConnectedTargets.Count == 0) continue;
                    
                    var connector = _blockConnectorComponent.ConnectedTargets.First();
                    var target = connector.Key;
                    if (target is ItemShooterComponent shooter)
                    {
                        _inventoryItems[i] = shooter.InsertItemFromShooter(item);
                    }
                    else
                    {
                        var output = connector.Key.InsertItem(insertItem);
                        
                        //渡した結果がnullItemだったらそのアイテムを消す
                        if (output.Id == ItemMaster.EmptyItemId) _inventoryItems[i] = null;
                    }
                    
                    continue;
                }
                
                //時間を減らす
                var deltaTime = (float)GameUpdater.UpdateSecondTime; // floatとdobuleが混在しているの気持ち悪いから改善したい
                item.RemainingPercent -= deltaTime * _itemShooterBlockParam.ItemShootSpeed * item.CurrentSpeed;
                item.RemainingPercent = Math.Clamp(item.RemainingPercent, 0, 1);
                
                // velocityを更新する
                item.CurrentSpeed += _itemShooterBlockParam.Acceleration * deltaTime;
                item.CurrentSpeed = Mathf.Clamp(item.CurrentSpeed, 0, float.MaxValue);
            }
        }
        
        private ShooterInventoryItem InsertItemFromShooter(ShooterInventoryItem inventoryItem)
        {
            BlockException.CheckDestroy(this);
            
            for (var i = 0; i < _inventoryItems.Length; i++)
            {
                if (_inventoryItems[i] != null) continue;
                
                _inventoryItems[i] = inventoryItem;
                _inventoryItems[i].RemainingPercent = 1;
                return null;
            }
            
            return inventoryItem;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            // インサート間隔をチェック
            if (_lastInsertElapsedTime < InsertItemInterval) return itemStack;
            
            // インサート可能なスロットに挿入
            for (var i = 0; i < _inventoryItems.Length; i++)
            {
                if (_inventoryItems[i] != null) continue;
                
                _inventoryItems[i] = new ShooterInventoryItem(itemStack.Id, itemStack.ItemInstanceId, _itemShooterBlockParam.InitialShootSpeed);
                //挿入したのでアイテムを減らして返す
                _lastInsertElapsedTime = 0;
                return itemStack.SubItem(1);
            }
            
            return itemStack;
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            // 空きスロットがあるかどうか
            var nullCount = 0;
            foreach (var inventoryItem in _inventoryItems)
            {
                if (inventoryItem == null) nullCount++;
            }
            // 挿入可能スロットがない
            if (nullCount == 0) return false;
            
            // 挿入スロットが1個かどうか
            if (itemStacks.Count == 1 && itemStacks[0].Count == 1) return true;
            
            return false;
        }
        
        public IItemStack GetItem(int slot)
        {
            var itemStackFactory = ServerContext.ItemStackFactory;
            var item = _inventoryItems[slot];
            return item == null ? itemStackFactory.CreatEmpty() : itemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            _inventoryItems[slot] = new ShooterInventoryItem(itemStack.Id, itemStack.ItemInstanceId, _itemShooterBlockParam.InitialShootSpeed);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _inventoryItems.Length;
        }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public string SaveKey { get; } = typeof(ItemShooterComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            var items = _inventoryItems.Select(item => new ItemShooterItemJsonObject(item)).ToList();
            return JsonConvert.SerializeObject(items);
        }
    }
    
    public class ItemShooterItemJsonObject
    {
        [JsonProperty("itemStack")] public ItemStackSaveJsonObject ItemStackSave;
        
        [JsonProperty("remainingTime")] public double RemainingPercent;
        
        [JsonProperty("currentSpeed")] public double CurrentSpeed;
        
        public ItemShooterItemJsonObject(ShooterInventoryItem shooterInventoryItem)
        {
            if (shooterInventoryItem == null)
            {
                ItemStackSave = null;
                RemainingPercent = 0;
                CurrentSpeed = 0;
                return;
            }
            
            var item = ServerContext.ItemStackFactory.Create(shooterInventoryItem.ItemId, 1);
            ItemStackSave = new ItemStackSaveJsonObject(item);
            RemainingPercent = shooterInventoryItem.RemainingPercent;
            CurrentSpeed = shooterInventoryItem.CurrentSpeed;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/CollectBeltConveyorItemsTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Entity.Interface;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Server
{
    public class CollectBeltConveyorItemsTest
    {
        //4秒で入って出るベルトコンベアで残り1秒で出る時の座標が正しいかどうかをテストする
        private const double RemainingTime = 0.5;
        private const int ItemInstanceId = 100;
        
        private readonly List<Vector2Int> _plusPlayerCoordinate = new() { new Vector2Int(0, 0) };
        
        /// <summary>
        ///     各方向に向いたベルトコンベア内のアイテムの位置が正しいかどうかをチェックする
        /// </summary>
        [Test]
        public void BlockDirectionItemPositionTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldDataStore = ServerContext.WorldBlockDatastore;
            var entityFactory = serviceProvider.GetService<IEntityFactory>();
            
            //x,yがともにプラスの時のテスト 
            
            //北向きに設置
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.North, worldDataStore);
            
            //エンティティを取得
            var itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            const float defaultY = CollectBeltConveyorItems.DefaultBeltConveyorHeight;
            Assert.AreEqual(0.5, itemEntity.Position.x); //0,0に設置してベルトコンベアの中心にアイテムがあるため、Z座標は0.5となる 
            Assert.AreEqual(defaultY, itemEntity.Position.y); //2次元座標から3次元座標に変換されているため、Y座標は0となる
            Assert.AreEqual(0.75, itemEntity.Position.z); //4秒のベルトコンベアで残り1秒の時の座標のため、1の3/4の位置にある
            //エンティティを検証
            Assert.AreEqual(ItemInstanceId, itemEntity.InstanceId.AsPrimitive());
            Assert.AreEqual(VanillaEntityType.VanillaItem, itemEntity.EntityType);
            
            
            //東向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.East, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(0.75, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.5, itemEntity.Position.z);
            
            
            //ブロックを削除し南向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.South, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.25, itemEntity.Position.z);
            
            
            //ブロックを削除し西向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.West, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //ブロックを削除し座標を検証
            Assert.AreEqual(0.25, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.5, itemEntity.Position.z);
            
            
            //x、yがマイナスであるときのテスト
            //北向きに設
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.North, worldDataStore);
            
            //エンティティを取得
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(-0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.25, itemEntity.Position.z); //ブロックの座標がマイナスなので-1を原点として3/4の値である-0.25となる
            
            
            //東向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.East, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(-0.25, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.5, itemEntity.Position.z);
            
            
            //ブロックを削除し南向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.South, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //座標を検証
            Assert.AreEqual(-0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.75, itemEntity.Position.z);
            
            
            //ブロックを削除し西向きに設置
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.West, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //ブロックを削除し座標を検証
            Assert.AreEqual(-0.75, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.5, itemEntity.Position.z);
        }
        
        
        /// <summary>
        ///     ベルトコンベアから別のベルトコンベアに移ってもInstanceIdは変化しないことをテスト
        /// </summary>
        [Test]
        public void ItemInstanceIdTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldDataStore = ServerContext.WorldBlockDatastore;
            
            worldDataStore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(0, 0, 1), BlockDirection.North, out var belt2);
            //二つのベルトコンベアを繋がるように設置
            
            var belt1 = CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.North, worldDataStore);
            
            //4秒間アップデートする
            var now = DateTime.Now;
            while (DateTime.Now - now < TimeSpan.FromSeconds(RemainingTime * 1.1)) GameUpdater.UpdateWithWait();
            
            //ベルトコンベアからアイテムを取得
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventory2Items = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(belt2.GetComponent<VanillaBeltConveyorComponent>());
            
            //InstanceIdが変化していないことを検証
            Assert.AreEqual(ItemInstanceId, inventory2Items[3].ItemInstanceId.AsPrimitive());
        }
        
        
        private IBlock CreateOneItemInsertedItem(Vector3Int pos, BlockDirection blockDirection, IWorldBlockDatastore datastore)
        {
            datastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, pos, blockDirection, out var beltConveyor);
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            //リフレクションで_inventoryItemsを取得
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(beltConveyorComponent);
            
            inventoryItems[0] = new VanillaBeltConveyorInventoryItem(new ItemId(1), new ItemInstanceId(ItemInstanceId));
            inventoryItems[1] = null;
            inventoryItems[2] = null;
            inventoryItems[3] = null;
            
            inventoryItems[0].RemainingPercent = 0.25f;
            
            return beltConveyor;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MachineRecipesMaster.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Mooresmaster.Loader.MachineRecipesModule;
using Mooresmaster.Model.MachineRecipesModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class MachineRecipesMaster
    {
        public readonly MachineRecipes MachineRecipes; // TODO 個々の使用箇所をメソッドか
        private readonly Dictionary<string, MachineRecipeMasterElement> _machineRecipesByRecipeKey;
        
        public MachineRecipesMaster(JToken jToken)
        {
            MachineRecipes = MachineRecipesLoader.Load(jToken);
            
            _machineRecipesByRecipeKey = new Dictionary<string, MachineRecipeMasterElement>();
            BuildMachineRecipes();
            
            #region Internal
            
            void BuildMachineRecipes()
            {
                foreach (var recipe in MachineRecipes.Data)
                {
                    var inputItemIds = new List<ItemId>();
                    foreach (var inputItem in recipe.InputItems)
                    {
                        var itemId = MasterHolder.ItemMaster.GetItemId(inputItem.ItemGuid);
                        inputItemIds.Add(itemId);
                    }
                    
                    var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
                    
                    var key = GetRecipeElementKey(blockId, inputItemIds);
                    _machineRecipesByRecipeKey.Add(key, recipe);
                }
            }
            
            #endregion
        }
        
        public bool TryGetRecipeElement(BlockId blockId, List<ItemId> inputItemIds, out MachineRecipeMasterElement recipe)
        {
            var key = GetRecipeElementKey(blockId, inputItemIds);
            return _machineRecipesByRecipeKey.TryGetValue(key, out recipe);
        }
        
        public MachineRecipeMasterElement GetRecipeElement(Guid machineRecipeGuid)
        {
            return MachineRecipes.Data.ToList().Find(x => x.MachineRecipeGuid == machineRecipeGuid);
        }
        
        private static string GetRecipeElementKey(BlockId blockId, List<ItemId> itemIds)
        {
            StringBuilder items = new StringBuilder();
            items.Append(blockId);
            
            itemIds.Sort((a, b) => a.AsPrimitive() - b.AsPrimitive());
            itemIds.ForEach(i =>
            {
                items.Append('_');
                items.Append(i.AsPrimitive());
            });
            
            return items.ToString();
        }
    }
    
    public static class MachineRecipeMasterExtension
    {
        public static ItemId GetBlockItemId(this MachineRecipeMasterElement recipe)
        {
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            return MasterHolder.BlockMaster.GetItemId(blockId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Train/TrainCar.cs
```cs
namespace Game.Train.Train
{
    public class TrainCar
    {
        // 駆動力 (動力車での推進力、貨車では0)
        public int TractionForce { get; private set; }

        // インベントリスロット数 (貨車での容量、動力車では0?)
        public int InventorySlots { get; private set; }

        public TrainCar(int tractionForce, int inventorySlots)
        {
            TractionForce = tractionForce;
            InventorySlots = inventorySlots;
        }

    }

}

```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaMachineSaveComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Newtonsoft.Json;

namespace Game.Block.Blocks.Machine
{
    public class VanillaMachineSaveComponent : IBlockSaveState
    {
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        
        public VanillaMachineSaveComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            VanillaMachineProcessorComponent vanillaMachineProcessorComponent)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
        }
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        [Obsolete("機械のセーブ周りのリファクタをしたい")] // TODO 機械のセーブ、保存周りのリファクタ
        public static string SaveKeyStatic => typeof(VanillaMachineSaveComponent).FullName;
        public string SaveKey { get; } = typeof(VanillaMachineSaveComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            // JsonObjectにリファクタ
            var jsonObject = new VanillaMachineJsonObject
            {
                InputSlot = _vanillaMachineInputInventory.InputSlot.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
                OutputSlot = _vanillaMachineOutputInventory.OutputSlot.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
                State = (int)_vanillaMachineProcessorComponent.CurrentState,
                RemainingTime = _vanillaMachineProcessorComponent.RemainingSecond,
                RecipeGuidStr = _vanillaMachineProcessorComponent.RecipeGuid.ToString(),
            };
            
            return JsonConvert.SerializeObject(jsonObject);
        }
    }
    
    public class VanillaMachineJsonObject
    {
        [JsonProperty("inputSlot")]
        public List<ItemStackSaveJsonObject> InputSlot;
        [JsonProperty("outputSlot")]
        public List<ItemStackSaveJsonObject> OutputSlot;
        [JsonProperty("recipeGuid")]
        public string RecipeGuidStr;
        [JsonIgnore]
        public Guid RecipeGuid => Guid.Parse(RecipeGuidStr);
        
        [JsonProperty("remainingTime")]
        public double RemainingTime;
        
        [JsonProperty("state")]
        public int State;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/CommonMachineBlockStateChangeProcessor.cs
```cs
using System;
using Game.Block.Blocks.Machine;
using Game.Block.Interface.State;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    /// <summary>
    /// TODO マシーン系は自動でつけるみたいなシステムが欲しいな、、、
    /// </summary>
    public class CommonMachineBlockStateChangeProcessor : MonoBehaviour, IBlockStateChangeProcessor
    {
        public CommonMachineBlockStateDetail CurrentMachineState { get; private set; }
        
        
        private void Awake()
        {
        }
        
        private void Start()
        {

        }
        
        
        public void OnChangeState(BlockStateMessagePack blockState)
        {
            CurrentMachineState = blockState.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            var currentState = CurrentMachineState.CurrentStateType;
            var previousState = CurrentMachineState.PreviousStateType;
            
            switch (currentState)
            {
                case VanillaMachineBlockStateConst.ProcessingState:
                    if (previousState == VanillaMachineBlockStateConst.IdleState)
                    {
                    }
                    
                    break;
                case VanillaMachineBlockStateConst.IdleState:
                    break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/GearMachineSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Game.PlayerInventory;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class GearMachineSaveLoadTest
    {
        //ギア機械のインベントリのあるブロックを追加した時のテスト
        //レシピやブロックが変わった時はテストコードを修正してください
        [Test]
        public void InventoryBlockTest()
        {
            //機械の追加
            var (blockFactory, worldBlockDatastore, _, assembleSaveJsonText, _) = CreateBlockTestModule();
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GearMachine, new Vector3Int(0, 0), BlockDirection.North, out var gearMachineBlock);
            var machineInventory = gearMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            
            //レシピ用のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(1), 3));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 1));
            
            //処理を開始
            gearMachineBlock.GetComponent<GearEnergyTransformer>().SupplyPower(new RPM(1000), new Torque(1000), true);
            GameUpdater.UpdateWithWait();
            //別のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(5), 6));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 4));
            
            //リフレクションで機械の状態を設定
            //機械のレシピの残り時間設定
            var vanillaMachineProcessor = gearMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            //ステータスをセット
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("RemainingSecond")
                .SetValue(vanillaMachineProcessor, 0.3);
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("CurrentState")
                .SetValue(vanillaMachineProcessor, ProcessState.Processing);
            
            //機械のアウトプットスロットの設定
            var outputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(machineInventory);
            
            outputInventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            outputInventory.SetItem(2, itemStackFactory.Create(new ItemId(3), 2));
            
            //レシピIDを取得
            var recipeId = vanillaMachineProcessor.RecipeGuid;
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            //配置したブロックを削除
            worldBlockDatastore.RemoveBlock(new Vector3Int(0, 0));
            
            
            //ロードした時に機械の状態が正しいことを確認
            var (_, loadWorldBlockDatastore, _, _, loadJsonFile) = CreateBlockTestModule();
            
            loadJsonFile.Load(json);
            
            var loadMachineBlock = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            
            //ブロックID、intIDが同じであることを確認
            Assert.AreEqual(gearMachineBlock.BlockId, loadMachineBlock.BlockId);
            Assert.AreEqual(gearMachineBlock.BlockInstanceId, loadMachineBlock.BlockInstanceId);
            
            
            //機械のレシピの残り時間のチェック
            var machineProcessor = loadMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            Assert.AreEqual(0.3, machineProcessor.RemainingSecond);
            //レシピIDのチェック
            Assert.AreEqual(recipeId, machineProcessor.RecipeGuid);
            //機械のステータスのチェック
            Assert.AreEqual(ProcessState.Processing, machineProcessor.CurrentState);
            
            
            var loadMachineInventory = loadMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            //インプットスロットのチェック
            var inputInventoryField = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(5), 6), inputInventoryField.InputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 4), inputInventoryField.InputSlot[1]);
            
            //アウトプットスロットのチェック
            var outputInventoryField = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.CreatEmpty(), outputInventoryField.OutputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 1), outputInventoryField.OutputSlot[1]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), outputInventoryField.OutputSlot[2]);
        }
        
        private (IBlockFactory, IWorldBlockDatastore, PlayerInventoryDataStore, AssembleSaveJsonText, WorldLoaderFromJson)
            CreateBlockTestModule()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var playerInventoryDataStore = serviceProvider.GetService<PlayerInventoryDataStore>();
            var loadJsonFile = serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson;
            
            return (blockFactory, worldBlockDatastore, playerInventoryDataStore, assembleSaveJsonText, loadJsonFile);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineOutputInventory.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Service;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Context;
using Mooresmaster.Model.MachineRecipesModule;
using UniRx;

namespace Game.Block.Blocks.Machine.Inventory
{
    public class VanillaMachineOutputInventory
    {
        public IReadOnlyList<IItemStack> OutputSlot => _itemDataStoreService.InventoryItems;
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly ConnectingInventoryListPriorityInsertItemService _connectInventoryService;
        private readonly BlockInstanceId _blockInstanceId;
        
        private readonly int _inputSlotSize;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        public VanillaMachineOutputInventory(int outputSlot, IItemStackFactory itemStackFactory,
            BlockOpenableInventoryUpdateEvent blockInventoryUpdate, BlockInstanceId blockInstanceId, int inputSlotSize, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockInventoryUpdate = blockInventoryUpdate;
            _blockInstanceId = blockInstanceId;
            _inputSlotSize = inputSlotSize;
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, itemStackFactory, outputSlot);
            _connectInventoryService = new ConnectingInventoryListPriorityInsertItemService(blockConnectorComponent);
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        private void Update()
        {
            InsertConnectInventory();
        }
        
        /// <summary>
        ///     アウトプットスロットにアイテムを入れれるかチェック
        /// </summary>
        /// <param name="machineRecipe"></param>
        /// <returns>スロットに空きがあったらtrue</returns>
        public bool IsAllowedToOutputItem(MachineRecipeMasterElement machineRecipe)
        {
            foreach (var itemOutput in machineRecipe.OutputItems)
            {
                var outputItemId = MasterHolder.ItemMaster.GetItemId(itemOutput.ItemGuid);
                var outputItemStack = ServerContext.ItemStackFactory.Create(outputItemId, itemOutput.Count);
                
                var isAllowed = OutputSlot.Aggregate(false, (current, slot) => slot.IsAllowedToAdd(outputItemStack) || current);
                
                if (!isAllowed) return false;
            }
            
            return true;
        }
        
        public void InsertOutputSlot(MachineRecipeMasterElement machineRecipe)
        {
            //アウトプットスロットにアイテムを格納する
            foreach (var itemOutput in machineRecipe.OutputItems)
                for (var i = 0; i < OutputSlot.Count; i++)
                {
                    var outputItemId = MasterHolder.ItemMaster.GetItemId(itemOutput.ItemGuid);
                    var outputItemStack = ServerContext.ItemStackFactory.Create(outputItemId, itemOutput.Count);
                    
                    if (!OutputSlot[i].IsAllowedToAdd(outputItemStack)) continue;
                    
                    var item = OutputSlot[i].AddItem(outputItemStack).ProcessResultItemStack;
                    _itemDataStoreService.SetItem(i, item);
                    break;
                }
        }
        
        private void InsertConnectInventory()
        {
            for (var i = 0; i < OutputSlot.Count; i++)
                _itemDataStoreService.SetItem(i, _connectInventoryService.InsertItem(OutputSlot[i]));
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(
                _blockInstanceId, slot + _inputSlotSize, itemStack));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockInventory.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Block.Interface.ComponentAttribute;

namespace Game.Block.Interface.Component
{
    /// <summary>
    ///     ベルトコンベアに乗っているアイテムを機械に入れたり、機械からベルトコンベアにアイテムを載せるなどの処理をするための共通インターフェース
    ///     ブロック同士でアイテムをやり取りしたいときに使う
    /// </summary>
    [DisallowMultiple]
    public interface IBlockInventory : IBlockComponent
    {
        public IItemStack InsertItem(IItemStack itemStack);
        public bool InsertionCheck(List<IItemStack> itemStacks);
        
        public IItemStack GetItem(int slot);
        void SetItem(int slot, IItemStack itemStack);
        public int GetSlotSize();
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearMachineIoTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.MachineRecipesModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class GearMachineIoTest
    {
        public int GearMachineRecipeIndex = 3;
        
        //アイテムが通常通り処理されるかのテスト
        [Test]
        public void ItemProcessingOutputTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[GearMachineRecipeIndex];
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var block = blockFactory.Create(blockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var blockInventory = block.GetComponent<VanillaMachineBlockInventoryComponent>();
            foreach (var inputItem in recipe.InputItems)
            {
                blockInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var gearEnergyTransformer = block.GetComponent<GearEnergyTransformer>();
            var gearMachineParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearMachine).BlockParam as GearMachineBlockParam;
            var machineProcessor = block.GetComponent<VanillaMachineProcessorComponent>();
            
            //最大クラフト時間を超過するまでクラフトする
            var craftTime = DateTime.Now.AddSeconds(recipe.Time);
            while (craftTime.AddSeconds(0.4).CompareTo(DateTime.Now) == 1)
            {
                var requiredRpm = new RPM(gearMachineParam.RequiredRpm);
                var requiredTorque = new Torque(gearMachineParam.RequireTorque);
                gearEnergyTransformer.SupplyPower(requiredRpm, requiredTorque, true);
                machineProcessor.Update();
                GameUpdater.Wait();
                GameUpdater.UpdateDeltaTime();
            }
            
            //検証
            AssertInventory(blockInventory, recipe);
        }
        
        
        [Test]
        // RPM、トルクが足りないときに処理に時間がかかるテスト
        public void NotEnoughTorqueOrRpmTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[GearMachineRecipeIndex];
            
            var recipeBlockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var lackRpmBlock = blockFactory.Create(recipeBlockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var lackTorqueBlock = blockFactory.Create(recipeBlockId, new BlockInstanceId(2), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.zero));
            
            var lackRpmInventory = lackRpmBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            var lackTorqueInventory = lackTorqueBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            foreach (var inputItem in recipe.InputItems)
            {
                lackRpmInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
                lackTorqueInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var lackRpmGearMachine = lackRpmBlock.GetComponent<GearEnergyTransformer>();
            var lackTorqueGearMachine = lackTorqueBlock.GetComponent<GearEnergyTransformer>();
            var gearMachineParam = lackRpmBlock.BlockMasterElement.BlockParam as GearMachineBlockParam;
            
            var lackRpmProcessor = lackRpmBlock.GetComponent<VanillaMachineProcessorComponent>();
            var lackTorqueProcessor = lackTorqueBlock.GetComponent<VanillaMachineProcessorComponent>();
            
            //最大クラフト時間を超過するまでクラフトする
            var craftTime = DateTime.Now.AddSeconds(recipe.Time * 2);
            while (craftTime.AddSeconds(0.3).CompareTo(DateTime.Now) == 1)
            {
                var rpm = new RPM(gearMachineParam.RequiredRpm / 2f);
                lackRpmGearMachine.SupplyPower(rpm, new Torque(gearMachineParam.RequireTorque), true);
                lackTorqueGearMachine.SupplyPower(new RPM(gearMachineParam.RequiredRpm), (Torque)gearMachineParam.RequireTorque / 2f, true);
                
                lackRpmProcessor.Update();
                lackTorqueProcessor.Update();
                
                GameUpdater.Wait();
                GameUpdater.UpdateDeltaTime();
            }
            
            //検証
            AssertInventory(lackRpmInventory, recipe);
            AssertInventory(lackTorqueInventory, recipe);
        }
        
        private void AssertInventory(VanillaMachineBlockInventoryComponent inventory, MachineRecipeMasterElement recipe)
        {
            (List<IItemStack> input, List<IItemStack> output) = GetInputOutputSlot(inventory);
            
            Assert.AreEqual(0, input.Count);
            foreach (var inputItem in input) Assert.AreEqual(ItemMaster.EmptyItemId, inputItem.Id);
            
            Assert.AreNotEqual(0, output.Count);
            for (var i = 0; i < output.Count; i++)
            {
                var outputItemId = MasterHolder.ItemMaster.GetItemId(recipe.OutputItems[i].ItemGuid);
                Assert.AreEqual(outputItemId, output[i].Id);
                Assert.AreEqual(recipe.OutputItems[i].Count, output[i].Count);
            }
        }
        
        private (List<IItemStack>, List<IItemStack>) GetInputOutputSlot(VanillaMachineBlockInventoryComponent vanillaMachineInventory)
        {
            var vanillaMachineInputInventory = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            var vanillaMachineOutputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            
            var inputSlot = vanillaMachineInputInventory.InputSlot.Where(i => i.Count != 0).ToList();
            inputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            var outputSlot = vanillaMachineOutputInventory.OutputSlot.Where(i => i.Count != 0).ToList();
            outputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            return (inputSlot, outputSlot);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearBeltConveyorTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlockConnectInfoModule;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class GearBeltConveyorTest
    {
        // トルクの供給率が100%のとき、指定した時間でアイテムが出てくるテスト
        [Test]
        public void OutputTestWhenTorqueSuppliedRateIs100()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            const int id = 2;
            const int count = 3;
            var item = itemStackFactory.Create(new ItemId(id), count);
            var dummy = new DummyBlockInventory();
            
            
            // gearBeltConveyorブロックを生成
            var gearBeltConveyorPosition = new Vector3Int(0, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GearBeltConveyor, gearBeltConveyorPosition, BlockDirection.North, out var gearBeltConveyor);
            var beltConveyorComponent = gearBeltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)gearBeltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            connectInventory.Add(dummy, new ConnectedInfo());
            
            // generatorブロックを作成
            var generatorPosition = new Vector3Int(1, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.East, out var generator);
            
            // testGearブロックを作成
            var testGearPosition = new Vector3Int(2, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, testGearPosition, BlockDirection.East, out var testGear);
            
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            IReadOnlyDictionary<GearNetworkId, GearNetwork> gearNetwork = gearNetworkDatastore.GearNetworks;
            
            
            const int torqueRate = 1;
            const int generatorRpm = 10;
            var gearBeltConveyorBlockParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearBeltConveyor).BlockParam as GearBeltConveyorBlockParam;
            var duration = 1f / (generatorRpm * torqueRate * gearBeltConveyorBlockParam.BeltConveyorSpeed);
            var expectedEndTime = DateTime.Now.AddSeconds(duration);
            var startTime = DateTime.Now;
            beltConveyorComponent.InsertItem(item);
            
            // for (var i = 0; i < 100; i++)
            // {
            //     GameUpdater.UpdateWithWait();
            // }
            var c = 0;
            while (!dummy.IsItemExists)
            {
                c++;
                GameUpdater.UpdateWithWait();
                var elapsed = DateTime.Now - startTime;
                if (elapsed.TotalSeconds > 20) Assert.Fail();
            }
            
            Assert.True(dummy.IsItemExists);
            
            var now = DateTime.Now;
            Debug.Log($"{now} {expectedEndTime}\n{(now - startTime).TotalSeconds}\n{(expectedEndTime - now).TotalSeconds}\n{duration}\n{c}");
            Assert.True(now <= expectedEndTime.AddSeconds(0.4));
            Assert.True(expectedEndTime.AddSeconds(-0.4) <= now);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/Util/ItemRecipeViewerDataContainer.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Mooresmaster.Model.CraftRecipesModule;
using Mooresmaster.Model.MachineRecipesModule;

namespace Game.CraftChainer.Util
{
    // TODO クラフトレシピ改善時にこれを使う
    public class ItemRecipeViewerDataContainer
    {
        private readonly Dictionary<ItemId, RecipeViewerItemRecipes> _recipeViewerElements = new();
        
        public ItemRecipeViewerDataContainer()
        {
            // そのアイテムを作成するための機械のレシピを取得
            // Get the recipe of the machine to create the item
            var machineRecipeDictionary = new Dictionary<ItemId, List<MachineRecipeMasterElement>>();
            foreach (var machineRecipeMaster in MasterHolder.MachineRecipesMaster.MachineRecipes.Data)
            {
                foreach (var outputItem in machineRecipeMaster.OutputItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(outputItem.ItemGuid);
                    if (!machineRecipeDictionary.ContainsKey(itemId))
                    {
                        machineRecipeDictionary.Add(itemId, new List<MachineRecipeMasterElement>());
                    }
                    
                    machineRecipeDictionary[itemId].Add(machineRecipeMaster);
                }
            }
            
            // そのアイテムを作成するためのクラフトレシピを取得
            // Get the craft recipe to create the item
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var resultCraftRecipes = MasterHolder.CraftRecipeMaster.GetResultItemCraftRecipes(itemId).ToList();
                
                // そのアイテムを作成するための機械のレシピを機械ごとに作成
                // Create a machine recipe for each machine to create the item
                var resultMachineRecipes = new Dictionary<BlockId, List<MachineRecipeMasterElement>>();
                if (machineRecipeDictionary.TryGetValue(itemId, out var machineRecipesList))
                {
                    foreach (var machineRecipe in machineRecipesList)
                    {
                        var blockId = MasterHolder.BlockMaster.GetBlockId(machineRecipe.BlockGuid);
                        if (resultMachineRecipes.ContainsKey(blockId))
                        {
                            resultMachineRecipes[blockId].Add(machineRecipe);
                        }
                        else
                        {
                            resultMachineRecipes.Add(blockId, new List<MachineRecipeMasterElement> { machineRecipe });
                        }
                    }
                }
                
                _recipeViewerElements.Add(itemId, new RecipeViewerItemRecipes(resultCraftRecipes, resultMachineRecipes, itemId));
            }
            
            // レシピが存在しないアイテムを除外する
            // Exclude items with no recipes
            var removeList = new List<ItemId>();
            foreach (var kv in _recipeViewerElements)
            {
                var itemId = kv.Key;
                var recipe = kv.Value;
                
                if (recipe.CraftRecipes.Count == 0 && recipe.MachineRecipes.Count == 0)
                {
                    removeList.Add(itemId);
                }
            }
            foreach (var itemId in removeList)
            {
                _recipeViewerElements.Remove(itemId);
            }
        }
        
        public RecipeViewerItemRecipes GetItem(ItemId itemId)
        {
            return _recipeViewerElements.GetValueOrDefault(itemId);
        }
    }
    
    public class RecipeViewerItemRecipes
    {
        public readonly ItemId ResultItemId;
        
        //TODO 他のmodの他のレシピにも対応できるようの柔軟性をもたせた設計を考える
        public readonly List<CraftRecipeMasterElement> CraftRecipes;
        public readonly Dictionary<BlockId, List<MachineRecipeMasterElement>> MachineRecipes;
        
        public RecipeViewerItemRecipes(List<CraftRecipeMasterElement> craftRecipes, Dictionary<BlockId, List<MachineRecipeMasterElement>> machineRecipes, ItemId resultItemId)
        {
            CraftRecipes = craftRecipes;
            MachineRecipes = machineRecipes;
            ResultItemId = resultItemId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/MachineSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Assert = UnityEngine.Assertions.Assert;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class MachineSaveLoadTest
    {
        //インベントリのあるブロックを追加した時のテスト
        //レシピやブロックが変わった時はテストコードを修正してください
        [Test]
        public void InventoryBlockTest()
        {
            //機械の追加
            var (blockFactory, worldBlockDatastore, _, assembleSaveJsonText, _) = CreateBlockTestModule();
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId , new Vector3Int(0, 0), BlockDirection.North, out var machineBlock);
            var machineInventory = machineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            
            //レシピ用のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(1), 3));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 1));
            //処理を開始
            GameUpdater.UpdateWithWait();
            //別のアイテムを追加
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(5), 6));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 4));
            
            //リフレクションで機械の状態を設定
            //機械のレシピの残り時間設定
            var vanillaMachineProcessor = machineBlock.GetComponent<VanillaMachineProcessorComponent>();
            //ステータスをセット
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("RemainingSecond")
                .SetValue(vanillaMachineProcessor, 0.3);
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("CurrentState")
                .SetValue(vanillaMachineProcessor, ProcessState.Processing);
            
            //機械のアウトプットスロットの設定
            var outputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(machineInventory);
            
            outputInventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            outputInventory.SetItem(2, itemStackFactory.Create(new ItemId(3), 2));
            
            //レシピIDを取得
            var recipeId = vanillaMachineProcessor.RecipeGuid;
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            //配置したブロックを削除
            worldBlockDatastore.RemoveBlock(new Vector3Int(0, 0));
            
            
            //ロードした時に機械の状態が正しいことを確認
            var (_, loadWorldBlockDatastore, _, _, loadJsonFile) = CreateBlockTestModule();
            
            loadJsonFile.Load(json);
            
            var loadMachineBlock = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            
            //ブロックID、intIDが同じであることを確認
            Assert.AreEqual(machineBlock.BlockId, loadMachineBlock.BlockId);
            Assert.AreEqual(machineBlock.BlockInstanceId, loadMachineBlock.BlockInstanceId);
            
            
            //機械のレシピの残り時間のチェック
            var machineProcessor = loadMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            Assert.AreEqual(0.3, machineProcessor.RemainingSecond);
            //レシピIDのチェック
            Assert.AreEqual(recipeId, machineProcessor.RecipeGuid);
            //機械のステータスのチェック
            Assert.AreEqual(ProcessState.Processing, machineProcessor.CurrentState);
            
            
            var loadMachineInventory = loadMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            //インプットスロットのチェック
            var inputInventoryField = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(5), 6), inputInventoryField.InputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 4), inputInventoryField.InputSlot[1]);
            
            //アウトプットスロットのチェック
            var outputInventoryField = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.CreatEmpty(), outputInventoryField.OutputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 1), outputInventoryField.OutputSlot[1]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), outputInventoryField.OutputSlot[2]);
        }
        
        private (IBlockFactory, IWorldBlockDatastore, PlayerInventoryDataStore, AssembleSaveJsonText, WorldLoaderFromJson)
            CreateBlockTestModule()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var playerInventoryDataStore = serviceProvider.GetService<PlayerInventoryDataStore>();
            var loadJsonFile = serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson;
            
            return (blockFactory, worldBlockDatastore, playerInventoryDataStore, assembleSaveJsonText, loadJsonFile);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineInputInventory.cs
```cs
using System.Collections.Generic;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Event;
using Game.Context;
using Mooresmaster.Model.MachineRecipesModule;

namespace Game.Block.Blocks.Machine.Inventory
{
    /// <summary>
    ///     インプットのインベントリとアウトプットのインベントリを同じように扱う
    ///     Insertなどの処理は基本的にInputのインベントリにのみ行う
    /// </summary>
    public class VanillaMachineInputInventory
    {
        private readonly BlockId _blockId;
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly BlockInstanceId _blockInstanceId;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        public VanillaMachineInputInventory(BlockId blockId, int inputSlot, BlockOpenableInventoryUpdateEvent blockInventoryUpdate, BlockInstanceId blockInstanceId)
        {
            _blockId = blockId;
            _blockInventoryUpdate = blockInventoryUpdate;
            _blockInstanceId = blockInstanceId;
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, inputSlot);
        }
        
        public IReadOnlyList<IItemStack> InputSlot => _itemDataStoreService.InventoryItems;
        
        public bool IsAllowedToStartProcess()
        {
            //ブロックIDと現在のインプットスロットからレシピを検索する
            if (TryGetRecipeElement(out var recipe))
            {
                //実行できるレシピかどうか
                return recipe.RecipeConfirmation(_blockId, InputSlot);
            }
            return false;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return _itemDataStoreService.InsertItem(itemStack);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return _itemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool TryGetRecipeElement(out MachineRecipeMasterElement recipe)
        {
            return MachineRecipeMasterUtil.TryGetRecipeElement(_blockId, InputSlot, out recipe);
        }
        
        public void ReduceInputSlot(MachineRecipeMasterElement recipe)
        {
            //inputスロットからアイテムを減らす
            foreach (var item in recipe.InputItems)
                for (var i = 0; i < InputSlot.Count; i++)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(item.ItemGuid);
                    
                    if (_itemDataStoreService.InventoryItems[i].Id != itemId || item.Count > InputSlot[i].Count) continue;
                    //アイテムを減らす
                    _itemDataStoreService.SetItem(i, InputSlot[i].SubItem(item.Count));
                    break;
                }
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return _itemDataStoreService.InsertionCheck(itemStacks);
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(
                _blockInstanceId, slot, itemStack));
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/BeltConveyorTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;
using Random = System.Random;

namespace Tests.CombinedTest.Core
{
    /// <summary>
    ///     コンフィグが変わったらこのテストを変更に応じて変更してください
    /// </summary>
    public class BeltConveyorTest
    {
        //一定個数以上アイテムが入らないテストした後、正しく次に出力されるかのテスト
        [Test]
        public void FullInsertAndChangeConnectorBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //あまり深い意味はないが取りあえずテストは2回実行する
            {
                var id = new ItemId(random.Next(0, 10));
                
                var item = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount + 1);
                var beltConveyor = ServerContext.BlockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var endTime = DateTime.Now.AddSeconds(beltConveyorParam.TimeOfItemEnterToExit);
                
                while (DateTime.Now < endTime.AddSeconds(0.1))
                {
                    item = beltConveyorComponent.InsertItem(item);
                    GameUpdater.UpdateWithWait();
                }
                
                Assert.AreEqual(item.Count, 1);
                
                var dummy = new DummyBlockInventory();
                
                var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
                connectInventory.Add(dummy, new ConnectedInfo());
                GameUpdater.UpdateWithWait();
                
                Assert.AreEqual(itemStackFactory.Create(id, 1).ToString(), dummy.InsertedItems[0].ToString());
            }
        }
        
        //一個のアイテムが入って正しく搬出されるかのテスト
        [Test]
        public void InsertBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            
            var id = new ItemId(2);
            const int count = 3;
            var item = itemStackFactory.Create(id, count);
            var dummy = new DummyBlockInventory();
            
            // アイテムを挿入
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            connectInventory.Add(dummy, new ConnectedInfo());
            
            var expectedEndTime = DateTime.Now.AddSeconds(beltConveyorParam.TimeOfItemEnterToExit);
            var outputItem = beltConveyorComponent.InsertItem(item);
            
            //5秒以上経過したらループを抜ける 
            while (!dummy.IsItemExists) GameUpdater.UpdateWithWait();
            
            
            //チェック
            Assert.True(DateTime.Now <= expectedEndTime.AddSeconds(0.1));
            Assert.True(expectedEndTime.AddSeconds(-0.1) <= DateTime.Now);
            
            Debug.Log($"{(DateTime.Now - expectedEndTime).TotalSeconds}");
            
            Assert.True(outputItem.Equals(itemStackFactory.Create(id, count - 1)));
            var tmp = itemStackFactory.Create(id, 1);
            Debug.Log($"{tmp} {dummy.InsertedItems[0]}");
            Assert.AreEqual(tmp.ToString(), dummy.InsertedItems[0].ToString());
        }
        
        //ベルトコンベアのインベントリをフルにするテスト
        [Test]
        public void FullInsertBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //あまり深い意味はないが取りあえずテストは2回実行する
            {
                var id = new ItemId(random.Next(1, 11));
                var item = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount + 1);
                var dummy = new DummyBlockInventory(beltConveyorParam.BeltConveyorItemCount);
                var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
                connectInventory.Add(dummy, new ConnectedInfo());
                
                while (!dummy.IsItemExists)
                {
                    item = beltConveyorComponent.InsertItem(item);
                    GameUpdater.UpdateWithWait();
                }
                
                Assert.True(item.Equals(itemStackFactory.Create(id, 0)));
                var tmp = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount);
                Assert.True(dummy.InsertedItems[0].Equals(tmp));
            }
        }
        
        //二つのアイテムが入ったとき、一方しか入らないテスト
        [Test]
        public void Insert2ItemBeltConveyorTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //あまり深い意味はないが取りあえずテストは2回実行する
            {
                //必要な変数を作成
                var item1 = itemStackFactory.Create(new ItemId(random.Next(1, 11)), random.Next(1, 10));
                var item2 = itemStackFactory.Create(new ItemId(random.Next(1, 11)), random.Next(1, 10));
                
                var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId , new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var item1Out = beltConveyorComponent.InsertItem(item1);
                var item2Out = beltConveyorComponent.InsertItem(item2);
                
                Assert.True(item1Out.Equals(item1.SubItem(1)));
                Assert.True(item2Out.Equals(item2));
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/BeltConveyorInsertTest.cs
```cs
using System;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    public class BeltConveyorInsertTest
    {
        //2つのアイテムがチェストから出されてベルトコンベアに入り、全てチェストに入るテスト
        [Test]
        public void TwoItemIoTest()
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //それぞれを設置
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, Vector3Int.zero, BlockDirection.North, out var inputChest);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(0, 0, 1), BlockDirection.North, out var beltConveyor);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 0, 2), BlockDirection.North, out var outputChest);
            
            //インプットチェストにアイテムを2つ入れる
            var inputChestComponent = inputChest.GetComponent<VanillaChestComponent>();
            inputChestComponent.SetItem(0, new ItemId(1), 2);
            
            //ベルトコンベアのアイテムが出てから入るまでの6秒間アップデートする
            var now = DateTime.Now;
            while (DateTime.Now - now < TimeSpan.FromSeconds(5)) GameUpdater.UpdateWithWait();
            
            //アイテムが出ているか確認
            Assert.AreEqual(0, inputChestComponent.GetItem(0).Count);
            //アイテムが入っているか確認
            var outputChestComponent = outputChest.GetComponent<VanillaChestComponent>();
            Assert.AreEqual(2, outputChestComponent.GetItem(0).Count);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/BlockTemplateUtil.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.InventoryConnectsModule;
using Newtonsoft.Json;

namespace Game.Block.Factory.BlockTemplate
{
    public class BlockTemplateUtil
    {
        public static BlockConnectorComponent<IBlockInventory> CreateInventoryConnector(InventoryConnects inventoryConnects, BlockPositionInfo blockPositionInfo)
        {
            return new BlockConnectorComponent<IBlockInventory>(inventoryConnects.InputConnects, inventoryConnects.OutputConnects, blockPositionInfo);
        }
        
        // TODO 保存ステートを誰でも持てるようになったので、このあたりも各自でセーブ、ロードできるように簡略化したい
        public static (VanillaMachineInputInventory, VanillaMachineOutputInventory) GetMachineIOInventory(
            BlockId blockId,BlockInstanceId blockInstanceId,
            IMachineParam machineParam, 
            BlockConnectorComponent<IBlockInventory> blockConnectorComponent,
            BlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            var inputSlotCount = machineParam.InputSlotCount;
            var outputSlotCount = machineParam.OutputSlotCount;
            
            var input = new VanillaMachineInputInventory(
                blockId, inputSlotCount,
                blockInventoryUpdateEvent, blockInstanceId);
            
            var output = new VanillaMachineOutputInventory(
                outputSlotCount, ServerContext.ItemStackFactory, blockInventoryUpdateEvent, blockInstanceId,
                inputSlotCount, blockConnectorComponent);
            
            return (input, output);
        }
        
        public static VanillaMachineProcessorComponent MachineLoadState(
            Dictionary<string, string> componentStates,
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            ElectricPower requestPower)
        {
            var state = componentStates[VanillaMachineSaveComponent.SaveKeyStatic];
            var jsonObject = JsonConvert.DeserializeObject<VanillaMachineJsonObject>(state);
            
            var inputItems = jsonObject.InputSlot.Select(item => item.ToItemStack()).ToList();
            for (var i = 0; i < inputItems.Count; i++)
            {
                vanillaMachineInputInventory.SetItem(i, inputItems[i]);
            }
            
            var outputItems = jsonObject.OutputSlot.Select(item => item.ToItemStack()).ToList();
            for (var i = 0; i < outputItems.Count; i++)
            {
                vanillaMachineOutputInventory.SetItem(i, outputItems[i]);
            }
            
            var recipe = jsonObject.RecipeGuid == Guid.Empty ?
                null :
                MasterHolder.MachineRecipesMaster.GetRecipeElement(jsonObject.RecipeGuid);
            
            var processor = new VanillaMachineProcessorComponent(
                vanillaMachineInputInventory,
                vanillaMachineOutputInventory,
                (ProcessState)jsonObject.State,
                jsonObject.RemainingTime,
                recipe,
                requestPower);
            
            return processor;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/MachineIOTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Core.Const;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class MachineIOTest
    {
        //アイテムが通常通り処理されるかのテスト
        [Test]
        public void ItemProcessingOutputTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[0];
            
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var block = blockFactory.Create(blockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var blockInventory = block.GetComponent<VanillaMachineBlockInventoryComponent>();
            foreach (var inputItem in recipe.InputItems)
            {
                blockInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var blockMachineComponent = block.GetComponent<VanillaElectricMachineComponent>();
            
            var craftTime = DateTime.Now.AddSeconds(recipe.Time);
            //最大クラフト時間を超過するまでクラフトする
            while (craftTime.AddSeconds(0.2).CompareTo(DateTime.Now) == 1)
            {
                blockMachineComponent.SupplyEnergy(new ElectricPower(10000));
                GameUpdater.UpdateWithWait();
            }
            
            //検証
            (List<IItemStack> input, List<IItemStack> output) = GetInputOutputSlot(blockInventory);
            
            Assert.AreEqual(0, input.Count);
            foreach (var inputItem in input) Assert.AreEqual(ItemMaster.EmptyItemId, inputItem.Id);
            
            Assert.AreNotEqual(0, output.Count);
            for (var i = 0; i < output.Count; i++)
            {
                var expectedOutputId = MasterHolder.ItemMaster.GetItemId(recipe.OutputItems[i].ItemGuid);
                Assert.AreEqual(expectedOutputId, output[i].Id);
                Assert.AreEqual(recipe.OutputItems[i].Count, output[i].Count);
            }
        }
        
        public (List<IItemStack>, List<IItemStack>) GetInputOutputSlot(VanillaMachineBlockInventoryComponent vanillaMachineInventory)
        {
            var vanillaMachineInputInventory = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            var vanillaMachineOutputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            
            var inputSlot = vanillaMachineInputInventory.InputSlot.Where(i => i.Count != 0).ToList();
            inputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            var outputSlot = vanillaMachineOutputInventory.OutputSlot.Where(i => i.Count != 0).ToList();
            outputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            return (inputSlot, outputSlot);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/VanillaBeltConveyorComponent.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Connector;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Newtonsoft.Json;

namespace Game.Block.Blocks.BeltConveyor
{
    /// <summary>
    ///     アイテムの搬出入とインベントリの管理を行う
    /// </summary>
    public class VanillaBeltConveyorComponent : IBlockInventory, IBlockSaveState, IItemCollectableBeltConveyor, IUpdatableBlockComponent
    {
        public BeltConveyorSlopeType SlopeType { get; }
        public IReadOnlyList<IOnBeltConveyorItem> BeltConveyorItems => _inventoryItems;
        private readonly VanillaBeltConveyorInventoryItem[] _inventoryItems;
        
        private readonly IBlockInventoryInserter _blockInventoryInserter;
        private readonly int _inventoryItemNum;
        
        private double _timeOfItemEnterToExit; //ベルトコンベアにアイテムが入って出るまでの時間
        
        public VanillaBeltConveyorComponent(int inventoryItemNum, float timeOfItemEnterToExit, IBlockInventoryInserter blockInventoryInserter, BeltConveyorSlopeType slopeType)
        {
            SlopeType = slopeType;
            _inventoryItemNum = inventoryItemNum;
            _timeOfItemEnterToExit = timeOfItemEnterToExit;
            _blockInventoryInserter = blockInventoryInserter;
            
            _inventoryItems = new VanillaBeltConveyorInventoryItem[inventoryItemNum];
        }
        
        public VanillaBeltConveyorComponent(Dictionary<string, string> componentStates, int inventoryItemNum, float timeOfItemEnterToExit, IBlockInventoryInserter blockInventoryInserter, BeltConveyorSlopeType slopeType) :
            this(inventoryItemNum, timeOfItemEnterToExit, blockInventoryInserter, slopeType)
        {
            var itemJsons = JsonConvert.DeserializeObject<List<string>>(componentStates[SaveKey]);
            for (var i = 0; i < itemJsons.Count; i++)
            {
                if (itemJsons[i] != null)
                {
                    _inventoryItems[i] = VanillaBeltConveyorInventoryItem.LoadItem(itemJsons[i]);
                }
            }
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //新しく挿入可能か
            if (_inventoryItems[^1] != null)
                //挿入可能でない
                return itemStack;
            
            _inventoryItems[^1] = new VanillaBeltConveyorInventoryItem(itemStack.Id, itemStack.ItemInstanceId);
            
            //挿入したのでアイテムを減らして返す
            return itemStack.SubItem(1);
        }
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            // 空きスロットがない
            if (_inventoryItems[^1] != null) return false;
            
            // 挿入スロットが1個かどうか
            if (itemStacks.Count == 1 && itemStacks[0].Count == 1) return true;
            
            return false;
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            
            return _inventoryItems.Length;
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            if (_inventoryItems[slot] == null) return itemStackFactory.CreatEmpty();
            return itemStackFactory.Create(_inventoryItems[slot].ItemId, 1);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //TODO lockすべき？？
            _inventoryItems[slot] = new VanillaBeltConveyorInventoryItem(itemStack.Id, itemStack.ItemInstanceId);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public string SaveKey { get; } = typeof(VanillaBeltConveyorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var saveItems = new List<string>();
            foreach (var t in _inventoryItems)
            {
                saveItems.Add(t?.GetSaveJsonString());
            }
            
            return JsonConvert.SerializeObject(saveItems);
        }
        
        /// <summary>
        ///     アイテムの搬出判定を行う
        ///     判定はUpdateで毎フレーム行われる
        ///     TODO 個々のマルチスレッド対応もいい感じにやりたい
        /// </summary>
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            //TODO lockすべき？？
            var count = _inventoryItems.Length;
            
            for (var i = 0; i < count; i++)
            {
                var item = _inventoryItems[i];
                if (item == null) continue;
                
                //次のインデックスに入れる時間かどうかをチェックする
                var nextIndexStartTime = i * (1f / _inventoryItemNum);
                var isNextInsertable = item.RemainingPercent <= nextIndexStartTime;
                
                //次に空きがあれば次に移動する
                if (isNextInsertable && i != 0)
                {
                    if (_inventoryItems[i - 1] == null)
                    {
                        _inventoryItems[i - 1] = item;
                        _inventoryItems[i] = null;
                    }
                }
                
                //最後のアイテムの場合は接続先に渡す
                if (i == 0 && item.RemainingPercent <= 0)
                {
                    var insertItem = ServerContext.ItemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
                    
                    var output = _blockInventoryInserter.InsertItem(insertItem);
                    
                    //渡した結果がnullItemだったらそのアイテムを消す
                    if (output.Id == ItemMaster.EmptyItemId) _inventoryItems[i] = null;
                    
                    continue;
                }
                
                //時間を減らす 
                var diff = (float)(GameUpdater.UpdateSecondTime * (1f / (float)_timeOfItemEnterToExit));
                var last = item.RemainingPercent;
                item.RemainingPercent -= diff;
                var current = item.RemainingPercent;
                
                if (item.ItemInstanceId.AsPrimitive() != 0)
                {
                    UnityEngine.Debug.Log($"Belt Last:{last:F3} Current:{current:F3} Diff:{diff:F3} {item.ItemInstanceId}");
                }
            }
        }
        
        public void SetTimeOfItemEnterToExit(double time)
        {
            _timeOfItemEnterToExit = time;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaBeltConveyorTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaBeltConveyorTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            //TODo UP bletからの入力を受付?
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var beltParam = blockMasterElement.BlockParam as BeltConveyorBlockParam;
            
            var slopeType = beltParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            var connectorComponent = BlockTemplateUtil.CreateInventoryConnector(beltParam.InventoryConnectors, blockPositionInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(connectorComponent);
            var itemCount = beltParam.BeltConveyorItemCount;
            var time = beltParam.TimeOfItemEnterToExit;
            
            var beltComponent = componentStates == null ? 
                new VanillaBeltConveyorComponent(itemCount, time, beltConveyorConnector, slopeType) : 
                new VanillaBeltConveyorComponent(componentStates, itemCount, time, beltConveyorConnector, slopeType);
            
            
            var components = new List<IBlockComponent>
            {
                beltComponent,
                connectorComponent
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

コードを書く場合はコメント、空白、タブ、改行は本のコードと全く同じにしてください。適切な差分を維持するため、必要箇所以外は編集しないでください。また、コピペしやすいように、差分表記ではなく、コードそのものを記述してください。
# Instructions
私はこのコードベースに液体システムを作りたいです。
このシステムを作るにあたって必要なTODOを洗い出してください。TODOはコーディングだけでなく、この追加システムの仕様の定義やその他の要素も含まれます。

# 概要
- 液体システムがほしい
- 揚程とか考えるのは作るのも考えるのもだるいので考えない
- 内部実装はベルトコンベアみたいな仕組みで水を運搬する
- 機械レシピに必要な液体があるかかどうかを設定できるようにする
