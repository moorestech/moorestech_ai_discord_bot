moorestech_server/Assets/Scripts/Game.Paths/CalcFileHash.cs
```cs
using System;
using System.IO;
using System.Security.Cryptography;

namespace Game.Paths
{
    public static class CalcFileHash
    {
        public static string GetSha1Hash(string filePath)
        {
            using var sha1 = new SHA1Managed();
            using var stream = File.OpenRead(filePath);
            var hash = sha1.ComputeHash(stream);
            return BitConverter.ToString(hash).Replace("-", string.Empty);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/GameObjectExtension.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public static class GameObjectExtension
    {
        public static string GetFullPath(this GameObject obj)
        {
            return GetFullPath(obj.transform);
        }
        
        public static string GetFullPath(this Transform t)
        {
            var path = t.name;
            var parent = t.parent;
            while (parent)
            {
                path = $"{parent.name}/{path}";
                parent = parent.parent;
            }
            
            return path;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Paths/StringExtension.cs
```cs
namespace Game.Paths
{
    public static class StringExtension
    {
        public static string ReplaceFileNotAvailableCharacter(this string fileName, string replace)
        {
            fileName = fileName.Replace("/", replace);
            fileName = fileName.Replace("\\", replace);
            fileName = fileName.Replace(" ", replace);
            fileName = fileName.Replace(":", replace);
            fileName = fileName.Replace("*", replace);
            fileName = fileName.Replace("?", replace);
            fileName = fileName.Replace("\"", replace);
            fileName = fileName.Replace("<", replace);
            fileName = fileName.Replace(">", replace);
            fileName = fileName.Replace("|", replace);
            fileName = fileName.Replace(".", replace);
            return fileName;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/EventTestUtil.cs
```cs
using System.Collections.Generic;
using System.Linq;
using MessagePack;
using Server.Protocol.PacketResponse;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class EventTestUtil
    {
        public static List<byte> EventRequestData(int playerID)
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(playerID)).ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/PlayerPrefsKeys.cs
```cs
namespace Client.Common
{
    public class PlayerPrefsKeys
    {
        public const string PlayerIdKey = "PlayerId";
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/QuitGame.cs
```cs
using UnityEngine;
using UnityEngine.UI;

namespace Client.MainMenu
{
    public class QuitGame : MonoBehaviour
    {
        [SerializeField] private Button quitButton;
        
        private void Awake()
        {
            quitButton.onClick.AddListener(Application.Quit);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/IPacketResponse.cs
```cs
using System.Collections.Generic;

namespace Server.Protocol.PacketResponse
{
    public interface IPacketResponse
    {
        public ProtocolMessagePackBase GetResponse(List<byte> payload);
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/UI/SelectionButton.cs
```cs
using System.Threading;
using Cysharp.Threading.Tasks;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Skit.UI
{
    public class SelectionButton : MonoBehaviour
    {
        [SerializeField] private Button button;
        [SerializeField] private TMP_Text buttonText;
        
        private int _index;
        
        public void SetButton(string text, int index)
        {
            buttonText.text = text;
            _index = index;
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
        
        public async UniTask<int> WaitClick(CancellationToken ct)
        {
            await button.OnClickAsync(ct);
            return _index;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/Asset/AddressableLoader.cs
```cs
using System;
using System.Linq;
using Cysharp.Threading.Tasks;
using UnityEngine.AddressableAssets;
using UnityEngine.ResourceManagement.AsyncOperations;

namespace Client.Common.Asset
{
    public class AddressableLoader
    {
        public static async UniTask<LoadedAsset<T>> LoadAsync<T>(string address) where T : UnityEngine.Object
        {
            if (string.IsNullOrEmpty(address))
            {
                return null;
            }
            
            var handle = Addressables.LoadAssetAsync<T>(address);
            await handle.Task;
            
            return handle.Status == AsyncOperationStatus.Succeeded ? new LoadedAsset<T>(handle.Result) : null;
        }
        
        public static async UniTask<T> LoadAsyncDefault<T>(string address) where T : UnityEngine.Object
        {
            var loadedAsset = await LoadAsync<T>(address);
            return loadedAsset?.Asset;
        }
    }
    
    public class LoadedAsset<T> : IDisposable where T : UnityEngine.Object
    {
        public T Asset { get; }
        
        public LoadedAsset(T asset)
        {
            Asset = asset;
        }
        
        public void Dispose()
        {
            Addressables.Release(Asset);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/PauseMenu/SaveButton.cs
```cs
using Client.Game.InGame.Context;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.Presenter.PauseMenu
{
    public class SaveButton : MonoBehaviour
    {
        [SerializeField] private Button saveButton;
        
        private void Start()
        {
            saveButton.onClick.AddListener(ClientContext.VanillaApi.SendOnly.Save);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/EmotionType.cs
```cs
namespace Client.Skit.SkitTrack
{
    public enum EmotionType
    {
        Normal,
        Happy,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/PauseMenu/NetworkDisconnectPresenter.cs
```cs
using Client.Common;
using Client.Game.InGame.Context;
using UniRx;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace Client.Game.InGame.Presenter.PauseMenu
{
    public class NetworkDisconnectPresenter : MonoBehaviour
    {
        [SerializeField] private GameObject disconnectPanel;
        
        [SerializeField] private Button goToMainMenuButton;
        
        private void Start()
        {
            ClientContext.VanillaApi.OnDisconnect.Subscribe(_ => { disconnectPanel.gameObject.SetActive(true); }).AddTo(this);
            goToMainMenuButton.onClick.AddListener(() => { SceneManager.LoadScene(SceneConstant.MainMenuSceneName); });
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/RPM.cs
```cs
// ReSharper disable InconsistentNaming

using UnitGenerator;

namespace Game.Gear.Common
{
    [UnitOf(typeof(float), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable)]
    public partial struct RPM
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Skit/Starter/StartSkitUI.cs
```cs
using UnityEngine;

namespace Client.Game.Skit.Starter
{
    public class StartSkitUI : MonoBehaviour
    {
        [SerializeField] private GameObject startStoryPanel;
        
        public void ShowStartStoryUI(bool enable)
        {
            startStoryPanel.SetActive(enable);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/SceneConstant.cs
```cs
namespace Client.Common
{
    public class SceneConstant
    {
        public const string MainMenuSceneName = "MainMenu";
        public const string GameInitializerSceneName = "GameInitialaizer";
        public const string MainGameSceneName = "MainGame";
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/Settings/PlayerConnectionSetting.cs
```cs
namespace Client.Network.Settings
{
    public class PlayerConnectionSetting
    {
        public readonly int PlayerId;
        
        public PlayerConnectionSetting(int playerId)
        {
            PlayerId = playerId;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/ResetStoryButton.cs
```cs
using Client.Game.Sequence;
using UnityEngine;
using UnityEngine.UI;

namespace Client.MainMenu
{
    public class ResetStoryButton : MonoBehaviour
    {
        [SerializeField] private Button resetStoryButton;
        
        private void Start()
        {
            resetStoryButton.onClick.AddListener(() =>
            {
                PlayerPrefs.DeleteKey(S1InitialMovie.S1InitialMoviePlayerPrefsKey);
                PlayerPrefs.Save();
            });
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Skit/Starter/PlayerSkitStarterDetector.cs
```cs
using UnityEngine;

namespace Client.Game.Skit.Starter
{
    public class PlayerSkitStarterDetector : MonoBehaviour
    {
        [SerializeField] private StartSkitUI startSkitUI;
        
        public bool IsStartReady => CurrentSkitStarterObject != null;
        public SkitStarterObject CurrentSkitStarterObject { get; private set; }
        
        private void OnDisable()
        {
            startSkitUI.ShowStartStoryUI(false);
        }
        
        private void OnTriggerEnter(Collider other)
        {
            if (other.TryGetComponent<SkitStarterObject>(out var storyStarterObject))
            {
                CurrentSkitStarterObject = storyStarterObject;
                startSkitUI.ShowStartStoryUI(true);
            }
        }
        
        private void OnTriggerExit(Collider other)
        {
            if (other.TryGetComponent<SkitStarterObject>(out var _))
            {
                CurrentSkitStarterObject = null;
                startSkitUI.ShowStartStoryUI(false);
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/BlockConstant.cs
```cs
using Core.Master;

namespace Client.Common
{
    public static class BlockConstant
    {
        public static readonly BlockId NullBlockId = new(0);
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/LanguageSetting.cs
```cs
using Client.Localization;
using TMPro;
using UnityEngine;

namespace Client.MainMenu
{
    public class LanguageSetting : MonoBehaviour
    {
        [SerializeField] private TMP_Dropdown tmpDropdown;
        
        private void Start()
        {
            tmpDropdown.ClearOptions();
            tmpDropdown.AddOptions(Localize.LanguageCodes);
            tmpDropdown.value = Localize.LanguageCodes.IndexOf(Localize.CurrentLanguageCode);
            tmpDropdown.onValueChanged.AddListener(OnValueChanged);
        }
        
        private void OnValueChanged(int index)
        {
            Localize.SetLanguage(Localize.LanguageCodes[index]);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/Event/GrabInventoryUpdateEvent.cs
```cs
using Game.PlayerInventory.Interface.Event;
using static Game.PlayerInventory.Interface.Event.IGrabInventoryUpdateEvent;

namespace Game.PlayerInventory.Event
{
    public class GrabInventoryUpdateEvent : IGrabInventoryUpdateEvent
    {
        public void Subscribe(UpdateInventoryEvent updateInventoryEvent)
        {
            OnPlayerInventoryUpdate += updateInventoryEvent;
        }
        
        public event UpdateInventoryEvent OnPlayerInventoryUpdate;
        
        public void OnInventoryUpdateInvoke(
            PlayerInventoryUpdateEventProperties properties)
        {
            OnPlayerInventoryUpdate?.Invoke(properties);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/StoryTrackDefine.cs
```cs
namespace Client.Skit.SkitTrack
{
    public class StoryTrackDefine
    {
        public static IStoryTrack GetStoryTrack(string key)
        {
            return key switch
            {
                "Camerawork" => new CameraworkTrack(),
                "CameraWarp" => new CameraWarpTrack(),
                "Text" => new TextTrack(),
                "CharacterTransform" => new CharacterTransformTrack(),
                "CharacterMotion" => new CharacterMotionTrack(),
                "CharacterEmotion" => new CharacterEmotionTrack(),
                "WaitTime" => new WaitTimeTrack(),
                "Transition" => new TransitionTrack(),
                "SelectionTrack" => new SelectionTrack(),
                "Jump" => new JumpTrack(),
                _ => null,
            };
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/Event/IGrabInventoryUpdateEvent.cs
```cs
namespace Game.PlayerInventory.Interface.Event
{
    public interface IGrabInventoryUpdateEvent
    {
        public delegate void UpdateInventoryEvent(
            PlayerInventoryUpdateEventProperties playerInventoryUpdateEventProperties);
        
        public void Subscribe(UpdateInventoryEvent updateInventoryEvent);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/PauseMenuState.cs
```cs
using Client.Game.InGame.UI.UIState.UIObject;
using Client.Input;

namespace Client.Game.InGame.UI.UIState
{
    public class PauseMenuState : IUIState
    {
        private readonly PauseMenuObject _pauseMenu;
        
        public PauseMenuState(PauseMenuObject pauseMenu)
        {
            _pauseMenu = pauseMenu;
            pauseMenu.gameObject.SetActive(false);
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.CloseUI.GetKeyDown) return UIStateEnum.GameScreen;
            
            return UIStateEnum.Current;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            _pauseMenu.gameObject.SetActive(true);
            InputManager.MouseCursorVisible(true);
        }
        
        public void OnExit()
        {
            _pauseMenu.gameObject.SetActive(false);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIStateEnum.cs
```cs
namespace Client.Game.InGame.UI.UIState
{
    public enum UIStateEnum
    {
        Current,
        
        GameScreen,
        PlayerInventory,
        BlockInventory,
        PauseMenu,
        DeleteBar,
        Story,
        PlaceBlock,
        BlockDebug,
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/Settings/ConnectionServerConfig.cs
```cs
namespace Client.Network.Settings
{
    public class ConnectionServerConfig
    {
        public readonly string IP;
        public readonly int Port;
        
        public ConnectionServerConfig(string ip, int port)
        {
            IP = ip;
            Port = port;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Util/ToByteList.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Server.Util
{
    public static class ToByteList
    {
        public static List<byte> Convert(int sendData)
        {
            var result = BitConverter.GetBytes(sendData);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(result);
            return result.ToList();
        }
        
        public static List<byte> Convert(short sendData)
        {
            var result = BitConverter.GetBytes(sendData);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(result);
            return result.ToList();
        }
        
        public static List<byte> Convert(float sendData)
        {
            var result = BitConverter.GetBytes(sendData);
            if (BitConverter.IsLittleEndian)
                Array.Reverse(result);
            return result.ToList();
        }
        
        public static List<byte> Convert(string sendData)
        {
            return Encoding.UTF8.GetBytes(sendData).ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/StartLocal.cs
```cs
using System.Diagnostics;
using Client.Common;
using Client.Starter;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using Debug = UnityEngine.Debug;

namespace Client.MainMenu
{
    public class StartLocal : MonoBehaviour
    {
        [SerializeField] private Button startLocalButton;
        
        private Process _serverProcess;
        
        
        private void Start()
        {
            startLocalButton.onClick.AddListener(() => ConnectLocalServer().Forget());
        }
        
        private async UniTask ConnectLocalServer()
        {
            Debug.Log("Server started");
            
            SceneManager.sceneLoaded += OnMainGameSceneLoaded;
            SceneManager.LoadScene(SceneConstant.GameInitializerSceneName);
        }
        
        private void OnMainGameSceneLoaded(Scene scene, LoadSceneMode mode)
        {
            SceneManager.sceneLoaded -= OnMainGameSceneLoaded;
            var starter = FindObjectOfType<InitializeScenePipeline>();
            
            starter.SetProperty(new InitializeProprieties(
                true, _serverProcess,
                ServerConst.LocalServerIp,
                ServerConst.LocalServerPort,
                PlayerPrefs.GetInt(PlayerPrefsKeys.PlayerIdKey)));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/Event/MainInventoryUpdateEvent.cs
```cs
using Game.PlayerInventory.Interface.Event;
using static Game.PlayerInventory.Interface.Event.IMainInventoryUpdateEvent;

namespace Game.PlayerInventory.Event
{
    public class MainInventoryUpdateEvent : IMainInventoryUpdateEvent
    {
        public void Subscribe(UpdateInventoryEvent updateInventoryEvent)
        {
            OnPlayerInventoryUpdate += updateInventoryEvent;
        }
        
        public event UpdateInventoryEvent OnPlayerInventoryUpdate;
        
        public void OnInventoryUpdateInvoke(
            PlayerInventoryUpdateEventProperties properties)
        {
            OnPlayerInventoryUpdate?.Invoke(properties);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/JumpTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class JumpTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            return parameters[0];
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/Event/IMainInventoryUpdateEvent.cs
```cs
namespace Game.PlayerInventory.Interface.Event
{
    public interface IMainInventoryUpdateEvent
    {
        public delegate void UpdateInventoryEvent(
            PlayerInventoryUpdateEventProperties playerInventoryUpdateEventProperties);
        
        public void Subscribe(UpdateInventoryEvent updateInventoryEvent);
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/VanillaMapObjectType.cs
```cs
namespace Game.Map.Interface.MapObject
{
    public static class VanillaMapObjectType
    {
        public const string VanillaPebble = "vanilla:Pebble";
        public const string VanillaTree = "vanilla:Tree";
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockInstanceId.cs
```cs
using System;
using UnitGenerator;

namespace Game.Block.Interface
{
    [UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter | UnitGenerateOptions.Comparable)]
    public readonly partial struct BlockInstanceId
    {
        private static readonly Random Random = new();
        
        public static BlockInstanceId Create()
        {
            return new BlockInstanceId(Random.Next(int.MinValue, int.MaxValue));
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/HotBarSlotToInventorySlotTest.cs
```cs
using Game.PlayerInventory.Interface;
using NUnit.Framework;

namespace Tests.UnitTest.Game
{
    public class HotBarSlotToInventorySlotTest
    {
        [TestCase(0, 36)]
        [TestCase(1, 37)]
        [TestCase(8, 44)]
        public void Test(int hotBarSlot, int inventorySlot)
        {
            Assert.AreEqual(inventorySlot, PlayerInventoryConst.HotBarSlotToInventorySlot(hotBarSlot));
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/IUIState.cs
```cs
namespace Client.Game.InGame.UI.UIState
{
    public interface IUIState
    {
        public void OnEnter(UIStateEnum lastStateEnum);
        public UIStateEnum GetNextUpdate();
        public void OnExit();
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/UIHighlight/UIHighlightTutorialTargetObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Tutorial.UIHighlight
{
    [RequireComponent(typeof(RectTransform))]
    public class UIHighlightTutorialTargetObject : MonoBehaviour
    {
        public bool ActiveSelf => gameObject.activeInHierarchy;
        
        public string HighlightObjectId => highlightObjectId;
        [SerializeField] private string highlightObjectId;
        
        public RectTransform RectTransform => rectTransform;
        [SerializeField] private RectTransform rectTransform;
        
        public void Initialize(string uiObjectId)
        {
            highlightObjectId = uiObjectId;
            rectTransform = GetComponent<RectTransform>();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/TestModDirectory.cs
```cs
using System;
using System.IO;

namespace Tests.Module.TestMod
{
    public class TestModDirectory
    {
        private static string FolderDirectory => Path.Combine(Environment.CurrentDirectory, "../", "moorestech_server", "Assets", "Scripts", "", "Tests.Module", "TestMod");
        
        public static string ConfigOnlyDirectory => Path.Combine(FolderDirectory, "ConfigOnly");
        public static string ForUnitTestModDirectory => Path.Combine(FolderDirectory, "ForUnitTest");
        
        public static string MoorestechAlphaModDirectory => Path.Combine(Environment.CurrentDirectory, "../", "moorestech_client", "Server");
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/Event/PlayerInventoryUpdateEventProperties.cs
```cs
using Core.Item.Interface;

namespace Game.PlayerInventory.Interface.Event
{
    public class PlayerInventoryUpdateEventProperties
    {
        public readonly int PlayerId;
        public readonly int InventorySlot;
        public readonly IItemStack ItemStack;
        
        public PlayerInventoryUpdateEventProperties(int playerId, int inventorySlot, IItemStack itemStack)
        {
            PlayerId = playerId;
            InventorySlot = inventorySlot;
            ItemStack = itemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Extension/BlockPositionInfoExtension.cs
```cs
using UnityEngine;

namespace Game.Block.Interface.Extension
{
    public static class BlockPositionInfoExtension
    {
        public static bool IsContainPos(this BlockPositionInfo self, Vector3Int pos)
        {
            return self.MinPos.x <= pos.x && pos.x <= self.MaxPos.x &&
                   self.MinPos.y <= pos.y && pos.y <= self.MaxPos.y &&
                   self.MinPos.z <= pos.z && pos.z <= self.MaxPos.z;
        }
        
        public static bool IsOverlap(this BlockPositionInfo self, BlockPositionInfo other)
        {
            return self.MinPos.x <= other.MaxPos.x && other.MinPos.x <= self.MaxPos.x &&
                   self.MinPos.y <= other.MaxPos.y && other.MinPos.y <= self.MaxPos.y &&
                   self.MinPos.z <= other.MaxPos.z && other.MinPos.z <= self.MaxPos.z;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/Command/CommandUIInput.cs
```cs
using Client.Game.InGame.Context;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.Presenter.Command
{
    public class CommandUIInput : MonoBehaviour
    {
        [SerializeField] private TMP_InputField commandInputField;
        [SerializeField] private Button submitButton;
        
        
        private void Start()
        {
            submitButton.onClick.AddListener(SubmitCommand);
        }
        
        private void SubmitCommand()
        {
            ClientContext.VanillaApi.SendOnly.SendCommand(commandInputField.text);
            commandInputField.text = string.Empty;
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/MapVeinGameObjectInspector.cs
```cs
using System;
using Client.Game.InGame.Map.MapVein;
using UnityEditor;
using UnityEditor.IMGUI.Controls;
using UnityEngine;

[CustomEditor(typeof(MapVeinGameObject))]
public class MapVeinGameObjectInspector : Editor
{
    private readonly BoxBoundsHandle _boxBoundsHandle = new();
    
    private void OnSceneGUI()
    {
        var mapVein = target as MapVeinGameObject;
        if (mapVein == null)
        {
            return;
        }
        
        EditorGUI.BeginChangeCheck();
        
        _boxBoundsHandle.center = mapVein.Bounds.center + mapVein.transform.position;
        _boxBoundsHandle.size = mapVein.Bounds.size;
        
        _boxBoundsHandle.SetColor(Color.red);
        _boxBoundsHandle.DrawHandle();
        
        if (EditorGUI.EndChangeCheck())
        {
            
            var bounds = new Bounds(_boxBoundsHandle.center, _boxBoundsHandle.size);
            mapVein.SetBounds(bounds);
            Undo.RecordObject(mapVein, "Change Bounds");
            EditorUtility.SetDirty(mapVein);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Skit/SkitCamera.cs
```cs
using DG.Tweening;
using UnityEngine;

namespace Client.Skit.Skit
{
    public interface ISkitCamera
    {
        public void TweenCamera(Vector3 fromPos, Vector3 fromRot, Vector3 toPos, Vector3 toRot, float duration, Ease easing);
        
        public void SetTransform(Vector3 pos, Vector3 rot);
        
        public void SetActive(bool enabled);
    }
    
    public class SkitCamera : MonoBehaviour, ISkitCamera
    {
        [SerializeField] private Camera camera;
        
        public void TweenCamera(Vector3 fromPos, Vector3 fromRot, Vector3 toPos, Vector3 toRot, float duration, Ease easing)
        {
            camera.transform.position = fromPos;
            camera.transform.eulerAngles = fromRot;
            
            camera.transform.DOMove(toPos, duration).SetEase(easing);
            camera.transform.DORotate(toRot, duration).SetEase(easing);
        }
        
        public void SetTransform(Vector3 pos, Vector3 rot)
        {
            camera.transform.position = pos;
            camera.transform.eulerAngles = rot;
        }
        
        public void SetActive(bool enabled)
        {
            gameObject.SetActive(enabled);
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/SchemaWatcher.cs
```cs

```

moorestech_client/Assets/Scripts/Client.Common/LayerConst.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public class LayerConst
    {
        public static readonly int PlayerLayer = LayerMask.NameToLayer("Player");
        public static readonly int BlockLayer = LayerMask.NameToLayer("Block");
        public static readonly int BlockBoundingBoxLayer = LayerMask.NameToLayer("BlockBoundingBox");
        public static readonly int MapObjectLayer = LayerMask.NameToLayer("MapObject");
        
        public static readonly int BlockOnlyLayerMask = 1 << BlockLayer;
        public static readonly int MapObjectOnlyLayerMask = 1 << MapObjectLayer;
        public static readonly int PlayerOnlyLayerMask = 1 << PlayerLayer;
        
        public static readonly int Without_Player_MapObject_Block_LayerMask = ~MapObjectOnlyLayerMask & ~PlayerOnlyLayerMask & ~BlockOnlyLayerMask;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/SkitState.cs
```cs
using Client.Game.Skit;

namespace Client.Game.InGame.UI.UIState
{
    public class SkitState : IUIState
    {
        private readonly SkitManager _skitManager;
        
        public SkitState(SkitManager skitManager)
        {
            _skitManager = skitManager;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (_skitManager.IsPlayingSkit) return UIStateEnum.Current;
            return UIStateEnum.GameScreen;
        }
        
        public void OnExit()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeJsonObject.cs
```cs
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Game.Challenge
{
    public class ChallengeJsonObject
    {
        [JsonProperty("completedGuids")] public List<string> CompletedGuids;
        [JsonProperty("playerId")] public int PlayerId;
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/PopUp/ServerConnectPopup.cs
```cs
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace Client.MainMenu.PopUp
{
    public class ServerConnectPopup : MonoBehaviour
    {
        [SerializeField] private TMP_Text logText;
        [SerializeField] private Button closeButton;
        
        private void Start()
        {
            closeButton.onClick.AddListener(() =>
                gameObject.SetActive(false)
            );
        }
        
        public void SetText(string text)
        {
            gameObject.SetActive(true);
            logText.text = text;
        }
    }
}
```

schema/challenges.json
```cs
{
  "$id": "challenges",
  "type": "object",
  "isDefaultOpen": true,

  "properties": {
    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "ChallengeMasterElement",

      "items": {
        "type": "object",
        "properties": {

          "challengeGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "prevChallengeGuid": {
            "type": "string",
            "format": "uuid",
            "foreignKey": "challenges:challengeGuid:title",
            "optional": true
          },

          "title": {
            "type": "string",
            "default": "New Challenge"
          },

          "summary": {
            "type": "string",
            "default": "New Challenge summary"
          },

          "playSkitType": {
            "type": "string",
            "default": "createItem",
            "enum": ["None", "BackgroundSkit"]
          },

          "playSkitParam": {
            "oneOf": [
              {
                "if": {
                  "properties": {
                    "playSkitType": { "const": "None" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "playSkitType": { "const": "BackgroundSkit" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "fireSkitName": {
                      "type": "string"
                    }
                  }
                }
              }
            ]
          },


          "taskCompletionType": {
            "type": "string",
            "default": "createItem",
            "enum": ["createItem", "inInventoryItem","blockPlace"]
          },

          "taskParam": {
            "oneOf": [
              {
                "if": {
                  "properties": {
                    "taskCompletionType": { "const": "createItem" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "itemGuid": {
                      "type": "string",
                      "format": "uuid",
                      "foreignKey": "items:itemGuid:name"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "taskCompletionType": { "const": "inInventoryItem" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "itemGuid": {
                      "type": "string",
                      "format": "uuid",
                      "foreignKey": "items:itemGuid:name"
                    },
                    "itemCount": {
                      "type": "integer",
                        "default": 1
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "taskCompletionType": { "const": "blockPlace" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "blockGuid": {
                      "type": "string",
                      "format": "uuid",
                      "foreignKey": "blocks:blockGuid:name"
                    },
                    "itemCount": {
                      "type": "integer",
                        "default": 1
                    }

                  }
                }
              }
            ]
          },


          "tutorials": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {

                "tutorialType": {
                  "type": "string",
                  "default": "uiHighLight",
                  "enum": ["mapObjectPin", "keyControl", "uiHighLight"]
                },

                "tutorialParam": {
                  "oneOf": [
                    {
                      "if": {
                        "properties": {
                          "tutorialType": { "const": "mapObjectPin" }
                        }
                      },
                      "then": {
                        "type": "object",
                        "properties": {
                          "mapObjectGuid": {
                            "type": "string",
                            "format": "uuid",
                            "foreignKey": "mapObjects:mapObjectGuid:mapObjectName"
                          },
                          "pinText": {
                            "type": "string",
                            "default": "pin text"
                          }
                        }
                      }
                    },
                    {
                      "if": {
                        "properties": {
                          "tutorialType": { "const": "keyControl" }
                        }
                      },
                      "then": {
                        "type": "object",
                        "properties": {
                          "uiState": {
                            "type": "string",
                            "enum" : ["GameScreen","PlayerInventory", "BlockInventory", "PauseMenu","DeleteBar","Story","PlaceBlock"],
                            "default": "GameScreen"
                          },
                          "controlText": {
                            "type": "string",
                            "default": "control text"
                          }
                        }
                      }
                    },
                    {
                      "if": {
                        "properties": {
                          "tutorialType": { "const": "uiHighLight" }
                        }
                      },
                      "then": {
                        "type": "object",
                        "properties": {
                          "highLightUIObjectId": {
                            "type": "string",
                            "default": "ui object id"
                          },
                          "highLightText": {
                            "type": "string",
                            "default": "highlight text"
                          }
                        }
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    }
  }
}

```

moorestech_client/Assets/Scripts/Client.Skit/UI/SkitUI.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using TMPro;
using UnityEngine;

namespace Client.Skit.UI
{
    public class SkitUI : MonoBehaviour
    {
        [SerializeField] private GameObject storyPanel;
        
        [SerializeField] private TMP_Text characterNameText;
        [SerializeField] private TMP_Text storyText;
        
        [SerializeField] private CanvasGroup transitionImage;
        
        [SerializeField] private GameObject selectionPanel;
        [SerializeField] private List<SelectionButton> selectionButtons;
        
        public void SetText(string characterName, string text)
        {
            storyPanel.SetActive(true);
            characterNameText.text = characterName;
            storyText.text = text.Replace("\\n", "\n");
        }
        
        public void ShowTransition(bool isShow, float duration)
        {
            transitionImage.alpha = isShow ? 0 : 1;
            transitionImage.DOFade(isShow ? 1 : 0, duration);
        }
        
        public void ShowSelectionUI(bool enable)
        {
            selectionPanel.SetActive(enable);
        }
        
        public async UniTask<int> WaitSelectText(List<string> texts)
        {
            for (var i = 0; i < selectionButtons.Count; i++)
                if (i < texts.Count)
                {
                    selectionButtons[i].SetButton(texts[i], i);
                    selectionButtons[i].SetActive(true);
                }
                else
                {
                    selectionButtons[i].SetActive(false);
                }
            
            var cancelToken = this.GetCancellationTokenOnDestroy();
            
            var (_, resultIndex) = await UniTask.WhenAny(selectionButtons.Select(button => button.WaitClick(cancelToken)));
            
            return resultIndex;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIStateDictionary.cs
```cs
using System.Collections.Generic;

namespace Client.Game.InGame.UI.UIState
{
    public class UIStateDictionary
    {
        private readonly Dictionary<UIStateEnum, IUIState> _stateDictionary = new();
        
        public UIStateDictionary(
            GameScreenState gameScreenState,
            PlayerInventoryState playerInventoryState,
            BlockInventoryState blockInventoryState,
            PauseMenuState pauseMenuState,
            DeleteBlockState deleteBlockState,
            SkitState skitState,
            PlaceBlockState placeBlockState)
        {
            _stateDictionary.Add(UIStateEnum.GameScreen, gameScreenState);
            _stateDictionary.Add(UIStateEnum.PlayerInventory, playerInventoryState);
            _stateDictionary.Add(UIStateEnum.BlockInventory, blockInventoryState);
            _stateDictionary.Add(UIStateEnum.PauseMenu, pauseMenuState);
            _stateDictionary.Add(UIStateEnum.DeleteBar, deleteBlockState);
            _stateDictionary.Add(UIStateEnum.Story, skitState);
            _stateDictionary.Add(UIStateEnum.PlaceBlock, placeBlockState);
        }
        
        public IUIState GetState(UIStateEnum state)
        {
            return _stateDictionary[state];
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Common/GameStateController.cs
```cs
using Client.Game.InGame.Control;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory;
using Client.Input;
using Client.Skit.Skit;
using UnityEngine;

namespace Client.Game.Common
{
    public class GameStateController : MonoBehaviour
    {
        private static GameStateController _instance;
        [SerializeField] private SkitCamera skitCamera;
        [SerializeField] private InGameCameraController inGameCameraController;
        
        [SerializeField] private PlayerObjectController playerObjectController;
        
        [SerializeField] private HotBarView hotBarView;
        [SerializeField] private GameObject challengeText;
        
        private void Awake()
        {
            _instance = this;
        }
        
        public void Start()
        {
            ChangeState(GameStateType.InGame);
        }
        
        public static void ChangeState(GameStateType gameStateType)
        {
            switch (gameStateType)
            {
                case GameStateType.InGame:
                    _instance.SetInGameState();
                    break;
                case GameStateType.Skit:
                    _instance.SetSkitState();
                    break;
                case GameStateType.CutScene:
                    _instance.SetCutSceneState();
                    break;
            }
        }
        
        private void SetInGameState()
        {
            skitCamera.SetActive(false);
            inGameCameraController.SetActive(true);
            
            playerObjectController.SetActive(true);
            
            hotBarView.SetActive(true);
            challengeText.SetActive(true);
            
            InputManager.MouseCursorVisible(false);
        }
        
        private void SetSkitState()
        {
            skitCamera.SetActive(true);
            inGameCameraController.SetActive(false);
            
            playerObjectController.SetActive(false);
            
            hotBarView.SetActive(false);
            challengeText.SetActive(false);
            
            InputManager.MouseCursorVisible(true);
        }
        
        private void SetCutSceneState()
        {
            skitCamera.SetActive(false);
            inGameCameraController.SetActive(false);
            
            playerObjectController.SetActive(false);
            
            hotBarView.SetActive(false);
            challengeText.SetActive(false);
            
            InputManager.MouseCursorVisible(false);
        }
    }
    
    public enum GameStateType
    {
        InGame,
        Skit,
        CutScene,
    }
}
```

moorestech_server/Assets/Scripts/Game.Paths/GameSystemPaths.cs
```cs
using System;
using System.IO;
using System.Runtime.InteropServices;

namespace Game.Paths
{
    public static class GameSystemPaths
    {
        public static string GameSystemDirectory
        {
            get
            {
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
                    return DirectoryCreator("C:\\Users", Environment.UserName, "AppData", "Roaming", ".moorestech");
                if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                    return DirectoryCreator("/Users", Environment.UserName, "Library", "Application Support",
                        "moorestech");
                if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
                    return DirectoryCreator("/home", Environment.UserName, ".moorestech");
                throw new Exception("Unsupported OS");
            }
        }
        
        public static string TmpFileDirectory => DirectoryCreator(GameSystemDirectory, "Tmp");
        public static string ExtractedModDirectory => DirectoryCreator(TmpFileDirectory, "ExtractedMods");
        public static string SaveFileDirectory => DirectoryCreator(GameSystemDirectory, "Saves");
        
        public static string GetExtractedModDirectory(string folderName)
        {
            return Path.Combine(ExtractedModDirectory, folderName);
        }
        
        public static string CreateExtractedModDirectory(string folderName)
        {
            return DirectoryCreator(ExtractedModDirectory, folderName);
        }

        
        public static string GetSaveFilePath(string fileName)
        {
            return Path.Combine(SaveFileDirectory, fileName);
        }
        
        
        private static string DirectoryCreator(params string[] paths)
        {
            var directory = Path.Combine(paths);
            if (!Directory.Exists(directory)) Directory.CreateDirectory(directory);
            return directory;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/DebugSheet/DebugSheetControllerExtension.cs
```cs
using System;
using Client.Game.GameDebug;
using UnityDebugSheet.Runtime.Core.Scripts;

namespace Client.DebugSystem
{
    public static class DebugSheetControllerExtension
    {
        public static void AddEnumPickerWithSave<TEnum>(this DebugPage debugPage, TEnum defaultValue, string label, string key, Action<TEnum> valueChangedOrInitialize) where TEnum : Enum
        {
            var value = (TEnum)Enum.ToObject(typeof(TEnum), DebugParameters.GetInt(key, Convert.ToInt32(defaultValue)));
            valueChangedOrInitialize(value);
            
            debugPage.AddEnumPicker(value, label, activeValueChanged: d =>
            {
                DebugParameters.SaveInt(key, Convert.ToInt32(d));
                valueChangedOrInitialize((TEnum)d);
            });
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.CutScene/TimelinePlayer.cs
```cs
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Playables;

namespace Client.CutScene
{
    public class TimelinePlayer : MonoBehaviour
    {
        [SerializeField] private PlayableDirector playableDirector;
        
        public async UniTask Play(PlayableAsset playableAsset)
        {
            playableDirector.playableAsset = playableAsset;
            playableDirector.Play();
            
            await UniTask.WaitUntil(() => playableDirector.state != PlayState.Playing);
            
            playableDirector.playableAsset = null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/TextureExtension.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public static class TextureExtension
    {
        public static Sprite ToSprite(this Texture2D texture2D)
        {
            return texture2D == null ? null : Sprite.Create(texture2D, new Rect(0, 0, texture2D.width, texture2D.height), Vector2.zero);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Electric/EnergizedRangeObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Electric
{
    public class EnergizedRangeObject : MonoBehaviour
    {
        public void SetRange(int range)
        {
            var y = transform.localScale.y;
            transform.localScale = new Vector3(range, y, range);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CameraWarpTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Skit.SkitTrack
{
    public class CameraWarpTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var pos = new Vector3(float.Parse(parameters[1]), float.Parse(parameters[2]), float.Parse(parameters[3]));
            var rot = new Vector3(float.Parse(parameters[5]), float.Parse(parameters[6]), float.Parse(parameters[7]));
            
            storyContext.SkitCamera.SetTransform(pos, rot);
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Const/BlockConst.cs
```cs
using Core.Master;

namespace Core.Const
{
    public static class BlockConst
    {
        public static readonly BlockId EmptyBlockId = new(0);
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/IStoryTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public interface IStoryTrack
    {
        public UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIObject/PauseMenuObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.UI.UIState.UIObject
{
    public class PauseMenuObject : MonoBehaviour
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CameraworkTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;
using static System.Enum;

namespace Client.Skit.SkitTrack
{
    public class CameraworkTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var duration = float.Parse(parameters[0]);
            var easing = (Ease)Parse(typeof(Ease), parameters[1]);
            
            var fromPos = new Vector3(float.Parse(parameters[3]), float.Parse(parameters[4]), float.Parse(parameters[5]));
            var fromRot = new Vector3(float.Parse(parameters[7]), float.Parse(parameters[8]), float.Parse(parameters[9]));
            
            var toPos = new Vector3(float.Parse(parameters[11]), float.Parse(parameters[12]), float.Parse(parameters[13]));
            var toRot = new Vector3(float.Parse(parameters[15]), float.Parse(parameters[16]), float.Parse(parameters[17]));
            
            storyContext.SkitCamera.TweenCamera(fromPos, fromRot, toPos, toRot, duration, easing);
            
            return null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/VanillaApiEvent.cs
```cs
using System;
using System.Collections.Generic;
using System.Threading;
using Client.Network.Settings;
using Cysharp.Threading.Tasks;
using Server.Protocol;
using UniRx;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Client.Network.API
{
    public class VanillaApiEvent
    {
        private readonly Dictionary<string, Subject<byte[]>> _eventResponseSubjects = new();
        private readonly PacketExchangeManager _packetExchangeManager;
        private readonly PlayerConnectionSetting _playerConnectionSetting;
        
        public VanillaApiEvent(PacketExchangeManager packetExchangeManager, PlayerConnectionSetting playerConnectionSetting)
        {
            _packetExchangeManager = packetExchangeManager;
            _playerConnectionSetting = playerConnectionSetting;
            CollectEvent().Forget();
        }
        
        private async UniTask CollectEvent()
        {
            while (true)
            {
                var ct = new CancellationTokenSource().Token;
                
                try
                {
                    await RequestAndParse(ct);
                }
                catch (Exception e)
                {
                    Debug.LogError($"Event Protocol Error:{e.Message}\n{e.StackTrace}");
                }
                
                await UniTask.Delay(ServerConst.PollingRateMillSec, cancellationToken: ct);
            }
            
            #region Internal
            
            async UniTask RequestAndParse(CancellationToken ct)
            {
                var request = new EventProtocolMessagePack(_playerConnectionSetting.PlayerId);
                
                var response = await _packetExchangeManager.GetPacketResponse<ResponseEventProtocolMessagePack>(request, ct);
                
                foreach (var eventMessagePack in response.Events)
                {
                    if (!_eventResponseSubjects.TryGetValue(eventMessagePack.Tag, out var subjects)) continue;
                    
                    subjects.OnNext(eventMessagePack.Payload);
                }
            }
            
            #endregion
        }
        
        public IDisposable SubscribeEventResponse(string tag, Action<byte[]> responseAction)
        {
            if (!_eventResponseSubjects.TryGetValue(tag, out var subject))
            {
                subject = new Subject<byte[]>();
                _eventResponseSubjects.Add(tag, subject);
            }
            
            return subject.Subscribe(responseAction);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Control/UICursorFollowControl.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Control
{
    public class UICursorFollowControl : MonoBehaviour
    {
        [SerializeField] private Vector3 offSet = Vector3.zero;
        private RectTransform _canvasRect;
        
        private void Start()
        {
            _canvasRect = transform.root.GetComponentsInChildren<RectTransform>()[0];
        }
        
        private void Update()
        {
            var magnification = _canvasRect.sizeDelta.x / Screen.width;
            
            var itemPos = new Vector3();
            
            itemPos.x = UnityEngine.Input.mousePosition.x * magnification - _canvasRect.sizeDelta.x / 2;
            itemPos.y = UnityEngine.Input.mousePosition.y * magnification - _canvasRect.sizeDelta.y / 2;
            itemPos.z = transform.localPosition.z;
            
            transform.localPosition = itemPos + offSet;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/MaterialConst.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public class MaterialConst
    {
        public const string PlaceBlockAnimationMaterial = "PlaceBlockAnimation";
        
        public const string PreviewPlaceBlockMaterial = "PreviewPlaceBlock";
        
        public const string PreviewColorPropertyName = "_PreviewColor";
        public static readonly Color PlaceableColor = new(0.41f,0.59f,0.86f,1f);
        public static readonly Color NotPlaceableColor = new(0.9f,0.25f,0.16f,1);
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/Responses.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Interface;
using Game.Challenge;
using Mooresmaster.Model.ChallengesModule;
using Server.Event.EventReceive;
using Server.Util.MessagePack;
using UnityEngine;
using static Server.Protocol.PacketResponse.GetMapObjectInfoProtocol;
using static Server.Protocol.PacketResponse.InitialHandshakeProtocol;

namespace Client.Network.API
{
    public class InitialHandshakeResponse
    {
        public Vector3 PlayerPos { get; }
        public WorldDataResponse WorldData { get; }
        public List<MapObjectsInfoMessagePack> MapObjects { get; }
        public PlayerInventoryResponse Inventory { get; }
        public ChallengeResponse Challenge { get; }
        public List<BlockStateMessagePack> BlockStates { get; }
        
        public InitialHandshakeResponse(ResponseInitialHandshakeMessagePack response, WorldDataResponse worldData, List<MapObjectsInfoMessagePack> mapObjects, PlayerInventoryResponse inventory, ChallengeResponse challenge, List<BlockStateMessagePack> blockStates)
        {
            PlayerPos = response.PlayerPos;
            WorldData = worldData;
            MapObjects = mapObjects;
            Inventory = inventory;
            Challenge = challenge;
            BlockStates = blockStates;
        }
    }
    
    public class PlayerInventoryResponse
    {
        public PlayerInventoryResponse(List<IItemStack> mainInventory, IItemStack grabItem)
        {
            MainInventory = mainInventory;
            GrabItem = grabItem;
        }
        
        public List<IItemStack> MainInventory { get; }
        public IItemStack GrabItem { get; }
    }
    
    public class WorldDataResponse
    {
        public readonly List<BlockInfo> Blocks;
        public readonly List<EntityResponse> Entities;
        
        public WorldDataResponse(List<BlockInfo> blocks, List<EntityResponse> entities)
        {
            Blocks = blocks;
            Entities = entities;
        }
    }
    
    public class BlockInfo
    {
        public readonly BlockDirection BlockDirection;
        public readonly BlockId BlockId;
        public readonly Vector3Int BlockPos;
        
        public BlockInfo(BlockDataMessagePack blockDataMessagePack)
        {
            BlockPos = blockDataMessagePack.BlockPos;
            BlockId = blockDataMessagePack.BlockId;
            BlockDirection = blockDataMessagePack.BlockDirection;
        }
    }
    
    public class EntityResponse
    {
        public readonly long InstanceId;
        public readonly Vector3 Position;
        public readonly string State;
        public readonly string Type;
        
        public EntityResponse(EntityMessagePack entityMessagePack)
        {
            InstanceId = entityMessagePack.InstanceId;
            Type = entityMessagePack.Type;
            Position = entityMessagePack.Position;
            State = entityMessagePack.State;
        }
    }
    
    public class ChallengeResponse
    {
        public readonly List<ChallengeMasterElement> CompletedChallenges;
        public readonly List<ChallengeMasterElement> CurrentChallenges;
        
        public ChallengeResponse(List<ChallengeMasterElement> currentChallenges, List<ChallengeMasterElement> completedChallenges)
        {
            CurrentChallenges = currentChallenges;
            CompletedChallenges = completedChallenges;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/BlockDebugState.cs
```cs
using System.Threading;
using Client.Game.GameDebug;
using Client.Game.InGame.Control;
using Client.Game.InGame.UI.UIState.Input;
using Client.Game.Skit;
using Client.Input;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class BlockDebugState : IUIState
    {
        private readonly SkitManager _skitManager;
        private readonly ScreenClickableCameraController _screenClickableCameraController;
        
        private CancellationTokenSource _startTweenCameraCancellationTokenSource;
        
        public BlockDebugState(SkitManager skitManager, InGameCameraController inGameCameraController)
        {
            _screenClickableCameraController = new ScreenClickableCameraController(inGameCameraController);
            _skitManager = skitManager;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            _screenClickableCameraController.OnEnter();
            _screenClickableCameraController.StartTweenFromTop();
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.PlayerInventory;
            if (_skitManager.IsPlayingSkit) return UIStateEnum.Story;
            if (DebugInfoStore.EnableBlockDebugMode) return UIStateEnum.GameScreen;
            
            _screenClickableCameraController.GetNextUpdate();
            
            if (BlockClickDetect.TryGetCursorOnBlock(out var block))
            {
                DebugInfoStore.InvokeClickBlock(block);
            }
            
            return UIStateEnum.Current;
        }
        
        public void OnExit()
        {
            _screenClickableCameraController.OnExit();
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/ItemStackMetaData.cs
```cs
using MessagePack;

namespace Core.Item.Interface
{
    [MessagePackObject]
    public abstract class ItemStackMetaData
    {
        public abstract bool Equals(ItemStackMetaData target);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningIdleState.cs
```cs

using Client.Game.InGame.UI.Util;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningIdleState : IMapObjectMiningState
    {
        public MapObjectMiningIdleState()
        {
            MouseCursorExplainer.Instance.Hide();
        }
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            return
                context.CurrentFocusMapObjectGameObject != null 
                    ? new MapObjectMiningFocusState() 
                    : this;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Extension/BlockExtension.cs
```cs
using Game.Block.Interface.Component;

namespace Game.Block.Interface.Extension
{
    public static class BlockExtension
    {
        public static T GetComponent<T>(this IBlock block) where T : IBlockComponent
        {
            return block.ComponentManager.GetComponent<T>();
        }
        
        public static bool ExistsComponent<T>(this IBlock block) where T : IBlockComponent
        {
            return block.ComponentManager.ExistsComponent<T>();
        }
        
        public static bool TryGetComponent<T>(this IBlock block, out T component) where T : IBlockComponent
        {
            return block.ComponentManager.TryGetComponent(out component);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/items.json
```cs
{
  "data": [
    {
      "maxStack": 100,
      "name": "Test1",
      "itemGuid": "00000000-0000-0000-1234-000000000001",
      "imagePath": "Test1",
      "sortPriority": 100
    },
    {
      "maxStack": 50,
      "name": "Test2",
      "itemGuid": "00000000-0000-0000-1234-000000000002",
      "imagePath": "Test2"
    },
    {
      "maxStack": 300,
      "name": "Test3",
      "itemGuid": "00000000-0000-0000-1234-000000000003",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test4",
      "itemGuid": "00000000-0000-0000-1234-000000000004",
      "imagePath": "Test1"
    },
    {
      "maxStack": 200,
      "name": "Test5",
      "itemGuid": "00000000-0000-0000-1234-000000000005",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test6",
      "itemGuid": "00000000-0000-0000-1234-000000000006",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test7",
      "itemGuid": "00000000-0000-0000-1234-000000000007",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test8",
      "itemGuid": "00000000-0000-0000-1234-000000000008",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test9",
      "itemGuid": "00000000-0000-0000-1234-000000000009",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test10",
      "itemGuid": "00000000-0000-0000-1234-000000000010",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "Test11",
      "itemGuid": "00000000-0000-0000-1234-000000000011",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "tree",
      "itemGuid": "00000000-0000-0000-1234-000000000012",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "stone",
      "itemGuid": "00000000-0000-0000-1234-000000000013",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "SmallTestGear",
      "itemGuid": "00000000-0000-0000-1234-000000000014",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "BigTestGear",
      "itemGuid": "16000000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestShaft",
      "itemGuid": "17000000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestGearMachine",
      "itemGuid": "18000000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestSimpleGearGenerator",
      "itemGuid": "19000000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestFastSimpleGearGenerator",
      "itemGuid": "11100000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "SmallRequireTorqueTestGear",
      "itemGuid": "11200000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "BigRequireTorqueTestGear",
      "itemGuid": "11300000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "InfinityTestSimpleGearGenerator",
      "itemGuid": "11400000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "StraightTestItemShooter",
      "itemGuid": "11500000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "DownTestItemShooter",
      "itemGuid": "11600000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "UpTestItemShooter",
      "itemGuid": "11700000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "GearBeltConveyor",
      "itemGuid": "11800000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestElectricMachine1",
      "itemGuid": "11900000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestElectricMachine2",
      "itemGuid": "12010000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "maxStack": 100,
      "name": "TestElectricMachine3",
      "itemGuid": "12102000-0000-0000-0000-000000000000",
      "imagePath": "Test1"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "GearMiner",
      "imagePath": "Test1",
      "itemGuid": "ca6225bf-41ea-466d-89ef-98334f8c628f"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerTransporter",
      "itemGuid": "db52f4b0-c28c-4f18-a6c8-0b054e460006"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerCrafter",
      "itemGuid": "b76d00ed-72c9-436d-af80-11739a4f3e14"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerProviderChest",
      "itemGuid": "35be2026-4730-46d3-9821-5d5f88ac3326"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMainComputer",
      "itemGuid": "59ca039e-7b91-41d9-b387-9bbfa73b74e5"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerBeltConveyor",
      "itemGuid": "9ba04edc-1fe0-4528-91a8-80155a51bfe0"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMachine1",
      "itemGuid": "0b9e2f8f-b53f-440f-8913-0664f51e6856"
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMachine2",
      "itemGuid": "7dd72da1-e030-494e-a650-a651f7826648"
    },
    {
      "maxStack": 100,
      "name": "Chainer - A",
      "itemGuid": "189672cb-6811-4080-bde1-1f9ff0ec63ff"
    },
    {
      "maxStack": 100,
      "name": "Chainer - B",
      "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
    },
    {
      "maxStack": 100,
      "name": "Chainer - C",
      "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "blockType": "TrainRail",
      "maxStack": 100,
      "name": "TestTrainRail",
      "itemGuid": "1b72541e-0896-43bb-91fa-0b3fef137dcf"
    },
    {
      "maxStack": 100,
      "name": "TestTrainStation",
      "itemGuid": "9bdfa843-d4ee-4033-a61c-538bb9aaa21d"
    },
    {
      "maxStack": 100,
      "name": "TestTrainCargoPlatform",
      "itemGuid": "4a2cd701-ecd0-45f1-ae00-1e43adcadd84"
    }
  ]
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/ITutorialView.cs
```cs
namespace Client.Game.InGame.Tutorial
{
    public interface ITutorialView
    {
        public void CompleteTutorial();
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ConfigOnly/mods/testConfigOnlyMod2/modMeta.json
```cs
{
  "id": "testMod2",
  "name": "Test Mod 2",
  "version": "2.0",
  "author": "Test Author 2",
  "description": "This is a test mod."
}
```

moorestech_server/Assets/Scripts/Core.Master/MapObjectMaster.cs
```cs
using System;
using Mooresmaster.Loader.MapObjectsModule;
using Mooresmaster.Model.MapObjectsModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class MapObjectMaster
    {
        public readonly MapObjects MapObjects;
        
        public MapObjectMaster(JToken jToken)
        {
            MapObjects = MapObjectsLoader.Load(jToken);
        }
        
        public MapObjectMasterElement GetMapObjectElement(Guid guid)
        {
            return Array.Find(MapObjects.Data, x => x.MapObjectGuid == guid);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/EntityInstanceId.cs
```cs
using UnitGenerator;

namespace Game.Entity.Interface
{
    [UnitOf(typeof(long))]
    public partial struct EntityInstanceId
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/WaitTimeTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class WaitTimeTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var time = float.Parse(parameters[0]);
            await UniTask.Delay((int)(time * 1000));
            
            return null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Player/PlayerGrabItemManager.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Player
{
    public class PlayerGrabItemManager : MonoBehaviour
    {
        [SerializeField] private Transform leftHandParent;
        [SerializeField] private Transform rightHandParent;
        
        public void SetItem(GameObject item, bool isLeft, Vector3 position = default, Quaternion rotation = default)
        {
            var parent = isLeft ? leftHandParent : rightHandParent;
            item.transform.SetParent(parent);
            item.transform.localPosition = position;
            item.transform.localRotation = rotation;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Extension/BlockMasterExtension.cs
```cs
using System;
using Core.Master;

namespace Game.Block.Interface.Extension
{
    public static class BlockMasterExtension
    {
        public static BlockId GetVerticalOverrideBlockId(this BlockId blockId,BlockVerticalDirection verticalDirection)
        {
            var blockElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            var overrideBlock = blockElement.OverrideVerticalBlock;
            if (overrideBlock == null)
            {
                return blockId;
            }
            
            if (verticalDirection is BlockVerticalDirection.Up && overrideBlock.UpBlockGuid != Guid.Empty)
            {
                return MasterHolder.BlockMaster.GetBlockId(overrideBlock.UpBlockGuid);
            }
            if (verticalDirection is BlockVerticalDirection.Horizontal && overrideBlock.HorizontalBlockGuid != Guid.Empty)
            {
                return MasterHolder.BlockMaster.GetBlockId(overrideBlock.HorizontalBlockGuid);
            }
            if (verticalDirection is  BlockVerticalDirection.Down && overrideBlock.DownBlockGuid != Guid.Empty)
            {
                return MasterHolder.BlockMaster.GetBlockId(overrideBlock.DownBlockGuid);
            }
            
            return blockId;
        }
        
        public static BlockId GetVerticalOverrideBlockId(this Guid blockGuid,BlockVerticalDirection verticalDirection)
        {
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockGuid);
            return blockId.GetVerticalOverrideBlockId(verticalDirection);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/mapObjects.json
```cs
{
  "data": [
    {
      "earnItemHps": [
        0,
        10,
        20
      ],
      "hp": 30,
      "mapObjectName": "vanilla:Tree",
      "miningTools": [
        {
          "attackSpeed": 1.6,
          "damage": 1,
          "toolItemGuid": "00000000-0000-0000-1234-000000000001"
        }
      ],
      "earnItems": [
        {
          "maxCount": 5,
          "minCount": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        }
      ],
      "mapObjectGuid": "8c0e1339-be75-4690-99cd-58b5385a17cd",
      "soundEffectType": "tree",
      "miningType": "PickUp",
      "miningParam": {}
    }
  ]
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/MinHeap.cs
```cs
//generated by Chat GPT 4o
using System;
using System.Collections.Generic;

namespace Game.Train.RailGraph
{
    public class MinHeap<T> where T : IComparable<T>
    {
        private List<T> _elements;

        public MinHeap()
        {
            _elements = new List<T>();
        }

        public int Count => _elements.Count;

        public bool IsEmpty => Count == 0;

        // Insert a new element into the heap
        public void Insert(T item)
        {
            _elements.Add(item);
            HeapifyUp(_elements.Count - 1);
        }

        // Get the minimum element without removing it
        public T Peek()
        {
            if (IsEmpty)
            {
                throw new InvalidOperationException("Heap is empty.");
            }
            return _elements[0];
        }

        // Remove and return the minimum element
        public T RemoveMin()
        {
            if (IsEmpty)
            {
                throw new InvalidOperationException("Heap is empty.");
            }

            T root = _elements[0];
            _elements[0] = _elements[Count - 1];
            _elements.RemoveAt(Count - 1);

            if (!IsEmpty)
            {
                HeapifyDown(0);
            }

            return root;
        }

        private void HeapifyUp(int index)
        {
            while (index > 0)
            {
                int parentIndex = (index - 1) / 2;

                if (_elements[index].CompareTo(_elements[parentIndex]) >= 0)
                {
                    break;
                }

                Swap(index, parentIndex);
                index = parentIndex;
            }
        }

        private void HeapifyDown(int index)
        {
            while (index < Count)
            {
                int leftChildIndex = 2 * index + 1;
                int rightChildIndex = 2 * index + 2;
                int smallestIndex = index;

                if (leftChildIndex < Count && _elements[leftChildIndex].CompareTo(_elements[smallestIndex]) < 0)
                {
                    smallestIndex = leftChildIndex;
                }

                if (rightChildIndex < Count && _elements[rightChildIndex].CompareTo(_elements[smallestIndex]) < 0)
                {
                    smallestIndex = rightChildIndex;
                }

                if (smallestIndex == index)
                {
                    break;
                }

                Swap(index, smallestIndex);
                index = smallestIndex;
            }
        }

        private void Swap(int index1, int index2)
        {
            T temp = _elements[index1];
            _elements[index1] = _elements[index2];
            _elements[index2] = temp;
        }
    }

}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/DeleteBlockState.cs
```cs
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Control;
using Client.Game.InGame.UI.UIState.Input;
using Client.Game.InGame.UI.UIState.UIObject;
using Client.Input;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class DeleteBlockState : IUIState
    {
        private readonly DeleteBarObject _deleteBarObject;
        
        private readonly ScreenClickableCameraController _screenClickableCameraController;
        
        private BlockGameObject _removeTargetBlock;
        
        public DeleteBlockState(DeleteBarObject deleteBarObject, InGameCameraController inGameCameraController)
        {
            _screenClickableCameraController = new ScreenClickableCameraController(inGameCameraController);
            _deleteBarObject = deleteBarObject;
            deleteBarObject.gameObject.SetActive(false);
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            _screenClickableCameraController.OnEnter();
            _deleteBarObject.gameObject.SetActive(true);
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.CloseUI.GetKeyDown || InputManager.UI.BlockDelete.GetKeyDown) return UIStateEnum.GameScreen;
            
            if (InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.PlayerInventory;
            if (InputManager.UI.OpenMenu.GetKeyDown) return UIStateEnum.PauseMenu;
            
            if (BlockClickDetect.TryGetCursorOnBlock(out var blockGameObject))
            {
                if (_removeTargetBlock == null || _removeTargetBlock != blockGameObject)
                {
                    if (_removeTargetBlock != null) _removeTargetBlock.ResetMaterial();
                    
                    _removeTargetBlock = blockGameObject;
                    _removeTargetBlock.SetRemovePreviewing();
                }
            }
            else if (_removeTargetBlock != null)
            {
                _removeTargetBlock.ResetMaterial();
                _removeTargetBlock = null;
            }
            
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && _removeTargetBlock != null)
            {
                var blockPosition = _removeTargetBlock.BlockPosInfo.OriginalPos;
                ClientContext.VanillaApi.SendOnly.BlockRemove(blockPosition);
            }
            
            _screenClickableCameraController.GetNextUpdate();
            
            return UIStateEnum.Current;
        }
        
        
        public void OnExit()
        {
            if (_removeTargetBlock != null) _removeTargetBlock.ResetMaterial();
            _deleteBarObject.gameObject.SetActive(false);
            
            _screenClickableCameraController.OnExit();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/ItemManaged/GrabInventoryData.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Event;
using Game.PlayerInventory.Interface.Event;

namespace Game.PlayerInventory.ItemManaged
{
    public class GrabInventoryData : IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems => _openableInventoryService.InventoryItems;
        
        private readonly GrabInventoryUpdateEvent _grabInventoryUpdateEvent;
        private readonly OpenableInventoryItemDataStoreService _openableInventoryService;
        private readonly int _playerId;
        
        public GrabInventoryData(int playerId, GrabInventoryUpdateEvent grabInventoryUpdateEvent)
        {
            _playerId = playerId;
            _grabInventoryUpdateEvent = grabInventoryUpdateEvent;
            _openableInventoryService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, 1);
        }
        
        public GrabInventoryData(int playerId, GrabInventoryUpdateEvent grabInventoryUpdateEvent, IItemStack itemStacks) : this(playerId, grabInventoryUpdateEvent)
        {
            _openableInventoryService.SetItemWithoutEvent(0, itemStacks);
        }
        
        public IItemStack GetItem(int slot)
        {
            return _openableInventoryService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _openableInventoryService.SetItem(slot, itemStack);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            _openableInventoryService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            return _openableInventoryService.ReplaceItem(slot, itemStack);
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            return _openableInventoryService.ReplaceItem(slot, itemId, count);
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return _openableInventoryService.InsertItem(itemStack);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            return _openableInventoryService.InsertItem(itemId, count);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return _openableInventoryService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return _openableInventoryService.InsertionCheck(itemStacks);
        }
        
        public int GetSlotSize()
        {
            return _openableInventoryService.GetSlotSize();
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            return _openableInventoryService.CreateCopiedItems();
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _grabInventoryUpdateEvent.OnInventoryUpdateInvoke(new PlayerInventoryUpdateEventProperties(
                _playerId, slot, itemStack));
        }
    }
}
```

schema/items.json
```cs
{
  "$id": "items",
  "type": "object",
  "isDefaultOpen": true,

  "properties": {
    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "ItemMasterElement",
      
      "items": {
        "type": "object",
        "thumbnail": "imagePath",

        "properties": {
          "itemGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "imagePath": {
            "type": "string",
            "pattern": "@imagePath",
            "thumbnail": true,
            "optional": true
          },

          "name": {
            "type": "string"
          },

          "maxStack": {
            "type": "integer",
            "default" : 100
          },

          "sortPriority": {
            "type": "number",
            "default" : 100,
            "optional": true
          }
        }
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/Factory/ChallengeFactory.cs
```cs
using System.Collections.Generic;
using Mooresmaster.Model.ChallengesModule;

namespace Game.Challenge.Task.Factory
{
    public class ChallengeFactory
    {
        public delegate IChallengeTask ChallengeTaskCreator(int playerId, ChallengeMasterElement challengeElement);
        
        private readonly Dictionary<string,ChallengeTaskCreator> _taskCreators = new();
        
        public ChallengeFactory()
        {
            _taskCreators.Add(VanillaChallengeType.CreateItemTask,CreateItemChallengeTask.Create);
            _taskCreators.Add(VanillaChallengeType.InInventoryItemTask,InInventoryItemChallengeTask.Create);
            _taskCreators.Add(VanillaChallengeType.BlockPlaceTask,BlockPlaceChallengeTask.Create);
        }
        
        public IChallengeTask CreateChallengeTask(int playerId, ChallengeMasterElement challengeElement)
        {
            var creator = _taskCreators[challengeElement.TaskCompletionType];
            return creator(playerId, challengeElement);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockException.cs
```cs
using System;
using Game.Block.Interface.Component;

namespace Game.Block.Interface
{
    public static class BlockException
    {
        private const string IsDestroyed = "This component is already destroyed";
        private static readonly InvalidOperationException IsDestroyedException = new(IsDestroyed);
        
        public static void CheckDestroy(IBlockComponent blockComponent)
        {
            if (blockComponent.IsDestroy)
            {
                throw IsDestroyedException;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/ProgressBar/ProgressBarView.cs
```cs
using System;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.ProgressBar
{
    public class ProgressBarView : MonoBehaviour
    {
        [SerializeField] private GameObject viewRoot;
        [SerializeField] private Scrollbar scrollbar;
        
        public static ProgressBarView Instance;
        
        private void Awake()
        {
            Instance = this;
            Hide();
        }
        
        public void Show()
        {
            viewRoot.SetActive(true);
        }
        
        public void Hide()
        {
            viewRoot.SetActive(false);
        }
        
        public void SetProgress(float progress)
        {
            scrollbar.size = progress;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/IgnoreRendererMaterialReplacer.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class IgnoreRendererMaterialReplacer : MonoBehaviour
    {
        
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/Util/CreateEmptyItemStacksArray.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Context;

namespace Core.Item.Util
{
    public static class CreateEmptyItemStacksList
    {
        public static List<IItemStack> Create(int count)
        {
            var a = new List<IItemStack>();
            for (var i = 0; i < count; i++) a.Add(ServerContext.ItemStackFactory.CreatEmpty());
            
            return a;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Input/HotBarKeyBoardComposite.cs
```cs
using UnityEditor;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Layouts;
using UnityEngine.InputSystem.Utilities;
#if UNITY_EDITOR
#endif

namespace Client.Input
{
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif
    [DisplayStringFormat("{select0}/{select1}/{select2}/{select3}/{select4}/{select5}/{select6}/{select7}/{select8}")]
    public class HotBarKeyBoardComposite : InputBindingComposite<int>
    {
        [InputControl(layout = "Button")] public int select0 = 1;
        [InputControl(layout = "Button")] public int select1 = 2;
        [InputControl(layout = "Button")] public int select2 = 3;
        [InputControl(layout = "Button")] public int select3 = 4;
        [InputControl(layout = "Button")] public int select4 = 5;
        [InputControl(layout = "Button")] public int select5 = 6;
        [InputControl(layout = "Button")] public int select6 = 7;
        [InputControl(layout = "Button")] public int select7 = 8;
        [InputControl(layout = "Button")] public int select8 = 9;
#if UNITY_EDITOR
        static HotBarKeyBoardComposite()
        {
            Initialize();
        }
#endif
        
        [RuntimeInitializeOnLoadMethod]
        private static void Initialize()
        {
            InputSystem.RegisterBindingComposite<HotBarKeyBoardComposite>();
        }
        
        public override int ReadValue(ref InputBindingCompositeContext context)
        {
            if (context.ReadValueAsButton(select0)) return select0;
            if (context.ReadValueAsButton(select1)) return select1;
            if (context.ReadValueAsButton(select2)) return select2;
            if (context.ReadValueAsButton(select3)) return select3;
            if (context.ReadValueAsButton(select4)) return select4;
            if (context.ReadValueAsButton(select5)) return select5;
            if (context.ReadValueAsButton(select6)) return select6;
            if (context.ReadValueAsButton(select7)) return select7;
            if (context.ReadValueAsButton(select8)) return select8;
            
            return 0;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/UIHighlight/UIHighlightTutorialManager.cs
```cs
using Mooresmaster.Model.ChallengesModule;
using UnityEngine;

namespace Client.Game.InGame.Tutorial.UIHighlight
{
    public class UIHighlightTutorialManager : MonoBehaviour, ITutorialViewManager
    {
        public const string TutorialType = "uiHighLight";
        
        [SerializeField] private UIHighlightTutorialView highlightTutorialViewPrefab;
        [SerializeField] private RectTransform highlightParent;
        
        public ITutorialView ApplyTutorial(ITutorialParam param)
        {
            var highlightParam = (UiHighLightTutorialParam)param;
            
            var highlightTargetObjects = FindObjectsOfType<UIHighlightTutorialTargetObject>(true);
            foreach (var targetObject in highlightTargetObjects)
            {
                if (targetObject.HighlightObjectId != highlightParam.HighLightUIObjectId) continue;
                
                var highlightView = Instantiate(highlightTutorialViewPrefab, transform);
                highlightView.SetTargetObject(targetObject, highlightParam.HighLightText);
                return highlightView;
            }
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/EntityInstance/PlayerEntity.cs
```cs
using UnityEngine;

namespace Game.Entity.Interface.EntityInstance
{
    public class PlayerEntity : IEntity
    {
        public PlayerEntity(EntityInstanceId instanceId, Vector3 position)
        {
            InstanceId = instanceId;
            Position = position;
        }
        
        public Vector3 Position { get; private set; }
        
        public EntityInstanceId InstanceId { get; }
        public string EntityType => VanillaEntityType.VanillaPlayer;
        public string State => string.Empty;
        
        public void SetPosition(Vector3 serverVector3)
        {
            Position = serverVector3;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BackgroundSkit/BackgroundSkitUI.cs
```cs
using Cysharp.Threading.Tasks;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.BackgroundSkit
{
    public class BackgroundSkitUI : MonoBehaviour
    {
        [SerializeField] private TMP_Text characterName;
        [SerializeField] private TMP_Text line;
        
        [SerializeField] private AudioSource voiceSource;
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
        
        public async UniTask SetText(string name, string sentence, AudioClip voice = null)
        {
            characterName.text = name;
            line.text = sentence;
            
            if (voice == null)
            {
                await UniTask.Delay(3000);
                return;
            }
            
            voiceSource.clip = voice;
            voiceSource.Play();
            
            await UniTask.Delay((int)(voiceSource.clip.length * 1000));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearPower.cs
```cs
using UnitGenerator;

namespace Game.Gear.Common
{
    [UnitOf(typeof(float), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable)]
    public partial struct GearPower
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CharacterEmotionTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using static System.Enum;

namespace Client.Skit.SkitTrack
{
    public class CharacterEmotionTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var characterKey = parameters[0];
            var emotion = (EmotionType)Parse(typeof(EmotionType), parameters[1]);
            var duration = float.Parse(parameters[2]);
            
            var character = storyContext.GetCharacter(characterKey);
            character.SetEmotion(emotion, duration);
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/Factory/VanillaChallengeType.cs
```cs
namespace Game.Challenge.Task.Factory
{
    public class VanillaChallengeType
    {
        public const string CreateItemTask = "createItem";
        public const string InInventoryItemTask = "inInventoryItem";
        public const string BlockPlaceTask = "blockPlace";
    }
}
```

moorestech_client/Assets/Scripts/Client.Localization/TextMeshProLocalize.cs
```cs
using System;
using TMPro;
using UniRx;
using UnityEngine;

namespace Client.Localization
{
    [RequireComponent(typeof(TextMeshProUGUI))]
    public class TextMeshProLocalize : MonoBehaviour
    {
        [SerializeField] private string key;
        
        private TMP_Text _text;
        
        private void Awake()
        {
            _text = GetComponent<TextMeshProUGUI>();
            _text.text = Localize.Get(key);
            
            Localize.OnLanguageChanged.Subscribe(_ => GetComponent<TextMeshProUGUI>().text = Localize.Get(key))
                .AddTo(this);
        }
        
        public void SetKey(string key, params string[] addContents)
        {
            this.key = key;
            
            var text = string.Empty;
            try
            {
                text = string.Format(Localize.Get(key), addContents);
            }
            catch (FormatException e)
            {
                text = "[Localize] Format Error : " + key;
            }
            catch (Exception e)
            {
                text = $"[Localize] Other Error : {key} : {e.Message}";
            }
            
            if (_text == null) _text = GetComponent<TextMeshProUGUI>();
            _text.text = text;
            _text.ForceMeshUpdate();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Input/InputManager.cs
```cs
using System;
using UnityEngine;
using UnityEngine.InputSystem;

namespace Client.Input
{
    public static class InputManager
    {
        private static PayerInputManager player;
        private static PlayableInputManager playable;
        private static UIInputManager ui;
        private static MoorestechInputSettings _instance;
        public static PayerInputManager Player => player ??= new PayerInputManager(Instance);
        
        public static PlayableInputManager Playable => playable ??= new PlayableInputManager(Instance);
        
        public static UIInputManager UI => ui ??= new UIInputManager(Instance);
        
        
        private static MoorestechInputSettings Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new MoorestechInputSettings();
                    _instance.Enable();
                }
                
                return _instance;
            }
        }
        
        public static void MouseCursorVisible(bool isVisible)
        {
            Cursor.lockState = isVisible ? CursorLockMode.None : CursorLockMode.Locked;
        }
    }
    
    public class PayerInputManager
    {
        public readonly InputKey Jump;
        public readonly InputKey Look;
        public readonly InputKey Move;
        public readonly InputKey Sprint;
        
        public PayerInputManager(MoorestechInputSettings settings)
        {
            Move = new InputKey(settings.Player.Move);
            Look = new InputKey(settings.Player.Look);
            Jump = new InputKey(settings.Player.Jump);
            Sprint = new InputKey(settings.Player.Sprint);
        }
    }
    
    public class PlayableInputManager
    {
        public readonly InputKey BlockPlaceRotation;
        public readonly InputKey ClickPosition;
        public readonly InputKey ScreenLeftClick;
        public readonly InputKey ScreenRightClick;
        
        public PlayableInputManager(MoorestechInputSettings settings)
        {
            ScreenLeftClick = new InputKey(settings.Playable.ScreenLeftClick);
            ScreenRightClick = new InputKey(settings.Playable.ScreenRightClick);
            ClickPosition = new InputKey(settings.Playable.ClickPosition);
            BlockPlaceRotation = new InputKey(settings.Playable.BlockPlaceRotation);
        }
    }
    
    public class UIInputManager
    {
        public readonly InputKey AllCraft;
        public readonly InputKey BlockDelete;
        public readonly InputKey CloseUI;
        public readonly InputKey HotBar;
        public readonly InputKey InventoryItemHalve;
        public readonly InputKey InventoryItemOnePut;
        public readonly InputKey ItemDirectMove;
        public readonly InputKey OneStackCraft;
        public readonly InputKey OpenInventory;
        public readonly InputKey OpenMenu;
        public readonly InputKey QuestUI;
        public readonly InputKey SwitchHotBar;
        
        public UIInputManager(MoorestechInputSettings settings)
        {
            OpenMenu = new InputKey(settings.UI.OpenMenu);
            CloseUI = new InputKey(settings.UI.CloseUI);
            OpenInventory = new InputKey(settings.UI.OpenInventory);
            InventoryItemOnePut = new InputKey(settings.UI.InventoryItemOnePut);
            InventoryItemHalve = new InputKey(settings.UI.InventoryItemHalve);
            HotBar = new InputKey(settings.UI.HotBar);
            SwitchHotBar = new InputKey(settings.UI.SwitchHotBar);
            BlockDelete = new InputKey(settings.UI.BlockDelete);
            AllCraft = new InputKey(settings.UI.AllCraft);
            OneStackCraft = new InputKey(settings.UI.OneStackCraft);
            QuestUI = new InputKey(settings.UI.QuestUI);
            ItemDirectMove = new InputKey(settings.UI.ItemDirectMove);
        }
    }
    
    public class InputKey
    {
        private readonly InputAction _inputAction;
        
        
        public InputKey(InputAction key)
        {
            _inputAction = key;
            key.started += _ => { OnGetKeyDown?.Invoke(); };
            key.performed += _ => { OnGetKey?.Invoke(); };
            key.canceled += _ => { OnGetKeyUp?.Invoke(); };
        }
        
        public bool GetKeyDown => _inputAction.WasPressedThisFrame();
        public bool GetKey => _inputAction.IsPressed();
        public bool GetKeyUp => _inputAction.WasReleasedThisFrame();
        
        public event Action OnGetKeyDown;
        public event Action OnGetKey;
        public event Action OnGetKeyUp;
        
        public TValue ReadValue<TValue>() where TValue : struct
        {
            return _inputAction.ReadValue<TValue>();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/GameDebug/DebugInfoStore.cs
```cs
using System;
using Client.Game.InGame.Block;
using UniRx;

namespace Client.Game.GameDebug
{
    public class DebugInfoStore
    {
        public static bool EnableBlockDebugMode { get; set; }
        
        public static IObservable<BlockGameObject> OnClickBlock => _onClickBlock;
        private static readonly Subject<BlockGameObject> _onClickBlock = new();
        
        public static void InvokeClickBlock(BlockGameObject block)
        {
            _onClickBlock.OnNext(block);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CharacterTransformTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Skit.SkitTrack
{
    public class CharacterTransformTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var characterKey = parameters[0];
            
            var posX = float.Parse(parameters[2]);
            var posY = float.Parse(parameters[3]);
            var posZ = float.Parse(parameters[4]);
            var pos = new Vector3(posX, posY, posZ);
            
            var rotX = float.Parse(parameters[6]);
            var rotY = float.Parse(parameters[7]);
            var rotZ = float.Parse(parameters[8]);
            var rot = new Vector3(rotX, rotY, rotZ);
            
            var character = storyContext.GetCharacter(characterKey);
            
            character.SetTransform(pos, rot);
            
            return null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/InitializeProprieties.cs
```cs
using System.Diagnostics;

namespace Client.Starter
{
    public class InitializeProprieties
    {
        public readonly bool IsLocal;
        public readonly Process LocalServerProcess;
        public readonly int PlayerId;
        public readonly string ServerIp;
        public readonly int ServerPort;
        
        public InitializeProprieties(bool isLocal, Process localServerProcess, string serverIp, int serverPort, int playerId)
        {
            IsLocal = isLocal;
            LocalServerProcess = localServerProcess;
            ServerIp = serverIp;
            ServerPort = serverPort;
            PlayerId = playerId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeEvent.cs
```cs
using System;
using Game.Challenge.Task;
using UniRx;

namespace Game.Challenge
{
    public class ChallengeEvent
    {
        private readonly Subject<IChallengeTask> _onCompleteChallenge = new();
        public IObservable<IChallengeTask> OnCompleteChallenge => _onCompleteChallenge;
        
        public void InvokeCompleteChallenge(IChallengeTask craftConfig)
        {
            _onCompleteChallenge.OnNext(craftConfig);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/EntityProperties.cs
```cs
using Server.Util.MessagePack;
using UnityEngine;

namespace Client.Common
{
    public class EntityProperties
    {
        public readonly long InstanceId;
        public readonly Vector3 Position;
        public readonly string State;
        public readonly string Type;
        
        public EntityProperties(EntityMessagePack entityMessagePack)
        {
            InstanceId = entityMessagePack.InstanceId;
            Type = entityMessagePack.Type;
            var x = entityMessagePack.Position.X;
            var y = entityMessagePack.Position.Y;
            var z = entityMessagePack.Position.Z;
            Position = new Vector3(x, y, z);
            State = entityMessagePack.State;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapObjectFactory.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using UnityEngine;

namespace Game.Map
{
    public class MapObjectFactory : IMapObjectFactory
    {
        public IMapObject Create(int instanceId, Guid mapObjectGuid, int currentHp, bool isDestroyed, Vector3 position)
        {
            return new VanillaStaticMapObject(instanceId, mapObjectGuid, isDestroyed, currentHp, position);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/CharacterMotionTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class CharacterMotionTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var characterKey = parameters[0];
            var animationName = parameters[1];
            
            var character = storyContext.GetCharacter(characterKey);
            character.PlayAnimation(animationName);
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity/EntityFactory.cs
```cs
using System.Collections.Generic;
using Game.Entity.Interface;
using Game.Entity.Interface.EntityInstance;
using UnityEngine;

namespace Game.Entity
{
    public class EntityFactory : IEntityFactory
    {
        public IEntity CreateEntity(string entityType, EntityInstanceId instanceId, Vector3 position = default)
        {
            if (entityType == VanillaEntityType.VanillaPlayer) return new PlayerEntity(instanceId, position);
            
            if (entityType == VanillaEntityType.VanillaItem) return new ItemEntity(instanceId, position);
            
            throw new KeyNotFoundException("Entity type not found : " + entityType);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockDebugInfo.cs
```cs
using MessagePack;

namespace Game.Block.Interface.Component
{
    public interface IBlockDebugInfo : IBlockComponent
    {
        public BlockDebugInfo GetDebugInfo();
    }
    
    
    [MessagePackObject]
    public struct BlockDebugInfo
    {
        [Key(0)] public string ComponentName;
        [Key(1)] public string Value;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockGameObjectChild.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class BlockGameObjectChild : MonoBehaviour
    {
        public BlockGameObject BlockGameObject { get; private set; }
        
        public void Init(BlockGameObject blockGameObject)
        {
            BlockGameObject = blockGameObject;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/StoryContext.cs
```cs
using System.Collections.Generic;
using Client.Skit.Define;
using Client.Skit.Skit;
using Client.Skit.UI;
using UnityEngine;

namespace Client.Skit.SkitTrack
{
    public class StoryContext
    {
        private readonly Dictionary<string, SkitCharacter> _characters;
        public readonly ISkitCamera SkitCamera;
        public readonly SkitUI SkitUI;
        public readonly VoiceDefine VoiceDefine;
        
        public StoryContext(SkitUI skitUI, Dictionary<string, SkitCharacter> characters, SkitCamera skitCamera, VoiceDefine voiceDefine)
        {
            SkitUI = skitUI;
            _characters = characters;
            SkitCamera = skitCamera;
            VoiceDefine = voiceDefine;
        }
        
        public SkitCharacter GetCharacter(string characterKey)
        {
            return _characters[characterKey];
        }
        
        public void DestroyCharacter()
        {
            foreach (var character in _characters) Object.Destroy(character.Value.gameObject);
        }
    }
}
```

schema/ref/mineSettings.json
```cs
{
  "$id": "mineSettings",

  "type": "array",
  "overrideCodeGeneratePropertyName": "MineSettingsMasterElement",
  
  "items": {
    "type": "object",
    "properties": {
      "itemGuid": {
        "type": "string",
        "format": "uuid",
        "foreignKey": "items:itemGuid:name"
      },

      "time": {
        "type": "number",
        "default": 1
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Game.Gear/Common/IGearGenerator.cs
```cs
namespace Game.Gear.Common
{
    public interface IGearGenerator : IGear
    {
        public RPM GenerateRpm { get; }
        public Torque GenerateTorque { get; }
        
        public bool GenerateIsClockwise { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Vein/IMapVeinDatastore.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Game.Map.Interface.Vein
{
    public interface IMapVeinDatastore
    {
        public List<IMapVein> GetOverVeins(Vector3Int pos);
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/IWorldEnergySegmentDatastore.cs
```cs
using Game.EnergySystem;

namespace Game.World.Interface.DataStore
{
    public interface IWorldEnergySegmentDatastore<TSegment> where TSegment : EnergySegment, new()
    {
        public TSegment GetEnergySegment(IElectricTransformer transformer);
        public TSegment GetEnergySegment(int index);
        public TSegment CreateEnergySegment();
        public void SetEnergySegment(TSegment energySegment);
        public void RemoveEnergySegment(TSegment energySegment);
        public int GetEnergySegmentListCount();
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Element/ProgressArrowView.cs
```cs
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Element
{
    public class ProgressArrowView : MonoBehaviour
    {
        [SerializeField] private Slider slider;
        
        public void SetProgress(float value)
        {
            slider.value = value;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/VanillaEntityType.cs
```cs
namespace Game.Entity.Interface
{
    public static class VanillaEntityType
    {
        public const string VanillaPlayer = "va:Player";
        public const string VanillaItem = "va:Item";
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/GearMinerSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Inventory;
using Core.Master;
using Game.Block.Blocks.Miner;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    /// <summary>
    /// This test class verifies the save and load functionality of the GearMiner block.
    /// It ensures that the miner's state, including its inventory and remaining mining time, is correctly preserved.
    /// </summary>
    public class GearMinerSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            // Initialize the server and get the block factory.
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;

            // Get the block GUID for the GearMiner.
            var minerGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearMiner).BlockGuid;

            // Create the position info for the miner.
            var minerPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);

            // Create an instance of the GearMiner block.
            var originalMiner = blockFactory.Create(ForUnitTestModBlockId.GearMiner, new BlockInstanceId(1), minerPosInfo);
            var originalMinerComponent = originalMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Set the remaining mining time to a specific value.
            var originalRemainingSecond = 0.35;

            // Access the miner's inventory using reflection to set test items.
            var inventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(originalMinerComponent);

            // Set some items in the miner's inventory.
            inventory.SetItem(0, new ItemId(1), 1);
            inventory.SetItem(2, new ItemId(4), 1);

            // Set the remaining mining time using reflection.
            typeof(VanillaMinerProcessorComponent)
                .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                .SetValue(originalMinerComponent, originalRemainingSecond);

            // Save the state of the miner to a JSON string.
            var json = originalMiner.GetSaveState();
            Debug.Log(json);

            // Load a new miner instance from the saved state.
            var loadedMiner = blockFactory.Load(minerGuid, new BlockInstanceId(2), json, minerPosInfo);
            var loadedMinerComponent = loadedMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Access the loaded miner's inventory and remaining mining time.
            var loadedInventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);

            var loadedRemainingSecond =
                (double)typeof(VanillaMinerProcessorComponent)
                    .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);

            // Assert that the original and loaded inventories are equal.
            Assert.AreEqual(inventory.GetItem(0), loadedInventory.GetItem(0));
            Assert.AreEqual(inventory.GetItem(1), loadedInventory.GetItem(1));
            Assert.AreEqual(inventory.GetItem(2), loadedInventory.GetItem(2));

            // Assert that the remaining mining time is the same.
            Assert.AreEqual(originalRemainingSecond, loadedRemainingSecond);
        }
    }
}

```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryMoveUtil/ItemMoveInventoryType.cs
```cs
namespace Server.Protocol.PacketResponse.Util.InventoryMoveUtil
{
    public enum ItemMoveInventoryType
    {
        MainInventory,
        GrabInventory,
        BlockInventory,
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/ServerConst.cs
```cs
namespace Server.Protocol
{
    public class ServerConst
    {
        public const int PollingRateMillSec = 100;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Entity/IEntityObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Entity
{
    public interface IEntityObject
    {
        public void SetDirectPosition(Vector3 position);
        public void SetInterpolationPosition(Vector3 position);
        public void Destroy();
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Json/MapInfoJson.cs
```cs
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Map.Interface.Json
{
    public class MapInfoJson
    {
        [JsonProperty("mapObjects")] public List<MapObjectInfoJson> MapObjects;
        [JsonProperty("mapVeins")] public List<MapVeinInfoJson> MapVeins;
    }
    
    public class MapObjectInfoJson
    {
        [JsonProperty("instanceId")] public int InstanceId;
        [JsonProperty("mapObjectGuid")] public string MapObjectGuidStr;
        [JsonIgnore] public Guid MapObjectGuid => new(MapObjectGuidStr);
        
        [JsonProperty("x")] public float X;
        [JsonProperty("y")] public float Y;
        [JsonProperty("z")] public float Z;
        
        [JsonIgnore] public Vector3 Position => new(X, Y, Z);
    }
    
    public class MapVeinInfoJson
    {
        [JsonProperty("veinItemGuid")] public string VeinItemGuidStr;
        [JsonIgnore] public Guid VeinItemGuid => Guid.Parse(VeinItemGuidStr);
        
        [JsonIgnore] public Vector3Int MinPosition => new(MinX, MinY, MinZ);
        [JsonProperty("minX")] public int MinX;
        [JsonProperty("minY")] public int MinY;
        [JsonProperty("minZ")] public int MinZ;
        
        [JsonIgnore] public Vector3Int MaxPosition => new(MaxX, MaxY, MaxZ);
        [JsonProperty("maxX")] public int MaxX;
        [JsonProperty("maxY")] public int MaxY;
        [JsonProperty("maxZ")] public int MaxZ;
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/TransitionTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class TransitionTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var isShow = parameters[0] == "TRUE";
            var duration = float.Parse(parameters[1]);
            storyContext.SkitUI.ShowTransition(isShow, duration);
            
            await UniTask.Delay((int)(duration * 1000));
            
            return null;
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/GenerateTextTrackVoice.cs
```cs
using UnityEditor;
using UnityEngine;

public class GenerateTextTrackVoice : EditorWindow
{
    private void CreateGUI()
    {
    }
    
    [MenuItem("moorestech/GenerateTextTrackVoice")]
    private static void ShowWindow()
    {
        var window = GetWindow<GenerateTextTrackVoice>();
        window.titleContent = new GUIContent("GenerateTextTrackVoice");
        window.Show();
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/ComponentAttribute/DisallowMultiple.cs
```cs
using System;

namespace Game.Block.Interface.ComponentAttribute
{
    [AttributeUsage(AttributeTargets.Interface | AttributeTargets.Class)]
    public class DisallowMultiple : Attribute
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/ServerConst.cs
```cs
using static System.IO.Path;

namespace Client.Common
{
    public class ServerConst
    {
        public const string LocalServerIp = "127.0.0.1";
        public const int LocalServerPort = 11564;
        
        public const int DefaultPlayerId = 1;
        
        
        public static readonly string ServerDirName = "Server";
        public static readonly string ServerDirectory = GetFullPath("./" + ServerDirName);
        
        public static readonly string ServerExePath = Combine(ServerDirectory, "moorestech_server.exe");
        public static readonly string ServerModsDirectory = Combine(ServerDirectory, "mods");
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockSaveState.cs
```cs

namespace Game.Block.Interface.Component
{
    public interface IBlockSaveState : IBlockComponent
    {
        public string SaveKey { get; }
        string GetSaveState();
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/WorldSettingJsonObject.cs
```cs
using Newtonsoft.Json;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public class WorldSettingJsonObject
    {
        [JsonProperty("SpawnX")] public int SpawnX;
        [JsonProperty("SpawnY")] public int SpawnY;
        
        public WorldSettingJsonObject(Vector3Int spawnPoint)
        {
            SpawnX = spawnPoint.x;
            SpawnY = spawnPoint.y;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World/WorldBlockUpdateEvent.cs
```cs
using System;
using Game.Block.Interface.Extension;
using Game.World.Interface.DataStore;
using UniRx;
using UnityEngine;

namespace Game.World
{
    public class WorldBlockUpdateEvent : IWorldBlockUpdateEvent
    {
        private readonly Subject<BlockUpdateProperties> _onBlockPlaceEvent = new();
        private readonly Subject<BlockUpdateProperties> _onBlockRemoveEvent = new();
        public IObservable<BlockUpdateProperties> OnBlockPlaceEvent => _onBlockPlaceEvent;
        
        public IObservable<BlockUpdateProperties> OnBlockRemoveEvent => _onBlockRemoveEvent;
        
        public IDisposable SubscribePlace(Vector3Int subscribePos, Action<BlockUpdateProperties> blockPlaceEvent)
        {
            return _onBlockPlaceEvent.Subscribe(data =>
            {
                if (data.BlockData.BlockPositionInfo.IsContainPos(subscribePos)) blockPlaceEvent(new BlockUpdateProperties(subscribePos, data.BlockData));
            });
        }
        
        public IDisposable SubscribeRemove(Vector3Int subscribePos, Action<BlockUpdateProperties> blockPlaceEvent)
        {
            return _onBlockRemoveEvent.Subscribe(data =>
            {
                if (data.BlockData.BlockPositionInfo.IsContainPos(subscribePos)) blockPlaceEvent(new BlockUpdateProperties(subscribePos, data.BlockData));
            });
        }
        
        public void OnBlockPlaceEventInvoke(Vector3Int pos, WorldBlockData worldBlockData)
        {
            _onBlockPlaceEvent.OnNext(new BlockUpdateProperties(pos, worldBlockData));
        }
        
        public void OnBlockRemoveEventInvoke(Vector3Int pos, WorldBlockData worldBlockData)
        {
            _onBlockRemoveEvent.OnNext(new BlockUpdateProperties(pos, worldBlockData));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/PlayerInventoryData.cs
```cs
using Core.Inventory;

namespace Game.PlayerInventory.Interface
{
    public class PlayerInventoryData
    {
        public readonly IOpenableInventory GrabInventory;
        public readonly IOpenableInventory MainOpenableInventory;
        
        public PlayerInventoryData(IOpenableInventory mainOpenableInventory, IOpenableInventory grabInventory)
        {
            MainOpenableInventory = mainOpenableInventory;
            GrabInventory = grabInventory;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Context/ItemStackSaveJsonObjectExtension.cs
```cs
using Core.Item.Interface;

namespace Game.Context
{
    public static class ItemStackSaveJsonObjectExtension
    {
        public static IItemStack ToItemStack(this ItemStackSaveJsonObject itemStackSaveJsonObject)
        {
            return ServerContext.ItemStackFactory.Create(itemStackSaveJsonObject.ItemGuid, itemStackSaveJsonObject.Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIObject/DeleteBarObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.UI.UIState.UIObject
{
    public class DeleteBarObject : MonoBehaviour
    {
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/SetPlayerId.cs
```cs
using Client.Common;
using UnityEngine;

namespace Client.MainMenu
{
    /// <summary>
    ///     IDID
    /// </summary>
    public class SetPlayerId : MonoBehaviour
    {
        private void Start()
        {
            if (!PlayerPrefs.HasKey(PlayerPrefsKeys.PlayerIdKey))
            {
                //ID
                PlayerPrefs.SetInt(PlayerPrefsKeys.PlayerIdKey, Random.Range(2, int.MaxValue));
                PlayerPrefs.Save();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/IPlayerInventoryDataStore.cs
```cs
using System.Collections.Generic;

namespace Game.PlayerInventory.Interface
{
    public interface IPlayerInventoryDataStore
    {
        public PlayerInventoryData GetInventoryData(int playerId);
        public List<PlayerInventorySaveJsonObject> GetSaveJsonObject();
        public void LoadPlayerInventory(List<PlayerInventorySaveJsonObject> saveInventoryDataList);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Skit/Starter/SkitStarterObject.cs
```cs
using UnityEngine;

namespace Client.Game.Skit.Starter
{
    public class SkitStarterObject : MonoBehaviour
    {
        [SerializeField] private TextAsset scenarioCsv;
        public TextAsset ScenarioCsv => scenarioCsv;
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/IEntityFactory.cs
```cs
using UnityEngine;

namespace Game.Entity.Interface
{
    public interface IEntityFactory
    {
        public IEntity CreateEntity(string entityType, EntityInstanceId instanceId, Vector3 serverPosition = default);
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/IWorldSettingsDatastore.cs
```cs
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public interface IWorldSettingsDatastore
    {
        public Vector3Int WorldSpawnPoint { get; }
        
        public WorldSettingJsonObject GetSaveJsonObject();
        public void Initialize();
        public void LoadSettingData(WorldSettingJsonObject worldSettingJsonObject);
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/modMeta.json
```cs
{
  "id": "forUniTest",
  "name": "Test Mod 2",
  "version": "2.0",
  "author": "Test Author",
  "description": "This is a test mod."
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad.Interface/IWorldSaveDataSaver.cs
```cs
namespace Game.SaveLoad.Interface
{
    public interface IWorldSaveDataSaver
    {
        public void Save();
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/BlockPlaceChallengeTask.cs
```cs
using System;
using Game.Context;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.ChallengesModule;
using UniRx;

namespace Game.Challenge.Task
{
    public class BlockPlaceChallengeTask : IChallengeTask
    {
        public ChallengeMasterElement ChallengeMasterElement { get; }
        public int PlayerId { get; }
        
        public IObservable<IChallengeTask> OnChallengeComplete => _onChallengeComplete;
        private readonly Subject<IChallengeTask> _onChallengeComplete = new();
        
        private bool _completed;
        
        public static IChallengeTask Create(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            return new BlockPlaceChallengeTask(playerId, challengeMasterElement);
        }
        public BlockPlaceChallengeTask(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            ChallengeMasterElement = challengeMasterElement;
            PlayerId = playerId;
            
            var worldEvent = ServerContext.WorldBlockUpdateEvent;
            worldEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlace);
        }
        
        private void OnBlockPlace(BlockUpdateProperties properties)
        {
            if (_completed) return;
            
            var param = ChallengeMasterElement.TaskParam as BlockPlaceTaskParam;
            if (param.BlockGuid == properties.BlockData.Block.BlockGuid)
            {
                _completed = true;
                _onChallengeComplete.OnNext(this);
            }
        }
        
        public void ManualUpdate()
        {
            
        }
    }
}
```

schema/mapObjects.json
```cs
{
  "$id": "mapObjects",
  "type": "object",
  "isDefaultOpen": true,
  
  "properties": {
    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "MapObjectMasterElement",

      "items": {
        "type": "object",
        "properties": {

          "mapObjectGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "mapObjectName": {
            "type": "string",
            "default": "mapObjectName"
          },

          "hp": {
            "type": "integer",
            "default": 100
          },
          "earnItemHps": {
            "type": "array",
            "items": {
              "type": "integer"
            },
            "default": [0]
          },
          "soundEffectType":{
            "type": "string",
            "enum":["tree","stone"]
          },
          "earnItems": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "itemGuid": {
                  "type": "string",
                  "format": "uuid",
                  "foreignKey": "items:itemGuid:name"
                },
                "minCount": {
                  "type": "integer",
                  "default": 1
                },
                "maxCount": {
                  "type": "integer",
                  "default": 3
                }
              }
            }
          },
          
          "miningType": {
            "type": "string",
            "enum":["PickUp","Mining"]
          },
          
          "miningParam": {
            "oneOf": [
              {
                "if": {
                  "properties": {
                    "miningType": { "const": "PickUp" }
                  }
                },
                "then": {
                  "type": "object",
                  "optional": true,
                  "properties": {
                  }
                }
              },

              {
                "if": {
                  "properties": {
                    "miningType": { "const": "Mining" }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    
                    "miningTools": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "toolItemGuid": {
                            "type": "string",
                            "format": "uuid",
                            "foreignKey": "items:itemGuid:name"
                          },
                          "damage": {
                            "type": "integer",
                            "default": 10
                          },
                          "attackSpeed": {
                            "type": "number",
                            "default": 1
                          }
                        }
                      }
                    }

                  }
                }
              }

            ]
          }
        }
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/AssembleSaveJsonText.cs
```cs
using Game.Challenge;
using Game.Context;
using Game.Entity.Interface;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using Game.SaveLoad.Json.WorldVersions;
using Game.World.Interface.DataStore;
using Newtonsoft.Json;

namespace Game.SaveLoad.Json
{
    public class AssembleSaveJsonText
    {
        private readonly ChallengeDatastore _challengeDatastore;
        private readonly IEntitiesDatastore _entitiesDatastore;
        private readonly IPlayerInventoryDataStore _inventoryDataStore;
        private readonly IMapObjectDatastore _mapObjectDatastore;
        private readonly IWorldSettingsDatastore _worldSettingsDatastore;
        
        public AssembleSaveJsonText(IPlayerInventoryDataStore inventoryDataStore, IEntitiesDatastore entitiesDatastore, IWorldSettingsDatastore worldSettingsDatastore, IMapObjectDatastore mapObjectDatastore, ChallengeDatastore challengeDatastore)
        {
            _inventoryDataStore = inventoryDataStore;
            _entitiesDatastore = entitiesDatastore;
            _worldSettingsDatastore = worldSettingsDatastore;
            _mapObjectDatastore = mapObjectDatastore;
            _challengeDatastore = challengeDatastore;
        }
        
        public string AssembleSaveJson()
        {
            var saveData = new WorldSaveAllInfoV1(
                ServerContext.WorldBlockDatastore.GetSaveJsonObject(),
                _inventoryDataStore.GetSaveJsonObject(),
                _entitiesDatastore.GetSaveJsonObject(),
                _worldSettingsDatastore.GetSaveJsonObject(),
                _mapObjectDatastore.GetSaveJsonObject(),
                _challengeDatastore.GetSaveJsonObject()
            );
            
            return JsonConvert.SerializeObject(saveData);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad.Interface/IWorldSaveDataLoader.cs
```cs
namespace Game.SaveLoad.Interface
{
    public interface IWorldSaveDataLoader
    {
        public void LoadOrInitialize();
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ElectricMinerSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Inventory;
using Core.Master;
using Game.Block.Blocks.Miner;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    /// <summary>
    /// This test class verifies the save and load functionality of the ElectricMiner block.
    /// It ensures that the miner's state, including its inventory and remaining mining time, is correctly preserved.
    /// </summary>
    public class ElectricMinerSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            // Initialize the server and get the block factory.
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;

            // Get the block GUID for the ElectricMiner.
            var minerGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.ElectricMinerId).BlockGuid;

            // Create the position info for the miner.
            var minerPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);

            // Create an instance of the ElectricMiner block.
            var originalMiner = blockFactory.Create(ForUnitTestModBlockId.ElectricMinerId, new BlockInstanceId(1), minerPosInfo);
            var originalMinerComponent = originalMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Set the remaining mining time to a specific value.
            var originalRemainingSecond = 0.35;

            // Access the miner's inventory using reflection to set test items.
            var inventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(originalMinerComponent);

            // Set some items in the miner's inventory.
            inventory.SetItem(0, new ItemId(1), 1);
            inventory.SetItem(2, new ItemId(4), 1);

            // Set the remaining mining time using reflection.
            typeof(VanillaMinerProcessorComponent)
                .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                .SetValue(originalMinerComponent, originalRemainingSecond);

            // Save the state of the miner to a JSON string.
            var json = originalMiner.GetSaveState();
            Debug.Log(json);
            
            
            // ------- finish Save -------
            // ------- start Load -------

            // Load a new miner instance from the saved state.
            var loadedMiner = blockFactory.Load(minerGuid, new BlockInstanceId(1), json, minerPosInfo);
            var loadedMinerComponent = loadedMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Access the loaded miner's inventory and remaining mining time.
            var loadedInventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);

            var loadedRemainingSecond =
                (double)typeof(VanillaMinerProcessorComponent)
                    .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);

            // Assert that the original and loaded inventories are equal.
            Assert.AreEqual(inventory.GetItem(0), loadedInventory.GetItem(0));
            Assert.AreEqual(inventory.GetItem(1), loadedInventory.GetItem(1));
            Assert.AreEqual(inventory.GetItem(2), loadedInventory.GetItem(2));

            // Assert that the remaining mining time is the same.
            Assert.AreEqual(originalRemainingSecond, loadedRemainingSecond);
        }
    }
}

```

moorestech_client/Assets/Scripts/Client.Common/Server/NetworkConst.cs
```cs
namespace Client.Common.Server
{
    public class NetworkConst
    {
        public const int SecondUpdateRate = 10;
        public const int UpdateIntervalMilliseconds = 1000 / SecondUpdateRate;
        public const float UpdateIntervalSeconds = 1.0f / SecondUpdateRate;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/ITutorialViewManager.cs
```cs
using Mooresmaster.Model.ChallengesModule;

namespace Client.Game.InGame.Tutorial
{
    public interface ITutorialViewManager
    {
        public ITutorialView ApplyTutorial(ITutorialParam param);

    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockVerticalDirection.cs
```cs
namespace Game.Block.Interface
{
    public enum BlockVerticalDirection
    {
        Up,
        Horizontal,
        Down,
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTestModBlockId.cs
```cs
using Core.Master;

namespace Tests.Module.TestMod
{
    public static class ForUnitTestModBlockId
    {
        public static readonly BlockId MachineId = (BlockId)1;
        public static readonly BlockId BlockId = (BlockId)2;
        public static readonly BlockId BeltConveyorId = (BlockId)3;
        public static readonly BlockId ElectricPoleId = (BlockId)4;
        public static readonly BlockId GeneratorId = (BlockId)5;
        public static readonly BlockId ElectricMinerId = (BlockId)6;
        public static readonly BlockId ChestId = (BlockId)7;
        public static readonly BlockId InfinityGeneratorId = (BlockId)8;
        
        public static readonly BlockId MultiBlockGeneratorId = (BlockId)10;
        
        public static readonly BlockId SmallGear = (BlockId)12;
        public static readonly BlockId BigGear = (BlockId)13;
        public static readonly BlockId Shaft = (BlockId)14;
        public static readonly BlockId GearMachine = (BlockId)15;
        public static readonly BlockId SimpleGearGenerator = (BlockId)16;
        public static readonly BlockId SimpleFastGearGenerator = (BlockId)17;
        public static readonly BlockId Teeth10RequireTorqueTestGear = (BlockId)18;
        public static readonly BlockId Teeth20RequireTorqueTestGear = (BlockId)19;
        public static readonly BlockId InfinityTorqueSimpleGearGenerator = (BlockId)20;
        public static readonly BlockId GearBeltConveyor = (BlockId)21;
        
        public static readonly BlockId StraightItemShooter = (BlockId)22;
        public static readonly BlockId DownItemShooter = (BlockId)23;
        public static readonly BlockId UpItemShooter = (BlockId)24;
        
        public static readonly BlockId MachineRecipeTest1 = (BlockId)25;
        public static readonly BlockId MachineRecipeTest2 = (BlockId)26;
        public static readonly BlockId MachineRecipeTest3 = (BlockId)27;
        
        public static readonly BlockId GearMiner = (BlockId)28;
        
        public static readonly BlockId CraftChainerTransporter = (BlockId)29;
        public static readonly BlockId CraftChainerCrafter = (BlockId)30;
        public static readonly BlockId CraftChainerProviderChest = (BlockId)31;
        public static readonly BlockId CraftChainerMainComputer = (BlockId)32;
        public static readonly BlockId CraftChainerBeltConveyor = (BlockId)33;
        public static readonly BlockId CraftChainerMachine1 = (BlockId)34;
        public static readonly BlockId CraftChainerMachine2 = (BlockId)35;
        
        public static readonly BlockId TestTrainRail = (BlockId)35;
        public static readonly BlockId TestTrainStation = (BlockId)36;
        public static readonly BlockId TestTrainCargoPlatform = (BlockId)37;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Map/MapVein/MapVeinGameObject.cs
```cs
using System;
using UnityEngine;

namespace Client.Game.InGame.Map.MapVein
{
    [ExecuteAlways]
    public class MapVeinGameObject : MonoBehaviour
    {
        public Vector3Int MinPosition => new(
            Mathf.RoundToInt(transform.position.x - bounds.size.x / 2f + bounds.center.x),
            Mathf.RoundToInt(transform.position.y - bounds.size.y / 2f + bounds.center.y),
            Mathf.RoundToInt(transform.position.z - bounds.size.z / 2f + bounds.center.z));
        
        public Vector3Int MaxPosition => new(
            Mathf.RoundToInt(transform.position.x + bounds.size.x / 2f + bounds.center.x),
            Mathf.RoundToInt(transform.position.y + bounds.size.y / 2f + bounds.center.y),
            Mathf.RoundToInt(transform.position.z + bounds.size.z / 2f + bounds.center.z));
        
        public Vector3 Size => bounds.size;
        public Vector3 CenterPosition => bounds.center + transform.position;
        
        public Guid VeinItemGuid => Guid.Parse(veinItemGuid);
        [SerializeField] private string veinItemGuid;
        
        public Bounds Bounds => bounds;
        [SerializeField] private Bounds bounds = new(Vector3.zero, Vector3.one);
        
        public void SetBounds(Bounds setBounds)
        {
            bounds = setBounds;
            
            var size = bounds.size;
            var sizeX = size.x < 1 ? 1 : Mathf.RoundToInt(size.x);
            var sizeY = size.y < 1 ? 1 : Mathf.RoundToInt(size.y);
            var sizeZ = size.z < 1 ? 1 : Mathf.RoundToInt(size.z);
            bounds.size = new Vector3(sizeX, sizeY, sizeZ);
            
            var centerX = sizeX % 2f == 0 ? 0 : 0.5f;
            var centerY = sizeY % 2f == 0 ? 0 : 0.5f;
            var centerZ = sizeZ % 2f == 0 ? 0 : 0.5f;
            bounds.center = new Vector3(centerX, centerY, centerZ);
        }
        
        private void Update()
        {
#if UNITY_EDITOR
            OnEditorUpdate();
#endif
        }
        
        private void OnEditorUpdate()
        {
            transform.position = new Vector3Int(
                Mathf.RoundToInt(transform.position.x),
                Mathf.RoundToInt(transform.position.y),
                Mathf.RoundToInt(transform.position.z));
            SetBounds(bounds);
        }
        
        private void OnDrawGizmosSelected()
        {
            var color = Color.red;
            color.a = 0.5f;
            Gizmos.color = color;
            Gizmos.DrawCube(CenterPosition, Size);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Skit/SkitCharacter.cs
```cs
using System.Collections.Generic;
using Client.Skit.SkitTrack;
using DG.Tweening;
using UnityEngine;

namespace Client.Skit.Skit
{
    public class SkitCharacter : MonoBehaviour
    {
        [SerializeField] private AudioSource voiceAudioSource;
        [SerializeField] private SkinnedMeshRenderer faceSkinnedMeshRenderer;
        [SerializeField] private Animator animator;
        
        public void Initialize(Transform parent, string name)
        {
            gameObject.name = name + " (StoryCharacter)";
            transform.SetParent(parent);
        }
        
        public void SetTransform(Vector3 position, Vector3 rotation)
        {
            transform.position = position;
            transform.eulerAngles = rotation;
        }
        
        public void PlayAnimation(string animationName)
        {
            animator.SetTrigger(animationName);
        }
        
        public void PlayVoice(AudioClip voiceClip)
        {
            voiceAudioSource.clip = voiceClip;
            voiceAudioSource.Play();
        }
        
        public void StopVoice()
        {
            voiceAudioSource.Stop();
        }
        
        public void SetEmotion(EmotionType emotion, float duration)
        {
            var blendShapeData = ToBlendShapeData(emotion);
            
            // Tween BlendShape
            foreach (var (key, value) in blendShapeData)
                DOTween.To(
                    () => faceSkinnedMeshRenderer.GetBlendShapeWeight(key),
                    x => faceSkinnedMeshRenderer.SetBlendShapeWeight(key, x),
                    value,
                    duration);
            
            #region Internal
            
            Dictionary<int, float> ToBlendShapeData(EmotionType emotionType)
            {
                return emotionType switch
                {
                    EmotionType.Normal => new Dictionary<int, float> { { 11, 0f } },
                    EmotionType.Happy => new Dictionary<int, float> { { 11, 100 } },
                };
            }
            
            #endregion
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Player/PlayerContainer.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Player
{
    public class PlayerContainer : MonoBehaviour
    {
        [SerializeField] private PlayerGrabItemManager playerGrabItemManager;
        [SerializeField] private PlayerObjectController playerObjectController;
        public PlayerGrabItemManager PlayerGrabItemManager => playerGrabItemManager;
        
        public IPlayerObjectController PlayerObjectController => playerObjectController;
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/craftRecipes.json
```cs
{
  "data": [
    {
      "craftResultCount": 2,
      "craftResultItemGuid": "00000000-0000-0000-1234-000000000003",
      "requiredItems": [
        {
          "percent": 1,
          "count": 2,
          "maxCount": 3,
          "minCount": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        },
        {
          "count": 2,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "craftRecipeGuid": "a7b03292-073b-460f-aed4-78d9dc6db7a8",
      "craftTime": 3
    },
    {
      "craftResultCount": 2,
      "craftResultItemGuid": "00000000-0000-0000-1234-000000000003",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        }
      ],
      "craftRecipeGuid": "aab28fa7-d853-4446-9509-a87070f423f0",
      "craftTime": 3
    },
    {
      "craftResultCount": 80,
      "craftResultItemGuid": "00000000-0000-0000-1234-000000000006",
      "requiredItems": [
        {
          "count": 5,
          "itemGuid": "00000000-0000-0000-1234-000000000006"
        }
      ],
      "craftRecipeGuid": "f94c8265-be95-4a1e-810f-e4d986f05006",
      "craftTime": 3
    },
    {
      "craftResultCount": 1,
      "craftResultItemGuid": "00000000-0000-0000-1234-000000000003",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 5,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "craftRecipeGuid": "f1b23a8e-83fc-43f2-8f79-6d236c56e81b",
      "craftTime": 3
    }
  ]
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/IGear.cs
```cs
namespace Game.Gear.Common
{
    public interface IGear : IGearEnergyTransformer
    {
        public int TeethCount { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/IWorldBlockDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public interface IWorldBlockDatastore
    {
        public IReadOnlyDictionary<BlockInstanceId, WorldBlockData> BlockMasterDictionary { get; }
        
        public IObservable<(BlockState state, WorldBlockData blockData)> OnBlockStateChange { get; }
        
        public bool TryAddBlock(BlockId blockId, Vector3Int position, BlockDirection direction, out IBlock block);
        public bool TryAddLoadedBlock(Guid blockGuid, BlockInstanceId blockInstanceId, Dictionary<string,string> componentStates, Vector3Int position, BlockDirection direction, out IBlock block);
        public bool RemoveBlock(Vector3Int pos);
        
        public IBlock GetBlock(Vector3Int pos);
        public IBlock GetBlock(BlockInstanceId blockInstanceId);
        public IBlock GetBlock(IBlockComponent component);
        
        public WorldBlockData GetOriginPosBlock(Vector3Int pos);
        public Vector3Int GetBlockPosition(BlockInstanceId blockInstanceId);
        public BlockDirection GetBlockDirection(Vector3Int pos);
        
        public List<BlockJsonObject> GetSaveJsonObject();
        public void LoadBlockDataList(List<BlockJsonObject> saveBlockDataList);
    }
    
    public static class WorldBlockDatastoreExtension
    {
        public static bool Exists(this IWorldBlockDatastore datastore, Vector3Int pos)
        {
            var block = datastore.GetBlock(pos);
            return block != null;
        }
        
        public static bool TryGetBlock(this IWorldBlockDatastore datastore, Vector3Int pos, out IBlock block)
        {
            block = datastore.GetBlock(pos);
            return block != null;
        }
        
        public static bool ExistsComponent<TComponent>(this IWorldBlockDatastore datastore, Vector3Int pos) where TComponent : IBlockComponent
        {
            var block = datastore.GetBlock(pos);
            if (block == null) return false;
            return block.ComponentManager.ExistsComponent<TComponent>();
        }
        
        public static TComponent GetBlock<TComponent>(this IWorldBlockDatastore datastore, Vector3Int pos) where TComponent : IBlockComponent
        {
            var block = datastore.GetBlock(pos);
            
            if (block.ComponentManager.TryGetComponent(out TComponent component2)) return component2;
            
            return default;
        }
        
        public static bool TryGetBlock<TComponent>(this IWorldBlockDatastore datastore, Vector3Int pos, out TComponent component) where TComponent : IBlockComponent
        {
            if (datastore.ExistsComponent<TComponent>(pos))
            {
                component = datastore.GetBlock<TComponent>(pos);
                return true;
            }
            
            component = default;
            return false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/WorldVersions/WorldSaveAllInfoV1.cs
```cs
using System.Collections.Generic;
using Game.Challenge;
using Game.Entity.Interface;
using Game.Map.Interface.Json;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using Newtonsoft.Json;

namespace Game.SaveLoad.Json.WorldVersions
{
    public class WorldSaveAllInfoV1
    {
        [JsonProperty("worldVersion")] public int WorldVersion = 1;
        
        public WorldSaveAllInfoV1(List<BlockJsonObject> world, List<PlayerInventorySaveJsonObject> inventory,
            List<EntityJsonObject> entities, WorldSettingJsonObject setting,
            List<MapObjectJsonObject> mapObjects, List<ChallengeJsonObject> challenge)
        {
            World = world;
            Inventory = inventory;
            Entities = entities;
            Setting = setting;
            MapObjects = mapObjects;
            Challenge = challenge;
        }
        
        [JsonProperty("world")] public List<BlockJsonObject> World { get; }
        [JsonProperty("playerInventory")] public List<PlayerInventorySaveJsonObject> Inventory { get; }
        [JsonProperty("entities")] public List<EntityJsonObject> Entities { get; }
        [JsonProperty("setting")] public WorldSettingJsonObject Setting { get; }
        [JsonProperty("mapObjects")] public List<MapObjectJsonObject> MapObjects { get; set; }
        [JsonProperty("challenge")] public List<ChallengeJsonObject> Challenge { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockStateObservable.cs
```cs
using System;
using UniRx;

namespace Game.Block.Interface.Component
{
    public interface IBlockStateObservable : IBlockStateDetail
    {
        public IObservable<Unit> OnChangeBlockState { get; }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/DebugEnvironmentController.cs
```cs
using UnityEngine;

namespace Client.DebugSystem
{
    public class DebugEnvironmentController : MonoBehaviour
    {
        [SerializeField] private GameObject debugEnvironment;
        [SerializeField] private GameObject pureNatureEnvironment;
        
        public static void SetEnvironment(DebugEnvironmentType environmentType)
        {
            var debugEnvironmentController = FindObjectOfType<DebugEnvironmentController>();
            if (debugEnvironmentController == null)
            {
                Debug.LogError("DebugEnvironmentController not found");
                return;
            }
            
            var debugEnvironment = false;
            var pureNatureEnvironment = false;
            switch (environmentType)
            {
                case DebugEnvironmentType.Debug:
                    debugEnvironment = true;
                    break;
                case DebugEnvironmentType.PureNature:
                    pureNatureEnvironment = true;
                    break;
            }
            
            debugEnvironmentController.debugEnvironment.SetActive(debugEnvironment);
            debugEnvironmentController.pureNatureEnvironment.SetActive(pureNatureEnvironment);
        }
    }
    
    public enum DebugEnvironmentType
    {
        Debug,
        PureNature
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearMinerMiningTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Core.Item.Interface;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Miner;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    /// <summary>
    /// Test class for the gear-powered miner component.
    /// </summary>
    public class GearMinerMiningTest
    {
        /// <summary>
        /// Tests that the gear miner produces items after the required mining time when supplied with correct RPM and torque.
        /// </summary>
        [Test]
        public void GearMiningTest()
        {
            // Initialize the dependency injection container and services.
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            // Retrieve necessary services.
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            
            // Locate a map vein (resource deposit) to mine.
            var (mapVein, position) = MinerMiningTest.GetMapVein();
            Assert.NotNull(mapVein, "No map vein found for mining.");

            // Add the gear miner block at the vein position.
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GearMiner, position, BlockDirection.North, out var gearMinerBlock);
            var gearMiner = worldBlockDatastore.GetBlock(position);

            // Retrieve the mining processor component from the gear miner.
            var minerProcessorComponent = gearMiner.GetComponent<VanillaMinerProcessorComponent>();

            // Use reflection to access private fields: _miningItems and _defaultMiningTime.
            var miningItemsField = typeof(VanillaMinerProcessorComponent).GetField("_miningItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var miningTimeField = typeof(VanillaMinerProcessorComponent).GetField("_defaultMiningTime", BindingFlags.NonPublic | BindingFlags.Instance);
            var miningItems = (List<IItemStack>)miningItemsField.GetValue(minerProcessorComponent);
            var miningItemId = miningItems[0].Id;
            var miningTime = (float)miningTimeField.GetValue(minerProcessorComponent);

            // Create a dummy inventory to receive mined items.
            var dummyInventory = new DummyBlockInventory();

            // Connect the dummy inventory to the miner's output.
            var minerConnectors = (Dictionary<IBlockInventory, ConnectedInfo>)gearMiner
                .GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            minerConnectors.Add(dummyInventory, new ConnectedInfo());

            // Place a gear generator adjacent to the gear miner to supply RPM and torque.
            var generatorPosition = position + new Vector3Int(0, 0, -1);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.InfinityTorqueSimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);

            // Ensure the gear network is updated so that the miner receives power.
            var gearNetwork = gearNetworkDatastore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();

            // Wait for the mining time to elapse.
            var mineEndTime = DateTime.Now.AddSeconds(miningTime * 1.2f);
            while (DateTime.Now < mineEndTime)
            {
                GameUpdater.UpdateWithWait();
            }

            // Verify that one item has been mined and transferred to the dummy inventory.
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id, "The mined item ID does not match.");
            Assert.AreEqual(1, dummyInventory.InsertedItems[0].Count, "The mined item count should be 1.");

            // Disconnect the dummy inventory to test internal storage.
            minerConnectors.Remove(dummyInventory);

            // Wait for two more mining cycles.
            mineEndTime = DateTime.Now.AddSeconds(miningTime * 2.2f);
            while (DateTime.Now < mineEndTime)
            {
                GameUpdater.UpdateWithWait();
            }

            // Check that two items are stored in the miner's internal inventory.
            var outputSlot = minerProcessorComponent.InventoryItems[0];
            Assert.AreEqual(miningItemId, outputSlot.Id, "The stored item ID does not match.");
            Assert.AreEqual(2, outputSlot.Count, "The stored item count should be 2.");

            // Reconnect the dummy inventory.
            minerConnectors.Add(dummyInventory, new ConnectedInfo());

            // Update the game state to allow the miner to transfer items to the dummy inventory.
            GameUpdater.UpdateWithWait();

            // Verify that a total of three items are now in the dummy inventory.
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id, "The mined item ID does not match after reconnection.");
            Assert.AreEqual(3, dummyInventory.InsertedItems[0].Count, "The total mined item count should be 3 after reconnection.");
        }
    }
}

```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/BlockJsonObject.cs
```cs
using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public class BlockJsonObject
    {
        [JsonProperty("blockGuid")] public string BlockGuidStr;
        [JsonIgnore] public Guid BlockGuid => Guid.Parse(BlockGuidStr);
        
        [JsonProperty("direction")] public int Direction;
        [JsonProperty("entityId")] public int EntityId;
        [JsonProperty("state")] public Dictionary<string,string> ComponentStates;
        
        [JsonIgnore] public Vector3Int Pos => new(X, Y, Z);
        [JsonProperty("X")] public int X;
        [JsonProperty("Y")] public int Y;
        [JsonProperty("Z")] public int Z;
        
        public BlockJsonObject(Vector3Int pos, string blockGuid, int entityId, Dictionary<string,string> componentStates, int direction)
        {
            X = pos.x;
            Y = pos.y;
            Z = pos.z;
            BlockGuidStr = blockGuid;
            EntityId = entityId;
            ComponentStates = componentStates;
            Direction = direction;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryMoveUtil/ItemMoveType.cs
```cs
namespace Server.Protocol.PacketResponse.Util.InventoryMoveUtil
{
    public enum ItemMoveType
    {
        SwapSlot,
        InsertSlot,
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/IBlockInventoryOpenStateDataStore.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface;
using UnityEngine;

namespace Game.PlayerInventory.Interface
{
    public interface IBlockInventoryOpenStateDataStore
    {
        public List<int> GetBlockInventoryOpenPlayers(BlockInstanceId blockBlockInstanceId);
        public void Open(int playerId, Vector3Int pos);
        public void Close(int playerId);
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity/EntitiesDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Game.Entity.Interface;
using UnityEngine;

namespace Game.Entity
{
    public class EntitiesDatastore : IEntitiesDatastore
    {
        private readonly Dictionary<EntityInstanceId, IEntity> _entities = new();
        
        private readonly IEntityFactory _entityFactory;
        
        public EntitiesDatastore(IEntityFactory entityFactory)
        {
            _entityFactory = entityFactory;
        }
        
        public void Add(IEntity entity)
        {
            _entities.Add(entity.InstanceId, entity);
        }
        
        public bool Exists(EntityInstanceId instanceId)
        {
            return _entities.ContainsKey(instanceId);
        }
        
        public IEntity Get(EntityInstanceId instanceId)
        {
            return _entities[instanceId];
        }
        
        public List<EntityJsonObject> GetSaveJsonObject()
        {
            var saveData = new List<EntityJsonObject>();
            foreach (KeyValuePair<EntityInstanceId, IEntity> entity in _entities)
            {
                var e = entity.Value;
                saveData.Add(new EntityJsonObject(e.EntityType, e.InstanceId.AsPrimitive(), e.Position));
            }
            
            return saveData;
        }
        
        public void LoadBlockDataList(List<EntityJsonObject> saveBlockDataList)
        {
            foreach (var save in saveBlockDataList)
            {
                var entity = _entityFactory.CreateEntity(save.Type, new EntityInstanceId(save.InstanceId));
                _entities.Add(entity.InstanceId, entity);
                
                var pos = new Vector3(save.X, save.Y, save.Z);
                SetPosition(new EntityInstanceId(save.InstanceId), pos);
            }
        }
        
        public void SetPosition(EntityInstanceId instanceId, Vector3 position)
        {
            if (_entities.TryGetValue(instanceId, out var entity))
            {
                entity.SetPosition(position);
                return;
            }
            
            throw new Exception("Entity not found " + instanceId);
        }
        
        public Vector3 GetPosition(EntityInstanceId instanceId)
        {
            if (_entities.TryGetValue(instanceId, out var entity)) return entity.Position;
            throw new Exception("Entity not found " + instanceId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/InternalItemContext.cs
```cs
namespace Core.Item
{
    internal class InternalItemContext
    {
        public static ItemStackFactory ItemStackFactory { get; private set; }
        
        public InternalItemContext(ItemStackFactory itemStackFactory)
        {
            ItemStackFactory = itemStackFactory;
        }
    }
}
```

moorestech_server/Assets/ServerStarter.cs
```cs
using System;
using System.Threading;
using Core.Update;
using Server.Boot;
using UnityEngine;

public class ServerStarter : MonoBehaviour
{
    private CancellationTokenSource _autoSaveToken;
    private Thread _serverUpdateThread;

    private void Start()
    {
        (_serverUpdateThread, _autoSaveToken) = StartServer.Start(new string[] { });
        _serverUpdateThread.Start();
    }

    private void FixedUpdate()
    {
        GameUpdater.Update();
    }

    private void OnDestroy()
    {
        _serverUpdateThread.Abort();
        _autoSaveToken.Cancel();
        GameUpdater.Dispose();
    }
}
```

schema/ref/gearConnects.json
```cs
{
  "$id": "gear",

  "type": "object",
  "properties": {

    "gearConnects": {
      "fixedParameter": {
        "path" : "./connectType",
        "value": "Gear"
      },
      "$ref" : "blockConnectInfo"
    }

  }
}

```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/SelectionTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;

namespace Client.Skit.SkitTrack
{
    public class SelectionTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            storyContext.SkitUI.ShowSelectionUI(true);
            
            var jumpTags = new List<string>();
            var selectionTexts = new List<string>();
            
            for (var i = 0; i < parameters.Count; i += 2)
            {
                var tag = parameters[i];
                var text = parameters[i + 1];
                //
                if (text == string.Empty) break;
                
                jumpTags.Add(tag);
                selectionTexts.Add(text);
            }
            
            var selectedIndex = await storyContext.SkitUI.WaitSelectText(selectionTexts);
            
            storyContext.SkitUI.ShowSelectionUI(false);
            
            var selectedTag = jumpTags[selectedIndex];
            if (selectedTag == string.Empty) return null;
            
            return selectedTag;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/GearStateChangeProcessor.cs
```cs
using System;
using System.Collections.Generic;
using Game.Gear.Common;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    public class GearStateChangeProcessor : MonoBehaviour, IBlockStateChangeProcessor
    {
        public IReadOnlyList<RotationInfo> RotationInfos => rotationInfos;
        [SerializeField] private List<RotationInfo> rotationInfos;
        
        public GearStateDetail CurrentGearState { get; private set; }
        
        public void OnChangeState(BlockStateMessagePack blockState)
        {
            CurrentGearState = blockState.GetStateDetail<GearStateDetail>(GearStateDetail.BlockStateDetailKey);
        }
        
        private void Update()
        {
            if (CurrentGearState == null) return;
            
            Rotate(CurrentGearState);
        }
        
        public void Rotate(GearStateDetail gearStateDetail)
        {
            var rpm = gearStateDetail.CurrentRpm;
            var rotation = rpm / 60 * Time.deltaTime * 360;
            foreach (var rotationInfo in rotationInfos)
            {
                var rotate = rotationInfo.RotationAxis switch
                {
                    RotationAxis.X => new Vector3(rotation, 0, 0),
                    RotationAxis.Y => new Vector3(0, rotation, 0),
                    RotationAxis.Z => new Vector3(0, 0, rotation),
                    _ => Vector3.zero,
                };
                rotate *= rotationInfo.IsReverse ? -1 : 1;
                rotate *= rotationInfo.RotationSpeed;
                rotate *= gearStateDetail.IsClockwise ? 1 : -1;
                
                rotationInfo.RotationTransform.Rotate(rotate);
            }
        }
    }
    
    [Serializable]
    public class RotationInfo
    {
        [SerializeField] private RotationAxis rotationAxis;
        [SerializeField] private Transform rotationTransform;
        [SerializeField] private bool isReverse;
        [SerializeField] private float rotationSpeed = 1;
        
        public RotationAxis RotationAxis => rotationAxis;
        public Transform RotationTransform => rotationTransform;
        public bool IsReverse => isReverse;
        public float RotationSpeed => rotationSpeed;
    }
    
    public enum RotationAxis
    {
        X,
        Y,
        Z,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/KeyControlTutorialManager.cs
```cs
using Client.Game.InGame.UI.UIState;
using Mooresmaster.Model.ChallengesModule;
using TMPro;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Tutorial
{
    public class KeyControlTutorialManager : MonoBehaviour, ITutorialView, ITutorialViewManager
    {
        public const string TutorialType = "keyControl";
        
        [SerializeField] private GameObject keyControlUIObject;
        [SerializeField] private TMP_Text keyControlTutorialText;
        
        private KeyControlTutorialParam _keyControlTutorialParam;
        private UIStateControl _uiStateControl;
        
        [Inject]
        public void Construct(UIStateControl uiStateControl)
        {
            _uiStateControl = uiStateControl;
        }
        
        private void Update()
        {
            if (_keyControlTutorialParam != null)
            {
                var active = _uiStateControl.CurrentState.ToString() == _keyControlTutorialParam.UiState;
                keyControlUIObject.gameObject.SetActive(active);
            }
            else
            {
                keyControlUIObject.gameObject.SetActive(false);
            }
        }
        
        public ITutorialView ApplyTutorial(ITutorialParam param)
        {
            _keyControlTutorialParam = (KeyControlTutorialParam)param;
            keyControlTutorialText.text = _keyControlTutorialParam.ControlText;
            return this;
        }
        
        public void CompleteTutorial()
        {
            _keyControlTutorialParam = null;
            keyControlUIObject.gameObject.SetActive(false);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/ElectricPower.cs
```cs
using UnitGenerator;

namespace Game.EnergySystem
{
    [UnitOf(typeof(float), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable)]
    public readonly partial struct ElectricPower
    {
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapVein.cs
```cs
using Core.Master;
using Game.Map.Interface.Vein;
using UnityEngine;

namespace Game.Map
{
    public class MapVein : IMapVein
    {
        public ItemId VeinItemId { get; }
        public Vector3Int VeinRangeMin { get; }
        public Vector3Int VeinRangeMax { get; }
        
        public MapVein(ItemId veinItemId, Vector3Int veinRangeMin, Vector3Int veinRangeMax)
        {
            VeinItemId = veinItemId;
            VeinRangeMin = veinRangeMin;
            VeinRangeMax = veinRangeMax;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IUpdatableBlockComponent.cs
```cs
namespace Game.Block.Interface.Component
{
    public interface IUpdatableBlockComponent : IBlockComponent
    {
        public void Update();
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/Torque.cs
```cs
using UnitGenerator;

namespace Game.Gear.Common
{
    [UnitOf(typeof(float), UnitGenerateOptions.ArithmeticOperator | UnitGenerateOptions.ValueArithmeticOperator | UnitGenerateOptions.Comparable)]
    public partial struct Torque
    {
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/craftRecipe.json
```cs
[
  {
    "requiredItems": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 2,
        "isRemain": false
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 3,
        "isRemain": false
      },
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 2,
        "isRemain": false
      }
    ],
    "resultItem": {
      "itemName": "Test3",
      "modId": "Test Author:forUniTest",
      "count": 1
    }
  },
  {
    "requiredItems": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "isRemain": false
      }
    ],
    "resultItem": {
      "itemName": "Test3",
      "modId": "Test Author:forUniTest",
      "count": 2
    }
  },
  {
    "requiredItems": [
      {
        "itemName": "Test6",
        "modId": "Test Author:forUniTest",
        "count": 5,
        "isRemain": false
      }
    ],
    "resultItem": {
      "itemName": "Test6",
      "modId": "Test Author:forUniTest",
      "count": 80
    }
  },
  {
    "requiredItems": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 3,
        "isRemain": true
      },
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 5,
        "isRemain": false
      }
    ],
    "resultItem": {
      "itemName": "Test3",
      "modId": "Test Author:forUniTest",
      "count": 1
    }
  }
]
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/MaxElectricPoleMachineConnectionRange.cs
```cs
using Core.Master;
using Game.Block;
using Mooresmaster.Model.BlocksModule;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public class MaxElectricPoleMachineConnectionRange
    {
        private readonly int _maxElectricPoleMachineConnectionRange = int.MinValue;
        
        public MaxElectricPoleMachineConnectionRange()
        {
            foreach (var blockElement in MasterHolder.BlockMaster.Blocks.Data)
            {
                if (blockElement.BlockType != BlockTypeConst.ElectricPole) continue;
                
                var param = blockElement.BlockParam as ElectricPoleBlockParam;
                if (_maxElectricPoleMachineConnectionRange < param.MachineConnectionRange)
                    _maxElectricPoleMachineConnectionRange = param.MachineConnectionRange;
            }
        }
        
        public int Get()
        {
            return _maxElectricPoleMachineConnectionRange;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/DebugSheet/DebugSheetController.cs
```cs
using Client.Game.GameDebug;
using IngameDebugConsole;
using Tayx.Graphy;
using UnityDebugSheet.Runtime.Core.Scripts;
using UnityDebugSheet.Runtime.Extensions.Graphy;
using UnityDebugSheet.Runtime.Extensions.IngameDebugConsole;
using UnityEngine;

namespace Client.DebugSystem
{
    public sealed class DebugSheetController : MonoBehaviour
    {
        [SerializeField] private GameObject runtimeHierarchyInspector;
        [SerializeField] private DebugSheet debugSheet;
        
        private void Start()
        {
            debugSheet.gameObject.SetActive(true);
            
            var rootPage = debugSheet.GetOrCreateInitialPage();
            
            rootPage.AddPageLinkButton<ItemGetDebugSheet>("Get Item");
            rootPage.AddPageLinkButton<IngameDebugConsoleDebugPage>("In-Game Debug Console", onLoad: x => x.page.Setup(DebugLogManager.Instance));
            rootPage.AddPageLinkButton<GraphyDebugPage>("Graphy", onLoad: x => x.page.Setup(GraphyManager.Instance));
            rootPage.AddSwitch(false, "Runtime Hierarchy Inspector", valueChanged: active => runtimeHierarchyInspector.SetActive(active));
            
            rootPage.AddEnumPickerWithSave(DebugEnvironmentType.Debug, "Select Environment", "DebugEnvironmentTypeKey", DebugEnvironmentController.SetEnvironment);
        }
        
        
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void CreateDebugger()
        {
            var prefab = Resources.Load<GameObject>("moorestech Debug Objects");
            Instantiate(prefab);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockConnectorComponent.cs
```cs
using System.Collections.Generic;
using Mooresmaster.Model.BlockConnectInfoModule;

namespace Game.Block.Interface.Component
{
    public interface IBlockConnectorComponent<TTarget> : IBlockComponent where TTarget : IBlockComponent
    {
        public IReadOnlyDictionary<TTarget, ConnectedInfo> ConnectedTargets { get; }
    }
    
    public struct ConnectedInfo
    {
        public IConnectOption SelfOption { get; }
        public IConnectOption TargetOption { get; }
        
        public IBlock TargetBlock { get; }
        
        public ConnectedInfo(IConnectOption selfOption, IConnectOption targetOption, IBlock targetBlock)
        {
            SelfOption = selfOption;
            TargetOption = targetOption;
            TargetBlock = targetBlock;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/IEntity.cs
```cs
using UnityEngine;

namespace Game.Entity.Interface
{
    public interface IEntity
    {
        EntityInstanceId InstanceId { get; }
        string EntityType { get; }
        
        Vector3 Position { get; }
        
        string State { get; }
        
        void SetPosition(Vector3 serverVector3);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/ClientContext.cs
```cs
using Client.Network.API;
using Client.Network.Settings;

namespace Client.Game.InGame.Context
{
    public class ClientContext
    {
        public static BlockGameObjectContainer BlockGameObjectContainer { get; private set; }
        public static ItemImageContainer ItemImageContainer { get; private set; }
        public static PlayerConnectionSetting PlayerConnectionSetting { get; private set; }
        public static VanillaApi VanillaApi { get; private set; }
        public static DIContainer DIContainer { get; private set; }
        
        public ClientContext(BlockGameObjectContainer blockGameObjectContainer, ItemImageContainer itemImageContainer, PlayerConnectionSetting playerConnectionSetting, VanillaApi vanillaApi)
        {
            BlockGameObjectContainer = blockGameObjectContainer;
            ItemImageContainer = itemImageContainer;
            PlayerConnectionSetting = playerConnectionSetting;
            VanillaApi = vanillaApi;
        }
        
        public void SetDIContainer(DIContainer diContainer)
        {
            DIContainer = diContainer;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/WorldSaverForJson.cs
```cs
using System.IO;
using Game.SaveLoad.Interface;

namespace Game.SaveLoad.Json
{
    public class WorldSaverForJson : IWorldSaveDataSaver
    {
        private readonly AssembleSaveJsonText _assembleSaveJsonText;
        private readonly SaveJsonFileName _fileName;
        
        public WorldSaverForJson(SaveJsonFileName fileName, AssembleSaveJsonText assembleSaveJsonText)
        {
            _fileName = fileName;
            _assembleSaveJsonText = assembleSaveJsonText;
        }
        
        public void Save()
        {
            File.WriteAllText(_fileName.FullSaveFilePath, _assembleSaveJsonText.AssembleSaveJson());
        }
    }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/craftRecipes.json
```cs
{
  "data": [
    {
      "craftTime": 5,
      "craftResultCount": 1,
      "craftResultItemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90",
          "isRemain": true
        },
        {
          "count": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        }
      ],
      "craftRecipeGuid": "f6d07ec4-94db-44ff-90ba-59cee0fb1d0b"
    },
    {
      "craftTime": 4,
      "craftResultCount": 1,
      "craftResultItemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 1,
          "itemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90"
        },
        {
          "count": 1,
          "itemGuid": "d382f613-8dec-4c87-b72c-c75f8d18ce73"
        }
      ],
      "craftRecipeGuid": "b7547ab6-87f2-4700-8d47-a0ec0230a811"
    },
    {
      "craftTime": 2,
      "craftResultCount": 1,
      "craftResultItemGuid": "d382f613-8dec-4c87-b72c-c75f8d18ce73",
      "craftRecipeGuid": "d4cbd944-839b-4d5a-91cc-e664633520c5",
      "requiredItems": [
        {
          "count": 5,
          "itemGuid": "19a3b0bc-10de-4e96-8a41-99f39675556d"
        }
      ]
    },
    {
      "craftTime": 5,
      "craftResultCount": 1,
      "craftResultItemGuid": "de89dc5c-b9d1-40f4-97ef-6b0bdcdd9379",
      "requiredItems": [
        {
          "count": 4,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 5,
          "itemGuid": "f92c51ab-1979-4a44-8c35-e86a51b33e61"
        }
      ],
      "craftRecipeGuid": "0141680f-4146-4bdb-b1be-c1bdb85bf981"
    },
    {
      "time": 1,
      "blockSize": [
        1,
        1,
        1
      ],
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "craftTime": 4,
      "craftResultCount": 1,
      "maxStack": 100,
      "craftResultItemGuid": "6b54897e-e7cb-4df7-807e-1597c2a859da",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "craftRecipeGuid": "bc4efda0-9707-48dc-9474-834db250ffda"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "99c95d35-9ba8-4027-9d88-48174a7322fa",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "craftRecipeGuid": "92585d73-55e4-4ce1-a3c9-9e67ebcf74b2"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "c82061f7-f4b2-45bc-8323-40f76dece8f2",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "craftRecipeGuid": "5d6e5479-c2e7-49c5-bfdb-c0274515083c"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "92fe1a42-ad46-4ff3-aa9a-83a9262c34d6"
        },
        {
          "count": 1,
          "itemGuid": "d382f613-8dec-4c87-b72c-c75f8d18ce73"
        },
        {
          "count": 1,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "8ec19b21-7e01-4932-9198-1ea7e5f9c2bf"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "067f2b59-a088-4fac-98cf-68060c6e9927",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "ee7c1edf-32ba-4bd2-962c-d29ee1309730"
        },
        {
          "count": 10,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "93c83117-c519-4673-9a81-062393722e51"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "requiredItems": [
        {
          "count": 25,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "d0e72dca-b0f0-4d0b-af72-cfb5f489f7c8",
      "craftResultItemGuid": "b7068d1c-f5cb-4af5-94e1-4ed9c9577ca8"
    },
    {
      "time": 1,
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "6f8e7dcb-e7d7-44c0-a63e-ffba1cd5e311",
      "requiredItems": [
        {
          "count": 10,
          "itemGuid": "975384df-a166-48a6-a5cf-d631f48715c0"
        },
        {
          "count": 5,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        }
      ],
      "craftRecipeGuid": "5392fbdb-8d93-4040-96eb-45a915d0c520"
    },
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "0559e1c6-5a63-40bc-92d8-64167fa6c3ba",
      "requiredItems": [
        {
          "count": 5,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "8f1d7de3-2ccd-457e-aa19-9c998ee59000"
    },
    {
      "craftTime": 2,
      "craftResultCount": 2,
      "craftResultItemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        },
        {
          "count": 1,
          "itemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e",
          "isRemain": true
        }
      ],
      "craftRecipeGuid": "804e2346-059c-4373-8160-eb4466815ba9"
    },
    {
      "maxStack": 100,
      "craftTime": 5,
      "craftResultCount": 1,
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "craftResultItemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90",
      "requiredItems": [
        {
          "count": 3,
          "itemGuid": "f92c51ab-1979-4a44-8c35-e86a51b33e61"
        }
      ],
      "craftRecipeGuid": "3d94ea46-b024-4be9-88fa-846e7a04157f"
    },
    {
      "maxStack": 100,
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "craftTime": 2,
      "craftResultCount": 1,
      "craftResultItemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        },
        {
          "count": 1,
          "itemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa",
          "isRemain": true
        }
      ],
      "craftRecipeGuid": "9236abf2-9a07-4397-9f03-f0d99981a6f7"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "craftTime": 3,
      "craftResultCount": 1,
      "craftResultItemGuid": "17d94f6e-9f34-4d4b-8068-4be4c7dbfbb2",
      "requiredItems": [
        {
          "count": 1,
          "itemGuid": "ee7c1edf-32ba-4bd2-962c-d29ee1309730"
        },
        {
          "count": 20,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "craftRecipeGuid": "c850e9e3-95aa-4586-9f14-8d449964cd82"
    }
  ]
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/item.json
```cs
[
  {
    "name": "Test1",
    "maxStacks": 100
  },
  {
    "name": "Test2",
    "maxStacks": 50
  },
  {
    "name": "Test3",
    "maxStacks": 300
  },
  {
    "name": "Test4",
    "maxStacks": 100
  },
  {
    "name": "Test5",
    "maxStacks": 200
  },
  {
    "name": "Test6",
    "maxStacks": 100
  },
  {
    "name": "Test7",
    "maxStacks": 100
  },
  {
    "name": "Test8",
    "maxStacks": 100
  },
  {
    "name": "Test9",
    "maxStacks": 100
  },
  {
    "name": "Test10",
    "maxStacks": 100
  },
  {
    "name": "Test11",
    "maxStacks": 100
  },
  {
    "name": "tree",
    "maxStacks": 100
  },
  {
    "name": "stone",
    "maxStacks": 100
  },
  {
    "name": "SmallTestGear",
    "maxStacks": 100
  },
  {
    "name": "BigTestGear",
    "maxStacks": 100
  },
  {
    "name": "TestShaft",
    "maxStacks": 100
  },
  {
    "name": "TestGearMachine",
    "maxStacks": 100
  },
  {
    "name": "TestSimpleGearGenerator",
    "maxStacks": 100
  },
  {
    "name": "TestFastSimpleGearGenerator",
    "maxStacks": 100
  },
  {
    "name": "SmallRequireTorqueTestGear",
    "maxStacks": 100
  },
  {
    "name": "BigRequireTorqueTestGear",
    "maxStacks": 100
  },
  {
    "name": "InfinityTestSimpleGearGenerator",
    "maxStacks": 100
  },
  {
    "name": "StraightTestItemShooter",
    "maxStacks": 100
  },
  {
    "name": "DownTestItemShooter",
    "maxStacks": 100
  },
  {
    "name": "UpTestItemShooter",
    "maxStacks": 100
  },
  {
    "name": "GearBeltConveyor",
    "maxStacks": 100
  }
]

```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/GetChallengeInfoProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Challenge;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    public class GetChallengeInfoProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:getChallengeInfo";
        
        private readonly ChallengeDatastore _challengeDatastore;
        
        public GetChallengeInfoProtocol(ServiceProvider serviceProvider)
        {
            _challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestChallengeMessagePack>(payload.ToArray());
            
            var info = _challengeDatastore.GetOrCreateChallengeInfo(data.PlayerId);
            var currentChallengeIds = info.CurrentChallenges.Select(c => c.ChallengeMasterElement.ChallengeGuid).ToList();
            
            return new ResponseChallengeInfoMessagePack(data.PlayerId, currentChallengeIds, info.CompletedChallengeGuids);
        }
        
        
        [MessagePackObject]
        public class RequestChallengeMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Obsolete("")]
            public RequestChallengeMessagePack() { }
            public RequestChallengeMessagePack(int playerId)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
            }
        }
        
        [MessagePackObject]
        public class ResponseChallengeInfoMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public List<string> CurrentChallengeGuidsStr { get; set; }
            [Key(4)] public List<string> CompletedChallengeGuidsStr { get; set; }
            
            [IgnoreMember] public List<Guid> CurrentChallengeGuids => CurrentChallengeGuidsStr.Select(Guid.Parse).ToList();
            [IgnoreMember] public List<Guid> CompletedChallengeGuids => CompletedChallengeGuidsStr.Select(Guid.Parse).ToList();
            
            [Obsolete("")]
            public ResponseChallengeInfoMessagePack() { }
            public ResponseChallengeInfoMessagePack(int playerId, List<Guid> currentChallengeIds, List<Guid> completedChallengeIds)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                CurrentChallengeGuidsStr = currentChallengeIds.Select(x => x.ToString()).ToList();
                CompletedChallengeGuidsStr = completedChallengeIds.Select(x => x.ToString()).ToList();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Event/BlockOpenableInventoryUpdateEvent.cs
```cs
using System;
using Game.Block.Interface.Event;

namespace Game.Block.Event
{
    public class BlockOpenableInventoryUpdateEvent : IBlockOpenableInventoryUpdateEvent
    {
        public void Subscribe(Action<BlockOpenableInventoryUpdateEventProperties> blockInventoryEvent)
        {
            OnBlockInventoryUpdate += blockInventoryEvent;
        }
        
        public event Action<BlockOpenableInventoryUpdateEventProperties> OnBlockInventoryUpdate;
        
        public void OnInventoryUpdateInvoke(BlockOpenableInventoryUpdateEventProperties properties)
        {
            OnBlockInventoryUpdate?.Invoke(properties);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/ItemStackFactory.cs
```cs
using System;
using System.Collections.Generic;
using Core.Const;
using Core.Item.Implementation;
using Core.Item.Interface;
using Core.Master;

namespace Core.Item
{
    public class ItemStackFactory : IItemStackFactory
    {
        private readonly IItemStack _nullItem;
        
        public ItemStackFactory()
        {
            _nullItem = new NullItemStack();
            new InternalItemContext(this);
        }
        
        public IItemStack Create(ItemId id, int count, Dictionary<string, ItemStackMetaData> metaData = null)
        {
            if (id == ItemMaster.EmptyItemId) return CreatEmpty();
            
            if (count < 1) return CreatEmpty();
            
            metaData = metaData == null ? new Dictionary<string, ItemStackMetaData>() : new Dictionary<string, ItemStackMetaData>(metaData);
            return new ItemStack(id, count, metaData);
        }
        
        public IItemStack Create(ItemId id, int count, ItemInstanceId instanceId, Dictionary<string, ItemStackMetaData> metaData = null)
        {
            if (id == ItemMaster.EmptyItemId) return CreatEmpty();
            
            if (count < 1) return CreatEmpty();
            
            metaData = metaData == null ? new Dictionary<string, ItemStackMetaData>() : new Dictionary<string, ItemStackMetaData>(metaData);
            return new ItemStack(id, count, instanceId, metaData);
        }
        public IItemStack Create(Guid itemGuid, int count, Dictionary<string, ItemStackMetaData> metaData = null)
        {
            if (count < 1) return CreatEmpty();
            
            var id = MasterHolder.ItemMaster.GetItemId(itemGuid);
            return Create(id, count, metaData);
        }
        
        public IItemStack CreatEmpty()
        {
            return _nullItem;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/EntityJsonObject.cs
```cs
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Entity.Interface
{
    public class EntityJsonObject
    {
        [JsonProperty("InstanceId")] public long InstanceId;
        [JsonProperty("Type")] public string Type;
        
        [JsonProperty("X")] public float X;
        [JsonProperty("Y")] public float Y;
        [JsonProperty("Z")] public float Z;
        
        public EntityJsonObject(string type, long instanceId, Vector3 serverVector3)
        {
            Type = type;
            InstanceId = instanceId;
            X = serverVector3.x;
            Y = serverVector3.y;
            Z = serverVector3.z;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/IBlockInventoryView.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Core.Item.Interface;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public interface IBlockInventoryView : ISubInventory
    {
        public void Initialize(BlockGameObject blockGameObject);
        public void UpdateItemList(List<IItemStack> response);
        public void UpdateInventorySlot(int slot, IItemStack item);
        public void DestroyUI();
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Skit/SkitObjectTransfomCopyer.cs
```cs
using UnityEngine;

namespace Client.Skit.Skit
{
    public class SkitObjectTransfomCopyer : MonoBehaviour
    {
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Vein/IMapVein.cs
```cs
using Core.Master;
using UnityEngine;

namespace Game.Map.Interface.Vein
{
    public interface IMapVein
    {
        public ItemId VeinItemId { get; }
        
        public Vector3Int VeinRangeMin { get; }
        public Vector3Int VeinRangeMax { get; }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/CharacterTestDebug.cs
```cs
using System;
using Client.Game.InGame.Control;
using UnityEngine;

namespace Client.DebugSystem
{
    public class CharacterTestDebug : MonoBehaviour
    {
        [SerializeField] private InGameCameraController _cameraController;
        
        private void Start()
        {
            _cameraController.SetControllable(true);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/IMapObjectMiningState.cs
```cs
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Cysharp.Threading.Tasks;

namespace Client.Game.InGame.Mining
{
    public interface IMapObjectMiningState
    {
        IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt);
    }
    
    public class MapObjectMiningControllerContext
    {
        public MapObjectGameObject CurrentFocusMapObjectGameObject { get; private set; }
        
        
        public readonly HotBarView HotBarView;
        public readonly ILocalPlayerInventory LocalPlayerInventory;
        public readonly IPlayerObjectController PlayerObjectController;
        
        public MapObjectMiningControllerContext(HotBarView hotBarView, ILocalPlayerInventory localPlayerInventory, IPlayerObjectController playerObjectController)
        {
            HotBarView = hotBarView;
            LocalPlayerInventory = localPlayerInventory;
            PlayerObjectController = playerObjectController;
        }
        
        
        
        public void SetFocusMapObjectGameObject(MapObjectGameObject mapObjectGameObject)
        {
            if (mapObjectGameObject != CurrentFocusMapObjectGameObject)
            {
                CurrentFocusMapObjectGameObject?.OutlineEnable(false);
                mapObjectGameObject?.OutlineEnable(true);
            }
            
            CurrentFocusMapObjectGameObject = mapObjectGameObject;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/PlayerInventorySaveJsonObject.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Newtonsoft.Json;

namespace Game.PlayerInventory.Interface
{
    public class PlayerInventorySaveJsonObject
    {
        [JsonProperty("PlayerId")] public int PlayerId;
        
        [JsonProperty("MainInventoryItems")] public List<ItemStackSaveJsonObject> MainInventoryItems;
        
        [JsonProperty("GrabInventoryItems")] public ItemStackSaveJsonObject GrabInventoryItem;
        
        public PlayerInventorySaveJsonObject()
        {
        }
        
        public PlayerInventorySaveJsonObject(int playerId, PlayerInventoryData playerInventoryData)
        {
            MainInventoryItems = new List<ItemStackSaveJsonObject>();
            for (var i = 0; i < playerInventoryData.MainOpenableInventory.GetSlotSize(); i++)
            {
                var item = playerInventoryData.MainOpenableInventory.GetItem(i);
                MainInventoryItems.Add(new ItemStackSaveJsonObject(item));
            }
            
            var grabItemStack = playerInventoryData.GrabInventory.GetItem(0);
            GrabInventoryItem = new ItemStackSaveJsonObject(grabItemStack);
            
            PlayerId = playerId;
        }
        
        public (List<IItemStack> mainInventory, IItemStack grabItem) GetPlayerInventoryData()
        {
            var mainItemStack = new List<IItemStack>();
            foreach (var items in MainInventoryItems)
            {
                mainItemStack.Add(items.ToItemStack());
            }
            var grabItem = GrabInventoryItem.ToItemStack();
            
            return (mainItemStack, grabItem);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/machineRecipes.json
```cs
{
  "data": [
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-000000000001",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-000000000002",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-000000000003",
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        },
        {
          "count": 4,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000005"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-00000000000f",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-000000000019",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-00000000001a",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "time": 1.5,
      "blockGuid": "00000000-0000-0000-0000-00000000001b",
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "00000000-0000-0000-1234-000000000001"
        },
        {
          "count": 3,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        },
        {
          "count": 4,
          "itemGuid": "00000000-0000-0000-1234-000000000003"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000005"
        },
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "00000000-0000-0000-1234-000000000002"
        }
      ],
      "machineRecipeGuid": "bd3d4d7d-9c3b-4ae1-875b-950327eedd9d"
    },
    {
      "maxStack": 100,
      "time": 0.01,
      "blockGuid": "00000000-0000-0000-0000-000000000022",
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
        }
      ],
      "machineRecipeGuid": "76a4be24-66d6-46c6-84d9-e4e865db3e04"
    },
    {
      "time": 0.01,
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
        },
        {
          "count": 1,
          "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "189672cb-6811-4080-bde1-1f9ff0ec63ff"
        }
      ],
      "machineRecipeGuid": "38dfacce-beea-4612-8c7c-29112c12409a",
      "blockGuid": "00000000-0000-0000-0000-000000000023"
    }
  ]
}
```

schema/ref/inventoryConnects.json
```cs
{
  "$id": "inventoryConnects",

  "type": "object",
  "properties": {

    "inputConnects": {
      "fixedParameter": {
        "path" : "./connectType",
        "value": "Inventory"
      },
      "$ref" : "blockConnectInfo"
    },

    "outputConnects": {
      "fixedParameter": {
        "path" : "./connectType",
        "value": "Inventory"
      },
      "$ref" : "blockConnectInfo"
    }

  }
}

```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/EnergyServiceDependencyContainer.cs
```cs
using Game.EnergySystem;
using Game.World.Interface.DataStore;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public class EnergyServiceDependencyContainer<TSegment> where TSegment : EnergySegment, new()
    {
        public readonly IWorldEnergySegmentDatastore<TSegment> WorldEnergySegmentDatastore;
        
        public EnergyServiceDependencyContainer(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore)
        {
            WorldEnergySegmentDatastore = worldEnergySegmentDatastore;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockIconImagePhotographer.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Client.Game.InGame.Context;
using Core.Master;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class BlockIconImagePhotographer : MonoBehaviour
    {
        [SerializeField] private int iconSize = 512;
        [SerializeField] Camera cameraPrefab;
        
        public async UniTask<List<Texture2D>> TakeBlockIconImages(List<BlockObjectInfo> blockObjectInfos)
        {
            var createdBlocks = new List<(GameObject block,BlockObjectInfo blockObjectInfo)>();
            
            foreach (var blockObjectInfo in blockObjectInfos)
            {
                var block = Instantiate(blockObjectInfo.BlockObjectPrefab, transform);
                createdBlocks.Add((block, blockObjectInfo));
            }
            
            // 
            var maxSize = GetMaxBlockSize(createdBlocks);
            var spacing = maxSize * 2f;
            for (int i = 0; i < createdBlocks.Count; i++)
            {
                var createdBlock = createdBlocks[i];
                createdBlock.block.transform.position = new Vector3(i * spacing, 0f, 0f);
                createdBlock.block.transform.rotation = Quaternion.identity;
                createdBlock.block.transform.localScale = Vector3.one;
            }
            
            // 
            var tasks = new List<UniTask<Texture2D>>();
            foreach (var block in createdBlocks)
            {
                tasks.Add(GetIcon(block.block, block.blockObjectInfo));
            }
            
            var result = await UniTask.WhenAll(tasks);
            
            return result.ToList();
        }
        
        private async UniTask<Texture2D> GetIcon(GameObject block, BlockObjectInfo blockObjectInfo)
        {
            // 
            var bounds = block.GetComponentsInChildren<Renderer>().Select(b => b.bounds).ToList();
            if (bounds.Count == 0)
            {
                throw new System.Exception(":" + block.name + " " + blockObjectInfo.BlockMasterElement.Name);
            }
            var center = bounds.Select(b => b.center).Aggregate((b1, b2) => b1 + b2) / bounds.Count;
            
            // (30Y45)
            var blockImageCamera = Instantiate(cameraPrefab);
            blockImageCamera.transform.rotation = Quaternion.Euler(30f, 45f, 0f);
            
            // 
            var minPos = bounds.Select(b => b.min).Aggregate(Vector3.Min);
            var maxPos = bounds.Select(b => b.max).Aggregate(Vector3.Max);
            var maxSize = Vector3.Distance(minPos, maxPos);
            
            // (FOV)
            float fovRad = blockImageCamera.fieldOfView * Mathf.Deg2Rad;
            float distance = (maxSize * 0.5f) / Mathf.Tan(fovRad * 0.5f);
            
            blockImageCamera.transform.position = center - blockImageCamera.transform.forward * (distance * 0.8f);
            blockImageCamera.transform.LookAt(center);
            
            // 
            blockImageCamera.clearFlags = CameraClearFlags.SolidColor;
            blockImageCamera.backgroundColor = new Color(0f, 0f, 0f, 0f);
            
            await UniTask.Yield(PlayerLoopTiming.Update);
            
            // RenderTexture
            var renderTexture = new RenderTexture(iconSize, iconSize, 24, RenderTextureFormat.ARGB32)
            {
                useMipMap = false,
                autoGenerateMips = false
            };
            
            blockImageCamera.targetTexture = renderTexture;
            blockImageCamera.Render();
            blockImageCamera.targetTexture = null;
            
            // Texture2D
            var texture = new Texture2D(iconSize, iconSize, TextureFormat.RGBA32, false);
            RenderTexture.active = renderTexture;
            texture.ReadPixels(new Rect(0, 0, iconSize, iconSize), 0, 0);
            texture.Apply();
            RenderTexture.active = null;
            
            // 
            Destroy(block);
            Destroy(renderTexture);
            
            return texture;
        }
        
        private float GetMaxBlockSize(List<(GameObject block,BlockObjectInfo blockObjectInfo)> createdBlocks)
        {
            float maxSize = 0f;
            foreach (var createdBlock in createdBlocks)
            {
                var renderers = createdBlock.block.GetComponentsInChildren<MeshRenderer>();
                if (renderers.Length == 0) continue;
                
                var boundsList = renderers.Select(r => r.bounds).ToList();
                var minPos = boundsList.Select(b => b.min).Aggregate(Vector3.Min);
                var maxPos = boundsList.Select(b => b.max).Aggregate(Vector3.Max);
                var size = Vector3.Distance(minPos, maxPos);
                
                if (size > maxSize)
                    maxSize = size;
            }
            
            return maxSize;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ItemConfigTest.cs
```cs
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Other
{
    public class ItemConfigTest
    {
        [TestCase(1, 100)]
        [TestCase(2, 50)]
        [TestCase(3, 300)]
        [TestCase(4, 100)]
        [TestCase(5, 200)]
        [TestCase(7, 100)]
        public void JsonStackTest(int id, int stack)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            Assert.AreEqual(stack, MasterHolder.ItemMaster.GetItemMaster(new ItemId(id)).MaxStack);
        }
        
        [TestCase(1, "Test1")]
        [TestCase(2, "Test2")]
        [TestCase(3, "Test3")]
        [TestCase(4, "Test4")]
        [TestCase(5, "Test5")]
        [TestCase(6, "Test6")]
        [TestCase(7, "Test7")]
        public void JsonNameTest(int id, string name)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            Assert.AreEqual(name, MasterHolder.ItemMaster.GetItemMaster(new ItemId(id)).Name);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/VanillaApi.cs
```cs
using System;
using System.Diagnostics;
using Client.Network.Settings;
using UniRx;
using VContainer.Unity;

namespace Client.Network.API
{
    public class VanillaApi : IInitializable
    {
        private readonly Process _localServerProcess;
        
        private readonly ServerCommunicator _serverCommunicator;
        public readonly VanillaApiEvent Event;
        public readonly VanillaApiWithResponse Response;
        public readonly VanillaApiSendOnly SendOnly;
        
        public VanillaApi(PacketExchangeManager packetExchangeManager, PacketSender packetSender, ServerCommunicator serverCommunicator, PlayerConnectionSetting playerConnectionSetting, Process localServerProcess)
        {
            _serverCommunicator = serverCommunicator;
            _localServerProcess = localServerProcess;
            
            Event = new VanillaApiEvent(packetExchangeManager, playerConnectionSetting);
            Response = new VanillaApiWithResponse(packetExchangeManager, playerConnectionSetting);
            SendOnly = new VanillaApiSendOnly(packetSender, playerConnectionSetting);
        }
        
        public IObservable<Unit> OnDisconnect => _serverCommunicator.OnDisconnect;
        
        public void Initialize()
        {
        }
        
        public void Disconnect()
        {
            _serverCommunicator.Close();
            _localServerProcess?.Kill();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObjectFactory.cs
```cs
using System;
using UnityEngine;

namespace Game.Map.Interface.MapObject
{
    public interface IMapObjectFactory
    {
        public IMapObject Create(int instanceId, Guid mapObjectGuid, int currentHp, bool isDestroyed, Vector3 position);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/ISubInventory.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;

namespace Client.Game.InGame.UI.Inventory
{
    public interface ISubInventory
    {
        public List<IItemStack> SubInventory { get; }
        public int Count { get; }
        public ItemMoveInventoryInfo ItemMoveInventoryInfo { get; }
        public IReadOnlyList<ItemSlotObject> SubInventorySlotObjects { get; }
    }
    
    public class EmptySubInventory : ISubInventory
    {
        public EmptySubInventory()
        {
            Count = 0;
            SubInventorySlotObjects = new List<ItemSlotObject>();
            SubInventory = new List<IItemStack>();
            ItemMoveInventoryInfo = null;
        }
        
        public IReadOnlyList<ItemSlotObject> SubInventorySlotObjects { get; }
        public List<IItemStack> SubInventory { get; }
        public int Count { get; }
        public ItemMoveInventoryInfo ItemMoveInventoryInfo { get; }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/mapObject.json
```cs
[
  {
    "type": "vanilla:Tree",
    "hp": 30,
    "earnItemHps": [
      0,
      10,
      20
    ],
    "earnItems": [
      {
        "itemModId": "Test Author:forUniTest",
        "itemName": "Test1",
        "minCount": 3,
        "maxCount": 5
      }
    ],
    "miningTools": [
      {
        "toolItemModId": "Test Author:forUniTest",
        "toolItemName": "Test1",
        "damage": 1,
        "attackSpeed": 1.6
      }
    ]
  }
]
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockComponent.cs
```cs
namespace Game.Block.Interface.Component
{
    public interface IBlockComponent
    {
        public bool IsDestroy { get; }
        
        public void Destroy();
    }
}
```

moorestech_client/Assets/Scripts/Editor/DirectoryProcessor.cs
```cs
//Credit https://kan-kikuchi.hatenablog.com/entry/DirectoryProcessor

using System.IO;

/// <summary>
///     
/// </summary>
public static class DirectoryProcessor
{
    /// <summary>
    ///     
    /// </summary>
    public static void CopyAndReplace(string sourcePath, string copyPath)
    {
        //
        Delete(copyPath);
        Directory.CreateDirectory(copyPath);
        
        //
        foreach (var file in Directory.GetFiles(sourcePath)) File.Copy(file, Path.Combine(copyPath, Path.GetFileName(file)));
        
        //
        foreach (var dir in Directory.GetDirectories(sourcePath)) CopyAndReplace(dir, Path.Combine(copyPath, Path.GetFileName(dir)));
    }
    
    /// <summary>
    ///     
    /// </summary>
    public static void Delete(string targetDirectoryPath)
    {
        if (!Directory.Exists(targetDirectoryPath)) return;
        
        //
        var filePaths = Directory.GetFiles(targetDirectoryPath);
        foreach (var filePath in filePaths)
        {
            File.SetAttributes(filePath, FileAttributes.Normal);
            File.Delete(filePath);
        }
        
        //
        var directoryPaths = Directory.GetDirectories(targetDirectoryPath);
        foreach (var directoryPath in directoryPaths) Delete(directoryPath);
        
        //
        Directory.Delete(targetDirectoryPath, false);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/TutorialManager.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Tutorial.UIHighlight;
using Core.Master;
using Game.Context;

namespace Client.Game.InGame.Tutorial
{
    public class TutorialManager
    {
        private readonly Dictionary<Guid, List<ITutorialView>> _tutorialViews = new();
        private readonly Dictionary<string, ITutorialViewManager> _tutorialViewManagers = new();
        
        public TutorialManager(MapObjectPin mapObjectPin, UIHighlightTutorialManager uiHighlightTutorialManager, KeyControlTutorialManager keyControlTutorialManager)
        {
            _tutorialViewManagers.Add(MapObjectPin.TutorialType, mapObjectPin);
            _tutorialViewManagers.Add(UIHighlightTutorialManager.TutorialType, uiHighlightTutorialManager);
            _tutorialViewManagers.Add(KeyControlTutorialManager.TutorialType, keyControlTutorialManager);
        }
        
        public void ApplyTutorial(Guid challengeGuid)
        {
            var tutorialViews = new List<ITutorialView>();
            var challenge = MasterHolder.ChallengeMaster.GetChallenge(challengeGuid);
            
            // Manager
            // Apply the tutorial to the actual Manager
            foreach (var tutorial in challenge.Tutorials)
            {
                var tutorialView = _tutorialViewManagers[tutorial.TutorialType].ApplyTutorial(tutorial.TutorialParam);
                
                if (tutorialView != null) tutorialViews.Add(tutorialView);
            }
            
            _tutorialViews.Add(challengeGuid, tutorialViews);
        }
        
        public void CompleteChallenge(Guid challengeId)
        {
            if (!_tutorialViews.TryGetValue(challengeId, out var tutorialViews)) return;
            
            foreach (var tutorialView in tutorialViews)
            {
                tutorialView.CompleteTutorial();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/IEntitiesDatastore.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Game.Entity.Interface
{
    public interface IEntitiesDatastore
    {
        public void Add(IEntity entity);
        public bool Exists(EntityInstanceId instanceId);
        public IEntity Get(EntityInstanceId instanceId);
        
        public void SetPosition(EntityInstanceId instanceId, Vector3 position);
        
        public Vector3 GetPosition(EntityInstanceId instanceId);
        
        
        public List<EntityJsonObject> GetSaveJsonObject();
        public void LoadBlockDataList(List<EntityJsonObject> saveBlockDataList);
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/MapObjectUpdateEventPacketTest.cs
```cs
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class MapObjectUpdateEventPacketTest
    {
        private const int PlayerId = 1;
        
        [Test]
        public void MapObjectDestroyToEventTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            
            var response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(PlayerId));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            //
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            
            //MapObject
            var mapObject = mapObjectDatastore.MapObjects[0];
            mapObject.Destroy();
            
            //map object
            response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(1, eventMessagePack.Events.Count);
            
            var data = MessagePackSerializer.Deserialize<MapObjectUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(MapObjectUpdateEventMessagePack.DestroyEventType, data.EventType);
            Assert.AreEqual(mapObject.InstanceId, data.InstanceId);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/HotBarItem.cs
```cs
using Client.Game.InGame.UI.Inventory.Element;
using Client.Mod.Texture;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory
{
    public class HotBarItem : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObject;
        [SerializeField] private TMP_Text keyBoardText;
        
        private void Awake()
        {
        }
        
        public void SetItem(ItemViewData itemViewData, int count)
        {
            itemSlotObject.SetItem(itemViewData, count);
        }
        
        public void SetKeyBoardText(string text)
        {
            keyBoardText.text = text;
        }
        
        public void SetSelect(bool isSelect)
        {
            itemSlotObject.SetHotBarSelect(isSelect);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/GameInitializerSceneLoader.cs
```cs
using Client.Common;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Client.Starter
{
    /// <summary>
    ///     <see cref="GameInitializerSceneLoader" />
    /// </summary>
    public class GameInitializerSceneLoader : MonoBehaviour
    {
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void Init()
        {
            var loader = FindObjectOfType<GameInitializerSceneLoader>(true);
            if (loader != null) SceneManager.LoadScene(SceneConstant.GameInitializerSceneName);
        }
    }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/challenges.json
```cs
{
    "data":[]
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/PreviewOnlyObject.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class PreviewOnlyObject : MonoBehaviour
    {
        private readonly List<Renderer> _renderers = new();
        
        public void Initialize()
        {
            _renderers.AddRange(GetComponentsInChildren<Renderer>(true));
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        public void SetEnableRenderers(bool enable)
        {
            foreach (var r in _renderers) r.enabled = enable;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Define/VoiceDefine.cs
```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Client.Skit.Define
{
    [CreateAssetMenu(fileName = "VoiceDefine", menuName = "moorestech/VoiceDefine", order = 0)]
    public class VoiceDefine : ScriptableObject
    {
        [SerializeField] private List<CharacterVoices> characterVoices;
        
        public AudioClip GetVoiceClip(string characterKey, string sentence)
        {
            var characterVoice = characterVoices.Find(x => x.CharacterKey == characterKey);
            if (characterVoice == null) return null;
            
            var voiceInfo = characterVoice.VoiceInfos.Find(x => x.Sentence == sentence);
            return voiceInfo?.VoiceClip;
        }
    }
    
    [Serializable]
    public class CharacterVoices
    {
        [SerializeField] private string characterKey;
        [SerializeField] private List<VoiceInfo> voiceInfos;
        
        [SerializeField] private string credit;
        public string CharacterKey => characterKey;
        
        public List<VoiceInfo> VoiceInfos => voiceInfos;
    }
    
    [Serializable]
    public class VoiceInfo
    {
        [SerializeField] [Multiline] private string sentence;
        [SerializeField] private AudioClip voiceClip;
        public string Sentence => sentence;
        
        public AudioClip VoiceClip => voiceClip;
    }
}
```

moorestech_server/Assets/Scripts/Game.Context/ServerContext.cs
```cs
using Core.Item.Interface;
using Game.Block.Interface;
using Game.Block.Interface.Event;
using Game.Map.Interface.Vein;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;

namespace Game.Context
{
    public class ServerContext
    {
        private static ServiceProvider _serviceProvider;
        
        public static IItemStackFactory ItemStackFactory { get; private set; }
        public static IBlockFactory BlockFactory { get; private set; }
        
        public static IWorldBlockDatastore WorldBlockDatastore { get; private set; }
        public static IMapVeinDatastore MapVeinDatastore { get; private set; }
        
        public static IWorldBlockUpdateEvent WorldBlockUpdateEvent { get; private set; }
        public static IBlockOpenableInventoryUpdateEvent BlockOpenableInventoryUpdateEvent { get; private set; }
        
        public static TType GetService<TType>()
        {
            return _serviceProvider.GetService<TType>();
        }
        
        public void SetMainServiceProvider(ServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }
        
        public ServerContext(ServiceProvider initializeServiceProvider)
        {
            ItemStackFactory = initializeServiceProvider.GetService<IItemStackFactory>();
            BlockFactory = initializeServiceProvider.GetService<IBlockFactory>();
            WorldBlockDatastore = initializeServiceProvider.GetService<IWorldBlockDatastore>();
            MapVeinDatastore = initializeServiceProvider.GetService<IMapVeinDatastore>();
            WorldBlockUpdateEvent = initializeServiceProvider.GetService<IWorldBlockUpdateEvent>();
            BlockOpenableInventoryUpdateEvent = initializeServiceProvider.GetService<IBlockOpenableInventoryUpdateEvent>();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Gear/SimpleGearGeneratorComponent.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Blocks.Gear
{
    public class SimpleGearGeneratorComponent : GearEnergyTransformer, IGearGenerator
    {
        public int TeethCount { get; }
        public RPM GenerateRpm { get; }
        public Torque GenerateTorque { get; }
        public bool GenerateIsClockwise { get; }
        
        public SimpleGearGeneratorComponent(SimpleGearGeneratorBlockParam simpleGearGeneratorBlockParam, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent) :
            base(new Torque(0), blockInstanceId, connectorComponent)
        {
            TeethCount = simpleGearGeneratorBlockParam.TeethCount;
            GenerateRpm = new RPM(simpleGearGeneratorBlockParam.GenerateRpm);
            GenerateTorque = new Torque(simpleGearGeneratorBlockParam.GenerateTorque);
            GenerateIsClockwise = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/IChallengeTask.cs
```cs
using System;
using Mooresmaster.Model.ChallengesModule;

namespace Game.Challenge.Task
{
    public interface IChallengeTask
    {
        public ChallengeMasterElement ChallengeMasterElement { get; }
        public int PlayerId { get; }
        
        public IObservable<IChallengeTask> OnChallengeComplete { get; }
        
        public void ManualUpdate();
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/Define/CharacterDefine.cs
```cs
using System;
using System.Collections.Generic;
using Client.Skit.Skit;
using UnityEngine;

namespace Client.Skit.Define
{
    [CreateAssetMenu(fileName = "CharacterDefine", menuName = "moorestech/CharacterDefine", order = 0)]
    public class CharacterDefine : ScriptableObject
    {
        [SerializeField] private List<CharacterInfo> characterInfos;
        public IReadOnlyList<CharacterInfo> CharacterInfos => characterInfos;
    }
    
    [Serializable]
    public class CharacterInfo
    {
        [SerializeField] private string characterKey;
        [SerializeField] private SkitCharacter characterPrefab;
        public string CharacterKey => characterKey;
        
        public SkitCharacter CharacterPrefab => characterPrefab;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Util/GameObjectEnterExplainer.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.UI.Util
{
    public class GameObjectEnterExplainer : MonoBehaviour
    {
        /// <summary>
        ///     
        /// </summary>
        [SerializeField] private string textKey;
        
        /// <summary>
        ///     
        /// </summary>
        [SerializeField] private bool displayEnable = true;
        
        [SerializeField] private int fontSize = IMouseCursorExplainer.DefaultFontSize;
        
        
        public void OnCursorEnter()
        {
            if (displayEnable) MouseCursorExplainer.Instance.Show(textKey, fontSize);
        }
        
        public void OnCursorExit()
        {
            MouseCursorExplainer.Instance.Hide();
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/IItemStackFactory.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;

namespace Core.Item.Interface
{
    public interface IItemStackFactory
    {
        public IItemStack Create(ItemId id, int count, Dictionary<string, ItemStackMetaData> metaData = null);
        public IItemStack Create(ItemId id, int count, ItemInstanceId instanceId, Dictionary<string, ItemStackMetaData> metaData = null);
        public IItemStack Create(Guid itemGuid, int count, Dictionary<string, ItemStackMetaData> metaData = null);
        
        public IItemStack CreatEmpty();
    }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/machineRecipes.json
```cs
{
  "data": [
    {
      "craftTime": 3,
      "craftResultCount": 1,
      "time": 10,
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "inputItems": [
        {
          "count": 1,
          "itemGuid": "6b22a093-0c83-4543-9985-aad0ceb5f8b0"
        },
        {
          "count": 3,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67"
        }
      ],
      "machineRecipeGuid": "5937e6fd-06f9-4b47-88b1-15eae9176c53"
    },
    {
      "time": 1,
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 1,
          "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67"
        },
        {
          "count": 1,
          "itemGuid": "6b54897e-e7cb-4df7-807e-1597c2a859da"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "92fe1a42-ad46-4ff3-aa9a-83a9262c34d6"
        }
      ],
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "machineRecipeGuid": "25e49e81-7217-420a-b328-1939a19cb335"
    },
    {
      "time": 1,
      "inputItems": [
        {
          "count": 8,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 2,
          "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67"
        },
        {
          "count": 1,
          "itemGuid": "99c95d35-9ba8-4027-9d88-48174a7322fa"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "ee7c1edf-32ba-4bd2-962c-d29ee1309730"
        }
      ],
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "machineRecipeGuid": "261c5041-5bde-4fe5-b2e4-4dcb980979ba"
    },
    {
      "time": 1,
      "inputItems": [
        {
          "count": 15,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        },
        {
          "count": 5,
          "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67"
        },
        {
          "count": 1,
          "itemGuid": "c82061f7-f4b2-45bc-8323-40f76dece8f2"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "96e59fa9-8468-4315-b8b8-8e087a146dbb"
        }
      ],
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "machineRecipeGuid": "9e318e0b-75b9-4f4c-97d0-c024655cc9eb"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "craftTime": 3,
      "craftResultCount": 1,
      "time": 1,
      "blockGuid": "a6f37336-8392-458a-b486-10d5b63c6e1a",
      "inputItems": [
        {
          "count": 3,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "975384df-a166-48a6-a5cf-d631f48715c0"
        }
      ],
      "machineRecipeGuid": "2d5e4d0c-ed24-4753-b386-fb518e2fd9fa"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "time": 5,
      "blockGuid": "1a61abfd-3531-43ff-96df-6b16c3436257",
      "inputItems": [
        {
          "count": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 3,
          "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5"
        }
      ],
      "machineRecipeGuid": "c9103ef7-cb64-4216-8dd3-23f9e56991d5"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "time": 1,
      "blockGuid": "ea0a407f-f9a5-4d5e-9c3e-69d6df2d383a",
      "inputItems": [
        {
          "count": 2,
          "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
        }
      ],
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
        }
      ],
      "machineRecipeGuid": "9035d818-9d4d-42cd-a2df-5b97756d9f7c"
    },
    {
      "time": 1,
      "blockGuid": "87aa9a75-906a-47db-92a5-876afe8a1691",
      "outputItems": [
        {
          "percent": 1,
          "count": 1,
          "itemGuid": "189672cb-6811-4080-bde1-1f9ff0ec63ff"
        }
      ],
      "inputItems": [
        {
          "count": 1,
          "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5"
        },
        {
          "count": 1,
          "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627"
        }
      ],
      "machineRecipeGuid": "80a5231b-d51f-454d-bd0a-18646d46403e"
    }
  ]
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/mapObjects.json
```cs
{
  "data": [
    {
      "maxStack": 100,
      "earnItemHps": [
        0
      ],
      "hp": 1,
      "mapObjectName": "Pebble",
      "earnItems": [
        {
          "maxCount": 1,
          "minCount": 1,
          "itemId": "f92c51ab-1979-4a44-8c35-e86a51b33e61",
          "itemGuid": "f92c51ab-1979-4a44-8c35-e86a51b33e61"
        }
      ],
      "mapObjectGuid": "12081941-baa5-42b1-a3ee-5f97f5ee5871",
      "soundEffectType": "stone",
      "miningType": "PickUp",
      "miningParam": {}
    },
    {
      "earnItemHps": [
        0,
        10,
        20
      ],
      "hp": 30,
      "mapObjectName": "Tree",
      "soundEffectType": "tree",
      "earnItems": [
        {
          "maxCount": 3,
          "minCount": 1,
          "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488"
        },
        {
          "maxCount": 8,
          "minCount": 2,
          "itemGuid": "19a3b0bc-10de-4e96-8a41-99f39675556d"
        }
      ],
      "mapObjectGuid": "6c5b31e2-4b26-4a89-b4e5-6f9a4aeaa6b7",
      "miningType": "Mining",
      "miningParam": {
        "miningTools": [
          {
            "attackSpeed": 8,
            "damage": 10,
            "toolItemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90"
          },
          {
            "attackSpeed": 2,
            "damage": 10,
            "toolItemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa"
          },
          {
            "attackSpeed": 1.5,
            "damage": 30,
            "toolItemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e"
          }
        ]
      }
    },
    {
      "resultItem": {
        "count": 1
      },
      "blockSize": [
        1,
        1,
        1
      ],
      "earnItemHps": [
        0,
        1,
        2,
        3
      ],
      "hp": 4,
      "mapObjectName": "",
      "soundEffectType": "stone",
      "miningType": "Mining",
      "earnItems": [
        {
          "maxCount": 1,
          "minCount": 1,
          "itemGuid": "6b22a093-0c83-4543-9985-aad0ceb5f8b0"
        }
      ],
      "miningParam": {
        "miningTools": [
          {
            "attackSpeed": 7,
            "damage": 1,
            "toolItemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa"
          },
          {
            "attackSpeed": 2,
            "damage": 1,
            "toolItemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e"
          }
        ]
      },
      "mapObjectGuid": "c5ad5661-9ae8-4863-9fc2-94819aff4cf7"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "craftResultCount": 1,
      "earnItemHps": [
        0,
        2
      ],
      "hp": 1,
      "mapObjectName": "",
      "soundEffectType": "stone",
      "miningType": "Mining",
      "earnItems": [
        {
          "maxCount": 2,
          "minCount": 1,
          "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154"
        }
      ],
      "miningParam": {
        "miningTools": [
          {
            "attackSpeed": 5,
            "damage": 1,
            "toolItemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa"
          },
          {
            "attackSpeed": 1.5,
            "damage": 1,
            "toolItemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e"
          }
        ]
      },
      "mapObjectGuid": "0ea1f1d6-4921-42a7-a7a6-bbb674e29089"
    }
  ]
}
```

moorestech_client/Assets/Scripts/Client.Game/Sequence/S1InitialMovie.cs
```cs
using Client.CutScene;
using Client.Game.Common;
using Client.Game.InGame.BackgroundSkit;
using Client.Game.Skit;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Playables;

namespace Client.Game.Sequence
{
    public class S1InitialMovie : MonoBehaviour
    {
        public const string S1InitialMoviePlayerPrefsKey = "S1InitialMoviePlayed"; //TODo 
        [SerializeField] private bool forcePlay;
        
        [SerializeField] private bool playCutscene = true;
        [SerializeField] private bool playSkit = true;
        [SerializeField] private bool playBackgroundSkit = true;
        
        [SerializeField] private TimelinePlayer timelinePlayer;
        [SerializeField] private TextAsset initialSkit;
        
        [SerializeField] private PlayableAsset initialMovie;
        
        [SerializeField] private SkitManager skitManager;
        
        [SerializeField] private TextAsset backgroundSkit;
        [SerializeField] private BackgroundSkitManager backgroundSkitManager;
        
        private void Start()
        {
            if (forcePlay)
            {
                InitialMovie().Forget();
                return;
            }
            
            var hasPlayed = PlayerPrefs.GetInt(S1InitialMoviePlayerPrefsKey, 0);
            if (hasPlayed != 0) return;
            
            PlayerPrefs.SetInt(S1InitialMoviePlayerPrefsKey, 1);
            PlayerPrefs.Save();
            
            InitialMovie().Forget();
        }
        
        private async UniTask InitialMovie()
        {
            if (playCutscene)
            {
                GameStateController.ChangeState(GameStateType.CutScene);
                await timelinePlayer.Play(initialMovie);
            }
            
            if (playSkit)
            {
                GameStateController.ChangeState(GameStateType.Skit);
                await skitManager.StartSkit(initialSkit);
            }
            
            if (playBackgroundSkit)
            {
                GameStateController.ChangeState(GameStateType.InGame);
                await backgroundSkitManager.StartBackgroundSkit(backgroundSkit);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/GetMapObjectInfoProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     map object
    /// </summary>
    public class GetMapObjectInfoProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:mapObjectInfo";
        
        private readonly IMapObjectDatastore _mapObjectDatastore;
        
        public GetMapObjectInfoProtocol(ServiceProvider serviceProvider)
        {
            _mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var sendMapObjects = new List<MapObjectsInfoMessagePack>();
            foreach (var mapObject in _mapObjectDatastore.MapObjects)
                sendMapObjects.Add(new MapObjectsInfoMessagePack(mapObject.InstanceId, mapObject.IsDestroyed));
            
            var response = new ResponseMapObjectInfosMessagePack(sendMapObjects);
            
            return response;
        }
        
        
        
        [MessagePackObject]
        public class RequestMapObjectInfosMessagePack : ProtocolMessagePackBase
        {
            public RequestMapObjectInfosMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
        
        [MessagePackObject]
        public class ResponseMapObjectInfosMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<MapObjectsInfoMessagePack> MapObjects { get; set; }
            
            [Obsolete("")]
            public ResponseMapObjectInfosMessagePack() { }
            
            public ResponseMapObjectInfosMessagePack(List<MapObjectsInfoMessagePack> mapObjects)
            {
                Tag = ProtocolTag;
                MapObjects = mapObjects;
            }
        }
        
        [MessagePackObject]
        public class MapObjectsInfoMessagePack
        {
            [Key(0)] public int InstanceId { get; set; }
            [Key(1)] public bool IsDestroyed { get; set; }
            
            [Obsolete("")]
            public MapObjectsInfoMessagePack() { }
            public MapObjectsInfoMessagePack(int instanceId, bool isDestroyed)
            {
                InstanceId = instanceId;
                IsDestroyed = isDestroyed;
            }
        }
    }
}
```

schema/craftRecipes.json
```cs
{
  "$id": "craftRecipes",
  "type": "object",
  "isDefaultOpen": true,

  "properties": {
    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "CraftRecipeMasterElement",

      "items": {
        "type": "object",

        "properties": {

          "craftRecipeGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "craftResultItemGuid": {
            "type": "string",
            "format": "uuid",
            "foreignKey": "items:itemGuid:name"
          },

          "craftResultCount": {
            "type": "integer",
            "default": 1
          },

          "craftTime": {
            "type": "number",
            "default": 3
          },

          "requiredItems": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "itemGuid": {
                  "type": "string",
                  "format": "uuid",
                  "foreignKey": "items:itemGuid:name"
                },
                "count": {
                  "type": "integer",
                  "default": 1
                },
                "isRemain": {
                  "type": "boolean",
                  "default": false,
                  "optional": true
                }
              }
            }
          }
        }
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/MapObjectDestructionInformationTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Map.Interface.MapObject;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.GetMapObjectInfoProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class MapObjectDestructionInformationTest
    {
        [Test]
        public void GetMapObjectTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            
            
            //
            mapObjectDatastore.Get(mapObjectDatastore.MapObjects[0].InstanceId).Destroy();
            
            
            var responseArray = packet.GetPacketResponse(MapObjectDestructionInformationProtocol())[0];
            var response = MessagePackSerializer.Deserialize<ResponseMapObjectInfosMessagePack>(responseArray.ToArray());
            
            foreach (var mapObject in mapObjectDatastore.MapObjects)
            {
                var responseObject =
                    response.MapObjects.Find(m => m.InstanceId == mapObject.InstanceId);
                Assert.AreEqual(mapObject.IsDestroyed, responseObject.IsDestroyed);
            }
        }
        
        // Packet
        private List<byte> MapObjectDestructionInformationProtocol()
        {
            return MessagePackSerializer.Serialize(new RequestMapObjectInfosMessagePack()).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/InInventoryItemChallengeTask.cs
```cs
using System;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Mooresmaster.Model.ChallengesModule;
using UniRx;

namespace Game.Challenge.Task
{
    public class InInventoryItemChallengeTask : IChallengeTask
    {
        public ChallengeMasterElement ChallengeMasterElement { get; }
        public int PlayerId { get; }
        
        public IObservable<IChallengeTask> OnChallengeComplete => _onChallengeComplete;
        private readonly Subject<IChallengeTask> _onChallengeComplete = new();
        
        private bool _completed;
        
        private readonly InInventoryItemTaskParam _inInventoryItemTaskParam;
        private readonly PlayerInventoryData _playerInventory;
        
        public static IChallengeTask Create(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            return new InInventoryItemChallengeTask(playerId, challengeMasterElement);
        }
        public InInventoryItemChallengeTask(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            ChallengeMasterElement = challengeMasterElement;
            PlayerId = playerId;
            
            _inInventoryItemTaskParam = (InInventoryItemTaskParam)challengeMasterElement.TaskParam;
            _playerInventory = ServerContext.GetService<IPlayerInventoryDataStore>().GetInventoryData(playerId);
        }
        
        public void ManualUpdate()
        {
            if (_completed) return;
            
            var itemCount = 0;
            foreach (var item in _playerInventory.MainOpenableInventory.InventoryItems)
            {
                var taskItemId = MasterHolder.ItemMaster.GetItemId(_inInventoryItemTaskParam.ItemGuid);
                if (item.Id != taskItemId) continue;
                
                itemCount += item.Count;
                if (itemCount < _inInventoryItemTaskParam.ItemCount) continue;
                
                _onChallengeComplete.OnNext(this);
                _completed = true;
                break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/CompletedChallengeEventPacket.cs
```cs
using System;
using Game.Challenge;
using Game.Challenge.Task;
using MessagePack;
using Newtonsoft.Json;
using UniRx;

namespace Server.Event.EventReceive
{
    public class CompletedChallengeEventPacket
    {
        public const string EventTag = "va:event:completedChallenge";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public CompletedChallengeEventPacket(EventProtocolProvider eventProtocolProvider, ChallengeEvent challengeEvent)
        {
            _eventProtocolProvider = eventProtocolProvider;
            challengeEvent.OnCompleteChallenge.Subscribe(OnCompletedChallenge);
        }
        
        private void OnCompletedChallenge(IChallengeTask currentChallenge)
        {
            var messagePack = new CompletedChallengeEventMessage(currentChallenge.ChallengeMasterElement.ChallengeGuid);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            var playerId = currentChallenge.PlayerId;
            _eventProtocolProvider.AddEvent(playerId, EventTag, payload);
        }
    }
    
    [MessagePackObject]
    public class CompletedChallengeEventMessage
    {
        [Key(0)] public string CompletedChallengeGuidStr { get; set; }
        [IgnoreMember] public Guid CompletedChallengeGuid => Guid.Parse(CompletedChallengeGuidStr);
        
        [Obsolete("")]
        public CompletedChallengeEventMessage()
        {
        }
        
        public CompletedChallengeEventMessage(Guid completedChallengeGuid)
        {
            CompletedChallengeGuidStr = completedChallengeGuid.ToString();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/ICraftingOpenableInventory.cs
```cs
using Core.Inventory;
using Core.Item.Interface;

namespace Game.PlayerInventory.Interface
{
    public interface ICraftingOpenableInventory : IOpenableInventory
    {
        public void NormalCraft();
        public void AllCraft();
        public void OneStackCraft();
        public IItemStack GetCreatableItem();
        public bool IsCreatable();
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeTask/CreateItemChallengeTask.cs
```cs
using System;
using Core.Master;
using Game.Context;
using Game.Crafting.Interface;
using Mooresmaster.Model.ChallengesModule;
using Mooresmaster.Model.CraftRecipesModule;
using UniRx;

namespace Game.Challenge.Task
{
    public class CreateItemChallengeTask : IChallengeTask
    {
        public ChallengeMasterElement ChallengeMasterElement { get; }
        public int PlayerId { get; }
        
        public IObservable<IChallengeTask> OnChallengeComplete => _onChallengeComplete;
        private readonly Subject<IChallengeTask> _onChallengeComplete = new();
        
        private bool _completed;
        
        
        public static IChallengeTask Create(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            return new CreateItemChallengeTask(playerId, challengeMasterElement);
        }
        
        public CreateItemChallengeTask(int playerId, ChallengeMasterElement challengeMasterElement)
        {
            ChallengeMasterElement = challengeMasterElement;
            PlayerId = playerId;
            
            var craftEvent = ServerContext.GetService<CraftEvent>();
            craftEvent.OnCraftItem.Subscribe(CreateItem);
        }
        
        private void CreateItem(CraftRecipeMasterElement craftRecipeMasterElement)
        {
            if (_completed) return;
            
            var param = ChallengeMasterElement.TaskParam as CreateItemTaskParam;
            
            if (craftRecipeMasterElement.CraftResultItemGuid == param.ItemGuid)
            {
                _completed = true;
                _onChallengeComplete.OnNext(this);
            }
        }
        
        public void ManualUpdate()
        {
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/ItemSelectModal.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Mod.Texture;
using Core.Master;
using Cysharp.Threading.Tasks;
using UniRx;
using UnityEngine;
using UnityEngine.UI;

namespace Client.DebugSystem
{
    public class ItemSelectModal : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        [SerializeField] private Transform itemSlotParent;
        [SerializeField] private Button closeButton;
        
        private List<ItemSlotObject> _itemSlotObjects;
        private ItemSlotObject _selectedItemSlotObject;
        
        public static ItemSelectModal Instance
        {
            get
            {
                if (_instance == null) { _instance = FindObjectOfType<ItemSelectModal>(true); }
                return _instance;
            }
        }
        
        private static ItemSelectModal _instance;
        
        public async UniTask<ItemViewData> SelectItem()
        {
            if (_itemSlotObjects == null)
            {
                Initialize();
            }
            
            gameObject.SetActive(true);
            
            var waitSelectItem = UniTask.WaitUntil(() => _selectedItemSlotObject != null);
            var waitClose = closeButton.OnClickAsync();
            await UniTask.WhenAny(waitSelectItem, waitClose);
            
            gameObject.SetActive(false);
            if (_selectedItemSlotObject == null)
            {
                return null;
            }
            
            var slotObject = _selectedItemSlotObject;
            _selectedItemSlotObject = null;
            
            return slotObject.ItemViewData;
        }
        
        private void Initialize()
        {
            _itemSlotObjects = new List<ItemSlotObject>();
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemView = ClientContext.ItemImageContainer.GetItemView(itemId);
                var itemSlotObject = Instantiate(itemSlotObjectPrefab, itemSlotParent);
                
                itemSlotObject.SetItem(itemView, 0);
                itemSlotObject.OnRightClickUp.Subscribe(item => _selectedItemSlotObject = item).AddTo(this);
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/DIContainer.cs
```cs
using UnityEngine;
using VContainer;
using VContainer.Unity;

namespace Client.Game.InGame.Context
{
    public class DIContainer
    {
        public IObjectResolver DIContainerResolver { get; private set; }
        
        public DIContainer(IObjectResolver objectResolver)
        {
            DIContainerResolver = objectResolver;
        }
        
        public GameObject Instantiate(GameObject prefab)
        {
            return DIContainerResolver.Instantiate(prefab);
        }
        
        public T Instantiate<T>(T prefab, Transform parent, bool worldPositionStays = false) where T : Object
        {
            return DIContainerResolver.Instantiate(prefab, parent, worldPositionStays);
        }
        
        public T Instantiate<T>(T prefab, Vector3 position, Quaternion rotation) where T : Object
        {
            return DIContainerResolver.Instantiate(prefab, position, rotation);
        }
        
        public T Instantiate<T>(T prefab, Vector3 position, Quaternion rotation, Transform parent) where T : Object
        {
            return DIContainerResolver.Instantiate(prefab, position, rotation, parent);
        }
        
        public void InjectGameObject(GameObject gameObject)
        {
            DIContainerResolver.InjectGameObject(gameObject);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IOpenableBlockInventoryComponent.cs
```cs
using Core.Inventory;

namespace Game.Block.Interface.Component
{
    public interface IOpenableBlockInventoryComponent : IBlockInventory, IOpenableInventory
    {
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/block.json
```cs
{
  "Blocks": [
    {
      "name": "TestElectricMachine",
      "type": "ElectricMachine",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test1",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inputSlot": 2,
        "outputSlot": 3,
        "requiredPower": 100,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestBlock",
      "type": "Block",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test2",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {}
    },
    {
      "name": "TestBeltConveyor",
      "type": "BeltConveyor",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test3",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "slot": 4,
        "time": 2000,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": -1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestElectricPole",
      "type": "ElectricPole",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test4",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "poleConnectionRange": 7,
        "machineConnectionRange": 5
      }
    },
    {
      "name": "TestElectricGenerator",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test5",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "isInfinityPower": false,
        "infinityPower": 0,
        "fuelSlot": 10,
        "fuel": [
          {
            "itemModId": "Test Author:forUniTest",
            "itemName": "Test1",
            "time": 1000,
            "power": 100
          },
          {
            "itemModId": "Test Author:forUniTest",
            "itemName": "Test2",
            "time": 2000,
            "power": 200
          }
        ],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestElectricMiner",
      "type": "ElectricMiner",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test6",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "requiredPower": 100,
        "outputSlot": 3,
        "mineSettings": [
          {
            "time": 1000,
            "itemModId": "Test Author:forUniTest",
            "itemName": "Test1"
          }
        ],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestChest",
      "type": "Chest",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test7",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "slot": 5,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "TestInfinityElectricGenerator",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test8",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "isInfinityPower": true,
        "infinityPower": 10,
        "fuelSlot": 0,
        "fuel": [],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "MultiBlock1",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test9",
      "size": {
        "x": 1,
        "y": 1,
        "z": 4
      },
      "param": {
        "isInfinityPower": true,
        "infinityPower": 10,
        "fuelSlot": 0,
        "fuel": [],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "MultiBlock2",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test10",
      "size": {
        "x": 3,
        "y": 1,
        "z": 2
      },
      "param": {
        "isInfinityPower": true,
        "infinityPower": 10,
        "fuelSlot": 0,
        "fuel": [],
        "inventoryConnectors": {
          "outputConnects": [
            {
              "offset": {
                "x": 2,
                "y": 0,
                "z": 2
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                }
              ]
            },
            {
              "offset": {
                "x": 2,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "MultiBlock3",
      "type": "ElectricGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "Test11",
      "size": {
        "x": 1,
        "y": 2,
        "z": 3
      },
      "param": {
        "isInfinityPower": true,
        "infinityPower": 10,
        "fuelSlot": 0,
        "fuel": [],
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "SmallTestGear",
      "type": "Gear",
      "itemModId": "Test Author:forUniTest",
      "itemName": "SmallTestGear",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "requireTorque": 0,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              },
              {
                "x": 0,
                "y": 1,
                "z": 0
              },
              {
                "x": 0,
                "y": -1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "BigTestGear",
      "type": "Gear",
      "itemModId": "Test Author:forUniTest",
      "itemName": "BigTestGear",
      "size": {
        "x": 3,
        "y": 3,
        "z": 1
      },
      "param": {
        "teethCount": 20,
        "requireTorque": 0,
        "gearConnects": [
          {
            "offset": {
              "x": 1,
              "y": 1,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          },
          {
            "offset": {
              "x": 0,
              "y": 1,
              "z": 0
            },
            "directions": [
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 2,
              "y": 1,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 1,
              "y": 2,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 1,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": -1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          }
        ]
      }
    },
    {
      "name": "TestShaft",
      "type": "Shaft",
      "itemModId": "Test Author:forUniTest",
      "itemName": "TestShaft",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "requireTorque": 0.1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "TestGearMachine",
      "type": "GearMachine",
      "itemModId": "Test Author:forUniTest",
      "itemName": "TestGearMachine",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inputSlot": 2,
        "outputSlot": 3,
        "teethCount": 10,
        "requireTorque": 0.1,
        "requiredRpm": 10,
        "requiredTorque": 1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "TestSimpleGearGenerator",
      "type": "SimpleGearGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "TestSimpleGearGenerator",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "generateRpm": 10,
        "generateTorque": 3,
        "requireTorque": 0.1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              },
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "TestFastSimpleGearGenerator",
      "type": "SimpleGearGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "TestFastSimpleGearGenerator",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "generateRpm": 20,
        "generateTorque": 1,
        "requireTorque": 0.1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              },
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "SmallRequireTorqueTestGear",
      "type": "Gear",
      "itemModId": "Test Author:forUniTest",
      "itemName": "SmallRequireTorqueTestGear",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "requireTorque": 1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              },
              {
                "x": 0,
                "y": 1,
                "z": 0
              },
              {
                "x": 0,
                "y": -1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "BigRequireTorqueTestGear",
      "type": "Gear",
      "itemModId": "Test Author:forUniTest",
      "itemName": "BigRequireTorqueTestGear",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 20,
        "requireTorque": 1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              },
              {
                "x": 0,
                "y": 1,
                "z": 0
              },
              {
                "x": 0,
                "y": -1,
                "z": 0
              }
            ],
            "option": {
              "isReverse": true
            }
          },
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "InfinityTestSimpleGearGenerator",
      "type": "SimpleGearGenerator",
      "itemModId": "Test Author:forUniTest",
      "itemName": "InfinityTestSimpleGearGenerator",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "teethCount": 10,
        "generateRpm": 10,
        "generateTorque": 1000000,
        "requireTorque": 0.1,
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 0,
                "y": 0,
                "z": -1
              },
              {
                "x": 0,
                "y": 0,
                "z": 1
              },
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ]
      }
    },
    {
      "name": "GearBeltConveyor",
      "type": "GearBeltConveyor",
      "itemModId": "Test Author:forUniTest",
      "itemName": "GearBeltConveyor",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "gearConnects": [
          {
            "offset": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "directions": [
              {
                "x": 1,
                "y": 0,
                "z": 0
              },
              {
                "x": -1,
                "y": 0,
                "z": 0
              }
            ],
            "option": {
              "isReverse": false
            }
          }
        ],
        "slot": 4,
        "beltConveyorSpeed": 0.01,
        "requiredTorque": 1
      }
    },
    {
      "name": "StraightTestItemShooter",
      "type": "ItemShooter",
      "itemModId": "Test Author:forUniTest",
      "itemName": "StraightTestItemShooter",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inventoryItemNum": 4,
        "initialShootSpeed": 1,
        "itemShootSpeed": 1,
        "acceleration": -0.2,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": -1
                },
                {
                  "x": 1,
                  "y": 0,
                  "z": 0
                },
                {
                  "x": -1,
                  "y": 0,
                  "z": 0
                }
              ]
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": 1
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "DownTestItemShooter",
      "type": "ItemShooter",
      "itemModId": "Test Author:forUniTest",
      "itemName": "DownTestItemShooter",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inventoryItemNum": 4,
        "initialShootSpeed": 1,
        "itemShootSpeed": 1,
        "acceleration": 0.7,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 1,
                  "z": -1
                }
              ]
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": 1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": 1
                }
              ]
            }
          ]
        }
      }
    },
    {
      "name": "UpTestItemShooter",
      "type": "ItemShooter",
      "itemModId": "Test Author:forUniTest",
      "itemName": "UpTestItemShooter",
      "size": {
        "x": 1,
        "y": 1,
        "z": 1
      },
      "param": {
        "inventoryItemNum": 4,
        "initialShootSpeed": 1,
        "itemShootSpeed": 1,
        "acceleration": -0.9,
        "inventoryConnectors": {
          "inputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 0,
                  "z": -1
                },
                {
                  "x": 0,
                  "y": -1,
                  "z": -1
                }
              ]
            }
          ],
          "outputConnects": [
            {
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "directions": [
                {
                  "x": 0,
                  "y": 1,
                  "z": 1
                }
              ]
            }
          ]
        }
      }
    }
  ]
}

```

moorestech_client/Assets/Scripts/Client.Game/InGame/Define/BlockPrefabContainer.cs
```cs
using System;
using System.Collections.Generic;
using Client.Common;
using Core.Const;
using Core.Master;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.Define
{
    [CreateAssetMenu(fileName = "BlockPrefabContainer", menuName = "moorestech/BlockPrefabContainer", order = 0)]
    public class BlockPrefabContainer : ScriptableObject
    {
        [SerializeField] private List<BlockPrefabInfo> blockPrefabs;
        
        public Dictionary<BlockId,BlockObjectInfo> GetBlockDataList()
        {
            var result = new Dictionary<BlockId,BlockObjectInfo>();
            
            foreach (var blockId in MasterHolder.BlockMaster.GetBlockIds())
            {
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                
                var blockPrefab = GetBlockPrefab(blockMasterElement.BlockGuid);
                if (blockPrefab == null) continue;
                
                result.Add(blockId, new BlockObjectInfo(blockPrefab, blockMasterElement));
            }
            
            return result;
        }
        
        private GameObject GetBlockPrefab(Guid blockGuid)
        {
            foreach (var blockPrefab in blockPrefabs)
                if (blockPrefab.GetGuid() == blockGuid)
                    return blockPrefab.BlockPrefab;
            return null;
        }
    }
    
    [Serializable]
    public class BlockPrefabInfo
    {
        public GameObject BlockPrefab => blockPrefab;
        
        [SerializeField] private string blockGuid;
        [SerializeField] private GameObject blockPrefab;
        
        public Guid GetGuid()
        {
            if (Guid.TryParse(blockGuid, out var guid))
            {
                return guid;
            }
            
            Debug.LogError($"InvalidGuid {blockGuid} {blockPrefab.name}");
            return Guid.Empty;
        }
    }
    
    
    
    public class BlockObjectInfo
    {
        public readonly BlockMasterElement BlockMasterElement;
        public readonly GameObject BlockObject;
        
        public BlockObjectInfo(GameObject blockObject, BlockMasterElement blockMasterElement)
        {
            BlockObject = blockObject;
            BlockMasterElement = blockMasterElement;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/VanillaApiSendOnly.cs
```cs
using System;
using System.Collections.Generic;
using Client.Network.Settings;
using Core.Master;
using Game.CraftChainer.CraftChain;
using Server.Protocol.PacketResponse;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using UnityEngine;

namespace Client.Network.API
{
    public class VanillaApiSendOnly
    {
        private readonly PacketSender _packetSender;
        private readonly PlayerConnectionSetting _playerConnectionSetting;
        private readonly int _playerId;
        
        public VanillaApiSendOnly(PacketSender packetSender, PlayerConnectionSetting playerConnectionSetting)
        {
            _packetSender = packetSender;
            _playerConnectionSetting = playerConnectionSetting;
            _playerId = playerConnectionSetting.PlayerId;
        }
        
        public void SetOpenCloseBlock(Vector3Int pos, bool isOpen)
        {
            var request = new BlockInventoryOpenCloseProtocol.BlockInventoryOpenCloseProtocolMessagePack(_playerId, pos, isOpen);
            _packetSender.Send(request);
        }
        
        public void ItemMove(int count, ItemMoveType itemMoveType, ItemMoveInventoryInfo fromInv, int fromSlot, ItemMoveInventoryInfo toInv, int toSlot)
        {
            var request = new InventoryItemMoveProtocol.InventoryItemMoveProtocolMessagePack(_playerId, count, itemMoveType, fromInv, fromSlot, toInv, toSlot);
            _packetSender.Send(request);
        }
        
        public void PlaceHotBarBlock(List<PlaceInfo> placePositions, int hotBarSlot)
        {
            var request = new SendPlaceHotBarBlockProtocol.SendPlaceHotBarBlockProtocolMessagePack(_playerId, hotBarSlot, placePositions);
            _packetSender.Send(request);
        }
        
        public void BlockRemove(Vector3Int pos)
        {
            var request = new RemoveBlockProtocol.RemoveBlockProtocolMessagePack(_playerId, pos);
            _packetSender.Send(request);
        }
        
        public void SendPlayerPosition(Vector3 pos)
        {
            var request = new SetPlayerCoordinateProtocol.PlayerCoordinateSendProtocolMessagePack(_playerId, pos);
            _packetSender.Send(request);
        }
        
        public void Craft(Guid craftRecipeId)
        {
            var request = new OneClickCraft.RequestOneClickCraftProtocolMessagePack(_playerId, craftRecipeId);
            _packetSender.Send(request);
        }
        
        public void Save()
        {
            var request = new SaveProtocol.SaveProtocolMessagePack();
            _packetSender.Send(request);
        }
        
        public void AttackMapObject(int mapObjectInstanceId, int attackDamage)
        {
            var request = new MapObjectAcquisitionProtocol.GetMapObjectProtocolProtocolMessagePack(_playerId, mapObjectInstanceId, attackDamage);
            _packetSender.Send(request);
        }
        
        public void SetCraftChainerCrafterRecipe(Vector3Int block ,List<CraftingSolverItem> inputs, List<CraftingSolverItem> outputs)
        {
            var request = new SetCraftChainerCrafterRecipeProtocol.SetCraftChainerCrafterRecipeProtocolMessagePack(block, inputs, outputs);
            _packetSender.Send(request);
        }
        
        public void SetCraftChainerMainComputerRequestItem(Vector3Int block, ItemId itemId, int count)
        {
            var request = new SetCraftChainerMainComputerRequestItemProtocol.SetCraftChainerMainComputerRequestItemProtocolMessagePack(block, itemId, count);
            _packetSender.Send(request);
        }
        
        public void SendCommand(string command)
        {
            var request = new SendCommandProtocol.SendCommandProtocolMessagePack(command);
            _packetSender.Send(request);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/EventProtocol.cs
```cs
using System;
using System.Collections.Generic;
using MessagePack;
using Server.Event;

namespace Server.Protocol.PacketResponse
{
    public class EventProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:event";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public EventProtocol(EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<EventProtocolMessagePack>(payload.ToArray());
            
            //
            var events = _eventProtocolProvider.GetEventBytesList(data.PlayerId);
            
            return new ResponseEventProtocolMessagePack(events);
        }
        
        
        
        [MessagePackObject]
        public class EventProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Obsolete("")]
            public EventProtocolMessagePack() { }
            
            public EventProtocolMessagePack(int playerId)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
            }
        }
        
        [MessagePackObject]
        public class ResponseEventProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<EventMessagePack> Events { get; set; }
            
            public ResponseEventProtocolMessagePack(List<EventMessagePack> events)
            {
                Tag = ProtocolTag;
                Events = events;
            }
            
            [Obsolete("")]
            public ResponseEventProtocolMessagePack() { }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/machineRecipe.json
```cs
[
  {
    "blockModId": "Test Author:forUniTest",
    "blockName": "TestElectricMachine",
    "time": 1.5,
    "input": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 3
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 1
      }
    ],
    "output": [
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      }
    ]
  },
  {
    "blockModId": "Test Author:forUniTest",
    "blockName": "TestBlock",
    "time": 1.5,
    "input": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 3
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 1
      }
    ],
    "output": [
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      }
    ]
  },
  {
    "blockModId": "Test Author:forUniTest",
    "blockName": "TestBeltConveyor",
    "time": 1.5,
    "input": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 2
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 3
      },
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 4
      }
    ],
    "output": [
      {
        "itemName": "Test5",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      }
    ]
  },
  {
    "blockModId": "Test Author:forUniTest",
    "blockName": "TestGearMachine",
    "time": 1.5,
    "input": [
      {
        "itemName": "Test1",
        "modId": "Test Author:forUniTest",
        "count": 3
      },
      {
        "itemName": "Test2",
        "modId": "Test Author:forUniTest",
        "count": 1
      }
    ],
    "output": [
      {
        "itemName": "Test3",
        "modId": "Test Author:forUniTest",
        "count": 1,
        "percent": 1
      }
    ]
  }
]

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/GetChallengeInfoProtocolTest.cs
```cs
using System;
using System.Linq;
using Game.Challenge;
using Game.Challenge.Task;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UniRx;
using static Server.Protocol.PacketResponse.GetChallengeInfoProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class GetChallengeInfoProtocolTest
    {
        private const int PlayerId = 1;
        private const string Challenge1Guid = "00000000-0000-0000-4567-000000000001";
        private const string Challenge2Guid = "00000000-0000-0000-4567-000000000002";
        private const string Challenge3Guid = "00000000-0000-0000-4567-000000000003";
        private const string Challenge4Guid = "00000000-0000-0000-4567-000000000004";
        
        [Test]
        public void GetCompletedChallengeTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            // 
            // Forced to complete a challenge
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            var playerChallengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            foreach (var challenge in playerChallengeInfo.CurrentChallenges.ToList())
            {
                var subject = (Subject<IChallengeTask>)challenge.OnChallengeComplete;
                subject.OnNext(challenge); // 
            }
            
            // 
            // Request current challenge information
            var messagePack = new RequestChallengeMessagePack(PlayerId);
            var response = packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList())[0];
            var challengeInfo = MessagePackSerializer.Deserialize<ResponseChallengeInfoMessagePack>(response.ToArray());
            
            // 
            // Verification
            Assert.AreEqual(PlayerId, challengeInfo.PlayerId);
            
            Assert.AreEqual(3, challengeInfo.CompletedChallengeGuids.Count);
            Assert.IsTrue(challengeInfo.CompletedChallengeGuids.Contains(Guid.Parse(Challenge1Guid)));
            Assert.IsTrue(challengeInfo.CompletedChallengeGuids.Contains(Guid.Parse(Challenge2Guid)));
            Assert.IsTrue(challengeInfo.CompletedChallengeGuids.Contains(Guid.Parse(Challenge3Guid)));
            
            Assert.AreEqual(1, challengeInfo.CurrentChallengeGuids.Count);
            Assert.IsTrue(challengeInfo.CurrentChallengeGuids.Contains(Guid.Parse(Challenge4Guid)));
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChestSaveLoadTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChestSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var blockGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.ChestId).BlockGuid;
            
            var chestPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var chestBlock = blockFactory.Create(ForUnitTestModBlockId.ChestId, new BlockInstanceId(1), chestPosInfo);
            var chest = chestBlock.GetComponent<VanillaChestComponent>();
            
            
            chest.SetItem(0, new ItemId(1), 7);
            chest.SetItem(2, new ItemId(2), 45);
            chest.SetItem(4, new ItemId(3), 3);
            
            var save = chest.GetSaveState();
            var states = new Dictionary<string, string>() { { chest.SaveKey, save } };
            Debug.Log(save);
            
            var chestBlock2 = blockFactory.Load(blockGuid, new BlockInstanceId(1), states, chestPosInfo);
            var chest2 = chestBlock2.GetComponent<VanillaChestComponent>();
            
            Assert.AreEqual(chest.GetItem(0), chest2.GetItem(0));
            Assert.AreEqual(chest.GetItem(2), chest2.GetItem(2));
            Assert.AreEqual(chest.GetItem(4), chest2.GetItem(4));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Connector/IBlockInventoryInserter.cs
```cs
using Core.Item.Interface;

namespace Game.Block.Blocks.Connector
{
    public interface IBlockInventoryInserter
    {
        public IItemStack InsertItem(IItemStack itemStack);
    }
}
```

moorestech_server/Assets/Scripts/Game.Entity.Interface/EntityInstance/ItemEntity.cs
```cs
using Core.Item.Interface;
using Core.Master;
using UnityEngine;

namespace Game.Entity.Interface.EntityInstance
{
    public class ItemEntity : IEntity
    {
        public ItemEntity(EntityInstanceId instanceId, Vector3 position)
        {
            InstanceId = instanceId;
            Position = position;
        }
        
        public EntityInstanceId InstanceId { get; }
        public string EntityType => VanillaEntityType.VanillaItem;
        public Vector3 Position { get; private set; }
        public string State { get; private set; }
        
        
        public void SetPosition(Vector3 position)
        {
            Position = position;
        }
        
        public void SetState(IItemStack itemStack)
        {
            State = itemStack.Id + "," + itemStack.Count;
        }
        
        public void SetState(ItemId id, int count)
        {
            State = id + "," + count;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaMachineBlockStateConst.cs
```cs
namespace Game.Block.Blocks.Machine
{
    public abstract class VanillaMachineBlockStateConst
    {
        public const string IdleState = "idle";
        public const string ProcessingState = "processing";
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/BlockDebug/BlockDebugSystem.cs
```cs
using Client.Game.GameDebug;
using Client.Game.InGame.Block;
using UniRx;
using UnityEngine;

namespace Client.DebugSystem.BlockDebug
{
    public class BlockDebugSystem
    {
        public void Initialize()
        {
            DebugInfoStore.OnClickBlock.Subscribe(OnClickBlock);
        }
        
        public void OnClickBlock(BlockGameObject block)
        {
            Debug.Log($"Block clicked: {block}");
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Mod/ModGetConfigStringTest.cs
```cs
using System.IO;
using Core.Master;
using Mod.Config;
using Mod.Loader;
using NUnit.Framework;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Mod
{
    /// <summary>
    ///     ConfigOnlytestConfigOnlyMod12
    ///     zip
    /// </summary>
    public class ModGetConfigStringTest
    {
        [Test]
        public void LoadConfigTest()
        {
            var modResource = new ModsResource(Path.Combine(TestModDirectory.ConfigOnlyDirectory, "mods"));
            var loaded = ModJsonStringLoader.GetConfigString(modResource);
            
            Assert.AreEqual(loaded.Count, 2);
            
            var test1modId = new ModId("Test Author 1:testMod1");
            //var test1Config = loaded.Find(x => x.ModId == test1modId);
            var test1Config = loaded["Test Author 1:testMod1"];
            Assert.AreEqual("testItemJson1", test1Config.JsonContents[new JsonFileName("item")]);
            Assert.AreEqual("testBlockJson1", test1Config.JsonContents[new JsonFileName("block")]);
            
            var test2modId = new ModId("Test Author 2:testMod2");
            //var test2Config = loaded.Find(x => x.ModId == test2modId);
            var test2Config = loaded["Test Author 2:testMod2"];
            Assert.AreEqual("testMachineRecipeJson1", test2Config.JsonContents[new JsonFileName("machineRecipe")]);
            Assert.AreEqual("testCraftRecipeJson1", test2Config.JsonContents[new JsonFileName("craftRecipe")]);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Util/AnchorPreset.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.Util
{
    /// <summary>
    ///     RectTransformAnchorenum
    ///     
    ///     RectTransformSetAnchor()
    /// </summary>
    /* usage
  var rect = GetComponent<RectTransform>();
  rect.SetAnchor(AnchorPresets.MiddleCenter);
  rect.localPosition = Vector3.zero;
  */
    public enum AnchorPresets
    {
        TopLeft,
        TopCenter,
        TopRight,
        
        MiddleLeft,
        MiddleCenter,
        MiddleRight,
        
        BottomLeft,
        BottonCenter,
        BottomRight,
        BottomStretch,
        
        VertStretchLeft,
        VertStretchRight,
        VertStretchCenter,
        
        HorStretchTop,
        HorStretchMiddle,
        HorStretchBottom,
        
        StretchAll,
    }
    
    public enum PivotPresets
    {
        TopLeft,
        TopCenter,
        TopRight,
        
        MiddleLeft,
        MiddleCenter,
        MiddleRight,
        
        BottomLeft,
        BottomCenter,
        BottomRight,
    }
    
    public static class RectTransformExtensions
    {
        public static void SetAnchor(this RectTransform source, AnchorPresets allign, int offsetX = 0, int offsetY = 0)
        {
            source.anchoredPosition = new Vector3(offsetX, offsetY, 0);
            
            switch (allign)
            {
                case AnchorPresets.TopLeft:
                    {
                        source.anchorMin = new Vector2(0, 1);
                        source.anchorMax = new Vector2(0, 1);
                        break;
                    }
                case AnchorPresets.TopCenter:
                    {
                        source.anchorMin = new Vector2(0.5f, 1);
                        source.anchorMax = new Vector2(0.5f, 1);
                        break;
                    }
                case AnchorPresets.TopRight:
                    {
                        source.anchorMin = new Vector2(1, 1);
                        source.anchorMax = new Vector2(1, 1);
                        break;
                    }
                
                case AnchorPresets.MiddleLeft:
                    {
                        source.anchorMin = new Vector2(0, 0.5f);
                        source.anchorMax = new Vector2(0, 0.5f);
                        break;
                    }
                case AnchorPresets.MiddleCenter:
                    {
                        source.anchorMin = new Vector2(0.5f, 0.5f);
                        source.anchorMax = new Vector2(0.5f, 0.5f);
                        break;
                    }
                case AnchorPresets.MiddleRight:
                    {
                        source.anchorMin = new Vector2(1, 0.5f);
                        source.anchorMax = new Vector2(1, 0.5f);
                        break;
                    }
                
                case AnchorPresets.BottomLeft:
                    {
                        source.anchorMin = new Vector2(0, 0);
                        source.anchorMax = new Vector2(0, 0);
                        break;
                    }
                case AnchorPresets.BottonCenter:
                    {
                        source.anchorMin = new Vector2(0.5f, 0);
                        source.anchorMax = new Vector2(0.5f, 0);
                        break;
                    }
                case AnchorPresets.BottomRight:
                    {
                        source.anchorMin = new Vector2(1, 0);
                        source.anchorMax = new Vector2(1, 0);
                        break;
                    }
                
                case AnchorPresets.HorStretchTop:
                    {
                        source.anchorMin = new Vector2(0, 1);
                        source.anchorMax = new Vector2(1, 1);
                        break;
                    }
                case AnchorPresets.HorStretchMiddle:
                    {
                        source.anchorMin = new Vector2(0, 0.5f);
                        source.anchorMax = new Vector2(1, 0.5f);
                        break;
                    }
                case AnchorPresets.HorStretchBottom:
                    {
                        source.anchorMin = new Vector2(0, 0);
                        source.anchorMax = new Vector2(1, 0);
                        break;
                    }
                
                case AnchorPresets.VertStretchLeft:
                    {
                        source.anchorMin = new Vector2(0, 0);
                        source.anchorMax = new Vector2(0, 1);
                        break;
                    }
                case AnchorPresets.VertStretchCenter:
                    {
                        source.anchorMin = new Vector2(0.5f, 0);
                        source.anchorMax = new Vector2(0.5f, 1);
                        break;
                    }
                case AnchorPresets.VertStretchRight:
                    {
                        source.anchorMin = new Vector2(1, 0);
                        source.anchorMax = new Vector2(1, 1);
                        break;
                    }
                
                case AnchorPresets.StretchAll:
                    {
                        source.anchorMin = new Vector2(0, 0);
                        source.anchorMax = new Vector2(1, 1);
                        break;
                    }
            }
        }
        
        public static void SetPivot(this RectTransform source, PivotPresets preset)
        {
            switch (preset)
            {
                case PivotPresets.TopLeft:
                    {
                        source.pivot = new Vector2(0, 1);
                        break;
                    }
                case PivotPresets.TopCenter:
                    {
                        source.pivot = new Vector2(0.5f, 1);
                        break;
                    }
                case PivotPresets.TopRight:
                    {
                        source.pivot = new Vector2(1, 1);
                        break;
                    }
                
                case PivotPresets.MiddleLeft:
                    {
                        source.pivot = new Vector2(0, 0.5f);
                        break;
                    }
                case PivotPresets.MiddleCenter:
                    {
                        source.pivot = new Vector2(0.5f, 0.5f);
                        break;
                    }
                case PivotPresets.MiddleRight:
                    {
                        source.pivot = new Vector2(1, 0.5f);
                        break;
                    }
                
                case PivotPresets.BottomLeft:
                    {
                        source.pivot = new Vector2(0, 0);
                        break;
                    }
                case PivotPresets.BottomCenter:
                    {
                        source.pivot = new Vector2(0.5f, 0);
                        break;
                    }
                case PivotPresets.BottomRight:
                    {
                        source.pivot = new Vector2(1, 0);
                        break;
                    }
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/SkitObjectTransfomCopyerInspector.cs
```cs
using Client.Skit.Skit;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(SkitObjectTransfomCopyer))]
public class SkitObjectTransfomCopyerInspector : Editor
{
    public override void OnInspectorGUI()
    {
        var obj = target as SkitObjectTransfomCopyer;
        if (GUILayout.Button(""))
        {
            //TSV
            var pos = obj.transform.position;
            var rot = obj.transform.eulerAngles;
            var str = $"pos\t{pos.x}\t{pos.y}\t{pos.z}\trot\t{rot.x}\t{rot.y}\t{rot.z}";
            EditorGUIUtility.systemCopyBuffer = str;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/BlockConnectorConnectPositionCalculatorTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Component;
using Game.Block.Interface;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    public class BlockConnectorConnectPositionCalculatorTest
    {
        
        [Test]
        public void Calculate_2x2_North_Test()
        {
            var direction = BlockDirection.North;
            
            var blockPositionInfo = new BlockPositionInfo(Vector3Int.zero, direction, new Vector3Int(2, 2, 2));
            
            var connectInfoItems = new List<BlockConnectInfoElement>
            {
                new("", new Vector3Int(1, 0, 0), new []{new Vector3Int(1,0,0)},null),
            };
            var connectionInfo = new BlockConnectInfo(connectInfoItems.ToArray());
            
            
            var result = BlockConnectorConnectPositionCalculator.CalculateConnectPosToConnector(connectionInfo, blockPositionInfo);
            
            Assert.AreEqual(1, result.Count);
            AssertConnectors(result, 0, new Vector3Int(1, 0, 0), new Vector3Int(2, 0, 0));
        }
        
        /// <summary>
        /// 2x2
        /// A test to confirm that a 2x2 block is placed facing north and the southeast connector faces east by placing the block facing east and correctly calculating the position.
        /// </summary>
        [Test]
        public void Calculate_2x2_East_Test()
        {
            var direction = BlockDirection.East;
            
            var blockPositionInfo = new BlockPositionInfo(Vector3Int.zero, direction, new Vector3Int(2, 2, 2));
            
            var connectInfoItems = new List<BlockConnectInfoElement>
            {
                new("", new Vector3Int(1, 0, 0), new []{new Vector3Int(1,0,0)},null),
            };
            var connectionInfo = new BlockConnectInfo(connectInfoItems.ToArray());
            
            
            var result = BlockConnectorConnectPositionCalculator.CalculateConnectPosToConnector(connectionInfo, blockPositionInfo);
            
            AssertConnectors(result, 0, Vector3Int.zero, new Vector3Int(0, 0, -1));
        }
        
        void AssertConnectors(Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)> result, int index, Vector3Int connectorPosition, Vector3Int targetPosition)
        {
            Assert.AreEqual(connectorPosition, result.Values.ToList()[index].position);
            Assert.AreEqual(targetPosition, result.Keys.ToList()[index]);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/IBlockPlacePreview.cs
```cs
using System.Collections.Generic;
using Mooresmaster.Model.BlocksModule;
using Server.Protocol.PacketResponse;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public interface IBlockPlacePreview
    {
        bool IsActive { get; }
        
        public List<bool> SetPreviewAndGroundDetect(List<PlaceInfo> currentPlaceInfos, BlockMasterElement holdingBlockMaster);
        
        public void SetActive(bool active);
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/IItemStackJsonObject.cs
```cs
using System;
using Core.Const;
using Core.Master;
using Newtonsoft.Json;

namespace Core.Item.Interface
{
    public class ItemStackSaveJsonObject
    {
        [JsonProperty("itemGuid")]
        public string ItemGuidStr;
        [JsonProperty("count")]
        public int Count;
        
        [JsonIgnore] public Guid ItemGuid => Guid.Parse(ItemGuidStr);
        
            
        public ItemStackSaveJsonObject() { }
        
        public ItemStackSaveJsonObject(IItemStack itemStack)
        {
            ItemGuidStr = 
                itemStack.Id == ItemMaster.EmptyItemId ?
                    Guid.Empty.ToString() : 
                    MasterHolder.ItemMaster.GetItemMaster(itemStack.Id).ItemGuid.ToString();
            Count = itemStack.Count;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Gear/GearComponent.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Blocks.Gear
{
    public class GearComponent : GearEnergyTransformer, IGear
    {
        public int TeethCount { get; }
        
        public GearComponent(int teethCount, Torque requiredPower, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent)
            : base(requiredPower, blockInstanceId, connectorComponent)
        {
            TeethCount = teethCount;
        }
        
        public GearComponent(GearMachineBlockParam gearMachineBlockParam, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent)
            : base(new Torque(gearMachineBlockParam.RequireTorque), blockInstanceId, connectorComponent)
        {
            TeethCount = gearMachineBlockParam.TeethCount;
        }
        
        public GearComponent(GearBlockParam gearBlockParam, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent)
            : base(new Torque(gearBlockParam.RequireTorque), blockInstanceId, connectorComponent)
        {
            TeethCount = gearBlockParam.TeethCount;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerManager.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using Game.World.Interface.DataStore;
using UniRx;

namespace Game.CraftChainer.CraftNetwork
{
    public class CraftChainerMainComputerManager
    {
        public static CraftChainerMainComputerManager Instance;
        
        private readonly List<CraftChainerMainComputerComponent> _mainComputers = new();
        
        public CraftChainerMainComputerManager()
        {
            Instance = this;
            
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlaceEvent);
            ServerContext.WorldBlockUpdateEvent.OnBlockRemoveEvent.Subscribe(OnBlockRemoveEvent);
        }
        
        private void OnBlockPlaceEvent(BlockUpdateProperties updateProperties)
        {
            var block = updateProperties.BlockData.Block;
            if (block.TryGetComponent<CraftChainerMainComputerComponent>(out var mainComputer))
            {
                _mainComputers.Add(mainComputer);
            }
            if (block.ExistsComponent<ICraftChainerNode>())
            {
                foreach (var computer in _mainComputers)
                {
                    computer.CraftChainerNetworkContext.ReSearchNetwork();
                }
            }
        }
        
        private void OnBlockRemoveEvent(BlockUpdateProperties updateProperties)
        {
            var block = updateProperties.BlockData.Block;
            if (block.TryGetComponent<CraftChainerMainComputerComponent>(out var mainComputer))
            {
                _mainComputers.Remove(mainComputer);
            }
            if (block.ExistsComponent<ICraftChainerNode>())
            {
                foreach (var computer in _mainComputers)
                {
                    computer.CraftChainerNetworkContext.ReSearchNetwork();
                }
            }
        }
        
        
        public CraftChainerNetworkContext GetChainerNetworkContext(CraftChainerNodeId nodeId)
        {
            foreach (var mainComputer in _mainComputers)
            {
                if (mainComputer.CraftChainerNetworkContext.IsExistNode(nodeId))
                {
                    return mainComputer.CraftChainerNetworkContext;
                }
            }
            
            return null;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockFactory.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;

namespace Game.Block.Factory
{
    public class BlockFactory : IBlockFactory
    {
        private readonly VanillaIBlockTemplates _vanillaIBlockTemplates;
        
        public BlockFactory(VanillaIBlockTemplates vanillaIBlockTemplates)
        {
            _vanillaIBlockTemplates = vanillaIBlockTemplates;
        }
        
        public IBlock Create(BlockId blockId, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var dictionary = _vanillaIBlockTemplates.BlockTypesDictionary;
            
            var blockElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            if (dictionary.TryGetValue(blockElement.BlockType, out var value))
                return value.New(blockElement, blockInstanceId, blockPositionInfo);
            
            throw new Exception("Block type not found :" + blockElement.BlockType);
        }
        
        public IBlock Load(Guid blockGuid, BlockInstanceId blockInstanceId, Dictionary<string, string> state, BlockPositionInfo blockPositionInfo)
        {
            var dictionary = _vanillaIBlockTemplates.BlockTypesDictionary;
            
            var blockElement = MasterHolder.BlockMaster.GetBlockMaster(blockGuid);
            if (dictionary.TryGetValue(blockElement.BlockType, out var value))
                return value.Load(state, blockElement, blockInstanceId, blockPositionInfo);
            
            throw new Exception("Block type not found :" + blockElement.BlockType);
        }
        
        public void RegisterTemplateIBlock(string key, IBlockTemplate block)
        {
            _vanillaIBlockTemplates.BlockTypesDictionary.Add(key, block);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/GroundGameObject.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.BlockSystem
{
    public class GroundGameObject : MonoBehaviour
    {
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/ElectricPole/VanillaElectricPoleComponent.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;

namespace Game.Block.Blocks.ElectricPole
{
    public class VanillaElectricPoleComponent : IElectricTransformer, IBlockComponent
    {
        public VanillaElectricPoleComponent(BlockInstanceId blockInstanceId)
        {
            BlockInstanceId = blockInstanceId;
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Control/InGameCameraController.cs
```cs
using System.Threading;
using Cinemachine;
using Client.Input;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;

namespace Client.Game.InGame.Control
{
    public class InGameCameraController : MonoBehaviour
    {
        public Vector3 Position => transform.position;
        public Vector3 CameraEulerAngle => transform.rotation.eulerAngles;
        public float CameraDistance => _cinemachineFraming.m_CameraDistance;
        
        [SerializeField] private Camera mainCamera;
        
        [SerializeField] private CinemachineVirtualCamera virtualCamera;
        [SerializeField] private Vector2 sensitivity = Vector2.one;
        [SerializeField] private float lerpSpeed = 5.0f; // Adjust this to change the lerp speed
        
        private CinemachineFramingTransposer _cinemachineFraming;
        private Quaternion _targetRotation; // The rotation to smoothly rotate towards
        
        private DG.Tweening.Sequence _currentSequence;
        
        private bool _isControllable;
        
        private void Awake()
        {
            _cinemachineFraming = virtualCamera.GetCinemachineComponent<CinemachineFramingTransposer>();
            _targetRotation = transform.rotation; // Initialize target rotation to current rotation
        }
        
        private void Update()
        {
            var distance = _cinemachineFraming.m_CameraDistance + InputManager.UI.SwitchHotBar.ReadValue<float>() / -200f;
            _cinemachineFraming.m_CameraDistance = Mathf.Clamp(distance, 0.6f, 10);
            
            if (!_isControllable && _currentSequence == null) return;
            
            //
            if (_isControllable)
            {
                GetMouseInput();
            }
            LeapCameraRotation();
            
            #region Internal
            
            void GetMouseInput()
            {
                var delta = InputManager.Player.Look.ReadValue<Vector2>();
                
                var rotation = _targetRotation.eulerAngles;
                rotation.x -= delta.y * sensitivity.y;
                if (90 < rotation.x && rotation.x < 180)
                    rotation.x = 90;
                else if (180 < rotation.x && rotation.x < 270) rotation.x = 270;
                
                rotation.y += delta.x * sensitivity.x;
                rotation.z = 0;
                _targetRotation = Quaternion.Euler(rotation);
            }
            
            void LeapCameraRotation()
            {
                var resultRotation = Quaternion.Lerp(transform.rotation, _targetRotation, lerpSpeed * Time.deltaTime);
                resultRotation = Quaternion.Euler(resultRotation.eulerAngles.x, resultRotation.eulerAngles.y, 0);
                transform.rotation = resultRotation;
            }
            
            #endregion
        }
        
        public void SetActive(bool enable)
        {
            enabled = enable;
            mainCamera.gameObject.SetActive(enable);
        }
        
        public void SetControllable(bool enable)
        {
            _isControllable = enable;
        }
        
        public void StartTweenCamera(Vector3 targetRotation, float targetDistance, float duration)
        {
            // DoTween
            _currentSequence?.Kill();
            _currentSequence = DOTween.Sequence()
                .Append(DOTween.To(() => _targetRotation, x => _targetRotation = x, targetRotation, duration).SetEase(Ease.InOutQuad))
                .Join(DOTween.To(() => _cinemachineFraming.m_CameraDistance, x => _cinemachineFraming.m_CameraDistance = x, targetDistance, duration).SetEase(Ease.InOutQuad));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Miner/VanillaGearMinerComponent.cs
```cs
using Game.Block.Blocks.Gear;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.MineSettingsModule;
using UniRx;

namespace Game.Block.Blocks.Miner
{
    public class VanillaGearMinerComponent : IBlockComponent
    {
        private readonly GearEnergyTransformer _gearEnergyTransformer;
        private readonly VanillaMinerProcessorComponent _vanillaMinerProcessorComponent;
        private readonly GearMinerBlockParam _gearMinerBlockParam;
        
        public VanillaGearMinerComponent(VanillaMinerProcessorComponent vanillaMinerProcessorComponent, GearEnergyTransformer gearEnergyTransformer, GearMinerBlockParam gearMinerBlockParam)
        {
            _gearMinerBlockParam = gearMinerBlockParam;
            _vanillaMinerProcessorComponent = vanillaMinerProcessorComponent;
            _gearEnergyTransformer = gearEnergyTransformer;
            _gearEnergyTransformer.OnGearUpdate.Subscribe(OnGearUpdate);
        }
        
        private void OnGearUpdate(GearUpdateType gearUpdateType)
        {
            var requiredRpm = new RPM(_gearMinerBlockParam.RequiredRpm);
            var requireTorque = new Torque(_gearMinerBlockParam.RequireTorque);
            
            var currentElectricPower = _gearEnergyTransformer.CalcMachineSupplyPower(requiredRpm, requireTorque);
            _vanillaMinerProcessorComponent.SupplyPower(currentElectricPower);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/InitialHandshakeProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Entity.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;

namespace Server.Protocol.PacketResponse
{
    public class InitialHandshakeProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:initialHandshake";
        
        private readonly IEntitiesDatastore _entitiesDatastore;
        private readonly IEntityFactory _entityFactory;
        private readonly IWorldSettingsDatastore _worldSettingsDatastore;
        
        public InitialHandshakeProtocol(ServiceProvider serviceProvider)
        {
            _entitiesDatastore = serviceProvider.GetService<IEntitiesDatastore>();
            _entityFactory = serviceProvider.GetService<IEntityFactory>();
            _worldSettingsDatastore = serviceProvider.GetService<IWorldSettingsDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestInitialHandshakeMessagePack>(payload.ToArray());
            
            
            var response = new ResponseInitialHandshakeMessagePack(GetPlayerPosition(new EntityInstanceId(data.PlayerId)));
            
            return response;
        }
        
        
        private Vector3MessagePack GetPlayerPosition(EntityInstanceId playerId)
        {
            if (_entitiesDatastore.Exists(playerId))
            {
                //
                var pos = _entitiesDatastore.GetPosition(playerId);
                return new Vector3MessagePack(pos.x, pos.y, pos.z);
            }
            
            var playerEntity = _entityFactory.CreateEntity(VanillaEntityType.VanillaPlayer, playerId);
            _entitiesDatastore.Add(playerEntity);
            
            
            //
            return new Vector3MessagePack(_worldSettingsDatastore.WorldSpawnPoint);
        }
        
        [MessagePackObject]
        public class RequestInitialHandshakeMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public string PlayerName { get; set; }
            
            [Obsolete("")]
            public RequestInitialHandshakeMessagePack() { }
            
            public RequestInitialHandshakeMessagePack(int playerId, string playerName)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                PlayerName = playerName;
            }
        }
        
        [MessagePackObject]
        public class ResponseInitialHandshakeMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3MessagePack PlayerPos { get; set; }
            
            [Obsolete("")]
            public ResponseInitialHandshakeMessagePack() { }
            
            public ResponseInitialHandshakeMessagePack(Vector3MessagePack playerPos)
            {
                Tag = ProtocolTag;
                PlayerPos = playerPos;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/GeneratorBlockInventoryView.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class GeneratorBlockInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform powerGeneratorFuelItemParent;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            
            
            var itemList = new List<IItemStack>();
            var param = blockGameObject.BlockMasterElement.BlockParam;
            var generatorParam = (ElectricGeneratorBlockParam)param;
            for (var i = 0; i < generatorParam.FuelItemSlotCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, powerGeneratorFuelItemParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            UpdateItemList(itemList);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/WorldObjectOffsetConverter.cs
```cs
using Game.Block.Interface;
using UnityEngine;

namespace Client.Common
{
    /// <summary>
    ///     00.50,0
    /// </summary>
    public static class WorldObjectOffsetConverter
    {
        public static Vector3 AddBlockPlaceOffset(this Vector3 vector3)
        {
            return vector3 + new Vector3(0.5f, 0, 0.5f);
        }
        
        public static Vector2 AddBlockPlaceOffset(this Vector2 vector2)
        {
            return vector2 + new Vector2(0.5f, 0.5f);
        }
        
        public static Vector3 AddBlockPlaceOffset(this Vector3Int pos)
        {
            return pos + new Vector3(0.5f, 0.5f, 0.5f);
        }
        
        public static (Vector3 minPos, Vector3 maxPos) GetWorldBlockBoundingBox(this Vector3Int blockPos, BlockDirection blockDirection, Vector3Int blockSize)
        {
            var maxPos = BlockPositionInfo.CalcBlockMaxPos(blockPos, blockDirection, blockSize);
            // +1 
            maxPos += Vector3Int.one;
            
            return (blockPos, maxPos);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/ElectricSegmentTest.cs
```cs
using Core.Update;
using Game.Block.Interface;
using Game.EnergySystem;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Block
{
    public class ElectricSegmentTest
    {
        [Test]
        public void ElectricEnergyTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var segment = new EnergySegment();
            
            var electric = new BlockElectricConsumer(new ElectricPower(100), new BlockInstanceId(0));
            var generate = new TestElectricGenerator(new ElectricPower(100), new BlockInstanceId(0));
            
            segment.AddGenerator(generate);
            segment.AddEnergyConsumer(electric);
            GameUpdater.UpdateWithWait();
            Assert.AreEqual(100, electric.CurrentPower.AsPrimitive());
            
            segment.RemoveGenerator(generate);
            GameUpdater.UpdateWithWait();
            Assert.AreEqual(0, electric.CurrentPower.AsPrimitive());
            
            var electric2 = new BlockElectricConsumer(new ElectricPower(300), new BlockInstanceId(1));
            segment.AddGenerator(generate);
            segment.AddEnergyConsumer(electric2);
            GameUpdater.UpdateWithWait();
            Assert.AreEqual(25, electric.CurrentPower.AsPrimitive());
            Assert.AreEqual(75, electric2.CurrentPower.AsPrimitive());
            
            segment.RemoveEnergyConsumer(electric);
            GameUpdater.UpdateWithWait();
            Assert.AreEqual(25, electric.CurrentPower.AsPrimitive());
            Assert.AreEqual(100, electric2.CurrentPower.AsPrimitive());
        }
    }
    
    internal class BlockElectricConsumer : IElectricConsumer
    {
        public ElectricPower CurrentPower;
        
        
        public BlockElectricConsumer(ElectricPower requestPower, BlockInstanceId blockInstanceId)
        {
            BlockInstanceId = blockInstanceId;
            RequestEnergy = requestPower;
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        public ElectricPower RequestEnergy{ get; }
        
        public void SupplyEnergy(ElectricPower power)
        {
            CurrentPower = power;
        }
        
        public bool IsDestroy { get; }
        
        public void Destroy()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Crafting.Interface/CraftEvent.cs
```cs
using System;
using Mooresmaster.Model.CraftRecipesModule;
using UniRx;

namespace Game.Crafting.Interface
{
    public class CraftEvent
    {
        private readonly Subject<CraftRecipeMasterElement> _onCraftItem = new();
        public IObservable<CraftRecipeMasterElement> OnCraftItem => _onCraftItem;
        
        public void InvokeCraftItem(CraftRecipeMasterElement craftMasterElement)
        {
            _onCraftItem.OnNext(craftMasterElement);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/PlaceBlockEventPacket.cs
```cs
using System;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using Server.Util.MessagePack;
using UniRx;
using UnityEngine;

namespace Server.Event.EventReceive
{
    public class PlaceBlockEventPacket
    {
        public const string EventTag = "va:event:blockPlace";
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public PlaceBlockEventPacket(EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnPlaceBlock);
        }
        
        private void OnPlaceBlock(BlockUpdateProperties updateProperties)
        {
            var pos = updateProperties.Pos;
            var direction = updateProperties.BlockData.BlockPositionInfo.BlockDirection;
            var blockId = updateProperties.BlockData.Block.BlockId;
            
            var messagePack = new PlaceBlockEventMessagePack(pos, blockId, direction);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class PlaceBlockEventMessagePack
    {
        [Key(0)] public BlockDataMessagePack BlockData { get; set; }
        
        [Obsolete("")]
        public PlaceBlockEventMessagePack()
        {
        }
        
        public PlaceBlockEventMessagePack(Vector3Int blockPos, BlockId blockId, BlockDirection direction)
        {
            BlockData = new BlockDataMessagePack(blockId, blockPos, direction);
        }
    }
    
    
    [MessagePackObject]
    public class BlockDataMessagePack
    {
        [Key(0)] public int BlockIdInt { get; set; }
        [Key(1)] public Vector3IntMessagePack BlockPos { get; set; }
        [Key(2)] public int Direction { get; set; }
        
        [IgnoreMember] public BlockDirection BlockDirection => (BlockDirection)Direction;
        [IgnoreMember] public BlockId BlockId => (BlockId)BlockIdInt;
        
        [Obsolete("")]
        public BlockDataMessagePack() { }
        
        public BlockDataMessagePack(BlockId blockId, Vector3Int blockPos, BlockDirection blockDirection)
        {
            BlockIdInt = (int)blockId;
            BlockPos = new Vector3IntMessagePack(blockPos);
            Direction = (int)blockDirection;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/MapObjectAcquisitionProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     MapObject
    /// </summary>
    public class MapObjectAcquisitionProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:mapObjectInfoAcquisition";
        
        
        private readonly IMapObjectDatastore _mapObjectDatastore;
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public MapObjectAcquisitionProtocol(ServiceProvider serviceProvider)
        {
            _mapObjectDatastore = serviceProvider.GetService<IMapObjectDatastore>();
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<GetMapObjectProtocolProtocolMessagePack>(payload.ToArray());
            
            var mapObject = _mapObjectDatastore.Get(data.InstanceId);
            var playerMainInventory = _playerInventoryDataStore.GetInventoryData(data.PlayerId).MainOpenableInventory;
            
            var earnedItem = mapObject.Attack(data.AttackDamage); // 
            
            foreach (var earnItem in earnedItem) playerMainInventory.InsertItem(earnItem);
            
            return null;
        }
        
        [MessagePackObject]
        public class GetMapObjectProtocolProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public int InstanceId { get; set; }
            [Key(4)] public int AttackDamage { get; set; }
            
            [Obsolete("")]
            public GetMapObjectProtocolProtocolMessagePack() { }
            
            public GetMapObjectProtocolProtocolMessagePack(int playerId, int instanceId, int attackDamage)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                InstanceId = instanceId;
                AttackDamage = attackDamage;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Chest/VanillaChestComponent.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.Connector;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Context;
using Newtonsoft.Json;
using static Game.Block.Interface.BlockException;

namespace Game.Block.Blocks.Chest
{
    public class VanillaChestComponent : IOpenableBlockInventoryComponent, IBlockSaveState, IUpdatableBlockComponent
    {
        public IReadOnlyList<IItemStack> InventoryItems => _itemDataStoreService.InventoryItems;
        public BlockInstanceId BlockInstanceId { get; }
        
        private readonly IBlockInventoryInserter _blockInventoryInserter;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        public VanillaChestComponent(BlockInstanceId blockInstanceId, int slotNum, IBlockInventoryInserter blockInventoryInserter)
        {
            BlockInstanceId = blockInstanceId;
            
            _blockInventoryInserter = blockInventoryInserter;
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, slotNum);
        }
        
        public VanillaChestComponent(Dictionary<string, string> componentStates, BlockInstanceId blockInstanceId, int slotNum, IBlockInventoryInserter blockInventoryInserter) :
            this(blockInstanceId, slotNum, blockInventoryInserter)
        {
            var itemJsons = JsonConvert.DeserializeObject<List<ItemStackSaveJsonObject>>(componentStates[SaveKey]);
            for (var i = 0; i < itemJsons.Count; i++)
            {
                var itemStack = itemJsons[i].ToItemStack();
                _itemDataStoreService.SetItem(i, itemStack);
            }
        }
        
        public string SaveKey { get; } = typeof(VanillaChestComponent).FullName;
        public string GetSaveState()
        {
            CheckDestroy(this);
            
            var itemJson = new List<ItemStackSaveJsonObject>();
            foreach (var item in _itemDataStoreService.InventoryItems)
            {
                itemJson.Add(new ItemStackSaveJsonObject(item));
            }
            
            return JsonConvert.SerializeObject(itemJson);
        }
        
        public void Update()
        {
            CheckDestroy(this);
            
            for (var i = 0; i < _itemDataStoreService.InventoryItems.Count; i++)
            {
                var setItem = _blockInventoryInserter.InsertItem(_itemDataStoreService.InventoryItems[i]);
                _itemDataStoreService.SetItem(i, setItem);
            }
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            CheckDestroy(this);
            
            var blockInventoryUpdate = (BlockOpenableInventoryUpdateEvent)ServerContext.BlockOpenableInventoryUpdateEvent;
            blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(BlockInstanceId, slot, itemStack));
        }
        
        public void SetItem(int slot, IItemStack itemStack) { CheckDestroy(this); _itemDataStoreService.SetItem(slot, itemStack); }
        public IItemStack InsertItem(IItemStack itemStack) { CheckDestroy(this); return _itemDataStoreService.InsertItem(itemStack); }
        public int GetSlotSize() { CheckDestroy(this); return _itemDataStoreService.GetSlotSize(); }
        public ReadOnlyCollection<IItemStack> CreateCopiedItems() { CheckDestroy(this); return _itemDataStoreService.CreateCopiedItems(); }
        public IItemStack GetItem(int slot) { CheckDestroy(this); return _itemDataStoreService.GetItem(slot); }
        public void SetItem(int slot, ItemId itemId, int count) { CheckDestroy(this); _itemDataStoreService.SetItem(slot, itemId, count); }
        public IItemStack ReplaceItem(int slot, IItemStack itemStack) { CheckDestroy(this); return _itemDataStoreService.ReplaceItem(slot, itemStack); }
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count) { CheckDestroy(this); return _itemDataStoreService.ReplaceItem(slot, itemId, count); }
        public IItemStack InsertItem(ItemId itemId, int count) { CheckDestroy(this); return _itemDataStoreService.InsertItem(itemId, count); }
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks) { CheckDestroy(this); return _itemDataStoreService.InsertItem(itemStacks); }
        public bool InsertionCheck(List<IItemStack> itemStacks) { CheckDestroy(this); return _itemDataStoreService.InsertionCheck(itemStacks); }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Challenge/ChallengeDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Core.Update;
using Game.Challenge.Task;
using Game.Challenge.Task.Factory;
using Game.Context;
using Mooresmaster.Model.ChallengesModule;
using UniRx;

namespace Game.Challenge
{
    public class ChallengeDatastore
    {
        private readonly Dictionary<int, PlayerChallengeInfo> _playerChallengeInfos = new();
        private readonly ChallengeFactory _challengeFactory = new();
        
        public ChallengeDatastore()
        {
            GameUpdater.UpdateObservable.Subscribe(Update);
        }
        
        private void Update(Unit unit)
        {
            foreach (var challengeInfo in _playerChallengeInfos.Values)
                for (var i = challengeInfo.CurrentChallenges.Count - 1; i >= 0; i--)
                {
                    var currentChallenge = challengeInfo.CurrentChallenges[i];
                    currentChallenge.ManualUpdate();
                }
        }
        
        public PlayerChallengeInfo GetOrCreateChallengeInfo(int playerId)
        {
            if (_playerChallengeInfos.TryGetValue(playerId, out var info)) return info;
            
            var initialChallenge = CreateInitialChallenge();
            _playerChallengeInfos.Add(playerId, initialChallenge);
            
            return initialChallenge;
            
            #region Internal
            
            PlayerChallengeInfo CreateInitialChallenge()
            {
                var initialChallenges = new List<IChallengeTask>();
                foreach (var challengeGuid in MasterHolder.ChallengeMaster.InitialChallenge)
                {
                    var challenge = MasterHolder.ChallengeMaster.GetChallenge(challengeGuid);
                    var initialChallenge = CreateChallenge(playerId, challenge);
                    initialChallenges.Add(initialChallenge);
                }
                
                return new PlayerChallengeInfo(initialChallenges, new List<Guid>());
            }
            
            #endregion
        }
        
        public void LoadChallenge(List<ChallengeJsonObject> challengeJsonObjects)
        {
            foreach (var challengeJsonObject in challengeJsonObjects)
            {
                var playerId = challengeJsonObject.PlayerId;
                var currentChallenges = new List<IChallengeTask>();
                
                // InitialChallenge
                foreach (var initialChallengeGuid in MasterHolder.ChallengeMaster.InitialChallenge)
                {
                    // 
                    if (challengeJsonObject.CompletedGuids.Contains(initialChallengeGuid.ToString())) continue;
                    
                    var challenge = MasterHolder.ChallengeMaster.GetChallenge(initialChallengeGuid);
                    var initialChallenge = CreateChallenge(playerId, challenge);
                    currentChallenges.Add(initialChallenge);
                }
                
                // CurrentChallenge
                foreach (var completedId in challengeJsonObject.CompletedGuids)
                {
                    // CurrentChallenge
                    //var challenge = MasterHolder.ChallengeMaster.GetChallenge();
                    
                    var nextChallenges = MasterHolder.ChallengeMaster.GetNextChallenges(Guid.Parse(completedId));
                    foreach (var nextChallenge in nextChallenges)
                    {
                        if (challengeJsonObject.CompletedGuids.Contains(nextChallenge.ToString())) continue;
                        
                        var challengeElement = MasterHolder.ChallengeMaster.GetChallenge(nextChallenge.ChallengeGuid);
                        var initialChallenge = CreateChallenge(playerId, challengeElement);
                        currentChallenges.Add(initialChallenge);
                    }
                }
                
                var completedChallengeIds =  challengeJsonObject.CompletedGuids.ConvertAll(Guid.Parse);
                _playerChallengeInfos.Add(playerId, new PlayerChallengeInfo(currentChallenges, completedChallengeIds));
            }
        }
        
        private IChallengeTask CreateChallenge(int playerId, ChallengeMasterElement challengeElement)
        {
            var challenge = _challengeFactory.CreateChallengeTask(playerId, challengeElement);
            challenge.OnChallengeComplete.Subscribe(CompletedChallenge);
            return challenge;
        }
        
        private void CompletedChallenge(IChallengeTask currentChallenge)
        {
            var playerId = currentChallenge.PlayerId;
            var challengeInfo = _playerChallengeInfos[playerId];
            
            challengeInfo.CurrentChallenges.Remove(currentChallenge);
            challengeInfo.CompletedChallengeGuids.Add(currentChallenge.ChallengeMasterElement.ChallengeGuid);
            
            var nextChallenges = MasterHolder.ChallengeMaster.GetNextChallenges(currentChallenge.ChallengeMasterElement.ChallengeGuid);
            foreach (var nextChallengeMaster in nextChallenges)
            {
                var challengeElement = MasterHolder.ChallengeMaster.GetChallenge(nextChallengeMaster.ChallengeGuid);
                
                var nextChallenge = CreateChallenge(playerId, challengeElement);
                challengeInfo.CurrentChallenges.Add(nextChallenge);
            }
            
            ServerContext.GetService<ChallengeEvent>().InvokeCompleteChallenge(currentChallenge);
        }

        
        public List<ChallengeJsonObject> GetSaveJsonObject()
        {
            var result = new List<ChallengeJsonObject>();
            foreach (var challengeInfo in _playerChallengeInfos)
            {
                var playerId = challengeInfo.Key;
                var completedIds = challengeInfo.Value.CompletedChallengeGuids.Select(x => x.ToString()).ToList();
                
                result.Add(new ChallengeJsonObject
                {
                    PlayerId = playerId,
                    CompletedGuids = completedIds
                });
            }
            
            return result;
        }
    }
    
    public class PlayerChallengeInfo
    {
        public List<IChallengeTask> CurrentChallenges { get; }
        public List<Guid> CompletedChallengeGuids { get; }
        
        public PlayerChallengeInfo(List<IChallengeTask> currentChallenges, List<Guid> completedChallengeGuids)
        {
            CurrentChallenges = currentChallenges;
            CompletedChallengeGuids = completedChallengeGuids;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/PacketSender.cs
```cs
using System;
using MessagePack;
using Server.Protocol;

namespace Client.Network.API
{
    /// <summary>
    ///     
    ///     <see cref="PacketExchangeManager" />
    /// </summary>
    public class PacketSender
    {
        private readonly ServerCommunicator _serverCommunicator;
        
        public PacketSender(ServerCommunicator serverCommunicator)
        {
            _serverCommunicator = serverCommunicator;
        }
        
        public void Send(ProtocolMessagePackBase sendData)
        {
            _serverCommunicator.Send(MessagePackSerializer.Serialize(Convert.ChangeType(sendData, sendData.GetType())));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/IBlockFactory.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Factory.BlockTemplate;

namespace Game.Block.Interface
{
    public interface IBlockFactory
    {
        public IBlock Create(BlockId blockId, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo);
        public IBlock Load(Guid blockGuid, BlockInstanceId blockInstanceId, Dictionary<string,string> state, BlockPositionInfo blockPositionInfo);
        
        public void RegisterTemplateIBlock(string key, IBlockTemplate block);
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Gear/SimpleGearService.cs
```cs
using System;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.Gear.Common;
using MessagePack;
using UniRx;

namespace Game.Block.Blocks.Gear
{
    public class SimpleGearService
    {
        private string _currentState = IGearEnergyTransformer.WorkingStateName;
        public IObservable<Unit> BlockStateChange => _onBlockStateChange;
        private readonly Subject<Unit> _onBlockStateChange = new();
        
        public IObservable<GearUpdateType> OnGearUpdate => _onGearUpdate;
        private readonly Subject<GearUpdateType> _onGearUpdate = new();
        
        public RPM CurrentRpm { get; private set; }
        public Torque CurrentTorque { get; private set; }
        public bool IsCurrentClockwise { get; private set; }
        public bool IsRocked { get; private set; }
        
        public void Rocked()
        {
            IsRocked = true;
            _currentState = IGearEnergyTransformer.RockedStateName;
            CurrentRpm = new RPM(0);
            CurrentTorque = new Torque(0);
            
            _onBlockStateChange.OnNext(Unit.Default);
            _onGearUpdate.OnNext(GearUpdateType.Rocked);
        }
        
        public BlockStateDetail GetBlockStateDetail()
        {
            var stateData = MessagePackSerializer.Serialize(new GearStateDetail(CurrentRpm.AsPrimitive(), IsCurrentClockwise));
            return new BlockStateDetail(GearStateDetail.BlockStateDetailKey, stateData);
        }
        
        public void SupplyPower(RPM rpm, Torque torque, bool isClockwise)
        {
            IsRocked = false;
            var isChanged =
                Math.Abs((CurrentRpm - rpm).AsPrimitive()) > 0.05f ||
                Math.Abs((CurrentTorque - torque).AsPrimitive()) > 0.05f ||
                IsCurrentClockwise != isClockwise;
            
            CurrentRpm = rpm;
            CurrentTorque = torque;
            IsCurrentClockwise = isClockwise;
            
            if (isChanged)
            {
                _onBlockStateChange.OnNext(Unit.Default);
            }
            
            _currentState = IGearEnergyTransformer.WorkingStateName;
            _onGearUpdate.OnNext(GearUpdateType.SupplyPower);
        }
        
        public void Destroy()
        {
            _onBlockStateChange.Dispose();
        }
    }
    
    public enum GearUpdateType
    {
        SupplyPower,
        Rocked,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/PauseMenu/BackToMainMenu.cs
```cs
using System.Threading;
using Client.Common;
using Client.Game.InGame.Context;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace Client.Game.InGame.Presenter.PauseMenu
{
    //
    public class BackToMainMenu : MonoBehaviour
    {
        [SerializeField] private Button backToMainMenuButton;
        
        private void Start()
        {
            backToMainMenuButton.onClick.AddListener(Back);
        }
        
        private void OnDestroy()
        {
            Disconnect();
        }
        
        private void OnApplicationQuit()
        {
            Disconnect();
        }
        
        private void Back()
        {
            Disconnect();
            SceneManager.LoadScene(SceneConstant.MainMenuSceneName);
        }
        
        
        private void Disconnect()
        {
            ClientContext.VanillaApi.SendOnly.Save();
            Thread.Sleep(50);
            ClientContext.VanillaApi.Disconnect();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/RecipeViewerView.cs
```cs
using System;
using Client.Game.InGame.UI.Inventory.Sub;
using Core.Master;
using Game.CraftChainer.Util;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class RecipeViewerView : MonoBehaviour
    {
        [SerializeField] private CraftInventoryView craftInventoryView;
        [SerializeField] private MachineRecipeView machineRecipeView;
        [SerializeField] private RecipeTabView recipeTabView;
        
        [SerializeField] private ItemListView itemListView;
        
        private void Awake()
        {
            itemListView.OnClickItem.Subscribe(SetItemListView);
            craftInventoryView.OnClickItem.Subscribe(SetItemListView);
            machineRecipeView.OnClickItem.Subscribe(SetItemListView);
            recipeTabView.OnClickTab.Subscribe(OnClickTab);
        }
        
        private void SetItemListView(RecipeViewerItemRecipes recipeViewerItemRecipes)
        {
            if (recipeViewerItemRecipes == null)
            {
                return;
            }
            
            craftInventoryView.SetRecipes(recipeViewerItemRecipes);
            machineRecipeView.SetRecipes(recipeViewerItemRecipes);
            recipeTabView.SetRecipeTabView(recipeViewerItemRecipes);
            
            var isFirstCraft = recipeViewerItemRecipes.CraftRecipes.Count != 0; 
            craftInventoryView.SetActive(isFirstCraft);
            machineRecipeView.SetActive(!isFirstCraft);
            if (isFirstCraft)
            {
                craftInventoryView.DisplayRecipe(0);
            }
            else
            {
                machineRecipeView.DisplayRecipe(0);
            }
        }
        
        private void OnClickTab(BlockId? blockId)
        {
            var isCraft = !blockId.HasValue;
            
            if (isCraft)
            {
                craftInventoryView.SetActive(true);
                machineRecipeView.SetActive(false);
            }
            else
            {
                craftInventoryView.SetActive(false);
                machineRecipeView.SetActive(true);
                
                machineRecipeView.SetBlockId(blockId.Value);
            }
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/GearBeltConveyorStateChangeProcessor.cs
```cs
using System;
using Game.Gear.Common;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    public class GearBeltConveyorStateChangeProcessor : MonoBehaviour, IBlockStateChangeProcessor
    {
        [SerializeField] private MeshRenderer meshRenderer;
        [SerializeField] private float speed = 1;
        
        public GearStateDetail CurrentGearState { get; private set; }
        
        private Vector2 _offset;
        private static readonly int BaseMap = Shader.PropertyToID("_BaseMap");
        
        public void OnChangeState(BlockStateMessagePack blockState)
        {
            CurrentGearState = blockState.GetStateDetail<GearStateDetail>(GearStateDetail.BlockStateDetailKey);
        }
        
        private void Update()
        {
            if (CurrentGearState == null) return;
            
            _offset.x += CurrentGearState.CurrentRpm / 60 * Time.time * speed;
            meshRenderer.sharedMaterial.SetTextureOffset(BaseMap, _offset);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlacePreviewObjectPool.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Core.Master;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPlacePreviewObjectPool
    {
        private readonly Transform _parentTransform;
        private readonly Dictionary<BlockId, List<PreviewObject>> _blockPreviewObjects = new();
        
        public BlockPlacePreviewObjectPool(Transform parentTransform)
        {
            _parentTransform = parentTransform;
        }
        
        class PreviewObject
        {
            public BlockPreviewObject BlockPreviewObject;
            public bool IsUsed;
        }
        
        public BlockPreviewObject GetObject(BlockId blockId)
        {
            if (!_blockPreviewObjects.ContainsKey(blockId))
            {
                _blockPreviewObjects.Add(blockId, new List<PreviewObject>());
            }
            
            var unusedObject = _blockPreviewObjects[blockId].Find(obj => !obj.IsUsed);
            if (unusedObject == null)
            {
                unusedObject = new PreviewObject
                {
                    BlockPreviewObject = CreatePreviewObject(blockId),
                    IsUsed = true
                };
                _blockPreviewObjects[blockId].Add(unusedObject);
            }
            else
            {
                unusedObject.IsUsed = true;
                unusedObject.BlockPreviewObject.SetActive(true);
            }
            
            return unusedObject.BlockPreviewObject;
            
            #region Internal
            
            BlockPreviewObject CreatePreviewObject(BlockId id)
            {
                var previewBlock = ClientContext.BlockGameObjectContainer.CreatePreviewBlock(id);
                previewBlock.transform.SetParent(_parentTransform);
                previewBlock.transform.localPosition = Vector3.zero;
                
                return previewBlock;
            }
            
            #endregion
        }
        
        
        public void AllUnUse()
        {
            foreach (var previewObjects in _blockPreviewObjects.Values)
            {
                foreach (var previewObject in previewObjects)
                {
                    previewObject.IsUsed = false;
                    previewObject.BlockPreviewObject.SetActive(false);
                }
            }
        }
        
        public void AllDestroy()
        {
            foreach (var previewObjects in _blockPreviewObjects.Values)
            {
                foreach (var previewObject in previewObjects)
                {
                    previewObject.BlockPreviewObject.Destroy();
                }
            }
            
            _blockPreviewObjects.Clear();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/RemoveBlockEventPacket.cs
```cs
using System;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using Server.Util.MessagePack;
using UniRx;
using UnityEngine;

namespace Server.Event.EventReceive
{
    public class RemoveBlockToSetEventPacket
    {
        public const string EventTag = "va:event:removeBlock";
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public RemoveBlockToSetEventPacket(EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            ServerContext.WorldBlockUpdateEvent.OnBlockRemoveEvent.Subscribe(OnBlockRemove);
        }
        
        private void OnBlockRemove(BlockUpdateProperties updateProperties)
        {
            var pos = updateProperties.Pos;
            var payload = MessagePackSerializer.Serialize(new RemoveBlockEventMessagePack(pos));
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, payload);
        }
    }
    
    [MessagePackObject]
    public class RemoveBlockEventMessagePack
    {
        [Obsolete("")]
        public RemoveBlockEventMessagePack()
        {
        }
        
        public RemoveBlockEventMessagePack(Vector3Int pos)
        {
            Position = new Vector3IntMessagePack(pos);
        }
        
        [Key(0)] public Vector3IntMessagePack Position { get; set; }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/MapObjectPin.cs
```cs
using System;
using System.Linq;
using Client.Game.InGame.Control;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Mooresmaster.Model.ChallengesModule;
using TMPro;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Tutorial
{
    public class MapObjectPin : MonoBehaviour, ITutorialView, ITutorialViewManager
    {
        public const string TutorialType = "mapObjectPin";
        
        [SerializeField] private TMP_Text pinText;
        
        private InGameCameraController _inGameCameraController;
        private MapObjectGameObjectDatastore _mapObjectGameObjectDatastore;
        private IPlayerObjectController _playerObjectController;
        
        private MapObjectPinTutorialParam _currentTutorialParam;
        private IDisposable _mapObjectOnDestroy;
        
        [Inject]
        public void Construct(InGameCameraController inGameCameraController, MapObjectGameObjectDatastore mapObjectGameObjectDatastore, IPlayerObjectController playerObjectController)
        {
            _inGameCameraController = inGameCameraController;
            _mapObjectGameObjectDatastore = mapObjectGameObjectDatastore;
            _playerObjectController = playerObjectController;
        }
        
        private void Update()
        {
            // Y
            transform.LookAt(_inGameCameraController.Position);
            transform.rotation = Quaternion.Euler(0, transform.rotation.eulerAngles.y, 0);
        }
        
        public ITutorialView ApplyTutorial(ITutorialParam param)
        {
            _currentTutorialParam = (MapObjectPinTutorialParam)param;
            
            _mapObjectOnDestroy?.Dispose();
            
            // MapObject
            var mapObjects = _mapObjectGameObjectDatastore.CreateMapObjectList(_currentTutorialParam.MapObjectGuid);
            var playerPos = _playerObjectController.Position;
            var sortedMapObjects = mapObjects.OrderBy(x => (playerPos - x.GetPosition()).sqrMagnitude).ToList();
            if (sortedMapObjects.Count == 0)
            {
                Debug.LogWarning($"MapObject {_currentTutorialParam.MapObjectGuid} ");
                return null;
            }
            
            var nearMapObject = sortedMapObjects.First();
            transform.position = nearMapObject.GetPosition();
            
            // MapObjectmapObject
            _mapObjectOnDestroy = nearMapObject.OnDestroyMapObject.Subscribe(_ =>
            {
                ApplyTutorial(_currentTutorialParam);
            }).AddTo(this);
            
            // 
            pinText.text = _currentTutorialParam.PinText;
            
            SetActive(true);
            
            return this;
        }
        
        public void CompleteTutorial()
        {
            SetActive(false);
            _currentTutorialParam = null;
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Miner/VanillaElectricMinerComponent.cs
```cs
using Game.Block.Interface;
using Game.EnergySystem;

namespace Game.Block.Blocks.Miner
{
    public class VanillaElectricMinerComponent : IElectricConsumer
    {
        public BlockInstanceId BlockInstanceId { get; }
        public ElectricPower RequestEnergy { get; }
        
        private readonly VanillaMinerProcessorComponent _vanillaMinerProcessorComponent;
        
        public VanillaElectricMinerComponent(BlockInstanceId blockInstanceId, ElectricPower requestEnergy, VanillaMinerProcessorComponent vanillaMinerProcessorComponent)
        {
            _vanillaMinerProcessorComponent = vanillaMinerProcessorComponent;
            BlockInstanceId = blockInstanceId;
            RequestEnergy = requestEnergy;
        }
        
        public void SupplyEnergy(ElectricPower power)
        {
            _vanillaMinerProcessorComponent.SupplyPower(power);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockPositionInfo.cs
```cs
using UnityEngine;

namespace Game.Block.Interface
{
    public class BlockPositionInfo
    {
        public BlockPositionInfo(Vector3Int originalPos, BlockDirection blockDirection, Vector3Int blockSize)
        {
            OriginalPos = originalPos;
            BlockDirection = blockDirection;
            BlockSize = blockSize;
            
            MaxPos = CalcBlockMaxPos(originalPos, blockDirection, BlockSize);
        }
        
        /// <summary>
        ///     
        /// </summary>
        public Vector3Int OriginalPos { get; }
        
        public Vector3Int BlockSize { get; }
        
        public Vector3Int MinPos => OriginalPos;
        public Vector3Int MaxPos { get; }
        
        public BlockDirection BlockDirection { get; }
        
        /// <summary>
        ///     
        ///      1,1 originmax
        /// </summary>
        public static Vector3Int CalcBlockMaxPos(Vector3Int originPos, BlockDirection direction, Vector3Int blockSize)
        {
            var addPos = Vector3Int.zero;
            switch (direction)
            {
                case BlockDirection.UpNorth:
                case BlockDirection.UpSouth:
                case BlockDirection.DownNorth:
                case BlockDirection.DownSouth:
                    addPos = new Vector3Int(blockSize.x, blockSize.z, blockSize.y);
                    break;
                case BlockDirection.UpEast:
                case BlockDirection.UpWest:
                case BlockDirection.DownEast:
                case BlockDirection.DownWest:
                    addPos = new Vector3Int(blockSize.y, blockSize.z, blockSize.x);
                    break;
                
                case BlockDirection.North:
                case BlockDirection.South:
                    addPos = new Vector3Int(blockSize.x, blockSize.y, blockSize.z);
                    break;
                case BlockDirection.East:
                case BlockDirection.West:
                    addPos = new Vector3Int(blockSize.z, blockSize.y, blockSize.x);
                    break;
            }
            
            // block size1-1
            return addPos + originPos - Vector3Int.one;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/SaveJsonFileName.cs
```cs
using Game.Paths;

namespace Game.SaveLoad.Json
{
    /// <summary>
    ///     JSON
    /// </summary>
    public class SaveJsonFileName
    {
        public string FullSaveFilePath { get; }
        
        public SaveJsonFileName(string fileName)
        {
            FullSaveFilePath = GameSystemPaths.GetSaveFilePath(fileName);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Game.Map.Interface.Json;

namespace Game.Map.Interface.MapObject
{
    public interface IMapObjectDatastore
    {
        public IReadOnlyList<IMapObject> MapObjects { get; }
        
        /// <summary>
        ///     
        ///     
        /// </summary>
        public void LoadMapObject(List<MapObjectJsonObject> savedMapObjects);
        
        public void Add(IMapObject mapObject);
        public IMapObject Get(int instanceId);
        
        public List<MapObjectJsonObject> GetSaveJsonObject();
        
        public event Action<IMapObject> OnDestroyMapObject;
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/CinematicCameraController.cs
```cs
using UnityEngine;

namespace Client.Common
{
    public class CinematicCameraController : MonoBehaviour
    {
        private const float StartVerticalRotationAngle = 70;
        private const float RockVerticalRotationAngle = 88;
        [SerializeField] private Transform cameraRootTransform;
        [SerializeField] private Transform cameraXTransform;
        [SerializeField] private Transform cameraYTransform;
        [SerializeField] private float mouseSpeed = 1f;
        [SerializeField] private float cameraSpeed = 0.05f;
        
        [SerializeField] private float positionMoveSpeed = 0.05f;
        [SerializeField] private float positionLerpSpeed = 0.05f;
        
        
        /// <summary>
        ///     
        /// </summary>
        private Vector3 _targetPosition;
        
        private float lastXmouse;
        
        /// <summary>
        ///     
        /// </summary>
        public Quaternion TargetCameraYRot { get; private set; }
        
        public Quaternion TargetCameraXRot { get; private set; }
        
        //
        private void Awake()
        {
            _targetPosition = cameraRootTransform.position;
            TargetCameraXRot = cameraXTransform.localRotation;
            TargetCameraYRot = cameraYTransform.localRotation;
        }
        
        private void Update()
        {
            //
            Cursor.visible = false;
            Cursor.lockState = CursorLockMode.Locked;
            
            float sensi;
            sensi = mouseSpeed;
            var xMouseRot = Input.GetAxis("Mouse X") * sensi;
            var yMouseRot = Input.GetAxis("Mouse Y") * sensi;
            
            // XY
            TargetCameraXRot *= Quaternion.Euler(-yMouseRot, 0, 0);
            
            //X-8585
            var xRotEuler = TargetCameraXRot.eulerAngles.x;
            //-180180
            xRotEuler = xRotEuler > 180 ? xRotEuler - 360 : xRotEuler;
            
            //X-8585X
            if (xRotEuler is <= -StartVerticalRotationAngle or >= StartVerticalRotationAngle)
            {
                var addXRate = (Mathf.Abs(xRotEuler) - StartVerticalRotationAngle) / (RockVerticalRotationAngle - StartVerticalRotationAngle);
                addXRate *= 0.7f;
                if (-0.2f < xMouseRot && xMouseRot < 0.2)
                    // +-1
                    addXRate *= lastXmouse < 0 ? -1 : 1;
                else
                    // +-1
                    addXRate *= xMouseRot < 0 ? -1 : 1;
                
                TargetCameraYRot *= Quaternion.Euler(0, xMouseRot + yMouseRot * addXRate, 0);
            }
            else
            {
                TargetCameraYRot *= Quaternion.Euler(0, xMouseRot, 0);
            }
            
            xRotEuler = Mathf.Clamp(xRotEuler, -RockVerticalRotationAngle, RockVerticalRotationAngle);
            TargetCameraXRot = Quaternion.Euler(xRotEuler, 0, 0);
            
            
            cameraXTransform.localRotation = Quaternion.Lerp(cameraXTransform.localRotation, TargetCameraXRot, cameraSpeed);
            cameraYTransform.localRotation = Quaternion.Lerp(cameraYTransform.localRotation, TargetCameraYRot, cameraSpeed);
            
            
            //
            var move = new Vector3(
                Input.GetKey(KeyCode.W) ? 1 :
                Input.GetKey(KeyCode.S) ? -1 : 0,
                Input.GetKey(KeyCode.LeftShift) ? -1 :
                Input.GetKey(KeyCode.Space) ? 1 : 0,
                Input.GetKey(KeyCode.A) ? -1 :
                Input.GetKey(KeyCode.D) ? 1 : 0
            );
            
            //XZ
            var cameraForward = transform.forward;
            cameraForward.y = 0;
            cameraForward.Normalize();
            var cameraRight = transform.right;
            cameraRight.y = 0;
            cameraRight.Normalize();
            _targetPosition += cameraForward * move.x * positionMoveSpeed;
            _targetPosition += cameraRight * move.z * positionMoveSpeed;
            _targetPosition.y += move.y * positionMoveSpeed;
            
            
            //
            cameraRootTransform.position = Vector3.Lerp(cameraRootTransform.position, _targetPosition, positionLerpSpeed);
            
            
            lastXmouse = xMouseRot;
        }
        
        public void SetCameraRotation(Quaternion rotation)
        {
            var euler = rotation.eulerAngles;
            TargetCameraXRot = Quaternion.Euler(euler.x, 0, 0);
            TargetCameraYRot = Quaternion.Euler(0, euler.y, 0);
            cameraXTransform.localRotation = TargetCameraXRot;
            cameraYTransform.localRotation = TargetCameraYRot;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerMainComputerSelectRequestItemModal.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Master;
using Cysharp.Threading.Tasks;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class CraftChainerMainComputerSelectRequestItemModal : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform itemsParent;
        [SerializeField] private TMP_InputField countInputField;
        
        [SerializeField] private Button requestButton;
        [SerializeField] private Button cancelButton;
        
        private readonly List<ItemSlotObject> _itemSlotObjects = new();
        private ItemId _selectedItemId;
        
        public void Initialize()
        {
            gameObject.SetActive(false);
            // Initialize item list
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemView = ClientContext.ItemImageContainer.GetItemView(itemId);
                var slotObject = Instantiate(itemSlotObjectPrefab, itemsParent);
                slotObject.SetItem(itemView, 0);
                slotObject.OnLeftClickUp.Subscribe(ClickItem);
                _itemSlotObjects.Add(slotObject);
            }
            countInputField.onValueChanged.AddListener(UpdateRequestButton);
        }
        
        public async UniTask<(ItemId,int)> GetRequestItem()
        {
            SetupUI();
            
            var result = await WaitRequestButton();
            
            gameObject.SetActive(false);
            return result;
            
            #region Internal
            
            void SetupUI()
            {
                gameObject.SetActive(true);
                countInputField.text = 1.ToString();
            }
            
            async UniTask<(ItemId, int)> WaitRequestButton()
            {
                var request = requestButton.OnClickAsync();
                var cancel = cancelButton.OnClickAsync();
                await UniTask.WhenAny(request, cancel);
                
                if (cancel.Status == UniTaskStatus.Succeeded)
                {
                    return (ItemMaster.EmptyItemId, 0);
                }
                
                if (int.TryParse(countInputField.text, out var count))
                {
                    return (_selectedItemId, count);
                }
                
                return (_selectedItemId, 1);
            }
            
            #endregion
        }
        
        
        private void ClickItem(ItemSlotObject itemSlotObject)
        {
            foreach (var slotObject in _itemSlotObjects)
            {
                slotObject.SetHotBarSelect(false);
            }
            
            itemSlotObject.SetHotBarSelect(true);
            _selectedItemId = itemSlotObject.ItemViewData.ItemId;
            
            UpdateRequestButton(countInputField.text);
        }
        
        private void UpdateRequestButton(string inputFieldText)
        {
            if (int.TryParse(inputFieldText, out var count))
            {
                requestButton.interactable = 0 < count;
                return;
            }
            requestButton.interactable = false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/DebugBlockInfoRequestProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface.Component;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class DebugBlockInfoRequestProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:blockDebug";
        
        private readonly IWorldBlockDatastore _worldBlockDatastore;
        
        public DebugBlockInfoRequestProtocol(ServiceProvider serviceProvider)
        {
            _worldBlockDatastore = serviceProvider.GetService<IWorldBlockDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestDebugBlockInfoRequestProtocolMessagePack>(payload.ToArray());
            
            var block = _worldBlockDatastore.GetBlock(data.BlockPos);
            if (block == null)
            {
                return new ResponseDebugBlockInfoRequestProtocolMessagePack(null);
            }
            
            var blockDebugInfo = new List<BlockDebugInfo>();
            var debugInfos = block.ComponentManager.GetComponents<IBlockDebugInfo>();
            foreach (var debug in debugInfos)
            {
                blockDebugInfo.Add(debug.GetDebugInfo());
            }
            
            return new ResponseDebugBlockInfoRequestProtocolMessagePack(blockDebugInfo);
        }
        
        
        [MessagePackObject]
        public class RequestDebugBlockInfoRequestProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            
            
            [Obsolete("")]
            public RequestDebugBlockInfoRequestProtocolMessagePack() { }
            
            public RequestDebugBlockInfoRequestProtocolMessagePack(Vector3Int pos)
            {
                Tag = BlockInventoryRequestProtocol.ProtocolTag;
                BlockPos = new Vector3IntMessagePack(pos);
            }
        }
        
        [MessagePackObject]
        public class ResponseDebugBlockInfoRequestProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<BlockDebugInfo> BlockDebugInfos { get; set; }
            
            [Obsolete("")]
            public ResponseDebugBlockInfoRequestProtocolMessagePack() { }
            public ResponseDebugBlockInfoRequestProtocolMessagePack(List<BlockDebugInfo> blockDebugInfo)
            {
                Tag = BlockInventoryRequestProtocol.ProtocolTag;
                BlockDebugInfos = blockDebugInfo;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Gear/GearEnergyTransformerComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlockConnectInfoModule;
using UniRx;
using UnityEngine;

namespace Game.Block.Blocks.Gear
{
    public class GearEnergyTransformer : IGearEnergyTransformer, IBlockStateObservable, IBlockStateDetail
    {
        public IObservable<Unit> OnChangeBlockState => _simpleGearService.BlockStateChange;
        public IObservable<GearUpdateType> OnGearUpdate => _simpleGearService.OnGearUpdate;
        
        public BlockInstanceId BlockInstanceId { get; }
        public RPM CurrentRpm => _simpleGearService.CurrentRpm;
        public Torque CurrentTorque => _simpleGearService.CurrentTorque;
        public bool IsCurrentClockwise => _simpleGearService.IsCurrentClockwise;
        
        public bool IsRocked => _simpleGearService.IsRocked;
        public bool IsDestroy { get; private set; }
        
        private readonly IBlockConnectorComponent<IGearEnergyTransformer> _connectorComponent;
        
        private readonly Torque _requiredTorque;
        private readonly SimpleGearService _simpleGearService;
        
        public GearEnergyTransformer(Torque requiredTorque, BlockInstanceId blockInstanceId, IBlockConnectorComponent<IGearEnergyTransformer> connectorComponent)
        {
            _requiredTorque = requiredTorque;
            BlockInstanceId = blockInstanceId;
            _connectorComponent = connectorComponent;
            _simpleGearService = new SimpleGearService();
            
            GearNetworkDatastore.AddGear(this);
        }
        
        public BlockStateDetail GetBlockStateDetail()
        {
            return _simpleGearService.GetBlockStateDetail();
        }
        
        public Torque GetRequiredTorque(RPM rpm, bool isClockwise)
        {
            return _requiredTorque;
        }
        
        public void Rocked()
        {
            _simpleGearService.Rocked();
        }
        
        public virtual void SupplyPower(RPM rpm, Torque torque, bool isClockwise)
        {
            _simpleGearService.SupplyPower(rpm, torque, isClockwise);
        }
        
        public List<GearConnect> GetGearConnects()
        {
            var result = new List<GearConnect>();
            foreach (var target in _connectorComponent.ConnectedTargets)
            {
                result.Add(new GearConnect(target.Key, (GearConnectOption)target.Value.SelfOption, (GearConnectOption)target.Value.TargetOption));
            }
            return result;
        }
        
        public void Destroy()
        {
            IsDestroy = true;
            GearNetworkDatastore.RemoveGear(this);
            _simpleGearService.Destroy();
        }
    }
    
    public static class GearEnergyTransformerExtension
    {
        public static ElectricPower CalcMachineSupplyPower(this GearEnergyTransformer energyTransformer, RPM requiredRpm, Torque requiredTorque)
        {
            var currentRpm = energyTransformer.CurrentRpm;
            var currentTorque = energyTransformer.CurrentTorque;
            
            var rpmRate = Mathf.Min((currentRpm / requiredRpm).AsPrimitive(), 1);
            var torqueRate = Mathf.Min((currentTorque / requiredTorque).AsPrimitive(), 1);
            var powerRate = rpmRate * torqueRate;
            
            var requiredGearPower = requiredRpm.AsPrimitive() * requiredTorque.AsPrimitive();
            var currentElectricPower = new ElectricPower(requiredGearPower * powerRate);
            
            return currentElectricPower;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Mod/Texture/ItemTextureLoader.cs
```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Client.Common;
using Core.Master;
using Mod.Loader;
using Mooresmaster.Model.ItemsModule;
using UnityEngine;

namespace Client.Mod.Texture
{
    public static class ItemTextureLoader
    {
        public static Dictionary<ItemId, ItemViewData> GetItemTexture(string modDirectory)
        {
            var textureList = new Dictionary<ItemId, ItemViewData>();
            
            var mods = new ModsResource(modDirectory);
            
            foreach (var mod in mods.Mods)
            {
                // TODO MooresmastermodIdmod
                
                // 
                var itemIds = MasterHolder.ItemMaster.GetItemAllIds().ToList();
                foreach (var texture in GetTextures(itemIds, mod.Value))
                {
                    textureList.Add(texture.ItemId, texture);
                }
            }
            
            return textureList;
        }
        
        
        private static List<ItemViewData> GetTextures(List<ItemId> itemIds, global::Mod.Loader.Mod mod)
        {
            var textureList = new List<ItemViewData>();
            foreach (var itemId in itemIds)
            {
                var itemMaster = MasterHolder.ItemMaster.GetItemMaster(itemId);
                
                var path = string.IsNullOrEmpty(itemMaster.ImagePath) ? Path.Combine("assets", "item", $"{itemMaster.Name}.png") : itemMaster.ImagePath;
                
                var texture = GetExtractedZipTexture.Get(mod.ExtractedPath, path);
                if (texture == null) Debug.LogWarning("ItemTexture Not Found  ModId:" + mod.ModMetaJson.ModId + " ItemName:" + itemMaster.Name);
                
                textureList.Add(new ItemViewData(texture, itemMaster));
            }
            
            return textureList;
        }
    }
    
    
    public class ItemViewData
    {
        public readonly ItemId ItemId;
        public string ItemName => ItemMasterElement.Name;
        public readonly ItemMasterElement ItemMasterElement;
        
        public readonly Sprite ItemImage;
        public readonly UnityEngine.Texture ItemTexture;
        
        public ItemViewData(Texture2D itemTexture, ItemMasterElement itemMasterElement)
        {
            ItemImage = itemTexture.ToSprite();
            ItemTexture = itemTexture;
            ItemMasterElement = itemMasterElement;
            ItemId = MasterHolder.ItemMaster.GetItemId(itemMasterElement.ItemGuid);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.MainMenu/ConnectServer.cs
```cs
using System;
using System.Net;
using System.Net.Sockets;
using Client.Common;
using Client.MainMenu.PopUp;
using Client.Starter;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace Client.MainMenu
{
    public class ConnectServer : MonoBehaviour
    {
        [SerializeField] private TMP_InputField serverIp;
        [SerializeField] private TMP_InputField serverPort;
        
        [SerializeField] private ServerConnectPopup serverConnectPopup;
        
        [SerializeField] private Button connectButton;
        
        private void Start()
        {
            connectButton.onClick.AddListener(Connect);
        }
        
        private void Connect()
        {
            if (!IPAddress.TryParse(serverIp.text, out var address))
            {
                serverConnectPopup.SetText("IP");
                return;
            }
            
            var port = int.Parse(serverPort.text);
            if (65535 < port)
            {
                serverConnectPopup.SetText("65535");
                return;
            }
            
            if (port <= 1024)
            {
                serverConnectPopup.SetText("1024");
                return;
            }
            
            try
            {
                var remoteEndPoint = new IPEndPoint(address, port);
                var socket = new Socket(remoteEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
                
                socket.Connect(remoteEndPoint);
                
                if (socket.Connected)
                {
                    //
                    socket.Close();
                    
                    SceneManager.sceneLoaded += OnMainGameSceneLoaded;
                    SceneManager.LoadScene(SceneConstant.GameInitializerSceneName);
                }
            }
            catch (Exception e)
            {
                serverConnectPopup.SetText("\n" + e);
            }
        }
        
        private void OnMainGameSceneLoaded(Scene scene, LoadSceneMode mode)
        {
            SceneManager.sceneLoaded -= OnMainGameSceneLoaded;
            var starter = FindObjectOfType<InitializeScenePipeline>();
            
            var ip = serverIp.text;
            var port = int.Parse(serverPort.text);
            var playerId = PlayerPrefs.GetInt(PlayerPrefsKeys.PlayerIdKey);
            
            var properties = new InitializeProprieties(false, null, ip, port, playerId);
            
            starter.SetProperty(properties);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/ElectricSegmentMergeService.cs
```cs
using System.Collections.Generic;
using Game.EnergySystem;
using Game.World.Interface.DataStore;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class ElectricSegmentMergeService
    {
        /// <summary>
        ///     
        /// </summary>
        /// <param name="segmentDatastore"></param>
        /// <param name="poles"></param>
        /// <returns></returns>
        public static EnergySegment MergeAndSetDatastoreElectricSegments<TSegment>(
            IWorldEnergySegmentDatastore<TSegment> segmentDatastore, List<IElectricTransformer> poles)
            where TSegment : EnergySegment, new()
        {
            //
            var electricSegments = new List<TSegment>();
            foreach (var pole in poles)
            {
                var electricSegment = segmentDatastore.GetEnergySegment(pole);
                electricSegments.Add(electricSegment);
            }
            
            //
            var mergedElectricSegment = EnergySegmentExtension.Merge(electricSegments);
            //
            for (var i = 0; i < electricSegments.Count; i++)
            {
                segmentDatastore.RemoveEnergySegment(electricSegments[i]);
                electricSegments[i] = null;
            }
            
            //
            segmentDatastore.SetEnergySegment(mergedElectricSegment);
            
            return mergedElectricSegment;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/IBlockTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public interface IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo);
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo);
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/IWorldBlockUpdateEvent.cs
```cs
using System;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    public interface IWorldBlockUpdateEvent
    {
        public IObservable<BlockUpdateProperties> OnBlockPlaceEvent { get; }
        public IObservable<BlockUpdateProperties> OnBlockRemoveEvent { get; }
        
        /// <summary>
        ///     
        /// </summary>
        public IDisposable SubscribePlace(Vector3Int subscribePos, Action<BlockUpdateProperties> blockPlaceEvent);
        
        /// <summary>
        ///     
        /// </summary>
        public IDisposable SubscribeRemove(Vector3Int subscribePos, Action<BlockUpdateProperties> blockPlaceEvent);
    }
    
    public class BlockUpdateProperties
    {
        public Vector3Int Pos { get; }
        public WorldBlockData BlockData { get; }
        
        public BlockUpdateProperties(Vector3Int pos, WorldBlockData blockData)
        {
            Pos = pos;
            BlockData = blockData;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningMiningCompleteState.cs
```cs
using Client.Game.InGame.Context;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.SoundEffect;
using Mooresmaster.Model.MapObjectsModule;
using UnityEngine;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningMiningCompleteState : IMapObjectMiningState
    {
        private readonly MapObjectGameObject _completedMapObjectGameObject;
        private readonly int _attackDamage;
        
        public MapObjectMiningMiningCompleteState(MapObjectGameObject completedMapObjectGameObject, int attackDamage)
        {
            _completedMapObjectGameObject = completedMapObjectGameObject;
            _attackDamage = attackDamage;
        }
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            var masterElement = _completedMapObjectGameObject.MapObjectMasterElement;
            
            PlaySoundEffect(masterElement);
            
            var instanceId = _completedMapObjectGameObject.InstanceId;
            ClientContext.VanillaApi.SendOnly.AttackMapObject(instanceId, _attackDamage);
            
            return context.CurrentFocusMapObjectGameObject == null
                ? new MapObjectMiningIdleState()
                : new MapObjectMiningFocusState();
        }
        
        
        void PlaySoundEffect(MapObjectMasterElement masterElement)
        {
            SoundEffectType soundEffectType;
            switch (masterElement.SoundEffectType)
            {
                case MapObjectMasterElement.SoundEffectTypeConst.stone:
                    soundEffectType = SoundEffectType.DestroyStone;
                    break;
                case MapObjectMasterElement.SoundEffectTypeConst.tree:
                    soundEffectType = SoundEffectType.DestroyTree;
                    break;
                default:
                    soundEffectType = SoundEffectType.DestroyStone;
                    Debug.LogError("");
                    break;
            }
            
            SoundEffectManager.Instance.PlaySoundEffect(soundEffectType);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaElectricPoleTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.ElectricPole;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaElectricPoleTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var transformer = new VanillaElectricPoleComponent(blockInstanceId);
            var components = new List<IBlockComponent>
            {
                transformer,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var transformer = new VanillaElectricPoleComponent(blockInstanceId);
            var components = new List<IBlockComponent>
            {
                transformer,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/MapObjectUpdateEventPacket.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using MessagePack;

namespace Server.Event.EventReceive
{
    /// <summary>
    ///     Map
    /// </summary>
    public class MapObjectUpdateEventPacket
    {
        public const string EventTag = "va:event:mapObjectUpdate";
        private readonly EventProtocolProvider _eventProtocolProvider;
        private readonly IMapObjectDatastore _mapObjectDatastore;
        
        public MapObjectUpdateEventPacket(IMapObjectDatastore mapObjectDatastore,
            EventProtocolProvider eventProtocolProvider)
        {
            _mapObjectDatastore = mapObjectDatastore;
            _eventProtocolProvider = eventProtocolProvider;
            
            _mapObjectDatastore.OnDestroyMapObject += OnDestroyMapObject;
        }
        
        private void OnDestroyMapObject(IMapObject mapObject)
        {
            var messagePack = new MapObjectUpdateEventMessagePack(MapObjectUpdateEventMessagePack.DestroyEventType, mapObject.InstanceId);
            var data = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, data);
        }
    }
    
    [MessagePackObject]
    public class MapObjectUpdateEventMessagePack
    {
        public const string DestroyEventType = "destroy";
        
        
        [Obsolete("")]
        public MapObjectUpdateEventMessagePack()
        {
        }
        
        public MapObjectUpdateEventMessagePack(string eventType, int instanceId)
        {
            EventType = eventType;
            InstanceId = instanceId;
        }
        
        [Key(0)] public string EventType { get; set; }
        
        [Key(1)] public int InstanceId { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/MinerSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Inventory;
using Core.Master;
using Game.Block.Blocks.Miner;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    public class MinerSaveLoadTest
    {
        
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;
            var minerGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.ElectricMinerId).BlockGuid;
            
            var minerPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var originalMiner = blockFactory.Create(ForUnitTestModBlockId.ElectricMinerId, new BlockInstanceId(1), minerPosInfo);
            var originalMinerComponent = originalMiner.GetComponent<VanillaMinerProcessorComponent>();
            var originalRemainingMillSecond = 0.35;
            
            var inventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(originalMinerComponent);
            inventory.SetItem(0, new ItemId(1), 1);
            inventory.SetItem(2, new ItemId(4), 1);
            typeof(VanillaMinerProcessorComponent).GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                .SetValue(originalMinerComponent, originalRemainingMillSecond);
            
            
            var json = originalMiner.GetSaveState();
            Debug.Log(json);
            
            
            var loadedMiner = blockFactory.Load(minerGuid, new BlockInstanceId(1), json, minerPosInfo);
            var loadedMinerComponent = loadedMiner.GetComponent<VanillaMinerProcessorComponent>();
            var loadedInventory =
                (OpenableInventoryItemDataStoreService)typeof(VanillaMinerProcessorComponent)
                    .GetField("_openableInventoryItemDataStoreService", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(originalMinerComponent);
            var loadedRemainingMillSecond =
                (double)typeof(VanillaMinerProcessorComponent)
                    .GetField("_remainingSecond", BindingFlags.Instance | BindingFlags.NonPublic)
                    .GetValue(loadedMinerComponent);
            
            Assert.AreEqual(inventory.GetItem(0), loadedInventory.GetItem(0));
            Assert.AreEqual(inventory.GetItem(1), loadedInventory.GetItem(1));
            Assert.AreEqual(inventory.GetItem(2), loadedInventory.GetItem(2));
            Assert.AreEqual(originalRemainingMillSecond, loadedRemainingMillSecond);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/ProviderChest/CraftChainerProviderChestComponent.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Block.Blocks.Chest;
using Game.CraftChainer.CraftNetwork;
using Newtonsoft.Json;
using UniRx;

namespace Game.CraftChainer.BlockComponent.ProviderChest
{
    public class CraftChainerProviderChestComponent : ICraftChainerNode
    {
        public CraftChainerNodeId NodeId { get; }
        public IReadOnlyList<IItemStack> Inventory => _vanillaChestComponent.InventoryItems;
        private VanillaChestComponent _vanillaChestComponent;
        
        public CraftChainerProviderChestComponent()
        {
            NodeId = CraftChainerNodeId.Create();
        }
        public CraftChainerProviderChestComponent(Dictionary<string, string> componentStates) : this()
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerProviderChestComponentJsonObject>(state);
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        public void SetInitialVanillaChestComponent(VanillaChestComponent vanillaChestComponent)
        {
            _vanillaChestComponent = vanillaChestComponent;
        }
        
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public string SaveKey { get; } = typeof(CraftChainerProviderChestComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerProviderChestComponentJsonObject(this));
        }
    }
    
    public class ChainerProviderChestComponentJsonObject
    {
        [JsonProperty("nodeId")] public int NodeId { get; set; }
        
        public ChainerProviderChestComponentJsonObject(){}
        public ChainerProviderChestComponentJsonObject(CraftChainerProviderChestComponent component)
        {
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/BlockPlaceEventPacketTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;
using Random = System.Random;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class BlockPlaceEventPacketTest
    {
        //
        [Test]
        public void DontBlockPlaceTest()
        {
            var (packetResponse, _) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            List<List<byte>> response = packetResponse.GetPacketResponse(EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        //0
        [Test]
        public void BlockPlaceEvent()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDataStore = ServerContext.WorldBlockDatastore;
            
            
            //ID
            List<List<byte>> response = packetResponse.GetPacketResponse(EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            
            var random = new Random(1410);
            
            //
            var blocks = new List<TestBlockData>();
            for (var j = 0; j < 10; j++)
            {
                var x = random.Next(-10000, 10000);
                var y = random.Next(-10000, 10000);
                var pos = new Vector3Int(x, y);
                var blockId = random.Next(1, 20);
                var direction = random.Next(0, 4);
                
                //
                blocks.Add(new TestBlockData(pos, (BlockId)blockId, direction));
                //
                worldBlockDataStore.TryAddBlock((BlockId)blockId, pos, (BlockDirection)direction, out _);
            }
            
            
            //
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            
            //
            foreach (var r in eventMessagePack.Events)
            {
                var b = AnalysisResponsePacket(r.Payload);
                for (var j = 0; j < blocks.Count; j++)
                    if (b.Equals(blocks[j]))
                        blocks.RemoveAt(j);
            }
            
            //
            Assert.AreEqual(0, blocks.Count);
            
            
            //
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        private TestBlockData AnalysisResponsePacket(byte[] payload)
        {
            var data = MessagePackSerializer.Deserialize<PlaceBlockEventMessagePack>(payload).BlockData;
            
            return new TestBlockData(data.BlockPos, data.BlockId, data.Direction);
        }
        
        private List<byte> EventRequestData(int plyaerID)
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(plyaerID)).ToList();
        }
        
        private class TestBlockData
        {
            public readonly BlockDirection BlockDirection;
            public readonly BlockId id;
            public readonly int X;
            public readonly int Y;
            
            public TestBlockData(Vector3Int pos, BlockId id, int blockDirectionNum)
            {
                X = pos.x;
                Y = pos.y;
                this.id = id;
                BlockDirection = (BlockDirection)blockDirectionNum;
            }
            
            public override bool Equals(object? obj)
            {
                var b = obj as TestBlockData;
                return
                    b.id == id &&
                    b.X == X &&
                    b.Y == Y &&
                    b.BlockDirection == BlockDirection;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Common/Util/MaterialExtension.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Client.Common.Util
{
    public static class MaterialExtension
    {
        private static readonly Material urpMaterial = (Material)Resources.Load("URPLit");
        private static readonly Dictionary<string, string> standardToUrpColor = new() { { "_Color", "_BaseColor" }, { "_EmissionColor", "_EmissionColor" } };
        private static readonly Dictionary<string, string> standardToUrpTexture = new() { { "_MainTex", "_BaseMap" }, { "_BumpMap", "_BumpMap" }, { "_MetallicGlossMap", "_MetallicGlossMap" }, { "_ParallaxMap", "_ParallaxMap" }, { "_OcclusionMap", "_OcclusionMap" } };
        private static readonly Dictionary<string, string> standardToFloat = new() { { "_Metallic", "_Metallic" }, { "_Glossiness", "_Smoothness" } };
        
        public static Material StandardToUrpLit(this Material material)
        {
            if (material.shader.name != "Standard")
            {
                Debug.Log("Standard :" + material.name);
                return null;
            }
            
            var newMaterial = new Material(urpMaterial);
            newMaterial = CopyProperties(material, newMaterial, standardToUrpColor, standardToUrpTexture, standardToFloat);
            
            return newMaterial;
        }
        
        
        private static Material CopyProperties(Material material, Material newMaterial, Dictionary<string, string> colorIndex, Dictionary<string, string> textureIndex, Dictionary<string, string> floatIndex)
        {
            newMaterial.name = material.name;
            foreach (var index in colorIndex) newMaterial.SetColor(index.Value, material.GetColor(index.Key));
            foreach (var index in colorIndex) newMaterial.SetColor(index.Value, material.GetColor(index.Key));
            foreach (var index in textureIndex)
            {
                newMaterial.SetTexture(index.Value, material.GetTexture(index.Key));
                newMaterial.SetTextureOffset(index.Value, material.GetTextureOffset(index.Key));
                newMaterial.SetTextureScale(index.Value, material.GetTextureScale(index.Key));
            }
            
            foreach (var index in floatIndex) newMaterial.SetFloat(index.Value, material.GetFloat(index.Key));
            return newMaterial;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Tutorial/UIHighlight/UIHighlightTutorialView.cs
```cs
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.Tutorial.UIHighlight
{
    public class UIHighlightTutorialView : MonoBehaviour, ITutorialView
    {
        [SerializeField] private GameObject highlightObject;
        [SerializeField] private RectTransform highlightImage;
        [SerializeField] private TMP_Text highlightText;
        
        private UIHighlightTutorialTargetObject _highlightTutorialTargetObject;
        
        public void SetTargetObject(UIHighlightTutorialTargetObject tutorialTargetObject, string text)
        {
            _highlightTutorialTargetObject = tutorialTargetObject;
            highlightText.text = text;
        }
        
        private void Update()
        {
            SyncRectTransform();
        }
        
        private void SyncRectTransform()
        {
            highlightObject.SetActive(_highlightTutorialTargetObject.ActiveSelf);
            
            //
            var currentParent = highlightImage.parent;
            var targetRect = _highlightTutorialTargetObject.RectTransform;
            highlightImage.SetParent(targetRect.parent);
            
            //
            highlightImage.position = targetRect.position;
            highlightImage.rotation = targetRect.rotation;
            highlightImage.localScale = targetRect.localScale;
            
            highlightImage.pivot = targetRect.pivot;
            highlightImage.anchoredPosition = targetRect.anchoredPosition;
            highlightImage.anchorMax = targetRect.anchorMax;
            highlightImage.anchorMin = targetRect.anchorMin;
            highlightImage.offsetMax = targetRect.offsetMax;
            highlightImage.offsetMin = targetRect.offsetMin;
            highlightImage.sizeDelta = targetRect.sizeDelta;
            highlightImage.anchoredPosition3D = targetRect.anchoredPosition3D;
            
            //
            highlightImage.SetParent(currentParent);
        }
        
        public void CompleteTutorial()
        {
            Destroy(gameObject);
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/GearStateChangeProcessorInspector.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Game.Gear.Common;
using UnityEditor;
using UnityEngine;

[CustomEditor(typeof(GearStateChangeProcessor))]
public class GearStateChangeProcessorInspector : Editor
{
    [SerializeField] private float simulateRpm = 60;
    [SerializeField] private bool simulateIsClockwise = true;
    private bool _isSimulating = false;
    
    private readonly Dictionary<Transform, Quaternion> _initialRotations = new();

    public override void OnInspectorGUI()
    {
        var processor = target as GearStateChangeProcessor;
        if (processor == null)
        {
            return;
        }
        
        GUILayout.BeginVertical("Editor only info", "window");
        
        EditorGUILayout.LabelField("Simulate Gear State", EditorStyles.boldLabel);
        ShowSimulateProperty();
        ShowSimulateButton();
        
        GUILayout.Space(10);
        
        ShowCurrentState();

        GUILayout.EndVertical();
        GUILayout.Space(10);

        base.OnInspectorGUI();
        
        #region Internal
        
        void ShowSimulateProperty()
        {
            // RPM
            // RPM and rotation direction properties
            simulateRpm = EditorGUILayout.FloatField("RPM", simulateRpm);
            simulateIsClockwise = EditorGUILayout.Toggle("Is Clockwise", simulateIsClockwise);
        }
        
        void ShowSimulateButton()
        {
            // /
            // Simulation start/stop button
            if (_isSimulating)
            {
                if (GUILayout.Button("Stop Simulate"))
                {
                    foreach (var rotationInfo in processor.RotationInfos)
                    {
                        if (_initialRotations.TryGetValue(rotationInfo.RotationTransform, out var initialRotation))
                        {
                            rotationInfo.RotationTransform.rotation = initialRotation;
                        }
                    }
                    _isSimulating = false;
                    EditorApplication.update -= OnEditorUpdate;
                }
            }
            else
            {
                if (GUILayout.Button("Start Simulate"))
                {
                    _initialRotations.Clear();
                    foreach (var rotationInfo in processor.RotationInfos)
                    {
                        _initialRotations.Add(rotationInfo.RotationTransform, rotationInfo.RotationTransform.rotation);
                    }
                    _isSimulating = true;
                    EditorApplication.update += OnEditorUpdate;
                }
            }
        }
        
        void ShowCurrentState()
        {
            // 
            // Display the current state
            EditorGUILayout.LabelField("Current Gear State", EditorStyles.boldLabel);
            if (processor.CurrentGearState == null)
            {
                EditorGUILayout.LabelField("State data is null");
            }
            else
            {
                EditorGUILayout.LabelField($"RPM: {processor.CurrentGearState.CurrentRpm}");
                EditorGUILayout.LabelField($"Is Clockwise: {processor.CurrentGearState.IsClockwise}");
            }
        }
        
        
  #endregion
    }

    private void OnEditorUpdate()
    {
        if (!_isSimulating)
        {
            EditorApplication.update -= OnEditorUpdate;
            return;
        }

        var processor = target as GearStateChangeProcessor;
        if (processor != null)
        {
            Rotate(processor);
        }

        // Repaint the inspector to reflect changes
        Repaint();
    }

    private void Rotate(GearStateChangeProcessor processor)
    {
        var state = new GearStateDetail(simulateRpm, simulateIsClockwise);
        processor.Rotate(state);
    }
    
    private void OnDisable()
    {
        EditorApplication.update -= OnEditorUpdate;
    }
    private void OnDestroy()
    {
        EditorApplication.update -= OnEditorUpdate;
    }
}

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/GetMapObjectProtocolTest.cs
```cs
using System.Linq;
using Game.Context;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.MapObjectAcquisitionProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class GetMapObjectProtocolTest
    {
        private const int PlayerId = 0;
        
        [Test]
        public void GetMapObjectProtocol_DestroyAndAddToInventory_Test()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
            var worldMapObjectDataStore = serviceProvider.GetService<IMapObjectDatastore>();
            var itemFactory = ServerContext.ItemStackFactory;
            
            var mapObject = worldMapObjectDataStore.MapObjects[0];
            
            var playerInventory = playerInventoryDataStore.GetInventoryData(PlayerId).MainOpenableInventory;
            var itemSlot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            
            
            // 
            var messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 5);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            Assert.AreEqual(itemFactory.CreatEmpty(), playerInventory.GetItem(itemSlot));
            
            
            // 
            messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 5);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            var earnItem = mapObject.EarnItems[0];
            Assert.AreEqual(earnItem, playerInventory.GetItem(itemSlot));
            playerInventory.SetItem(itemSlot, itemFactory.CreatEmpty()); // 
            
            
            //2
            messagePack = new GetMapObjectProtocolProtocolMessagePack(PlayerId, mapObject.InstanceId, 20);
            packet.GetPacketResponse(MessagePackSerializer.Serialize(messagePack).ToList());
            
            Assert.AreEqual(earnItem.Id, playerInventory.GetItem(itemSlot).Id);
            Assert.AreEqual(earnItem.Count * 2, playerInventory.GetItem(itemSlot).Count);
            
            //
            Assert.IsTrue(mapObject.IsDestroyed);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/CraftChainerEntryPoint.cs
```cs
using Game.Context;
using Game.CraftChainer.BlockComponent.Template;
using Game.CraftChainer.CraftNetwork;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Game.CraftChainer
{
    public static class CraftChainerEntryPoint
    {
        public static void Entry()
        {
            // block template register
            var blockFactory = ServerContext.BlockFactory;    
            blockFactory.RegisterTemplateIBlock(BlockTypeConst.CraftChainerCrafter, new CraftChainerCrafterTemplate());
            blockFactory.RegisterTemplateIBlock(BlockTypeConst.CraftChainerTransporter, new CraftChainerTransporterTemplate());
            blockFactory.RegisterTemplateIBlock(BlockTypeConst.CraftChainerProviderChest, new CraftChainerProviderChestTemplate());
            blockFactory.RegisterTemplateIBlock(BlockTypeConst.CraftChainerMainComputer, new CraftChainerMainComputerTemplate());
            
            // manager init
            new CraftChainerMainComputerManager();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/RendererMaterialReplacerController.cs
```cs
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class RendererMaterialReplacerController
    {
        private readonly List<RendererMaterialReplacer> _rendererMaterialReplacers;
        
        public RendererMaterialReplacerController(GameObject targetObject)
        {
            _rendererMaterialReplacers = new List<RendererMaterialReplacer>();
            var ignoreParents = targetObject.GetComponentsInChildren<IgnoreRendererMaterialReplacer>(true);
            
            foreach (var renderer in targetObject.GetComponentsInChildren<Renderer>())
            {
                //  IgnoreRendererMaterialReplacer 
                // Ignore if the renderer is a child of the IgnoreRendererMaterialReplacer
                var isIgnore = false;
                foreach (var ignoreParent in ignoreParents)
                {
                    isIgnore |= renderer.transform.IsChildOf(ignoreParent.transform);
                }
                if (isIgnore) continue;
                
                _rendererMaterialReplacers.Add(new RendererMaterialReplacer(renderer));
            }
        }
        
        public void CopyAndSetMaterial(Material placeMaterial)
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.CopyAndSetMaterial(placeMaterial));
        }
        
        public void SetPlaceMaterialProperty(string propertyName, float value)
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.SetPlaceMaterialProperty(propertyName, value));
        }
        
        public void SetColor(string propertyName, Color color)
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.SetColor(propertyName, color));
        }
        
        public void ResetMaterial()
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.ResetMaterial());
        }
        
        public void DestroyMaterial()
        {
            _rendererMaterialReplacers.ForEach(replacer => replacer.DestroyMaterial());
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/BlockStateProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Context;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Event.EventReceive;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class BlockStateProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:blockState";
        
        public BlockStateProtocol(ServiceProvider serviceProvider)
        {
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestBlockStateProtocolMessagePack>(payload.ToArray());
            
            var block = ServerContext.WorldBlockDatastore.GetBlock(data.Position.Vector3Int);
            if (block == null)
            {
                return new ResponseBlockStateProtocolMessagePack(null);
            }
            
            var blockState = block.GetBlockState();
            
            return new ResponseBlockStateProtocolMessagePack(new BlockStateMessagePack(blockState, data.Position.Vector3Int));
        }
        
        [MessagePackObject]
        public class RequestBlockStateProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack Position { get; set; }
            
            [Obsolete("")]
            public RequestBlockStateProtocolMessagePack() { }
            
            public RequestBlockStateProtocolMessagePack(Vector3Int pos)
            {
                Tag = ProtocolTag;
                Position = new Vector3IntMessagePack(pos);
            }
        }
        
        [MessagePackObject]
        public class ResponseBlockStateProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public BlockStateMessagePack State { get; set; }
            
            [Obsolete("")]
            public ResponseBlockStateProtocolMessagePack() { }
            
            public ResponseBlockStateProtocolMessagePack(BlockStateMessagePack state)
            {
                Tag = ProtocolTag;
                State = state;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock CreateGear(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var configParam = blockMasterElement.BlockParam as GearBlockParam;
            var connectSetting = configParam.Gear.GearConnects;
            
            var gearConnector = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var gearComponent = new GearComponent(configParam, blockInstanceId, gearConnector);
            
            var components = new List<IBlockComponent>
            {
                gearComponent,
                gearConnector,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Mod.Loader/ModMetaJson.cs
```cs
using Newtonsoft.Json;

namespace Mod.Loader
{
    [JsonObject("ModMeta")]
    public class ModMetaJson
    {
        [JsonProperty("author")] private string _modAuthor;
        [JsonProperty("description")] private string _modDescription;
        
        
        [JsonProperty("id")] private string _modId;
        [JsonProperty("name")] private string _modName;
        [JsonProperty("version")] private string _modVersion;
        
        /// <summary>
        ///     modId  + : + modId 
        /// </summary>
        public string ModId => _modAuthor + ":" + _modId;
        
        public string ModName => _modName;
        public string ModVersion => _modVersion;
        public string ModAuthor => _modAuthor;
        public string ModDescription => _modDescription;
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/IgnoreRendererMaterialReplacerInspector.cs
```cs
using Client.Game.InGame.Block;
using UnityEditor;

[CustomEditor(typeof(IgnoreRendererMaterialReplacer))]
public class IgnoreRendererMaterialReplacerInspector : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        //TODO i18n
        
        EditorGUILayout.HelpBox("", MessageType.Info);
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/GrabInventoryUpdateEventPacket.cs
```cs
using System;
using Core.Item.Interface;
using Game.PlayerInventory.Interface.Event;
using MessagePack;
using Server.Util.MessagePack;

namespace Server.Event.EventReceive
{
    public class GrabInventoryUpdateEventPacket
    {
        public const string EventTag = "va:event:grabInvUpdate";
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public GrabInventoryUpdateEventPacket(IGrabInventoryUpdateEvent grabInventoryUpdateEvent,
            EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            grabInventoryUpdateEvent.Subscribe(ReceivedEvent);
        }
        
        
        private void ReceivedEvent(PlayerInventoryUpdateEventProperties playerInventoryUpdateEvent)
        {
            var messagePack = new GrabInventoryUpdateEventMessagePack(playerInventoryUpdateEvent.ItemStack);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddEvent(playerInventoryUpdateEvent.PlayerId, EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class GrabInventoryUpdateEventMessagePack
    {
        [Obsolete("")]
        public GrabInventoryUpdateEventMessagePack()
        {
        }
        
        public GrabInventoryUpdateEventMessagePack(IItemStack item)
        {
            Item = new ItemMessagePack(item);
        }
        
        [Key(0)] public ItemMessagePack Item { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaSimpleGearGeneratorTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaSimpleGearGeneratorTemplate : IBlockTemplate
    {
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock CreateGear(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var configParam = blockMasterElement.BlockParam as SimpleGearGeneratorBlockParam;
            var connectSetting = configParam.Gear.GearConnects;
            
            var blockComponent = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var gearComponent = new SimpleGearGeneratorComponent(configParam, blockInstanceId, blockComponent);
            
            var components = new List<IBlockComponent>
            {
                gearComponent,
                blockComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/CraftChain/CraftingSolverItem.cs
```cs
using System;
using Core.Master;
using MessagePack;
using Newtonsoft.Json;

namespace Game.CraftChainer.CraftChain
{
    public class CraftingSolverItem
    {
        public readonly ItemId ItemId;
        public readonly int Count;
        
        public CraftingSolverItem(ItemId itemId, int count)
        {
            ItemId = itemId;
            Count = count;
        }
    }
    
    [JsonObject, MessagePackObject]
    public class CraftingSolverItemJsonObjectMessagePack
    {
        [JsonProperty("itemGuid"), Key(0)] public string ItemGuid;
        [JsonProperty("count"), Key(1)] public int Count;
        
        public CraftingSolverItemJsonObjectMessagePack() { }
        public CraftingSolverItemJsonObjectMessagePack(CraftingSolverItem craftingSolverItem)
        {
            ItemGuid = MasterHolder.ItemMaster.GetItemMaster(craftingSolverItem.ItemId).ItemGuid.ToString();
            Count = craftingSolverItem.Count;
        }
        
        public CraftingSolverItem ToCraftingSolverItem()
        {
            var guid = new Guid(ItemGuid);
            var itemId = MasterHolder.ItemMaster.GetItemId(guid);
            return new CraftingSolverItem(itemId, Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BackgroundSkit/BackgroundSkitManager.cs
```cs
using Client.Game.InGame.UI.UIState;
using Client.Skit.Define;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Game.InGame.BackgroundSkit
{
    public class BackgroundSkitManager : MonoBehaviour
    {
        [SerializeField] private BackgroundSkitUI backgroundSkitUI;
        [SerializeField] private UIStateControl uiStateControl;
        
        [SerializeField] private VoiceDefine voiceDefine;
        
        public async UniTask StartBackgroundSkit(TextAsset storyCsv)
        {
            // UIGameScreen
            await UniTask.WaitUntil(() => uiStateControl.CurrentState == UIStateEnum.GameScreen);
            
            backgroundSkitUI.SetActive(true);
            
            var lines = storyCsv.text.Split('\n');
            
            foreach (var line in lines)
            {
                var values = line.Split(',');
                var characterName = values[0];
                var text = values[1].Replace("\\n", "\n");
                
                var voice = voiceDefine.GetVoiceClip(characterName, text);
                
                await backgroundSkitUI.SetText(characterName, text, voice);
            }
            
            backgroundSkitUI.SetActive(false);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/AllBlockStateProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Context;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Event.EventReceive;

namespace Server.Protocol.PacketResponse
{
    public class AllBlockStateProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:allBockState";
        
        public AllBlockStateProtocol(ServiceProvider serviceProvider)
        {
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var stateList = new List<BlockStateMessagePack>();
            foreach (var block in ServerContext.WorldBlockDatastore.BlockMasterDictionary.Values)
            {
                var pos = block.BlockPositionInfo.OriginalPos;
                var state = block.Block.GetBlockState();
                if (state != null) stateList.Add(new BlockStateMessagePack(state, pos));
            }
            
            return new ResponseAllBlockStateProtocolMessagePack(stateList);
        }
        
        [MessagePackObject]
        public class RequestAllBlockStateProtocolMessagePack : ProtocolMessagePackBase
        {
            public RequestAllBlockStateProtocolMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
        
        [MessagePackObject]
        public class ResponseAllBlockStateProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public List<BlockStateMessagePack> StateList { get; set; }
            
            [Obsolete("")]
            public ResponseAllBlockStateProtocolMessagePack() { }
            
            public ResponseAllBlockStateProtocolMessagePack(List<BlockStateMessagePack> stateList)
            {
                Tag = ProtocolTag;
                StateList = stateList;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/GameScreenState.cs
```cs
using Client.Game.GameDebug;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.Control;
using Client.Game.Skit;
using Client.Input;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class GameScreenState : IUIState
    {
        private readonly IBlockPlacePreview _blockPlacePreview;
        private readonly InGameCameraController _inGameCameraController;
        private readonly SkitManager _skitManager;
        
        public GameScreenState(IBlockPlacePreview blockPlacePreview, SkitManager skitManager, InGameCameraController inGameCameraController)
        {
            _blockPlacePreview = blockPlacePreview;
            _skitManager = skitManager;
            _inGameCameraController = inGameCameraController;
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.PlayerInventory;
            if (InputManager.UI.OpenMenu.GetKeyDown) return UIStateEnum.PauseMenu;
            if (BlockClickDetect.IsClickOpenableBlock(_blockPlacePreview)) return UIStateEnum.BlockInventory;
            if (InputManager.UI.BlockDelete.GetKeyDown) return UIStateEnum.DeleteBar;
            if (_skitManager.IsPlayingSkit) return UIStateEnum.Story;
            //TODO InputSystem
            if (UnityEngine.Input.GetKeyDown(KeyCode.B)) return UIStateEnum.PlaceBlock;
            if (DebugInfoStore.EnableBlockDebugMode) return UIStateEnum.BlockDebug;
            
            return UIStateEnum.Current;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            InputManager.MouseCursorVisible(false);
            _inGameCameraController.SetControllable(true);
        }
        
        public void OnExit()
        {
            _inGameCameraController.SetControllable(false);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/PlayerMainInventoryUpdateTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.EventProtocol;
using static Server.Protocol.PacketResponse.InventoryItemMoveProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class PlayerMainInventoryUpdateTest
    {
        private const int PlayerId = 0;
        
        [Test]
        public void UpdateTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var response = packetResponse.GetPacketResponse(EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            
            //
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0);
            var itemStackFactory = ServerContext.ItemStackFactory;
            playerInventoryData.MainOpenableInventory.SetItem(5, itemStackFactory.Create(new ItemId(1), 5));
            
            //
            response = packetResponse.GetPacketResponse(EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var data = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(5, data.Slot);
            Assert.AreEqual(1, data.Item.Id.AsPrimitive());
            Assert.AreEqual(5, data.Item.Count);
            
            
            //
            //
            packetResponse.GetPacketResponse(PlayerInventoryItemMove(true, 5, 3));
            packetResponse.GetPacketResponse(PlayerInventoryItemMove(false, 4, 3));
            
            response = packetResponse.GetPacketResponse(EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            
            Assert.AreEqual(4, eventMessagePack.Events.Count);
            
            var grabUp = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            var setMainInventory = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[1].Payload);
            var outMainInventory = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[2].Payload);
            var grabDown = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(eventMessagePack.Events[3].Payload);
            
            Assert.AreEqual(5, setMainInventory.Slot); //
            Assert.AreEqual(4, outMainInventory.Slot);
            
            Assert.AreEqual(1, grabUp.Item.Id.AsPrimitive()); //ID
            Assert.AreEqual(1, setMainInventory.Item.Id.AsPrimitive());
            Assert.AreEqual(1, outMainInventory.Item.Id.AsPrimitive());
            Assert.AreEqual(0, grabDown.Item.Id.AsPrimitive());
            
            Assert.AreEqual(3, grabUp.Item.Count); //
            Assert.AreEqual(2, setMainInventory.Item.Count);
            Assert.AreEqual(3, outMainInventory.Item.Count);
            Assert.AreEqual(0, grabDown.Item.Count);
            
            
            //
            packetResponse.GetPacketResponse(PlayerInventoryItemMove(true, 4, 3));
            packetResponse.GetPacketResponse(PlayerInventoryItemMove(false, 5, 3));
            
            response = packetResponse.GetPacketResponse(EventRequestData(PlayerId));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            
            Assert.AreEqual(4, eventMessagePack.Events.Count);
            grabUp = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(eventMessagePack.Events[0].Payload);
            setMainInventory = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[1].Payload);
            outMainInventory = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(eventMessagePack.Events[2].Payload);
            grabDown = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(eventMessagePack.Events[3].Payload);
            
            Assert.AreEqual(4, setMainInventory.Slot); //
            Assert.AreEqual(5, outMainInventory.Slot);
            
            Assert.AreEqual(1, grabUp.Item.Id.AsPrimitive()); //ID
            Assert.AreEqual(0, setMainInventory.Item.Id.AsPrimitive());
            Assert.AreEqual(1, outMainInventory.Item.Id.AsPrimitive());
            Assert.AreEqual(0, grabDown.Item.Id.AsPrimitive());
            
            Assert.AreEqual(3, grabUp.Item.Count); //
            Assert.AreEqual(0, setMainInventory.Item.Count);
            Assert.AreEqual(5, outMainInventory.Item.Count);
            Assert.AreEqual(0, grabDown.Item.Count);
        }
        
        
        private List<byte> EventRequestData(int plyaerID)
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(plyaerID)).ToList();
            ;
        }
        
        private List<byte> PlayerInventoryItemMove(bool toGrab, int inventorySlot, int itemCount)
        {
            InventoryItemMoveProtocolMessagePack messagePack;
            if (toGrab)
            {
                var from = new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory);
                var to = new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory);
                messagePack = new InventoryItemMoveProtocolMessagePack(PlayerId, itemCount, ItemMoveType.SwapSlot,
                    from, inventorySlot, to, 0);
            }
            else
            {
                var from = new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory);
                var to = new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory);
                messagePack = new InventoryItemMoveProtocolMessagePack(PlayerId, itemCount, ItemMoveType.SwapSlot,
                    from, 0, to, inventorySlot);
            }
            
            return MessagePackSerializer.Serialize(messagePack).ToList();
        }
    }
}
```

schema/machineRecipes.json
```cs
{
  "$id": "machineRecipes",
  "type": "object",
  "isDefaultOpen": true,

  "properties": {

    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "MachineRecipeMasterElement",

      "items": {
        "type": "object",
        "properties": {

          "machineRecipeGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "blockGuid": {
            "type": "string",
            "format": "uuid",
            "foreignKey": "blocks:blockGuid:name"
          },
          "time": {
            "type": "number",
            "default": 1
          },
          "inputItems": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "itemGuid": {
                  "type": "string",
                  "format": "uuid",
                  "foreignKey": "items:itemGuid:name"
                },
                "count": {
                  "type": "integer",
                  "default": 1
                }
              }
            }
          },
          "outputItems": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "itemGuid": {
                  "type": "string",
                  "format": "uuid",
                  "foreignKey": "items:itemGuid:name"
                },
                "count": {
                  "type": "integer",
                  "default": 1
                },
                "percent": {
                  "type": "number",
                  "default": 1,
                  "minimum": 0,
                  "maximum": 1
                }
              }
            }
          }
        }
      }
    }
  }
}

```

moorestech_client/Assets/Scripts/Client.Game/InGame/Control/BlockClickDetect.cs
```cs
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Input;
using UnityEngine;
using UnityEngine.EventSystems;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Client.Game.InGame.Control
{
    public static class BlockClickDetect
    {
        public static bool TryGetCursorOnBlockPosition(out Vector3Int position)
        {
            position = Vector3Int.zero;
            
            if (!TryGetCursorOnBlock(out var blockObject)) return false;
            
            
            position = blockObject.BlockPosInfo.OriginalPos;
            
            return true;
        }
        
        public static bool TryGetClickBlockPosition(out Vector3Int position)
        {
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && TryGetCursorOnBlockPosition(out position)) return true;
            
            position = Vector3Int.zero;
            return false;
        }
        
        public static bool TryGetClickBlock(out BlockGameObject blockObject)
        {
            blockObject = null;
            // UI
            if (EventSystem.current.IsPointerOverGameObject()) return false;
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && TryGetCursorOnBlock(out blockObject)) return true;
            
            blockObject = null;
            return false;
        }
        
        public static bool IsClickOpenableBlock(IBlockPlacePreview blockPlacePreview)
        {
            if (blockPlacePreview.IsActive) return false; //
            if (TryGetClickBlock(out var block))
            {
                var openable = block.BlockMasterElement.BlockType is
                    BlockTypeConst.Chest or
                    BlockTypeConst.ElectricMachine or
                    BlockTypeConst.ElectricGenerator or
                    BlockTypeConst.ElectricMiner or
                    BlockTypeConst.GearMachine or
                    BlockTypeConst.GearMiner or 
                    BlockTypeConst.CraftChainerProviderChest or
                    BlockTypeConst.CraftChainerCrafter or
                    BlockTypeConst.CraftChainerMainComputer;
                return openable;
            }
            
            return false;
        }
        
        public static bool TryGetCursorOnBlock(out BlockGameObject blockObject)
        {
            blockObject = null;
            
            var camera = Camera.main;
            if (camera == null) return false;
            
            //TODO InputSystem
            var ray = camera.ScreenPointToRay(UnityEngine.Input.mousePosition);
            
            if (!Physics.Raycast(ray, out var hit, 100, LayerConst.BlockOnlyLayerMask)) return false;
            var child = hit.collider.gameObject.GetComponent<BlockGameObjectChild>();
            if (child is null) return false;
            
            
            blockObject = child.BlockGameObject;
            
            return true;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/PacketExchangeManager.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Cysharp.Threading.Tasks;
using JetBrains.Annotations;
using MessagePack;
using Server.Protocol;
using UniRx;
using UnityEngine;

namespace Client.Network.API
{
    /// <summary>
    ///     <see cref="ServerCommunicator" />
    /// </summary>
    public class PacketExchangeManager
    {
        private readonly PacketSender _packetSender;
        
        private readonly Dictionary<int, ResponseWaiter> _responseWaiters = new();
        
        private int _sequenceId;
        
        public PacketExchangeManager(PacketSender packetSender)
        {
            _packetSender = packetSender;
            TimeOutUpdate().Forget();
        }
        
        private async UniTask TimeOutUpdate()
        {
            while (true)
            {
                for (var i = _responseWaiters.Count - 1; i >= 0; i--)
                {
                    var sequenceId = _responseWaiters.Keys.ElementAt(i);
                    var waiter = _responseWaiters[sequenceId];
                    var time = DateTime.Now - waiter.SendTime;
                    if (time.TotalSeconds < 10) continue;
                    
                    _responseWaiters[sequenceId].WaitSubject.OnNext(null);
                    _responseWaiters.Remove(sequenceId);
                }
                
                await UniTask.Delay(1000);
            }
        }
        
        public async UniTask ExchangeReceivedPacket(List<byte> data)
        {
            var response = MessagePackSerializer.Deserialize<ProtocolMessagePackBase>(data.ToArray());
            var sequence = response.SequenceId;
            
            await UniTask.SwitchToMainThread();
            
            if (!_responseWaiters.ContainsKey(sequence)) return;
            _responseWaiters[sequence].WaitSubject.OnNext(data);
            _responseWaiters.Remove(sequence);
        }
        
        [CanBeNull]
        public async UniTask<TResponse> GetPacketResponse<TResponse>(ProtocolMessagePackBase request, CancellationToken ct) where TResponse : ProtocolMessagePackBase
        {
            SendPacket();
            
            return await WaitReceive();
            
            #region Internal
            
            void SendPacket()
            {
                _sequenceId++;
                request.SequenceId = _sequenceId;
                _packetSender.Send(request);
            }
            
            async UniTask<TResponse> WaitReceive()
            {
                var responseWaiter = new ResponseWaiter(new Subject<List<byte>>());
                _responseWaiters.Add(_sequenceId, responseWaiter);
                
                var receiveData = await responseWaiter.WaitSubject.ToUniTask(true, ct);
                if (receiveData == null)
                {
                    Debug.Log("Receive null");
                    return null;
                }
                
                try
                {
                    return MessagePackSerializer.Deserialize<TResponse>(receiveData.ToArray());
                }
                catch (Exception e)
                {
                    Debug.LogError($"Tag:{request.Tag}\n{e.Message}\n{e.StackTrace}");
                    Console.WriteLine(e);
                    return null;
                }
            }
            
            #endregion
        }
    }
    
    
    public class ResponseWaiter
    {
        public ResponseWaiter(Subject<List<byte>> waitSubject)
        {
            WaitSubject = waitSubject;
            SendTime = DateTime.Now;
        }
        
        public Subject<List<byte>> WaitSubject { get; }
        public DateTime SendTime { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockComponentManager.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface.Component;
using Game.Block.Interface.ComponentAttribute;

namespace Game.Block.Interface
{
    public interface IBlockComponentManager
    {
        public T GetComponent<T>() where T : IBlockComponent;
        public List<T> GetComponents<T>() where T : IBlockComponent;
        
        public bool ExistsComponent<T>() where T : IBlockComponent;
        
        public bool TryGetComponent<T>(out T component) where T : IBlockComponent;
    }
    
    public class BlockComponentManager : IBlockComponentManager
    {
        private readonly List<IBlockComponent> _blockComponents = new();
        private bool IsDestroy { get; set; }
        
        public T GetComponent<T>() where T : IBlockComponent
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            return (T)_blockComponents.Find(x => x is T);
        }
        
        public List<T> GetComponents<T>() where T : IBlockComponent
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            return _blockComponents.FindAll(x => x is T).Cast<T>().ToList();
        }
        
        public bool ExistsComponent<T>() where T : IBlockComponent
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            return _blockComponents.Exists(x => x is T);
        }
        
        public bool TryGetComponent<T>(out T component) where T : IBlockComponent
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            var result = _blockComponents.Find(x => x is T);
            if (result == null)
            {
                component = default;
                return false;
            }
            
            component = (T)result;
            return true;
        }
        
        public void Destroy()
        {
            IsDestroy = true;
            foreach (var blockComponent in _blockComponents) blockComponent.Destroy();
        }
        
        public void AddComponent(IBlockComponent blockComponent)
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            CheckDisallowMultiple();
            
            _blockComponents.Add(blockComponent);
            
            #region Internal
            
            void CheckDisallowMultiple()
            {
                var componentType = blockComponent.GetType();
                var interfaces = componentType.GetInterfaces();
                
                foreach (var iface in interfaces)
                {
                    var attrs = iface.GetCustomAttributes(typeof(DisallowMultiple), true);
                    if (attrs.Length == 0) continue;
                    
                    if (_blockComponents.Any(c => iface.IsInstanceOfType(c)))
                    {
                        throw new InvalidOperationException($"{iface.Name}");
                    }
                }
            }
            
            #endregion
        }
        
        public void AddComponents(IEnumerable<IBlockComponent> blockComponents)
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            foreach (var blockComponent in blockComponents) AddComponent(blockComponent);
        }
        
        public void RemoveComponent(IBlockComponent blockComponent)
        {
            if (IsDestroy) throw new InvalidOperationException("Block is already destroyed");
            
            _blockComponents.Remove(blockComponent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearNetworkId.cs
```cs
using System;
using UnitGenerator;

namespace Game.Gear.Common
{
    [UnitOf(typeof(int))]
    public readonly partial struct GearNetworkId
    {
        private static readonly Random Random = new(123456);
        
        public static GearNetworkId CreateNetworkId()
        {
            // int
            return new GearNetworkId(Random.Next(int.MinValue, int.MaxValue));
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetPlayerCoordinateProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.Entity.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     
    /// </summary>
    public class SetPlayerCoordinateProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:playerCoordinate";
        
        private readonly IEntitiesDatastore _entitiesDatastore;
        
        public SetPlayerCoordinateProtocol(ServiceProvider serviceProvider)
        {
            _entitiesDatastore = serviceProvider.GetService<IEntitiesDatastore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<PlayerCoordinateSendProtocolMessagePack>(payload.ToArray());
            
            //
            _entitiesDatastore.SetPosition(new EntityInstanceId(data.PlayerId), data.Pos.Vector3);
            
            return null;
        }
        
        
        [MessagePackObject]
        public class PlayerCoordinateSendProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public Vector3MessagePack Pos { get; set; }
            
            public PlayerCoordinateSendProtocolMessagePack(int playerId, Vector3 pos)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Pos = new Vector3MessagePack(pos);
            }
            
            [Obsolete("")]
            public PlayerCoordinateSendProtocolMessagePack() { }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/GameDebug/DebugParameters.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Client.Game.GameDebug
{
    /// <summary>
    /// 
    /// </summary>
    public static class DebugParameters
    {
        static DebugParameters()
        {
            Load();
        }
        
        public static Dictionary<string, bool> BoolDebugParameters { get; private set; } = new();
        public static Dictionary<string, int> IntDebugParameters { get; private set; } = new();
        public static Dictionary<string, string> StringDebugParameters { get; private set; } = new();

        #region Public Accessors

        public static bool GetBool(string key, bool defaultValue)
        {
            return BoolDebugParameters.GetValueOrDefault(key, defaultValue);
        }

        public static void SaveBool(string key, bool value)
        {
            BoolDebugParameters[key] = value;
            Save();
        }

        public static int GetInt(string key, int defaultValue)
        {
            return IntDebugParameters.GetValueOrDefault(key, defaultValue);
        }

        public static void SaveInt(string key, int value)
        {
            IntDebugParameters[key] = value;
            Save();
        }

        public static string GetString(string key, string defaultValue)
        {
            return StringDebugParameters.GetValueOrDefault(key, defaultValue);
        }

        public static void SaveString(string key, string value)
        {
            StringDebugParameters[key] = value;
            Save();
        }

        #endregion

        #region Save / Load
        
        public const string BoolDebugParametersKey = "DebugParameters_Bool";
        public const string IntDebugParametersKey = "DebugParameters_Int";
        public const string StringDebugParametersKey = "DebugParameters_String";

        /// <summary>
        ///  PlayerPrefs 
        /// </summary>
        private static void Save()
        {
            // bool
            var boolDict = new SerializableDictionary<string, bool>(BoolDebugParameters);
            string boolJson = JsonUtility.ToJson(boolDict);
            PlayerPrefs.SetString(BoolDebugParametersKey, boolJson);

            // int
            var intDict = new SerializableDictionary<string, int>(IntDebugParameters);
            string intJson = JsonUtility.ToJson(intDict);
            PlayerPrefs.SetString(IntDebugParametersKey, intJson);

            // string
            var stringDict = new SerializableDictionary<string, string>(StringDebugParameters);
            string stringJson = JsonUtility.ToJson(stringDict);
            PlayerPrefs.SetString(StringDebugParametersKey, stringJson);

            PlayerPrefs.Save();
        }

        /// <summary>
        ///  PlayerPrefs 
        /// </summary>
        private static void Load()
        {
            // bool
            string boolJson = PlayerPrefs.GetString(BoolDebugParametersKey, "");
            if (!string.IsNullOrEmpty(boolJson))
            {
                var boolDict = JsonUtility.FromJson<SerializableDictionary<string, bool>>(boolJson);
                if (boolDict != null)
                {
                    BoolDebugParameters = boolDict.ToDictionary();
                }
            }

            // int
            string intJson = PlayerPrefs.GetString(IntDebugParametersKey, "");
            if (!string.IsNullOrEmpty(intJson))
            {
                var intDict = JsonUtility.FromJson<SerializableDictionary<string, int>>(intJson);
                if (intDict != null)
                {
                    IntDebugParameters = intDict.ToDictionary();
                }
            }

            // string
            string stringJson = PlayerPrefs.GetString(StringDebugParametersKey, "");
            if (!string.IsNullOrEmpty(stringJson))
            {
                var stringDict = JsonUtility.FromJson<SerializableDictionary<string, string>>(stringJson);
                if (stringDict != null)
                {
                    StringDebugParameters = stringDict.ToDictionary();
                }
            }
        }

        #endregion
    }

    /// <summary>
    /// Dictionary  JSON 
    /// </summary>
    /// <typeparam name="TKey"></typeparam>
    /// <typeparam name="TValue"></typeparam>
    [Serializable]
    public class SerializableDictionary<TKey, TValue> : ISerializationCallbackReceiver
    {
        [SerializeField]
        private List<TKey> keys = new();

        [SerializeField]
        private List<TValue> values = new();

        //  Dictionary  keys/values 
        private Dictionary<TKey, TValue> dictionary = new();

        public SerializableDictionary() { }

        public SerializableDictionary(Dictionary<TKey, TValue> dict)
        {
            dictionary = dict;
        }

        /// <summary>
        /// Dictionary 
        /// </summary>
        public Dictionary<TKey, TValue> ToDictionary()
        {
            return dictionary;
        }

        #region ISerializationCallbackReceiver implements

        public void OnBeforeSerialize()
        {
            // JSON Dictionary  keys/values 
            keys.Clear();
            values.Clear();

            foreach (var kvp in dictionary)
            {
                keys.Add(kvp.Key);
                values.Add(kvp.Value);
            }
        }

        public void OnAfterDeserialize()
        {
            // JSON keys/values  Dictionary 
            dictionary = new Dictionary<TKey, TValue>();
            for (int i = 0; i < Mathf.Min(keys.Count, values.Count); i++)
            {
                dictionary[keys[i]] = values[i];
            }
        }

        #endregion
    }
}

```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/LocalPlayerInventoryController.cs
```cs
using System;
using Client.Game.InGame.Context;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;

namespace Client.Game.InGame.UI.Inventory.Main
{
    public class LocalPlayerInventoryController
    {
        public ILocalPlayerInventory LocalPlayerInventory => _mainAndSubCombine;
        public IItemStack GrabInventory { get; private set; }
        
        private readonly LocalPlayerInventory _mainAndSubCombine;
        private ISubInventory _subInventory;
        
        public LocalPlayerInventoryController(ILocalPlayerInventory localPlayerInventoryMainAndSubCombine)
        {
            _mainAndSubCombine = (LocalPlayerInventory)localPlayerInventoryMainAndSubCombine;
            GrabInventory = ServerContext.ItemStackFactory.Create(new ItemId(0), 0);
        }
        
        public void MoveItem(LocalMoveInventoryType from, int fromSlot, LocalMoveInventoryType to, int toSlot, int count, bool isMoveSendData = true)
        {
            var fromInvItem = from switch
            {
                LocalMoveInventoryType.MainOrSub => LocalPlayerInventory[fromSlot],
                LocalMoveInventoryType.Grab => GrabInventory,
                _ => throw new ArgumentOutOfRangeException(nameof(from), from, null),
            };
            
            if (fromInvItem.Count < count) return;
            
            SetInventory();
            
            if (isMoveSendData) SendMoveItemData();
            
            #region InternalMethod
            
            void SetInventory()
            {
                var itemStackFactory = ServerContext.ItemStackFactory;
                
                var toInvItem = to switch
                {
                    LocalMoveInventoryType.MainOrSub => LocalPlayerInventory[toSlot],
                    LocalMoveInventoryType.Grab => GrabInventory,
                    _ => throw new ArgumentOutOfRangeException(nameof(to), to, null),
                };
                var moveItem = itemStackFactory.Create(fromInvItem.Id, count);
                
                var add = toInvItem.AddItem(moveItem);
                switch (to)
                {
                    case LocalMoveInventoryType.MainOrSub:
                        _mainAndSubCombine[toSlot] = add.ProcessResultItemStack;
                        break;
                    case LocalMoveInventoryType.Grab:
                        GrabInventory = add.ProcessResultItemStack;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(to), to, null);
                }
                
                var fromItemCount = fromInvItem.Count - count + add.RemainderItemStack.Count;
                var fromItem = itemStackFactory.Create(fromInvItem.Id, fromItemCount);
                switch (from)
                {
                    case LocalMoveInventoryType.Grab:
                        GrabInventory = fromItem;
                        break;
                    default:
                        _mainAndSubCombine[fromSlot] = fromItem;
                        break;
                }
            }
            
            void SendMoveItemData()
            {
                var fromInfo = GetServerInventoryInfo(from, fromSlot);
                var toInfo = GetServerInventoryInfo(to, toSlot);
                ClientContext.VanillaApi.SendOnly.ItemMove(count, ItemMoveType.SwapSlot, fromInfo, fromSlot, toInfo, toSlot);
            }
            
            ItemMoveInventoryInfo GetServerInventoryInfo(LocalMoveInventoryType localType, int localSlot)
            {
                return localType switch
                {
                    LocalMoveInventoryType.MainOrSub => localSlot < PlayerInventoryConst.MainInventorySize ? new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory) : _subInventory.ItemMoveInventoryInfo,
                    LocalMoveInventoryType.Grab => new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory),
                    _ => throw new ArgumentOutOfRangeException(nameof(localType), localType, null),
                };
            }
            
            #endregion
        }
        
        public void SetGrabItem(IItemStack itemStack)
        {
            GrabInventory = itemStack;
        }
        
        public void SetMainItem(int slot, IItemStack itemStack)
        {
            _mainAndSubCombine[slot] = itemStack;
        }
        
        public void SetSubInventory(ISubInventory subInventory)
        {
            _mainAndSubCombine.SetSubInventory(subInventory);
            _subInventory = subInventory;
        }
    }
    
    public enum LocalMoveInventoryType
    {
        MainOrSub, //
        Grab, //
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/PlayerInventoryResponseProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;

namespace Server.Protocol.PacketResponse
{
    public class PlayerInventoryResponseProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:playerInvRequest";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public PlayerInventoryResponseProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<PlayerInventoryResponseProtocolMessagePack>(payload.ToArray());
            
            var playerInventory = _playerInventoryDataStore.GetInventoryData(data.PlayerId);
            
            //
            var mainItems = new List<ItemMessagePack>();
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var id = playerInventory.MainOpenableInventory.GetItem(i).Id;
                var count = playerInventory.MainOpenableInventory.GetItem(i).Count;
                mainItems.Add(new ItemMessagePack(id, count));
            }
            
            //
            var grabItem = new ItemMessagePack(
                playerInventory.GrabInventory.GetItem(0).Id,
                playerInventory.GrabInventory.GetItem(0).Count);
            
            
            return new PlayerInventoryResponseProtocolMessagePack(data.PlayerId, mainItems.ToArray(), grabItem);
        }
        
        [MessagePackObject]
        public class RequestPlayerInventoryProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Obsolete("")]
            public RequestPlayerInventoryProtocolMessagePack() { }
            
            public RequestPlayerInventoryProtocolMessagePack(int playerId)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
            }
        }
        
        [MessagePackObject]
        public class PlayerInventoryResponseProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public ItemMessagePack[] Main { get; set; }
            [Key(4)] public ItemMessagePack Grab { get; set; }
            
            
            [Obsolete("")]
            public PlayerInventoryResponseProtocolMessagePack() { }
            
            public PlayerInventoryResponseProtocolMessagePack(int playerId, ItemMessagePack[] main, ItemMessagePack grab)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Main = main;
                Grab = grab;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/CraftRecipeMaster.cs
```cs
using System;
using Mooresmaster.Loader.CraftRecipesModule;
using Mooresmaster.Model.CraftRecipesModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class CraftRecipeMaster
    {
        public readonly CraftRecipes CraftRecipes;
        
        public CraftRecipeMaster(JToken craftRecipeJToken)
        {
            CraftRecipes = CraftRecipesLoader.Load(craftRecipeJToken);
        }
        
        public CraftRecipeMasterElement GetCraftRecipe(Guid guid)
        {
            return Array.Find(CraftRecipes.Data, x => x.CraftRecipeGuid == guid);
        }
        
        public CraftRecipeMasterElement[] GetResultItemCraftRecipes(ItemId itemId)
        {
            var itemGuid = MasterHolder.ItemMaster.GetItemMaster(itemId).ItemGuid;
            return Array.FindAll(CraftRecipes.Data, x => x.CraftResultItemGuid == itemGuid);
        }
        
        public CraftRecipeMasterElement[] GetAllCraftRecipes()
        {
            return CraftRecipes.Data;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/BlockRemoveEventPacketTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    /// <summary>
    ///     
    /// </summary>
    public class BlockRemoveEventPacketTest
    {
        [Test]
        public void RemoveBlockEvent()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            //ID
            List<List<byte>> response = packetResponse.GetPacketResponse(EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
            var worldBlock = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            //
            BlockPlace(4, 0, 1, worldBlock, blockFactory);
            BlockPlace(3, 1, 2, worldBlock, blockFactory);
            BlockPlace(2, 3, 3, worldBlock, blockFactory);
            BlockPlace(1, 4, 4, worldBlock, blockFactory);
            
            //
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(4, eventMessagePack.Events.Count);
            
            var worldDataStore = ServerContext.WorldBlockDatastore;
            //
            worldDataStore.RemoveBlock(new Vector3Int(4, 0));
            
            //
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            
            Assert.AreEqual(1, eventMessagePack.Events.Count);
            var pos = AnalysisResponsePacket(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(4, pos.x);
            Assert.AreEqual(0, pos.y);
            
            //
            worldDataStore.RemoveBlock(new Vector3Int(3, 1));
            worldDataStore.RemoveBlock(new Vector3Int(1, 4));
            //
            response = packetResponse.GetPacketResponse(EventRequestData(0));
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(2, eventMessagePack.Events.Count);
            pos = AnalysisResponsePacket(eventMessagePack.Events[0].Payload);
            Assert.AreEqual(3, pos.x);
            Assert.AreEqual(1, pos.y);
            pos = AnalysisResponsePacket(eventMessagePack.Events[1].Payload);
            Assert.AreEqual(1, pos.x);
            Assert.AreEqual(4, pos.y);
        }
        
        private void BlockPlace(int x, int y, int id, IWorldBlockDatastore worldBlockDatastore, IBlockFactory blockFactory)
        {
            worldBlockDatastore.TryAddBlock((BlockId)id, new Vector3Int(x, y), BlockDirection.North, out _);
        }
        
        private List<byte> EventRequestData(int playerID)
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(playerID)).ToList();
        }
        
        private Vector3Int AnalysisResponsePacket(byte[] payload)
        {
            var data = MessagePackSerializer.Deserialize<RemoveBlockEventMessagePack>(payload.ToArray());
            
            return data.Position;
        }
    }
}
```

schema/blocks.json
```cs
{
  "$id": "blocks",
  "type": "object",
  "isDefaultOpen": true,


  "defineInterface": [
      {
          "interfaceName": "IMachineParam",
          "properties": {
              "inputSlotCount": {
                  "type": "integer"
              },
              "outputSlotCount": {
                  "type": "integer"
              }
          }
      }
  ],


  "properties": {

    "data": {
      "type": "array",
      "overrideCodeGeneratePropertyName": "BlockMasterElement",

      "items": {
        "type": "object",

        "properties": {
          "blockGuid": {
            "type": "string",
            "format": "uuid",
            "autoGenerated": true
          },

          "name": {
            "type": "string"
          },

          "blockType": {
            "type": "string",
            "enum": [
              "Block","BeltConveyor","Chest",
              "ElectricMachine","ElectricPole","ElectricGenerator","ElectricMiner",

              "Gear","Shaft","GearMachine","SimpleGearGenerator","GearBeltConveyor","GearMiner",
              "ItemShooter",
              "CraftChainerTransporter", "CraftChainerCrafter", "CraftChainerProviderChest", "CraftChainerMainComputer",
              "TrainRail", "TrainStation", "TrainCargoPlatform"
            ]
          },

          "itemGuid": {
            "type": "string",
            "format": "uuid",
            "foreignKey": "items:itemGuid:name"
          },
          "blockSize": {
            "type": "array",
            "pattern": "@vector3Int",
            "items": {
              "type": "integer"
            },
            "default": [1,1,1]
          },

          "blockPrefabAddressablesPath": {
            "type": "string",
            "optional": true
          },

          "blockUIAddressablesPath": {
            "type": "string",
            "optional": true
          },

          "blockParam": {
            "oneOf": [
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "Block"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {}
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "BeltConveyor"
                    }
                  }
                },
                "then": {
                  "type": "object",

                  "properties": {
                    "beltConveyorItemCount": {"type": "integer", "default": 1},
                    "timeOfItemEnterToExit": {"type": "number", "default": 1},
                    "slopeType": {"type": "string", "enum": ["Straight", "Up", "Down"] },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "Chest"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "chestItemSlotCount": {"type": "integer", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ElectricMachine"
                    }
                  }
                },
                "then": {

                  "implementationInterface": [
                    "IMachineParam"
                  ],

                  "type": "object",
                  "properties": {

                    "inputSlotCount": { "type": "integer", "default": 1 },
                    "outputSlotCount": { "type": "integer", "default": 1 },
                    
                    "requiredPower": {"type": "number", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ElectricPole"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "poleConnectionRange": {"type": "integer", "default": 5},
                    "machineConnectionRange": {"type": "integer", "default": 5}
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ElectricGenerator"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "fuelItemSlotCount": {"type": "integer", "default": 3},

                    "isInfinityPower": {"type": "boolean", "default": false},
                    "infinityPower": {"type": "integer", "default": 0},

                    "fuelItems": {
                      "type": "array",
                      "optional": true,
                      "items": {
                        "type": "object",
                        "properties": {
                          "itemGuid": {
                            "type": "string",
                            "format": "uuid",
                            "foreignKey": "items:itemGuid:name"
                          },

                          "time": {
                            "type": "number",
                            "default": 1
                          },
                          "power": {
                            "type": "number",
                            "default": 10
                          }
                        }
                      }
                    },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ElectricMiner"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "requiredPower": {"type": "number", "default": 5},
                    "outputItemSlotCount": {"type": "integer", "default": 3},
                    "mineSettings": {
                      "$ref": "mineSettings"
                    },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "Gear"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "teethCount": {"type": "integer", "default": 10},
                    "requireTorque": {"type": "number", "default": 1},
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "Shaft"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "requireTorque": {"type": "number", "default": 1},
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "GearMachine"
                    }
                  }
                },
                "then": {

                  "implementationInterface": [
                    "IMachineParam"
                  ],

                  "type": "object",
                  "properties": {

                    "inputSlotCount": { "type": "integer", "default": 1 },
                    "outputSlotCount": { "type": "integer", "default": 1 },
                    
                    "teethCount": {"type": "integer", "default": 10},
                    "requireTorque": {"type": "number", "default": 1},
                    "requiredRpm": {"type": "number", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    },
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "SimpleGearGenerator"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "teethCount": {"type": "integer", "default": 10},
                    "generateRpm": {"type": "number", "default": 5},
                    "generateTorque": {"type": "number", "default": 1},
                    "requireTorque": {"type": "number", "default": 1},
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "GearBeltConveyor"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "beltConveyorItemCount": {"type": "integer", "default": 4},
                    "beltConveyorSpeed": {"type": "number", "default": 2},
                    "requireTorque": {"type": "number", "default": 2},
                    "slopeType": {"type": "string", "enum": ["Straight", "Up", "Down"] },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    },
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "ItemShooter"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "inventoryItemNum": {"type": "integer", "default": 4},
                    "initialShootSpeed": {"type": "number", "default": 3},
                    "itemShootSpeed": {"type": "number", "default": 2},
                    "acceleration": {"type": "number", "default": 1},
                    "slopeType": {"type": "string", "enum": ["Straight", "Up", "Down"] },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "GearMiner"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    "teethCount": {"type": "integer", "default": 10},
                    "requireTorque": {"type": "number", "default": 1},
                    "requiredRpm": {"type": "number", "default": 5},
                    
                    "outputItemSlotCount": {"type": "integer", "default": 3},
                    
                    "mineSettings": {
                      "$ref": "mineSettings"
                    },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    },
                    
                    "gear": {
                      "$ref": "gear"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "CraftChainerTransporter"
                    }
                  }
                },
                "then": {
                  "type": "object",

                  "properties": {
                    "transporterConveyorItemCount": {"type": "integer", "default": 1},
                    "timeOfItemEnterToExit": {"type": "number", "default": 1},
                    "slopeType": {"type": "string", "enum": ["Straight", "Up", "Down"] },
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "CraftChainerCrafter"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {
                    
                    "itemSlotCount": {"type": "integer", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }
                    
                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "CraftChainerProviderChest"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "itemSlotCount": {"type": "integer", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }

                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "CraftChainerMainComputer"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "itemSlotCount": {"type": "integer", "default": 5},
                    "inventoryConnectors": {
                      "$ref": "inventoryConnects"
                    }

                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "TrainRail"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": { }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "TrainStation"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "stationDistance": {"type": "integer", "default": 5}

                  }
                }
              },
              {
                "if": {
                  "properties": {
                    "blockType": {
                      "const": "TrainCargoPlatform"
                    }
                  }
                },
                "then": {
                  "type": "object",
                  "properties": {

                    "platformDistance": {"type": "integer", "default": 5},
                    
                    "inputSlotCount": { "type": "integer", "default": 10 },
                    "outputSlotCount": { "type": "integer", "default": 10 },

                    "loadingSpeed":  { "type": "number", "default": 20 }

                  }
                }
              }
            ]
          },

          "overrideVerticalBlock": {
            "type": "object",
            "optional": true,

            "properties": {

              "upBlockGuid" : {
                "type": "string",
                "format": "uuid",
                "foreignKey": "blocks:blockGuid:name"
              },
              "horizontalBlockGuid" : {
                "type": "string",
                "format": "uuid",
                "foreignKey": "blocks:blockGuid:name"
              },
              "downBlockGuid" : {
                "type": "string",
                "format": "uuid",
                "foreignKey": "blocks:blockGuid:name"
              }

            }

          }
        }
      }
    }
  }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/BlockDirection.cs
```cs
using System;
using UnityEngine;

namespace Game.Block.Interface
{
    /// <summary>
    ///     34
    ///     UpNorth
    ///     DownNorth
    /// </summary>
    public enum BlockDirection
    {
        UpNorth,
        UpEast,
        UpSouth,
        UpWest,
        
        North,
        East,
        South,
        West,
        
        DownNorth,
        DownEast,
        DownSouth,
        DownWest,
    }
    
    public delegate Vector3Int BlockPosConvertAction(Vector3Int pos);
    
    public static class BlockDirectionExtension
    {
        public static Quaternion GetRotation(this BlockDirection direction)
        {
            switch (direction)
            {
                case BlockDirection.UpNorth:
                    return Quaternion.Euler(-90, 0, 0);
                case BlockDirection.UpEast:
                    return Quaternion.Euler(-90, 0, 90);
                case BlockDirection.UpSouth:
                    return Quaternion.Euler(-90, 0, 180);
                case BlockDirection.UpWest:
                    return Quaternion.Euler(-90, 0, 270);
                
                case BlockDirection.North:
                    return Quaternion.Euler(0, 0, 0);
                case BlockDirection.East:
                    return Quaternion.Euler(0, 90, 0);
                case BlockDirection.South:
                    return Quaternion.Euler(0, 180, 0);
                case BlockDirection.West:
                    return Quaternion.Euler(0, 270, 0);
                
                case BlockDirection.DownNorth:
                    return Quaternion.Euler(90, 0, 180);
                case BlockDirection.DownEast:
                    return Quaternion.Euler(90, 0, 90);
                case BlockDirection.DownSouth:
                    return Quaternion.Euler(90, 0, 0);
                case BlockDirection.DownWest:
                    return Quaternion.Euler(90, 0, 270);
                
                default:
                    throw new ArgumentOutOfRangeException(nameof(direction), direction, null);
            }
        }
        
        public static BlockPosConvertAction GetCoordinateConvertAction(this BlockDirection blockDirection)
        {
            var rotation = blockDirection.GetRotation();
            var rotationMatrix = Matrix4x4.Rotate(rotation);
            
            // 
            return pos =>
            {
                //  float4  float4  pos 
                var transformed = rotationMatrix.MultiplyPoint3x4(pos);
                //  Vector3Int 
                return Vector3Int.RoundToInt(transformed);
            };
        }
        
        /// <summary>
        /// 
        /// When the block is rotating, return the world position of the reference coordinate in the block's local coordinate system.
        /// </summary>
        public static Vector3Int GetBlockBaseOriginPos(this BlockDirection blockDirection, BlockPositionInfo blockPositionInfo)
        {
            var pos = blockPositionInfo.OriginalPos;
            var size = blockPositionInfo.BlockSize;
            
            var minus = blockDirection.GetBlockDirectionOffset() * Vector3Int.one;
            var originPos = blockDirection.GetBlockModelOriginPos(pos, size);
            
            return originPos - minus;
        }
        
        
        public static Vector3Int GetBlockModelOriginPos(this BlockDirection blockDirection, Vector3Int pos, Vector3Int size)
        {
            var addPos = blockDirection.GetBlockDirectionOffset() * size;
            
            return pos + addPos;
        }
        
        public static Vector3Int GetBlockDirectionOffset(this BlockDirection blockDirection)
        {
            return blockDirection switch
            {
                BlockDirection.UpNorth => new Vector3Int(0, 0, 1),
                BlockDirection.UpEast => new Vector3Int(1, 0, 1),
                BlockDirection.UpSouth => new Vector3Int(1, 0, 1),
                BlockDirection.UpWest => new Vector3Int(0, 0, 1),
                BlockDirection.North => new Vector3Int(0, 0, 0),
                BlockDirection.East => new Vector3Int(0, 0, 1),
                BlockDirection.South => new Vector3Int(1, 0, 1),
                BlockDirection.West => new Vector3Int(1, 0, 0),
                BlockDirection.DownNorth => new Vector3Int(1, 1, 1),
                BlockDirection.DownEast => new Vector3Int(1, 1, 0),
                BlockDirection.DownSouth => new Vector3Int(0, 1, 0),
                BlockDirection.DownWest => new Vector3Int(0, 1, 1),
                _ => Vector3Int.zero
            };
        }
        
        public static BlockDirection HorizonRotation(this BlockDirection blockDirection)
        {
            return blockDirection switch
            {
                BlockDirection.UpNorth => BlockDirection.UpEast,
                BlockDirection.UpEast => BlockDirection.UpSouth,
                BlockDirection.UpSouth => BlockDirection.UpWest,
                BlockDirection.UpWest => BlockDirection.UpNorth,
                
                BlockDirection.North => BlockDirection.East,
                BlockDirection.East => BlockDirection.South,
                BlockDirection.South => BlockDirection.West,
                BlockDirection.West => BlockDirection.North,
                
                BlockDirection.DownNorth => BlockDirection.DownEast,
                BlockDirection.DownEast => BlockDirection.DownSouth,
                BlockDirection.DownSouth => BlockDirection.DownWest,
                BlockDirection.DownWest => BlockDirection.DownNorth,
                
                _ => blockDirection
            };
        }
        
        public static BlockDirection VerticalRotation(this BlockDirection blockDirection)
        {
            return blockDirection switch
            {
                BlockDirection.UpNorth => BlockDirection.DownNorth,
                BlockDirection.UpEast => BlockDirection.DownEast,
                BlockDirection.UpSouth => BlockDirection.DownSouth,
                BlockDirection.UpWest => BlockDirection.DownWest,
                
                BlockDirection.North => BlockDirection.UpNorth,
                BlockDirection.East => BlockDirection.UpEast,
                BlockDirection.South => BlockDirection.UpSouth,
                BlockDirection.West => BlockDirection.UpWest,
                
                BlockDirection.DownNorth => BlockDirection.North,
                BlockDirection.DownEast => BlockDirection.East,
                BlockDirection.DownSouth => BlockDirection.South,
                BlockDirection.DownWest => BlockDirection.West,
                
                _ => blockDirection
            };
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/ChallengeCompletedEventTest.cs
```cs
using System;
using System.Linq;
using Core.Master;
using Core.Update;
using Game.Block.Interface;
using Game.Challenge;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;
using static Server.Protocol.PacketResponse.OneClickCraft;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class ChallengeCompletedEventTest
    {
        private const int PlayerId = 0;
        private const int CraftRecipeId = 1;
        
        [Test]
        // 
        // Test to ensure that the item is created and that the challenge receives a completed event
        public void CreateItemChallengeClearTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
         
            ClearCraftChallenge(packet,serviceProvider);
            
            // 
            // Receive and test the event
            var response = packet.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var challengeCompleted = eventMessagePack.Events.First(e => e.Tag == CompletedChallengeEventPacket.EventTag);
            var completedChallenge = MessagePackSerializer.Deserialize<CompletedChallengeEventMessage>(challengeCompleted.Payload);
            
            var challengeId = new Guid("00000000-0000-0000-4567-000000000001");
            Assert.AreEqual(challengeId, completedChallenge.CompletedChallengeGuid);
        }
        
        public static void ClearCraftChallenge(PacketResponseCreator packet, ServiceProvider serviceProvider)
        {
            // 
            // Add crafting materials to the inventory
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var craftRecipeElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            foreach (var requiredItem in craftRecipeElement.RequiredItems)
            {
                var item = ServerContext.ItemStackFactory.Create(requiredItem.ItemGuid, requiredItem.Count);
                playerInventoryData.MainOpenableInventory.InsertItem(item);
            }
            
            // 
            // Execute the craft
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftRecipeElement.CraftRecipeGuid)).ToList());
        }
        
        [Test]
        // 
        // Test to ensure that the challenge receives a completed event when an item is in the inventory
        public void InInventoryChallengeClearTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            // 
            const int itemId = 1;
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var item1 = ServerContext.ItemStackFactory.Create(new ItemId(itemId), 2);
            playerInventoryData.MainOpenableInventory.SetItem(1, item1);
            var item2 = ServerContext.ItemStackFactory.Create(new ItemId(itemId), 1);
            playerInventoryData.MainOpenableInventory.SetItem(2, item2);
            
            // 
            GameUpdater.UpdateWithWait();
            
            // 
            // Receive and test the event
            var response = packet.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var challengeCompleted = eventMessagePack.Events.First(e => e.Tag == CompletedChallengeEventPacket.EventTag);
            var completedChallenge = MessagePackSerializer.Deserialize<CompletedChallengeEventMessage>(challengeCompleted.Payload);
            
            var challengeId = new Guid("00000000-0000-0000-4567-000000000002");
            Assert.AreEqual(challengeId, completedChallenge.CompletedChallengeGuid);
        }
        
        [Test]
        public void BlockPlaceChallengeClearTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            // 
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0,0,0), BlockDirection.East, out _);
            
            // 
            // Receive and test the event
            var response = packet.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var challengeCompleted = eventMessagePack.Events.First(e => e.Tag == CompletedChallengeEventPacket.EventTag);
            var completedChallenge = MessagePackSerializer.Deserialize<CompletedChallengeEventMessage>(challengeCompleted.Payload);
            
            var challengeId = new Guid("00000000-0000-0000-4567-000000000003");
            Assert.AreEqual(challengeId, completedChallenge.CompletedChallengeGuid);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/AutoSaveSystem.cs
```cs
using System;
using System.Threading;
using System.Threading.Tasks;
using Game.SaveLoad.Interface;

namespace Server.Boot
{
    public class AutoSaveSystem
    {
        private readonly IWorldSaveDataSaver _worldSaveDataSaver;
        
        public AutoSaveSystem(IWorldSaveDataSaver worldSaveDataSaver)
        {
            _worldSaveDataSaver = worldSaveDataSaver;
        }
        
        public async Task AutoSave(CancellationTokenSource cancellationTokenSource)
        {
            cancellationTokenSource.Token.ThrowIfCancellationRequested();
            while (true)
            {
                await Task.Delay(TimeSpan.FromSeconds(30));
                _worldSaveDataSaver.Save();
                if (cancellationTokenSource.Token.IsCancellationRequested) break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/IGearEnergyTransformer.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlockConnectInfoModule;

namespace Game.Gear.Common
{
    public interface IGearEnergyTransformer : IBlockComponent
    {
        public const string WorkingStateName = "Working";
        public const string RockedStateName = "Rocked";
        
        public BlockInstanceId BlockInstanceId { get; }
        
        public bool IsRocked { get; }
        
        public GearPower CurrentPower => new(CurrentRpm.AsPrimitive() * CurrentTorque.AsPrimitive());
        public RPM CurrentRpm { get; }
        public Torque CurrentTorque { get; }
        public bool IsCurrentClockwise { get; }
        
        public Torque GetRequiredTorque(RPM rpm, bool isClockwise);
        
        public void Rocked();
        public void SupplyPower(RPM rpm, Torque torque, bool isClockwise);
        
        public List<GearConnect> GetGearConnects();
    }
    
    public readonly struct GearConnect
    {
        public readonly IGearEnergyTransformer Transformer;
        public readonly GearConnectOption Self;
        public readonly GearConnectOption Target;
        
        public GearConnect(IGearEnergyTransformer transformer, GearConnectOption self, GearConnectOption target)
        {
            Transformer = transformer;
            Self = self;
            Target = target;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningController.cs
```cs
using Client.Common;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.UIState;
using UnityEngine;
using UnityEngine.EventSystems;
using VContainer;

namespace Client.Game.InGame.Mining
{
    /// <summary>
    ///     UI
    /// </summary>
    public class MapObjectMiningController : MonoBehaviour
    {
        [SerializeField] private HotBarView hotBarView;
        [SerializeField] private float miningDistance = 1.5f;
        
        private IMapObjectMiningState _currentState;
        private MapObjectMiningControllerContext _context;
        
        [Inject]
        public void Constructor(UIStateControl uiStateControl, ILocalPlayerInventory localPlayerInventory, IPlayerObjectController playerObjectController)
        {
            _currentState = new MapObjectMiningIdleState();
            _context = new MapObjectMiningControllerContext(hotBarView, localPlayerInventory, playerObjectController);
        }
        
        
        private void Update()
        {
            // update focus map object
            var currentMapObject = GetCurrentMapObject();
            _context.SetFocusMapObjectGameObject(currentMapObject);
            
            // update state
            _currentState = _currentState.GetNextUpdate(_context, Time.deltaTime);
            
            #region Internal
            
            MapObjectGameObject GetCurrentMapObject()
            {
                if (Camera.main == null) return null;
                
                var ray = Camera.main.ScreenPointToRay(new Vector2(Screen.width / 2.0f, Screen.height / 2.0f));
                if (!Physics.Raycast(ray, out var hit, 10, LayerConst.MapObjectOnlyLayerMask)) return null;
                if (EventSystem.current.IsPointerOverGameObject()) return null;
                if (!hit.collider.gameObject.TryGetComponent(out MapObjectGameObject mapObject)) return null;
                
                var playerPos = _context.PlayerObjectController.Position;
                var mapObjectPos = mapObject.transform.position;
                if (miningDistance < Vector3.Distance(playerPos, mapObjectPos)) return null;
                
                return mapObject;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/ItemManaged/MainOpenableInventoryData.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Event;
using Game.PlayerInventory.Interface;
using Game.PlayerInventory.Interface.Event;

namespace Game.PlayerInventory.ItemManaged
{
    public class MainOpenableInventoryData : IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems => _openableInventoryService.InventoryItems;
        
        private readonly MainInventoryUpdateEvent _mainInventoryUpdateEvent;
        private readonly OpenableInventoryItemDataStoreService _openableInventoryService;
        private readonly int _playerId;
        
        public MainOpenableInventoryData(int playerId, MainInventoryUpdateEvent mainInventoryUpdateEvent)
        {
            _playerId = playerId;
            _mainInventoryUpdateEvent = mainInventoryUpdateEvent;
            _openableInventoryService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, PlayerInventoryConst.MainInventorySize);
        }
        
        public MainOpenableInventoryData(int playerId, MainInventoryUpdateEvent mainInventoryUpdateEvent, List<IItemStack> itemStacks) : this(playerId, mainInventoryUpdateEvent)
        {
            for (var i = 0; i < itemStacks.Count; i++) _openableInventoryService.SetItemWithoutEvent(i, itemStacks[i]);
        }
        
        public IItemStack GetItem(int slot)
        {
            return _openableInventoryService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _openableInventoryService.SetItem(slot, itemStack);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            _openableInventoryService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            return _openableInventoryService.ReplaceItem(slot, itemStack);
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            return _openableInventoryService.ReplaceItem(slot, itemId, count);
        }
        
        /// <summary>
        ///     Insert
        /// </summary>
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return _openableInventoryService.InsertItemWithPrioritySlot(itemStack, PlayerInventoryConst.HotBarSlots);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            return _openableInventoryService.InsertItemWithPrioritySlot(itemId, count, PlayerInventoryConst.HotBarSlots);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return _openableInventoryService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return _openableInventoryService.InsertionCheck(itemStacks);
        }
        
        public int GetSlotSize()
        {
            return _openableInventoryService.GetSlotSize();
        }
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            return _openableInventoryService.CreateCopiedItems();
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _mainInventoryUpdateEvent.OnInventoryUpdateInvoke(new PlayerInventoryUpdateEventProperties(
                _playerId, slot, itemStack));
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/NetworkEventInventoryUpdater.cs
```cs
using Client.Game.InGame.Context;
using Game.Context;
using MessagePack;
using Server.Event.EventReceive;
using VContainer.Unity;

namespace Client.Game.InGame.UI.Inventory.Main
{
    public class NetworkEventInventoryUpdater : IInitializable
    {
        private readonly LocalPlayerInventoryController _localPlayerInventoryController;
        
        public NetworkEventInventoryUpdater(LocalPlayerInventoryController localPlayerInventoryController)
        {
            _localPlayerInventoryController = localPlayerInventoryController;
        }
        
        public void Initialize()
        {
            ClientContext.VanillaApi.Event.SubscribeEventResponse(GrabInventoryUpdateEventPacket.EventTag, OnGrabInventoryUpdateEvent);
            ClientContext.VanillaApi.Event.SubscribeEventResponse(MainInventoryUpdateEventPacket.EventTag, OnMainInventoryUpdateEvent);
        }
        
        /// <summary>
        ///     Grab
        /// </summary>
        private void OnGrabInventoryUpdateEvent(byte[] payload)
        {
            var packet = MessagePackSerializer.Deserialize<GrabInventoryUpdateEventMessagePack>(payload);
            var item = ServerContext.ItemStackFactory.Create(packet.Item.Id, packet.Item.Count);
            _localPlayerInventoryController.SetGrabItem(item);
        }
        
        /// <summary>
        ///     
        /// </summary>
        private void OnMainInventoryUpdateEvent(byte[] payload)
        {
            var packet = MessagePackSerializer.Deserialize<MainInventoryUpdateEventMessagePack>(payload);
            var item = ServerContext.ItemStackFactory.Create(packet.Item.Id, packet.Item.Count);
            _localPlayerInventoryController.SetMainItem(packet.Slot, item);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SaveProtocol.cs
```cs
using System.Collections.Generic;
using Game.SaveLoad.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SaveProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:save";
        
        private readonly IWorldSaveDataSaver _worldSaveDataSaver;
        
        public SaveProtocol(ServiceProvider serviceProvider)
        {
            _worldSaveDataSaver = serviceProvider.GetService<IWorldSaveDataSaver>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            Debug.Log("");
            _worldSaveDataSaver.Save();
            Debug.Log("");
            return null;
        }
        
        
        [MessagePackObject]
        public class SaveProtocolMessagePack : ProtocolMessagePackBase
        {
            public SaveProtocolMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/InitialHandshakeProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.InitialHandshakeProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class InitialHandshakeProtocolTest
    {
        private const int PlayerId = 1;
        
        [Test]
        public void SpawnCoordinateTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            //
            serviceProvider.GetService<IWorldSettingsDatastore>().Initialize();
            
            //
            var response = packet.GetPacketResponse(GetHandshakePacket(PlayerId))[0];
            var handShakeResponse =
                MessagePackSerializer.Deserialize<ResponseInitialHandshakeMessagePack>(response.ToArray());
            
            //
            Assert.AreEqual(0, handShakeResponse.PlayerPos.X);
            Assert.AreEqual(0, handShakeResponse.PlayerPos.Y);
            
            
            //
            packet.GetPacketResponse(GetPlayerPositionPacket(PlayerId, new Vector3(100, 0, -100)));
            
            
            //
            response = packet.GetPacketResponse(GetHandshakePacket(PlayerId))[0];
            handShakeResponse =
                MessagePackSerializer.Deserialize<ResponseInitialHandshakeMessagePack>(response.ToArray());
            Assert.AreEqual(100, handShakeResponse.PlayerPos.X);
            Assert.AreEqual(0, handShakeResponse.PlayerPos.Y);
            Assert.AreEqual(-100, handShakeResponse.PlayerPos.Z);
        }
        
        private List<byte> GetHandshakePacket(int playerId)
        {
            return MessagePackSerializer.Serialize(
                new RequestInitialHandshakeMessagePack(playerId, "test player name")).ToList();
        }
        
        
        private List<byte> GetPlayerPositionPacket(int playerId, Vector3 pos)
        {
            return MessagePackSerializer.Serialize(
                new SetPlayerCoordinateProtocol.PlayerCoordinateSendProtocolMessagePack(playerId, pos)).ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Skit/SkitTrack/TextTrack.cs
```cs
using System.Collections.Generic;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Skit.SkitTrack
{
    public class TextTrack : IStoryTrack
    {
        public async UniTask<string> ExecuteTrack(StoryContext storyContext, List<string> parameters)
        {
            var characterName = parameters[0];
            var characterDisplayName = parameters[2] == string.Empty ? characterName : parameters[2];
            var text = parameters[1];
            
            storyContext.SkitUI.SetText(characterDisplayName, text);
            
            var voiceAudioClip = storyContext.VoiceDefine.GetVoiceClip(characterName, text);
            
            var character = storyContext.GetCharacter(characterName);
            if (voiceAudioClip != null) character.PlayVoice(voiceAudioClip);
            
            //
            while (true)
            {
                if (Input.GetMouseButtonDown(0))
                {
                    // 1
                    await UniTask.Yield();
                    character.StopVoice();
                    return null;
                }
                
                await UniTask.Yield();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Util/PacketBufferParser.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Server.Util
{
    /// <summary>
    ///     
    /// </summary>
    public class PacketBufferParser
    {
        private readonly List<byte> _packetLengthBytes = new();
        private List<byte> _continuationFromLastTimeBytes = new();
        
        private bool _isGettingLength;
        private int _nextPacketLengthOffset;
        private int _packetLength;
        private int _remainingHeaderLength;
        
        public List<List<byte>> Parse(byte[] packet, int length)
        {
            //
            var actualStartPacketDataIndex = 0;
            var reminderLength = length;
            
            var result = new List<List<byte>>();
            
            //
            while (0 < reminderLength)
            {
                //
                if (_continuationFromLastTimeBytes.Count == 0)
                {
                    //
                    if (TryGetLength(packet, actualStartPacketDataIndex, out var payloadLength, out var headerLength))
                    {
                        _packetLength = payloadLength;
                        //short4
                        reminderLength -= _packetLength + headerLength;
                        actualStartPacketDataIndex += headerLength;
                    }
                    else
                    {
                        //
                        break;
                    }
                }
                else
                {
                    //
                    _packetLength -= _nextPacketLengthOffset;
                    reminderLength = length - _packetLength;
                }
                
                //
                if (reminderLength < 0)
                {
                    var addCollection = packet.Skip(actualStartPacketDataIndex).ToList();
                    _continuationFromLastTimeBytes.AddRange(addCollection);
                    //
                    _nextPacketLengthOffset = length - actualStartPacketDataIndex;
                    break;
                }
                
                //
                for (var i = 0;
                     i < _packetLength && actualStartPacketDataIndex < length;
                     actualStartPacketDataIndex++, i++)
                    _continuationFromLastTimeBytes.Add(packet[actualStartPacketDataIndex]);
                
                result.Add(_continuationFromLastTimeBytes);
                //
                _continuationFromLastTimeBytes = new List<byte>();
            }
            
            return result;
        }
        
        
        private bool TryGetLength(byte[] bytes, int startIndex, out int payloadLength, out int headerLength)
        {
            List<byte> headerBytes;
            if (_isGettingLength)
            {
                headerLength = _remainingHeaderLength;
                for (var i = 0; i < _remainingHeaderLength; i++) _packetLengthBytes.Add(bytes[i]);
                headerBytes = _packetLengthBytes;
                _isGettingLength = false;
            }
            else
            {
                payloadLength = -1;
                headerLength = -1;
                //
                if (bytes.Length <= startIndex + 3)
                {
                    _packetLengthBytes.Clear();
                    _remainingHeaderLength = 4;
                    for (var i = startIndex; i < bytes.Length; i++)
                    {
                        _remainingHeaderLength = 3 - (i - startIndex);
                        _packetLengthBytes.Add(bytes[i]);
                    }
                    
                    _isGettingLength = true;
                    return false;
                }
                
                headerLength = 4;
                headerBytes = new List<byte>
                {
                    bytes[startIndex],
                    bytes[startIndex + 1],
                    bytes[startIndex + 2],
                    bytes[startIndex + 3],
                };
            }
            
            
            if (BitConverter.IsLittleEndian) headerBytes.Reverse();
            
            payloadLength = BitConverter.ToInt32(headerBytes.ToArray(), 0);
            return true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MasterJsonCpntens.cs
```cs
using System.Collections.Generic;
using UnitGenerator;

namespace Core.Master
{
    public class MasterJsonCpntens
    {
        public readonly string BlockConfigJson;
        public readonly string ChallengeConfigJson;
        public readonly string CraftRecipeConfigJson;
        public readonly string ItemConfigJson;
        public readonly string MachineRecipeConfigJson;
        public readonly string MapObjectConfigJson;
        
        
        public MasterJsonCpntens(string itemJson, string blockConfigJson, string machineRecipeConfigJson, string craftRecipeConfigJson, string mapObjectConfigJson, string challengeConfigJson,ModId modId, Dictionary<JsonFileName,string> jsonContents)
        {
            ModId = modId;
            JsonContents = jsonContents;
            
            ItemConfigJson = itemJson;
            BlockConfigJson = blockConfigJson;
            MachineRecipeConfigJson = machineRecipeConfigJson;
            CraftRecipeConfigJson = craftRecipeConfigJson;
            MapObjectConfigJson = mapObjectConfigJson;
            ChallengeConfigJson = challengeConfigJson;
        }
        
        public readonly ModId ModId;
        
        /// <summary>
        /// Key : json file name ( Do not include ".json" )
        /// Value : json file contents
        /// </summary>
        public readonly Dictionary<JsonFileName,string> JsonContents = new();
        
        
        public MasterJsonCpntens(ModId modId, Dictionary<JsonFileName,string> jsonContents)
        {
            ModId = modId;
            JsonContents = jsonContents;
        }
    }
    
    [UnitOf(typeof(string))]
    public readonly partial struct ModId { }
    
    [UnitOf(typeof(string))]
    public readonly partial struct JsonFileName { }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/master/items.json
```cs
{
  "data": [
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "f92c51ab-1979-4a44-8c35-e86a51b33e61",
      "imagePath": "assets/item/.png",
      "sortPriority": 100
    },
    {
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "maxStack": 100,
      "name": "",
      "itemGuid": "19a3b0bc-10de-4e96-8a41-99f39675556d",
      "imagePath": "assets/item/.png",
      "sortPriority": 110
    },
    {
      "maxStack": 100,
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "resultItem": {
        "count": 1,
        "itemGuid": "19a3b0bc-10de-4e96-8a41-99f39675556d"
      },
      "name": "",
      "itemGuid": "d382f613-8dec-4c87-b72c-c75f8d18ce73",
      "imagePath": "assets/item/.jpg",
      "sortPriority": 120
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "94f7b602-d72f-4e28-b18a-202bf73ef488",
      "imagePath": "assets/item/.png",
      "sortPriority": 130
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "6b22a093-0c83-4543-9985-aad0ceb5f8b0",
      "imagePath": "assets/item/.png",
      "sortPriority": 140
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "32305de4-de08-42dd-8cef-1a5815c0c8f5",
      "sortPriority": 150
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "433735a5-8e53-4942-8c0f-6b19f8c70dfa",
      "sortPriority": 160
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "de89dc5c-b9d1-40f4-97ef-6b0bdcdd9379",
      "sortPriority": 170
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "693312d3-7e3a-4489-8746-4eebbc8dbd67",
      "sortPriority": 180
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "0a706c5c-eb74-4bb1-b13c-1319f38ac154",
      "sortPriority": 190
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "6b54897e-e7cb-4df7-807e-1597c2a859da",
      "sortPriority": 200
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "92fe1a42-ad46-4ff3-aa9a-83a9262c34d6",
      "sortPriority": 210
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "90efdad3-1edf-41a1-bc3e-615e692e2d6e",
      "sortPriority": 220
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "99c95d35-9ba8-4027-9d88-48174a7322fa",
      "sortPriority": 230
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "ee7c1edf-32ba-4bd2-962c-d29ee1309730",
      "sortPriority": 240
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "067f2b59-a088-4fac-98cf-68060c6e9927",
      "sortPriority": 250
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "b7068d1c-f5cb-4af5-94e1-4ed9c9577ca8",
      "sortPriority": 260
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "c82061f7-f4b2-45bc-8323-40f76dece8f2",
      "sortPriority": 270
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "96e59fa9-8468-4315-b8b8-8e087a146dbb",
      "sortPriority": 280
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "17d94f6e-9f34-4d4b-8068-4be4c7dbfbb2",
      "sortPriority": 290
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "975384df-a166-48a6-a5cf-d631f48715c0",
      "sortPriority": 300
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "6f8e7dcb-e7d7-44c0-a63e-ffba1cd5e311",
      "sortPriority": 310
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "0c17174c-bfb2-43a8-ab99-bb4274cb3927",
      "sortPriority": 320
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "0559e1c6-5a63-40bc-92d8-64167fa6c3ba",
      "sortPriority": 330
    },
    {
      "maxStack": 100,
      "blockSize": [
        1,
        1,
        1
      ],
      "craftTime": 3,
      "craftResultCount": 1,
      "name": "",
      "itemGuid": "f3934127-877a-4692-b9a0-cdaaca3d1b90",
      "sortPriority": 340
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "",
      "itemGuid": "3568d0bf-c71e-4f5a-beab-d7239da99829",
      "sortPriority": 350
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "91886efb-6f26-4ff5-80d8-5c5a1966b264",
      "sortPriority": 360
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "6690cf85-672a-46c0-97b2-45da0b6c954e",
      "sortPriority": 370
    },
    {
      "maxStack": 100,
      "blockSize": [
        1,
        1,
        1
      ],
      "name": "",
      "itemGuid": "6e05a18a-8e6a-4ba5-9191-a778ed105ae4",
      "sortPriority": 380
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "a094cb43-422b-42d0-bb44-ee5bf6d0321b",
      "sortPriority": 390
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "bb6170ae-27f8-41a9-90b2-b3b272b05dc2",
      "sortPriority": 400
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "8f13936b-8c95-4091-a34a-3739187dca82",
      "sortPriority": 410
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "Mk2",
      "itemGuid": "42ad9e08-907b-4540-ad64-1393e4dc401f",
      "sortPriority": 420
    },
    {
      "time": 1,
      "craftTime": 3,
      "craftResultCount": 1,
      "earnItemHps": [
        0
      ],
      "hp": 100,
      "mapObjectName": "mapObjectName",
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "",
      "itemGuid": "b8986659-052f-4208-a847-dbd975990d3c",
      "sortPriority": 430
    },
    {
      "time": 1,
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "",
      "itemGuid": "18e297cc-6c50-41dd-8352-8877af1b37de",
      "sortPriority": 440
    },
    {
      "maxStack": 100,
      "name": "CraftChainerTransporter",
      "itemGuid": "db52f4b0-c28c-4f18-a6c8-0b054e460006",
      "sortPriority": 450
    },
    {
      "maxStack": 100,
      "name": "CraftChainerCrafter",
      "itemGuid": "b76d00ed-72c9-436d-af80-11739a4f3e14",
      "sortPriority": 460
    },
    {
      "maxStack": 100,
      "name": "CraftChainerProviderChest",
      "itemGuid": "35be2026-4730-46d3-9821-5d5f88ac3326",
      "sortPriority": 470
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMainComputer",
      "itemGuid": "59ca039e-7b91-41d9-b387-9bbfa73b74e5",
      "sortPriority": 480
    },
    {
      "maxStack": 100,
      "name": "CraftChainerBeltConveyor",
      "itemGuid": "9ba04edc-1fe0-4528-91a8-80155a51bfe0",
      "sortPriority": 490
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMachine1",
      "itemGuid": "0b9e2f8f-b53f-440f-8913-0664f51e6856",
      "sortPriority": 500
    },
    {
      "maxStack": 100,
      "name": "CraftChainerMachine2",
      "itemGuid": "7dd72da1-e030-494e-a650-a651f7826648",
      "sortPriority": 510
    },
    {
      "maxStack": 100,
      "name": "Chainer - A",
      "itemGuid": "189672cb-6811-4080-bde1-1f9ff0ec63ff",
      "sortPriority": 520
    },
    {
      "maxStack": 100,
      "name": "Chainer - B",
      "itemGuid": "547791fe-bfd8-4748-aafa-c7449391eca5",
      "sortPriority": 530
    },
    {
      "maxStack": 100,
      "name": "Chainer - C",
      "itemGuid": "c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627",
      "sortPriority": 540
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "",
      "itemGuid": "edfa387f-183a-47dc-a548-5d2f14e315d7",
      "sortPriority": 550
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "26b38ec5-a2ce-432c-9211-530f2f86d435",
      "sortPriority": 560
    },
    {
      "maxStack": 100,
      "name": "",
      "itemGuid": "3f1b7698-db08-490d-bd0d-b4a3e0fb2f9c",
      "sortPriority": 570
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "maxStack": 100,
      "name": "",
      "itemGuid": "cc26c622-c212-47c6-88a5-931329a0509c",
      "sortPriority": 580
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 590,
      "maxStack": 100,
      "name": "",
      "itemGuid": "4a35c49b-f662-4a0e-b224-8f43bddd5b30"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 600,
      "maxStack": 100,
      "name": "",
      "itemGuid": "0a665a5a-3499-4ad5-a36c-6f52b4a643ec"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "blockPrefabAddressablesPath": "Vanilla/Block/PipeStraight",
      "sortPriority": 610,
      "maxStack": 100,
      "name": "",
      "itemGuid": "fd1bc661-61d5-4d53-b7e3-0d84d18e8f5d"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 575,
      "maxStack": 100,
      "name": "",
      "itemGuid": "caa17dec-8e5e-477b-9b1f-03cdfaa4df08"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 620,
      "maxStack": 100,
      "name": "",
      "itemGuid": "96f845c8-6365-47e6-b78a-e2853a6ebae7"
    },
    {
      "blockSize": [
        1,
        1,
        1
      ],
      "sortPriority": 445,
      "maxStack": 100,
      "name": "",
      "itemGuid": "27218416-d4d8-4583-b8d8-911cc778e95e"
    }
  ]
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/ChangeBlockStateEventPacket.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface.State;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using Server.Util.MessagePack;
using UniRx;
using UnityEngine;

namespace Server.Event.EventReceive
{
    public class ChangeBlockStateEventPacket
    {
        public const string EventTag = "va:event:changeBlockState";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public ChangeBlockStateEventPacket(EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            ServerContext.WorldBlockDatastore.OnBlockStateChange.Subscribe(ChangeState);
        }
        
        private void ChangeState((BlockState state, WorldBlockData blockData) state)
        {
            var messagePack = new BlockStateMessagePack(state.state, state.blockData.BlockPositionInfo.OriginalPos);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddBroadcastEvent(EventTag, payload);
        }
    }
    
    [MessagePackObject]
    public class BlockStateMessagePack
    {
        /// <summary>
        /// key Component key, value Component state
        /// </summary>
        [Key(0)] public Dictionary<string,byte[]> CurrentStateDetail { get; set; }
        
        [Key(1)] public Vector3IntMessagePack Position { get; set; } // TODO instanceId
        
        public TBlockState GetStateDetail<TBlockState>(string stateKey)
        {
            if (!CurrentStateDetail.TryGetValue(stateKey, out var bytes))
            {
                return default;
            }
            return MessagePackSerializer.Deserialize<TBlockState>(bytes);
        }
        
        [Obsolete("")]
        public BlockStateMessagePack()
        {
        }
        
        public BlockStateMessagePack(BlockState state, Vector3Int pos)
        {
            CurrentStateDetail = state.CurrentStateDetails;
            Position = new Vector3IntMessagePack(pos);
        }

    }
}
```

moorestech_client/Assets/Scripts/Client.Mod/Texture/GetExtractedZipTexture.cs
```cs
using System;
using System.IO;
using UnityEngine;

namespace Client.Mod.Texture
{
    //TODO 
    public static class GetExtractedZipTexture
    {
        public static Texture2D Get(string extractedModDirectory, string path)
        {
            //TODO 
            var imgPath = Path.Combine(extractedModDirectory, path);
            
            //
            if (!File.Exists(imgPath))
            {
                Debug.LogWarning($"  : {imgPath}");
                return null;
            }
            
            try
            {
                var texture = new Texture2D(1, 1);
                texture.LoadImage(File.ReadAllBytes(imgPath));
                return texture;
            }
            catch (Exception e)
            {
                Debug.Log($" {imgPath} \nMessage {e.Message} \nStackTrace {e.StackTrace}");
                return null;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/PlaceBlockState.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.Control;
using Client.Game.InGame.UI.UIState.Input;
using Client.Game.Skit;
using Client.Input;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class PlaceBlockState : IUIState
    {
        private readonly IBlockPlacePreview _blockPlacePreview;
        private readonly ScreenClickableCameraController _screenClickableCameraController;
        private readonly SkitManager _skitManager;
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        private readonly List<IDisposable> _blockPlacedDisposable = new();
        
        private bool _isChangeCameraAngle;
        
        public PlaceBlockState(IBlockPlacePreview blockPlacePreview, SkitManager skitManager, InGameCameraController inGameCameraController, BlockGameObjectDataStore blockGameObjectDataStore)
        {
            _skitManager = skitManager;
            _blockGameObjectDataStore = blockGameObjectDataStore;
            _blockPlacePreview = blockPlacePreview;
            _screenClickableCameraController = new ScreenClickableCameraController(inGameCameraController);
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            BlockPlaceSystem.SetEnableBlockPlace(true);
            _screenClickableCameraController.OnEnter();
            
            //TODO InputSystem
            // +B
            // Shift+B does not change camera position
            _isChangeCameraAngle = !UnityEngine.Input.GetKey(KeyCode.LeftShift);
            
            if (_isChangeCameraAngle)
            {
                _screenClickableCameraController.StartTweenFromTop();
            }
            
            // 
            foreach (var blockGameObject in _blockGameObjectDataStore.BlockGameObjectDictionary.Values)
            {
                blockGameObject.EnablePreviewOnlyObjects(true, true);
            }
            _blockPlacedDisposable.Add(_blockGameObjectDataStore.OnBlockPlaced.Subscribe(OnPlaceBlock));
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.PlayerInventory;
            if (BlockClickDetect.IsClickOpenableBlock(_blockPlacePreview)) return UIStateEnum.BlockInventory;
            if (InputManager.UI.BlockDelete.GetKeyDown) return UIStateEnum.DeleteBar;
            if (_skitManager.IsPlayingSkit) return UIStateEnum.Story;
            //TODO InputSystem
            if (InputManager.UI.CloseUI.GetKeyDown || UnityEngine.Input.GetKeyDown(KeyCode.B)) return UIStateEnum.GameScreen;
            
            _screenClickableCameraController.GetNextUpdate();
            
            return UIStateEnum.Current;
        }
        
        private void OnPlaceBlock(BlockGameObject blockGameObject)
        {
            blockGameObject.EnablePreviewOnlyObjects(true, false);
            
            _blockPlacedDisposable.Add(blockGameObject.OnFinishedPlaceAnimation.Subscribe(_ =>
            {
                blockGameObject.EnablePreviewOnlyObjects(true, true);
            }));
        }
        
        public void OnExit()
        {
            BlockPlaceSystem.SetEnableBlockPlace(false);
            foreach (var blockGameObject in _blockGameObjectDataStore.BlockGameObjectDictionary.Values)
            {
                blockGameObject.EnablePreviewOnlyObjects(false, false);
            }
            
            _blockPlacedDisposable.ForEach(d => d.Dispose());
            _blockPlacedDisposable.Clear();
            _screenClickableCameraController.OnExit();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Network/API/VanillaApiWithResponse.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Client.Network.Settings;
using Core.Item.Interface;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Challenge;
using Game.Context;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Client.Network.API
{
    public class VanillaApiWithResponse
    {
        private readonly IItemStackFactory _itemStackFactory;
        private readonly PacketExchangeManager _packetExchangeManager;
        private readonly PlayerConnectionSetting _playerConnectionSetting;
        
        public VanillaApiWithResponse(PacketExchangeManager packetExchangeManager, PlayerConnectionSetting playerConnectionSetting)
        {
            _itemStackFactory = ServerContext.ItemStackFactory;
            _packetExchangeManager = packetExchangeManager;
            _playerConnectionSetting = playerConnectionSetting;
        }
        
        public async UniTask<InitialHandshakeResponse> InitialHandShake(int playerId, CancellationToken ct)
        {
            //
            var request = new InitialHandshakeProtocol.RequestInitialHandshakeMessagePack(playerId, $"Player {playerId}");
            var response = await _packetExchangeManager.GetPacketResponse<InitialHandshakeProtocol.ResponseInitialHandshakeMessagePack>(request, ct);
            
            List<GetMapObjectInfoProtocol.MapObjectsInfoMessagePack> mapObjects = null;
            WorldDataResponse worldData = null;
            PlayerInventoryResponse inventory = null;
            ChallengeResponse challenge = null;
            List<BlockStateMessagePack> blockStates = null;
            
            //
            await UniTask.WhenAll(GetMapObjects(), GetWorld(), GetInventory(), GetChallenge(), GetBlockStates());
            
            return new InitialHandshakeResponse(response, worldData, mapObjects, inventory, challenge, blockStates);
            
            #region Internal
            
            async UniTask GetMapObjects()
            {
                mapObjects = await GetMapObjectInfo(ct);
            }
            
            async UniTask GetWorld()
            {
                worldData = await GetWorldData(ct);
            }
            
            async UniTask GetInventory()
            {
                inventory = await GetPlayerInventory(playerId, ct);
            }
            
            async UniTask GetChallenge()
            {
                challenge = await GetChallengeResponse(playerId, ct);
            }
            
            async UniTask GetBlockStates()
            {
                blockStates = await GetAllBlockState(ct);
            }
            
            #endregion
        }
        
        public async UniTask<List<GetMapObjectInfoProtocol.MapObjectsInfoMessagePack>> GetMapObjectInfo(CancellationToken ct)
        {
            var request = new GetMapObjectInfoProtocol.RequestMapObjectInfosMessagePack();
            var response = await _packetExchangeManager.GetPacketResponse<GetMapObjectInfoProtocol.ResponseMapObjectInfosMessagePack>(request, ct);
            return response?.MapObjects;
        }
        
        public async UniTask<List<IItemStack>> GetBlockInventory(Vector3Int blockPos, CancellationToken ct)
        {
            var request = new BlockInventoryRequestProtocol.RequestBlockInventoryRequestProtocolMessagePack(blockPos);
            
            var response = await _packetExchangeManager.GetPacketResponse<BlockInventoryRequestProtocol.BlockInventoryResponseProtocolMessagePack>(request, ct);
            
            var items = new List<IItemStack>(response.Items.Length);
            for (var i = 0; i < response.Items.Length; i++)
            {
                var id = response.Items[i].Id;
                var count = response.Items[i].Count;
                items.Add(_itemStackFactory.Create(id, count));
            }
            
            return items;
        }
        
        public async UniTask<PlayerInventoryResponse> GetMyPlayerInventory(CancellationToken ct)
        {
            return await GetPlayerInventory(_playerConnectionSetting.PlayerId, ct);
        }
        
        public async UniTask<PlayerInventoryResponse> GetPlayerInventory(int playerId, CancellationToken ct)
        {
            var request = new PlayerInventoryResponseProtocol.RequestPlayerInventoryProtocolMessagePack(playerId);
            
            var response = await _packetExchangeManager.GetPacketResponse<PlayerInventoryResponseProtocol.PlayerInventoryResponseProtocolMessagePack>(request, ct);
            
            var mainItems = new List<IItemStack>(response.Main.Length);
            foreach (var item in response.Main)
            {
                var id = item.Id;
                var count = item.Count;
                mainItems.Add(_itemStackFactory.Create(id, count));
            }
            
            var grabItem = _itemStackFactory.Create(response.Grab.Id, response.Grab.Count);
            
            return new PlayerInventoryResponse(mainItems, grabItem);
        }
        
        public async UniTask<WorldDataResponse> GetWorldData(CancellationToken ct)
        {
            var request = new RequestWorldDataProtocol.RequestWorldDataMessagePack();
            var response = await _packetExchangeManager.GetPacketResponse<RequestWorldDataProtocol.ResponseWorldDataMessagePack>(request, ct);
            
            return ParseWorldResponse(response);
            
            #region Internal
            
            WorldDataResponse ParseWorldResponse(RequestWorldDataProtocol.ResponseWorldDataMessagePack worldData)
            {
                var blocks = worldData.Blocks.Select(b => new BlockInfo(b));
                var entities = worldData.Entities.Select(e => new EntityResponse(e));
                
                return new WorldDataResponse(blocks.ToList(), entities.ToList());
            }
            
            #endregion
        }
        
        public async UniTask<ChallengeResponse> GetChallengeResponse(int playerId, CancellationToken ct)
        {
            var request = new GetChallengeInfoProtocol.RequestChallengeMessagePack(playerId);
            var response = await _packetExchangeManager.GetPacketResponse<GetChallengeInfoProtocol.ResponseChallengeInfoMessagePack>(request, ct);
            
            var current = response.CurrentChallengeGuids.Select(MasterHolder.ChallengeMaster.GetChallenge).ToList();
            var completed = response.CompletedChallengeGuids.Select(MasterHolder.ChallengeMaster.GetChallenge).ToList();
            
            return new ChallengeResponse(current, completed);
        }
        
        public async UniTask<List<BlockStateMessagePack>> GetAllBlockState(CancellationToken ct)
        {
            var request = new AllBlockStateProtocol.RequestAllBlockStateProtocolMessagePack();
            var response = await _packetExchangeManager.GetPacketResponse<AllBlockStateProtocol.ResponseAllBlockStateProtocolMessagePack>(request, ct);
            
            return response.StateList;
        }
        
        public async UniTask<BlockStateMessagePack> GetBlockState(Vector3Int blockPos, CancellationToken ct)
        {
            var request = new BlockStateProtocol.RequestBlockStateProtocolMessagePack(blockPos);
            var response = await _packetExchangeManager.GetPacketResponse<BlockStateProtocol.ResponseBlockStateProtocolMessagePack>(request, ct);
            
            return response.State;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/GetWorldDataProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Const;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.RequestWorldDataProtocol;
using Random = System.Random;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class GetWorldDataProtocolTest
    {
        public static readonly BlockId Block_1x4_Id = new(9); // 1x4ID
        
        //
        [Test]
        public void RandomPlaceBlockToWorldDataResponseTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var random = new Random(13944156);
            //
            for (var i = 0; i < 1000; i++)
            {
                var blockDirection = (BlockDirection)random.Next(0, 4);
                var pos = new Vector3Int(random.Next(-40, 40), random.Next(-40, 40));
                
                var blockId = random.Next(1, 20);
                worldBlockDatastore.TryAddBlock((BlockId)blockId, pos, blockDirection, out _);
            }
            
            var requestBytes = MessagePackSerializer.Serialize(new RequestWorldDataMessagePack());
            List<byte> responseBytes = packetResponse.GetPacketResponse(requestBytes.ToList())[0];
            var responseWorld = MessagePackSerializer.Deserialize<ResponseWorldDataMessagePack>(responseBytes.ToArray());
            
            //
            for (var i = 0; i < responseWorld.Blocks.Length; i++)
            {
                var block = responseWorld.Blocks[i];
                var pos = block.BlockPos;
                
                var id = worldBlockDatastore.GetOriginPosBlock(pos)?.Block.BlockId ?? BlockConst.EmptyBlockId;
                Assert.AreEqual(id, block.BlockId);
                
                var direction = worldBlockDatastore.GetOriginPosBlock(pos)?.BlockPositionInfo.BlockDirection ?? BlockDirection.North;
                Assert.AreEqual(direction, block.BlockDirection);
            }
        }
        
        //
        [Test]
        public void PlaceBlockToWorldDataTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlock = ServerContext.WorldBlockDatastore;
            
            //
            worldBlock.TryAddBlock(Block_1x4_Id, Vector3Int.zero, BlockDirection.North, out _);
            
            var requestBytes = MessagePackSerializer.Serialize(new RequestWorldDataMessagePack());
            List<byte> responseBytes = packetResponse.GetPacketResponse(requestBytes.ToList())[0];
            var responseWorld = MessagePackSerializer.Deserialize<ResponseWorldDataMessagePack>(responseBytes.ToArray());
            
            //
            Assert.AreEqual(Block_1x4_Id, responseWorld.Blocks[0].BlockId);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/ItemImageContainer.cs
```cs
using System;
using System.Collections.Generic;
using Client.Mod.Texture;
using Core.Master;
using UnityEngine;

namespace Client.Game.InGame.Context
{
    /// <summary>
    ///     
    /// </summary>
    public class ItemImageContainer
    {
        private readonly Dictionary<ItemId, ItemViewData> _itemImageList = new();
        
        private ItemImageContainer(Dictionary<ItemId, ItemViewData> itemImageList)
        {
            _itemImageList = itemImageList;
        }
        
        public static ItemImageContainer CreateAndLoadItemImageContainer(string modsDirectory)
        {
            var itemImageList = ItemTextureLoader.GetItemTexture(modsDirectory);
            
            return new ItemImageContainer(itemImageList);
        }
        
        public ItemViewData GetItemView(Guid itemGuid)
        {
            var itemId = MasterHolder.ItemMaster.GetItemId(itemGuid);
            return GetItemView(itemId);
        }
        
        public ItemViewData GetItemView(ItemId itemId)
        {
            if (itemId == ItemMaster.EmptyItemId)
            {
                return null;
            }
            
            if (_itemImageList.TryGetValue(itemId, out var view)) return view;
            
            Debug.LogError($"ItemViewData not found. itemId:{itemId}");
            return null;
        }
        
        public void AddItemView(ItemId itemId, ItemViewData itemViewData)
        {
            _itemImageList[itemId] = itemViewData;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Component/BlockConnectorConnectPositionCalculator.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Mooresmaster.Model.BlockConnectInfoModule;
using UnityEngine;

namespace Game.Block.Component
{
    public static class BlockConnectorConnectPositionCalculator
    {
        /// <summary>
        /// key: 
        ///      Position of the connector
        ///
        /// value: 
        ///        List of positions that can be connected to the connector
        /// </summary>
        public static Dictionary<Vector3Int, List<(Vector3Int position, IConnectOption targetOption)>> CalculateConnectorToConnectPosList(BlockConnectInfo inputConnectInfo, BlockPositionInfo blockPositionInfo)
        {
            var blockDirection = blockPositionInfo.BlockDirection;
            var blockBaseOriginPos = blockDirection.GetBlockBaseOriginPos(blockPositionInfo);
            var result = new Dictionary<Vector3Int, List<(Vector3Int position, IConnectOption targetOption)>>();
            
            if (inputConnectInfo == null) return result;
            foreach (var inputConnectSetting in inputConnectInfo.items)
            {
                var blockPosConvertAction = blockDirection.GetCoordinateConvertAction();
                
                var inputConnectorPos = blockBaseOriginPos + blockPosConvertAction(inputConnectSetting.Offset);
                var directions = inputConnectSetting.Directions;
                if (directions == null)
                {
                    result.Add(inputConnectorPos, null);
                    continue;
                }
                
                var targetPositions = directions.Select(c => (inputConnectorPos + blockPosConvertAction(c), inputConnectSetting.ConnectOption)).ToList();
                if (!result.TryAdd(inputConnectorPos, targetPositions)) result[inputConnectorPos] = result[inputConnectorPos].Concat(targetPositions).ToList();
            }
            
            return result;
        }
        
        /// <summary>
        /// key: 
        ///     Position to connect to the connector
        ///
        /// value: 
        ///        Position of the connector to connect to that position
        /// </summary>
        public static Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)> CalculateConnectPosToConnector(BlockConnectInfo outputConnectInfo, BlockPositionInfo blockPositionInfo)
        {
            var result = new Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)>();
            
            if (outputConnectInfo == null) return result;
            
            var connectorToConnectPosList = CalculateConnectorToConnectPosList(outputConnectInfo, blockPositionInfo);
            foreach (var (connectPos, targetOptions) in connectorToConnectPosList)
            {
                if (targetOptions == null) continue;
                
                foreach (var (targetPos, targetOption) in targetOptions)
                {
                    // targetPos
                    result[targetPos] = (connectPos, targetOption);
                }
            }
            
            return result;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearMinerTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Miner;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearMinerTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockOpenableInventoryUpdateEvent;
        
        public VanillaGearMinerTemplate(BlockOpenableInventoryUpdateEvent blockOpenableInventoryUpdateEvent)
        {
            _blockOpenableInventoryUpdateEvent = blockOpenableInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var minerParam = blockMasterElement.BlockParam as GearMinerBlockParam;
            var miningSettings = minerParam.MineSettings;
            
            var connectSetting = minerParam.Gear.GearConnects;
            var gearConnector = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var gearEnergyTransformer = new GearEnergyTransformer(new Torque(minerParam.RequireTorque), blockInstanceId, gearConnector);
            
            var requestPower = new ElectricPower(minerParam.RequireTorque * minerParam.RequiredRpm);
            var outputSlot = minerParam.OutputItemSlotCount;
            var inventoryConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(minerParam.InventoryConnectors, blockPositionInfo);
            var minerProcessorComponent = componentStates == null ? 
                new VanillaMinerProcessorComponent(blockInstanceId, requestPower, outputSlot, _blockOpenableInventoryUpdateEvent, inventoryConnectorComponent, blockPositionInfo, miningSettings) : 
                new VanillaMinerProcessorComponent(componentStates, blockInstanceId, requestPower, outputSlot, _blockOpenableInventoryUpdateEvent, inventoryConnectorComponent, blockPositionInfo, miningSettings);
                
            var gearMinerComponent = new VanillaGearMinerComponent(minerProcessorComponent, gearEnergyTransformer, minerParam);
            
            var components = new List<IBlockComponent>
            {
                minerProcessorComponent,
                inventoryConnectorComponent,
                gearConnector,
                gearEnergyTransformer,
                gearMinerComponent,
                
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/ChallengeMaster.cs
```cs
using System;
using System.Collections.Generic;
using Mooresmaster.Loader.ChallengesModule;
using Mooresmaster.Model.ChallengesModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class ChallengeMaster
    {
        public Challenges Challenges;
        public readonly List<Guid> InitialChallenge;
        
        private readonly Dictionary<Guid, List<Guid>> _nextChallenges;
        
        public ChallengeMaster(JToken challengeJToken)
        {
            Challenges = ChallengesLoader.Load(challengeJToken);
            _nextChallenges = new Dictionary<Guid, List<Guid>>();
            foreach (var challengeElement in Challenges.Data)
            {
                var next = new List<Guid>();
                foreach (var checkTarget in Challenges.Data)
                {
                    if (challengeElement.ChallengeGuid == checkTarget.PrevChallengeGuid)
                    {
                        next.Add(checkTarget.ChallengeGuid);
                    }
                }
                
                _nextChallenges.Add(challengeElement.ChallengeGuid, next);
            }
            
            InitialChallenge = new List<Guid>();
            foreach (var challengeElement in Challenges.Data)
            {
                // prevnull
                if (!challengeElement.PrevChallengeGuid.HasValue)
                {
                    InitialChallenge.Add(challengeElement.ChallengeGuid);
                }
            }
        }
        
        public List<ChallengeMasterElement> GetNextChallenges(Guid challengeGuid)
        {
            if (!_nextChallenges.TryGetValue(challengeGuid, out var nextChallenges))
            {
                throw new InvalidOperationException($"Next challenges not found. ChallengeGuid:{challengeGuid}");
            }
            
            return nextChallenges.ConvertAll(GetChallenge);
        }
        
        public ChallengeMasterElement GetChallenge(Guid guid)
        {
            return Array.Find(Challenges.Data, x => x.ChallengeGuid == guid);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaPowerGeneratorTemplate.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.PowerGenerator;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaPowerGeneratorTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var generatorParam = blockMasterElement.BlockParam as ElectricGeneratorBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(generatorParam.InventoryConnectors, blockPositionInfo);
            
            var properties = new VanillaPowerGeneratorProperties(blockInstanceId, generatorParam, blockPositionInfo, inputConnectorComponent);
            var generatorComponent = new VanillaElectricGeneratorComponent(properties);
            
            var components = new List<IBlockComponent>
            {
                generatorComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var generatorParam = blockMasterElement.BlockParam as ElectricGeneratorBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(generatorParam.InventoryConnectors, blockPositionInfo);
            
            var properties = new VanillaPowerGeneratorProperties(blockInstanceId, generatorParam, blockPositionInfo, inputConnectorComponent);
            var generatorComponent = new VanillaElectricGeneratorComponent(componentStates, properties);
            
            var components = new List<IBlockComponent>
            {
                generatorComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
    
    public class VanillaPowerGeneratorProperties
    {
        public readonly BlockInstanceId BlockInstanceId;
        public readonly BlockPositionInfo BlockPositionInfo;
        public readonly int FuelItemSlot;
        
        public readonly Dictionary<ItemId, FuelItemsElement> FuelSettings;
        public readonly ElectricPower InfinityPower;
        public readonly BlockConnectorComponent<IBlockInventory> InventoryInputConnectorComponent;
        public readonly bool IsInfinityPower;
        
        public VanillaPowerGeneratorProperties(BlockInstanceId blockInstanceId,ElectricGeneratorBlockParam param, BlockPositionInfo blockPositionInfo, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            FuelSettings = new Dictionary<ItemId, FuelItemsElement>();
            
            if (param.FuelItems != null)
            {
                foreach (var fuelItem in param.FuelItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(fuelItem.ItemGuid);
                    FuelSettings.Add(itemId, fuelItem);
                }
            }
            
            BlockInstanceId = blockInstanceId;
            FuelItemSlot = param.FuelItemSlotCount;
            BlockPositionInfo = blockPositionInfo;
            InventoryInputConnectorComponent = blockConnectorComponent;
            
            IsInfinityPower = param.IsInfinityPower;
            InfinityPower = new ElectricPower(param.InfinityPower);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerProviderChestSaveLoadTest.cs
```cs
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.ProviderChest;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerProviderChestSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);

            // CraftChainerProviderChest
            // Create a CraftChainerProviderChest block
            var providerChestBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerProviderChest, new BlockInstanceId(1), posInfo);

            // 
            // Get the component
            var originalProviderChestComponent = providerChestBlock.GetComponent<CraftChainerProviderChestComponent>();

            // 
            // Retrieve the save data
            var saveState = providerChestBlock.GetSaveState();

            // 
            // Load the block
            var loadedBlock = blockFactory.Load(providerChestBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedProviderChestComponent = loadedBlock.GetComponent<CraftChainerProviderChestComponent>();

            // NodeId
            // Check if NodeId is correctly saved and loaded
            Assert.AreEqual(originalProviderChestComponent.NodeId, loadedProviderChestComponent.NodeId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/RemoveBlockProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface.Component;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class RemoveBlockProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:removeBlock";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        
        public RemoveBlockProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RemoveBlockProtocolMessagePack>(payload.ToArray());
            
            
            //
            var playerMainInventory =
                _playerInventoryDataStore.GetInventoryData(data.PlayerId).MainOpenableInventory;
            
            var isNotRemainItem = true;
            
            //
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            if (worldBlockDatastore.TryGetBlock<IBlockInventory>(data.Pos, out var blockInventory))
                //
                for (var i = 0; i < blockInventory.GetSlotSize(); i++)
                {
                    //
                    var remainItem = playerMainInventory.InsertItem(blockInventory.GetItem(i));
                    //
                    //s
                    blockInventory.SetItem(i, remainItem);
                    
                    //
                    var emptyItem = ServerContext.ItemStackFactory.CreatEmpty();
                    if (!remainItem.Equals(emptyItem)) isNotRemainItem = false;
                }
            
            
            //
            
            //
            //Id
            var block = worldBlockDatastore.GetBlock(data.Pos);
            if (block == null) return null;
            
            //ID
            var blockItemId = MasterHolder.BlockMaster.GetBlockMaster(block.BlockId).ItemGuid;
            //
            var remainBlockItem = playerMainInventory.InsertItem(ServerContext.ItemStackFactory.Create(blockItemId, 1));
            
            
            //
            if (isNotRemainItem && remainBlockItem.Equals(ServerContext.ItemStackFactory.CreatEmpty()))
                worldBlockDatastore.RemoveBlock(data.Pos);
            
            return null;
        }
        
        
        [MessagePackObject]
        public class RemoveBlockProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public Vector3IntMessagePack Pos { get; set; }
            
            [Obsolete("")]
            public RemoveBlockProtocolMessagePack() { }
            public RemoveBlockProtocolMessagePack(int playerId, Vector3Int pos)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Pos = new Vector3IntMessagePack(pos);
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockGameObjectDataStore.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.BlockSystem;
using Client.Game.InGame.Context;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class BlockGameObjectDataStore : MonoBehaviour
    {
        public IReadOnlyDictionary<Vector3Int, BlockGameObject> BlockGameObjectDictionary => _blockObjectsDictionary;
        private readonly Dictionary<Vector3Int, BlockGameObject> _blockObjectsDictionary = new();
        
        public IObservable<BlockGameObject> OnBlockPlaced => _onBlockPlaced;
        private readonly Subject<BlockGameObject> _onBlockPlaced = new();
        
        
        public BlockGameObject GetBlockGameObject(Vector3Int position)
        {
            return _blockObjectsDictionary.GetValueOrDefault(position);
        }
        
        public bool ContainsBlockGameObject(Vector3Int position)
        {
            return _blockObjectsDictionary.ContainsKey(position);
        }
        
        public bool TryGetBlockGameObject(Vector3Int position, out BlockGameObject blockGameObject)
        {
            return _blockObjectsDictionary.TryGetValue(position, out blockGameObject);
        }
        
        
        public void PlaceBlock(Vector3Int blockPosition, BlockId blockId, BlockDirection blockDirection)
        {
            //ID
            if (_blockObjectsDictionary.ContainsKey(blockPosition))
            {
                //ID
                if (_blockObjectsDictionary[blockPosition].BlockId == blockId)
                {
                    return;
                }
                
                //ID
                Destroy(_blockObjectsDictionary[blockPosition].gameObject);
                _blockObjectsDictionary.Remove(blockPosition);
            }
            
            //
            var pos = SlopeBlockPlaceSystem.GetBlockPositionToPlacePosition(blockPosition, blockDirection, blockId);
            var rot = blockDirection.GetRotation();
            
            var block = ClientContext.BlockGameObjectContainer.CreateBlock(blockId, pos, rot, transform, blockPosition, blockDirection);
            //
            block.PlayPlaceAnimation().Forget();
            
            _blockObjectsDictionary.Add(blockPosition, block);
            _onBlockPlaced.OnNext(block);
        }
        
        public void RemoveBlock(Vector3Int blockPosition)
        {
            //
            if (!_blockObjectsDictionary.ContainsKey(blockPosition)) return;
            
            _blockObjectsDictionary[blockPosition].DestroyBlock().Forget();
            _blockObjectsDictionary.Remove(blockPosition);
        }
        
        public bool IsOverlapPositionInfo(BlockPositionInfo target)
        {
            foreach (var block in _blockObjectsDictionary.Values)
                if (block.BlockPosInfo.IsOverlap(target))
                    return true;
            return false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Crafter/CraftChainerCrafterInserter.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent.Crafter
{
    public class CraftChainerCrafterInserter : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        private int _index = 0;
        
        public CraftChainerCrafterInserter(BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockConnectorComponent = blockConnectorComponent;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var notChainerConnector = new List<IBlockInventory>();
            foreach (var connector in _blockConnectorComponent.ConnectedTargets)
            {
                var block = connector.Value.TargetBlock;
                if (block.ComponentManager.ExistsComponent<ICraftChainerNode>())
                {
                    continue;
                }
                
                notChainerConnector.Add(connector.Key);
            }
            if (notChainerConnector.Count == 0)
            {
                return itemStack;
            }
            
            _index++;
            if (notChainerConnector.Count <= _index)
            {
                _index = 0;
            }
            
            return notChainerConnector[_index].InsertItem(itemStack);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPreviewBoundingBoxSurface.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPreviewBoundingBoxSurface : MonoBehaviour
    {
        public PreviewSurfaceType PreviewSurfaceType => _previewSurfaceType;
        [SerializeField] private PreviewSurfaceType _previewSurfaceType;
        
        public void SetPreviewSurfaceType(PreviewSurfaceType previewSurfaceType)
        {
            _previewSurfaceType = previewSurfaceType;
        }
    }
    
    public enum PreviewSurfaceType
    {
        YX_Origin, // YX Front side of YX plane
        YX_Z, // YXZ Back side of the YX plane in the Z direction
        
        YZ_Origin, // YZ Front side of YZ plane
        YZ_X, // YZX Back side of the YZ plane in the X direction
        
        XZ_Origin, // XZ Bottom side of XZ plane
        XZ_Y, // XZY Top side of XZ plane
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaDefaultBlockTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaDefaultBlock : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, new List<IBlockComponent>(), blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, new List<IBlockComponent>(), blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/EnergySegmentExtension.cs
```cs
using System.Collections.Generic;

namespace Game.EnergySystem
{
    public static class EnergySegmentExtension
    {
        public static TSegment Merge<TSegment>(List<TSegment> segments) where TSegment : EnergySegment, new()
        {
            var newSegment = new TSegment();
            //1
            foreach (var electric in segments)
            {
                //
                foreach (var generator in electric.Generators) newSegment.AddGenerator(generator.Value);
                
                //
                foreach (var consumer in electric.Consumers) newSegment.AddEnergyConsumer(consumer.Value);
                
                //
                foreach (var transformer in electric.EnergyTransformers)
                    newSegment.AddEnergyTransformer(transformer.Value);
            }
            
            return newSegment;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Localization/Localize.cs
```cs
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using Client.Common;
using CsvHelper;
using UniRx;
using UnityEngine;

namespace Client.Localization
{
    public static class Localize
    {
        private const string DefaultLanguageCode = "english";
        private const int StartLocalizeTextIndex = 2;
        
        /// <summary>
        ///     
        ///     Key : 
        ///     Value : 
        /// </summary>
        private static readonly Dictionary<string, Dictionary<string, string>> localizeDictionary = new();
        
        private static readonly Subject<Unit> _onLanguageChangedSubject = new();
        
        public static IObservable<Unit> OnLanguageChanged => _onLanguageChangedSubject;
        
        public static string CurrentLanguageCode { get; private set; }
        public static List<string> LanguageCodes => localizeDictionary.Keys.ToList();
        
        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        public static void Initialize()
        {
            //player prefs
            CurrentLanguageCode = PlayerPrefs.GetString("LanguageCode", DefaultLanguageCode);
            
            // CSV
            var csvFilePath = Path.Combine(ServerConst.ServerDirectory, "config", "localization.csv");
            
            var languageCodes = new List<string>();
            var isFirstRow = true;
            
            using var reader = new StreamReader(csvFilePath);
            using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
            while (csv.Read())
            {
                if (isFirstRow)
                {
                    // csv1
                    // 1232
                    for (var i = StartLocalizeTextIndex; csv.TryGetField<string>(i, out var field); i++)
                    {
                        languageCodes.Add(field);
                        localizeDictionary.Add(field, new Dictionary<string, string>());
                    }
                    
                    isFirstRow = false;
                    continue;
                }
                
                var keyAndValues = new List<string>();
                for (var i = 0; csv.TryGetField<string>(i, out var field); i++) keyAndValues.Add(field);
                
                var key = keyAndValues[0];
                for (var i = StartLocalizeTextIndex; i < keyAndValues.Count; i++)
                    //\n\n
                    localizeDictionary[languageCodes[i - 2]].Add(key, keyAndValues[i].Replace("\\n", "\n"));
            }
        }
        
        public static string Get(string key)
        {
            if (localizeDictionary[CurrentLanguageCode].TryGetValue(key, out var value)) return value;
            return $"[Localize] Key : {key} is not found";
        }
        
        public static void SetLanguage(string languageCode)
        {
            if (localizeDictionary.ContainsKey(languageCode))
            {
                CurrentLanguageCode = languageCode;
                PlayerPrefs.SetString("LanguageCode", languageCode);
                PlayerPrefs.Save();
                _onLanguageChangedSubject?.OnNext(Unit.Default);
            }
            else
            {
                Debug.LogError($"[Localize] Language Code : {languageCode} is not found");
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChallengeSaveLoadTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Challenge;
using Game.Context;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.CombinedTest.Server.PacketTest.Event;
using Tests.Module.TestMod;

namespace Tests.CombinedTest.Game
{
    public class ChallengeSaveLoadTest
    {
        private const int PlayerId = 1;
        
        [Test]
        public void NonCompletedChallengeSaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            
            // ID
            // create a challenge for that player ID
            var challengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            // 
            // Check that the initial challenge is set correctly
            var initialChallenge = MasterHolder.ChallengeMaster.InitialChallenge.Select(MasterHolder.ChallengeMaster.GetChallenge).ToList();
            Assert.AreEqual(initialChallenge.Count,challengeInfo.CurrentChallenges.Count);
            foreach (var currentChallenge in challengeInfo.CurrentChallenges)
            {
                var challenge = initialChallenge.Find(c => c.ChallengeGuid == currentChallenge.ChallengeMasterElement.ChallengeGuid);
                Assert.IsNotNull(challenge);
            }
            
            
            // 
            // Save without clearing anything
            var saveJson = assembleSaveJsonText.AssembleSaveJson();
            
            // 
            // load
            (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            (serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(saveJson);
            
            // 
            // Check that the initial challenge is set correctly
            challengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            Assert.AreEqual(initialChallenge.Count,challengeInfo.CurrentChallenges.Count);
            foreach (var currentChallenge in challengeInfo.CurrentChallenges)
            {
                var challenge = initialChallenge.Find(c => c.ChallengeGuid == currentChallenge.ChallengeMasterElement.ChallengeGuid);
                Assert.IsNotNull(challenge);
            }
            // 
            // Check that nothing is cleared
            Assert.AreEqual(0,challengeInfo.CompletedChallengeGuids.Count);
        }
        
        [Test]
        public void CompletedChallengeSaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            
            // ID
            // create a challenge for that player ID
            var challengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            
            // 
            // Check that the initial challenge is set correctly
            var initialChallenge = MasterHolder.ChallengeMaster.InitialChallenge.Select(MasterHolder.ChallengeMaster.GetChallenge).ToList();
            foreach (var currentChallenge in challengeInfo.CurrentChallenges)
            {
                var challenge = initialChallenge.Find(c => c.ChallengeGuid == currentChallenge.ChallengeMasterElement.ChallengeGuid);
                Assert.IsNotNull(challenge);
            }
            
            // 
            // Clear the craft challenge
            ChallengeCompletedEventTest.ClearCraftChallenge(packet, serviceProvider);
            
            // 
            // Check that the craft challenge is cleared
            Assert.AreEqual(1, challengeInfo.CompletedChallengeGuids.Count);
            var currentChallengeCount = challengeInfo.CurrentChallenges.Count;
            
            // 
            // Save
            var saveJson = assembleSaveJsonText.AssembleSaveJson();
            
            // 
            // load
            (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            challengeDatastore = serviceProvider.GetService<ChallengeDatastore>();
            (serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(saveJson);
            
            // 
            // Check that the challenge is cleared
            var loadedChallengeInfo = challengeDatastore.GetOrCreateChallengeInfo(PlayerId);
            Assert.AreEqual(1, loadedChallengeInfo.CompletedChallengeGuids.Count);
            var challengeGuid = new Guid("00000000-0000-0000-4567-000000000001");
            Assert.AreEqual(challengeGuid, loadedChallengeInfo.CompletedChallengeGuids[0]);
            
            Assert.AreEqual(currentChallengeCount, loadedChallengeInfo.CurrentChallenges.Count);
            for (int i = 0; i < loadedChallengeInfo.CompletedChallengeGuids.Count; i++)
            {
                Assert.AreEqual(challengeInfo.CompletedChallengeGuids[i], loadedChallengeInfo.CompletedChallengeGuids[i]);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapVeinDatastore.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Map.Interface.Json;
using Game.Map.Interface.Vein;
using UnityEngine;

namespace Game.Map
{
    public class MapVeinDatastore : IMapVeinDatastore
    {
        private readonly List<IMapVein> _mapVeins = new();
        
        public MapVeinDatastore(MapInfoJson mapInfoJson)
        {
            //configmap obejct
            foreach (var veinJson in mapInfoJson.MapVeins)
            {
                var itemId = MasterHolder.ItemMaster.GetItemId(veinJson.VeinItemGuid);
                var vein = new MapVein(itemId, veinJson.MinPosition, veinJson.MaxPosition);
                _mapVeins.Add(vein);
            }
        }
        
        public List<IMapVein> GetOverVeins(Vector3Int pos)
        {
            var veins = new List<IMapVein>();
            foreach (var vein in _mapVeins)
                if (vein.VeinRangeMin.x <= pos.x && pos.x <= vein.VeinRangeMax.x &&
                    vein.VeinRangeMin.y <= pos.y && pos.y <= vein.VeinRangeMax.y)
                    veins.Add(vein);
            
            return veins;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Template/CraftChainerProviderChestTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Chest;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.CraftChainer.BlockComponent.ProviderChest;
using Game.CraftChainer.CraftNetwork;
using Mooresmaster.Model.BlocksModule;

namespace Game.CraftChainer.BlockComponent.Template
{
    public class CraftChainerProviderChestTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var chest = blockMasterElement.BlockParam as CraftChainerProviderChestBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(chest.InventoryConnectors, blockPositionInfo);
            
            var chainerProviderChestComponent = componentStates == null ?
                new CraftChainerProviderChestComponent() :
                new CraftChainerProviderChestComponent(componentStates);
            
            var inserter = new CraftChainerProviderChestBlockInventoryInserter(chainerProviderChestComponent.NodeId, inputConnectorComponent);
            
            var chestComponent = componentStates == null ? 
                new VanillaChestComponent(blockInstanceId, chest.ItemSlotCount, inserter) : 
                new VanillaChestComponent(componentStates, blockInstanceId, chest.ItemSlotCount, inserter);
            
            chainerProviderChestComponent.SetInitialVanillaChestComponent(chestComponent);
            
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
                chainerProviderChestComponent
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/PlaceBlockFromHotBarProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SendPlaceHotBarBlockProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:palceHotbarBlock";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public SendPlaceHotBarBlockProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SendPlaceHotBarBlockProtocolMessagePack>(payload.ToArray());
            var inventoryData = _playerInventoryDataStore.GetInventoryData(data.PlayerId);
            
            foreach (var placeInfo in data.PlacePositions)
            {
                PlaceBlock(placeInfo, data, inventoryData);
            }
            
            return null;
        }
        
        #region GetResponse
        
        static void PlaceBlock(PlaceInfoMessagePack placeInfo, SendPlaceHotBarBlockProtocolMessagePack data, PlayerInventoryData inventoryData)
        {
            //
            if (ServerContext.WorldBlockDatastore.Exists(placeInfo.Position)) return;
            
            //IDID
            var item = inventoryData.MainOpenableInventory.GetItem(data.InventorySlot);
            if (!MasterHolder.BlockMaster.IsBlock(item.Id)) return;
            
            // ID
            var blockId = MasterHolder.BlockMaster.GetBlockId(item.Id);
            blockId = blockId.GetVerticalOverrideBlockId(placeInfo.VerticalDirection);
            
            //
            ServerContext.WorldBlockDatastore.TryAddBlock(blockId, placeInfo.Position, placeInfo.Direction, out var block);
            
            //
            item = item.SubItem(1);
            inventoryData.MainOpenableInventory.SetItem(data.InventorySlot, item);
        }
        
        #endregion
        
        
        [MessagePackObject]
        public class SendPlaceHotBarBlockProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Key(3)] public int HotBarSlot { get; set; }
            [IgnoreMember] public int InventorySlot => PlayerInventoryConst.HotBarSlotToInventorySlot(HotBarSlot);
            
            [Key(4)] public List<PlaceInfoMessagePack> PlacePositions { get; set; }
            
            public SendPlaceHotBarBlockProtocolMessagePack(int playerId, int hotBarSlot, List<PlaceInfo> placeInfos)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                HotBarSlot = hotBarSlot;
                PlacePositions = placeInfos.ConvertAll(v => new PlaceInfoMessagePack(v));
            }
            
            [Obsolete("")]
            public SendPlaceHotBarBlockProtocolMessagePack() { }
        }
        
        [MessagePackObject]
        public class PlaceInfoMessagePack
        {
            [Key(0)] public Vector3IntMessagePack Position { get; set; }
            
            [Key(1)] public BlockDirection Direction { get; set; }
            
            [Key(2)] public BlockVerticalDirection VerticalDirection { get; set; }
            
            [Obsolete("")]
            public PlaceInfoMessagePack() { }
            
            public PlaceInfoMessagePack(PlaceInfo placeInfo)
            {
                Position = new Vector3IntMessagePack(placeInfo.Position);
                Direction = placeInfo.Direction;
                VerticalDirection = placeInfo.VerticalDirection;
            }
        }
    }
    
    public class PlaceInfo
    {
        public Vector3Int Position { get; set; }
        public BlockDirection Direction { get; set; }
        public BlockVerticalDirection VerticalDirection { get; set; }
        
        public bool Placeable { get; set; }
    }
}
```

moorestech_client/Assets/Scripts/Editor/TreePlacer.cs
```cs
using System;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using Random = UnityEngine.Random;

public class TreePlacer : EditorWindow
{
    // Prefab
    [SerializeField] private GameObject[] treePrefabs = Array.Empty<GameObject>();
    
    private float _maxTreeInterval = 8.0f;
    private float _maxTreeSize = 1.3f;
    
    //
    private float _minTreeInterval = 4.5f;
    
    //
    private float _minTreeSize = 0.8f;
    
    // 
    private Vector2 _offset = Vector2.zero;
    
    // 
    private Vector2 _origin = Vector2.zero;
    
    private GameObject _parent;
    
    // 
    private Vector2 _range = new(100, 100);
    
    
    // 
    private float _scale = 0.1f;
    
    // 
    private List<GameObject> _trees = new();
    
    // GUI
    private void OnGUI()
    {
        var so = new SerializedObject(this);
        so.Update();
        
        
        // 
        _scale = EditorGUILayout.FloatField("Scale", _scale);
        // 
        _offset = EditorGUILayout.Vector2Field("Offset", _offset);
        // 
        _range = EditorGUILayout.Vector2Field("Range", _range);
        // 
        _origin = EditorGUILayout.Vector2Field("Origin", _origin);
        //
        _minTreeInterval = EditorGUILayout.FloatField("MinTreeInterval", _minTreeInterval);
        _maxTreeInterval = EditorGUILayout.FloatField("MaxTreeInterval", _maxTreeInterval);
        //
        _minTreeSize = EditorGUILayout.FloatField("MinTreeSize", _minTreeSize);
        _maxTreeSize = EditorGUILayout.FloatField("MaxTreeSize", _maxTreeSize);
        
        // Prefab
        EditorGUILayout.PropertyField(so.FindProperty(nameof(treePrefabs)), true);
        
        _parent = EditorGUILayout.ObjectField("Parent", _parent, typeof(GameObject), true) as GameObject;
        
        // 
        if (GUILayout.Button("Place Trees")) OnPlaceButton();
        
        if (GUILayout.Button("")) _trees.Clear();
        
        so.ApplyModifiedProperties();
    }
    
    [MenuItem("Tools/TreePlacer")]
    private static void ShowWindow()
    {
        var window = GetWindow<TreePlacer>();
        window.titleContent = new GUIContent("TreePlacer");
        window.Show();
    }
    
    // 
    private void OnPlaceButton()
    {
        // 
        var min = _origin - _range * 0.5f;
        var max = _origin + _range * 0.5f;
        
        // 
        foreach (var tree in _trees) DestroyImmediate(tree);
        
        _trees = new List<GameObject>();
        
        // 
        for (var x = min.x; x < max.x; x += _minTreeInterval)
        for (var y = min.y; y < max.y; y += _minTreeInterval)
        {
            var tmpX = x + Random.Range(_minTreeInterval, _maxTreeInterval);
            var tmpY = y + Random.Range(_minTreeInterval, _maxTreeInterval);
            // 
            var noise = Mathf.PerlinNoise((tmpX + _offset.x) * _scale, (tmpY + _offset.y) * _scale);
            // 0.5
            if (!(noise > 0.5f)) continue;
            
            // Prefab
            var prefab = treePrefabs[Random.Range(0, treePrefabs.Length)];
            // 
            var tree = PrefabUtility.InstantiatePrefab(prefab) as GameObject;
            tree.transform.parent = _parent.transform;
            tree.transform.position = new Vector3(tmpX, 0, tmpY);
            var randomRotation = new Vector3(0, Random.Range(0, 360), 0);
            tree.transform.Rotate(randomRotation);
            var randomScale = Random.Range(_minTreeSize, _maxTreeSize);
            tree.transform.localScale = new Vector3(randomScale, randomScale, randomScale);
            // 
            _trees.Add(tree);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/RecipeViewerTabElement.cs
```cs
using System;
using Client.Mod.Texture;
using Core.Master;
using UniRx;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class RecipeViewerTabElement : MonoBehaviour, IPointerDownHandler
    {
        [SerializeField] private RectTransform selectedTab;
        [SerializeField] private RectTransform unselectedTab;
        [SerializeField] private Image selectedIcon;
        [SerializeField] private Image unselectedIcon;
        
        [SerializeField] private Sprite craftIcon;
        
        public IObservable<RecipeViewerTabElement> OnClickTab => onClickTab; // nullCraft
        private readonly Subject<RecipeViewerTabElement> onClickTab = new(); // If null, it means that Craft is selected
        
        private RectTransform _rectTransform;
        public BlockId? CurrentBlockId { get; private set; }
    
        public void Initialize()
        {
            _rectTransform = GetComponent<RectTransform>();
        }
        
        public void SetSelected(bool selected)
        {
            selectedTab.gameObject.SetActive(selected);
            unselectedTab.gameObject.SetActive(!selected);
            var width = selected ? selectedTab.rect.width : unselectedTab.rect.width;
            
            _rectTransform.sizeDelta = new Vector2(width, _rectTransform.sizeDelta.y);
        }
        
        public void SetMachineItem(BlockId blockId, ItemViewData itemViewData)
        {
            CurrentBlockId = blockId;
            selectedIcon.sprite = itemViewData.ItemImage;
            unselectedIcon.sprite = itemViewData.ItemImage;
            
        }
        
        public void SetCraftIcon()
        {
            CurrentBlockId = null;
            selectedIcon.sprite = craftIcon;
            unselectedIcon.sprite = craftIcon;
        }
        
        public void OnPointerDown(PointerEventData eventData)
        {
            onClickTab.OnNext(this);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/GearBeltConveyorComponent.cs
```cs
using System;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;

namespace Game.Block.Blocks.BeltConveyor
{
    public class GearBeltConveyorComponent : GearEnergyTransformer, IUpdatableBlockComponent
    {
        private readonly VanillaBeltConveyorComponent _beltConveyorComponent;
        private readonly double _beltConveyorSpeed;
        private readonly Torque _requiredTorque;
        
        public GearBeltConveyorComponent(VanillaBeltConveyorComponent beltConveyorComponent, BlockInstanceId entityId, double beltConveyorSpeed, Torque requiredTorque, BlockConnectorComponent<IGearEnergyTransformer> blockConnectorComponent)
            : base(requiredTorque, entityId, blockConnectorComponent)
        {
            _beltConveyorComponent = beltConveyorComponent;
            _requiredTorque = requiredTorque;
            _beltConveyorSpeed = beltConveyorSpeed;
        }
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
        }
        
        public override void SupplyPower(RPM rpm, Torque torque, bool isClockwise)
        {
            base.SupplyPower(rpm, torque, isClockwise);
            var torqueRate = torque / _requiredTorque;
            var speed = torqueRate.AsPrimitive() * rpm.AsPrimitive() * _beltConveyorSpeed;
            _beltConveyorComponent.SetTimeOfItemEnterToExit(1 / speed);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/MultiSizeBlockTest.cs
```cs
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.World.Interface.DataStore;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    public class MultiSizeBlockTest
    {
        public static readonly BlockId Block_1x4_Id = (BlockId)9;
        public static readonly BlockId Block_3x2_Id = (BlockId)10;
        public static readonly BlockId Block_1x2x3_Id = (BlockId)11;
        
        private IWorldBlockDatastore worldDatastore;
        
        [Test]
        public void BlockPlaceAndGetTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            worldDatastore = ServerContext.WorldBlockDatastore;
            
            //
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(10, 0, 10), BlockDirection.North, out _);
            RetrieveBlock(Block_1x4_Id, new Vector3Int(10, 0, 10));
            RetrieveBlock(Block_1x4_Id, new Vector3Int(10, 0, 13));
            RetrieveNonExistentBlock(new Vector3Int(9, 0, 10));
            RetrieveNonExistentBlock(new Vector3Int(10, 0, 15));
            
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(10, 0, -10), BlockDirection.East, out _);
            RetrieveBlock(Block_1x4_Id, new Vector3Int(10, 0, -10));
            RetrieveBlock(Block_1x4_Id, new Vector3Int(13, 0, -10));
            RetrieveNonExistentBlock(new Vector3Int(9, 0, -10));
            RetrieveNonExistentBlock(new Vector3Int(15, 0, -10));
            
            worldDatastore.TryAddBlock(Block_3x2_Id, new Vector3Int(-10, 0, -10), BlockDirection.South, out _);
            RetrieveBlock(Block_3x2_Id, new Vector3Int(-10, 0, -10));
            RetrieveBlock(Block_3x2_Id, new Vector3Int(-8, 0, -9));
            RetrieveNonExistentBlock(new Vector3Int(-10, 0, -11));
            RetrieveNonExistentBlock(new Vector3Int(-7, 0, -9));
            
            //
            worldDatastore.TryAddBlock(Block_1x2x3_Id, new Vector3Int(20, 0, 20), BlockDirection.North, out _);
            RetrieveBlock(Block_1x2x3_Id, new Vector3Int(20, 0, 20));
            RetrieveBlock(Block_1x2x3_Id, new Vector3Int(20, 1, 22));
            RetrieveNonExistentBlock(new Vector3Int(21, 1, 22));
            RetrieveNonExistentBlock(new Vector3Int(20, 2, 22));
            RetrieveNonExistentBlock(new Vector3Int(20, 1, 23));
            
            worldDatastore.TryAddBlock(Block_1x2x3_Id, new Vector3Int(40, 0, 40), BlockDirection.UpEast, out _);
            RetrieveBlock(Block_1x2x3_Id, new Vector3Int(40, 0, 40));
            RetrieveBlock(Block_1x2x3_Id, new Vector3Int(41, 2, 40));
            RetrieveNonExistentBlock(new Vector3Int(42, 2, 40));
            RetrieveNonExistentBlock(new Vector3Int(41, 3, 40));
            RetrieveNonExistentBlock(new Vector3Int(41, 2, 41));
        }
        
        
        [Test]
        public void OverlappingBlockTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            worldDatastore = ServerContext.WorldBlockDatastore;
            
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(10, 0, 10), BlockDirection.North, out _);
            worldDatastore.TryAddBlock(Block_3x2_Id, new Vector3Int(10, 0, 12), BlockDirection.South, out _);
            
            //3x2
            RetrieveBlock(Block_3x2_Id, new Vector3Int(11, 0, 12));
        }
        
        [Test]
        public void BoundaryBlockTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            worldDatastore = ServerContext.WorldBlockDatastore;
            
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(10, 0, 10), BlockDirection.North, out _);
            worldDatastore.TryAddBlock(Block_1x4_Id, new Vector3Int(11, 0, 11), BlockDirection.East, out _);
            
            //1x4
            RetrieveBlock(Block_1x4_Id, new Vector3Int(11, 0, 11));
        }
        
        /// <summary>
        ///     
        /// </summary>
        private void RetrieveBlock(BlockId expectedBlockId, Vector3Int position)
        {
            var block = worldDatastore.GetBlock(position);
            Assert.IsNotNull(block);
            Assert.AreEqual(expectedBlockId, block.BlockId);
        }
        
        /// <summary>
        ///     
        /// </summary>
        private void RetrieveNonExistentBlock(Vector3Int position)
        {
            Assert.False(worldDatastore.Exists(position));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailNodeId.cs
```cs
using System;
using UnitGenerator;

namespace Game.Train.RailGraph
{
    //uint
    [UnitOf(typeof(uint))]
    public partial struct RailNodeId
    {
        private static readonly Random Random = new();
        
        public static RailNodeId Create()
        {
            uint result = (uint)Random.Next(int.MinValue, int.MaxValue);
            return new RailNodeId(result);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Crafter/CraftCraftChainerCrafterComponent.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using MessagePack;
using Newtonsoft.Json;

namespace Game.CraftChainer.BlockComponent.Crafter
{
    public class CraftCraftChainerCrafterComponent : ICraftChainerNode, IBlockStateDetail
    {
        public CraftChainerNodeId NodeId { get; } = CraftChainerNodeId.Create();
        
        public CraftingSolverRecipe CraftingSolverRecipe { get; private set; } = new();
        
        public CraftCraftChainerCrafterComponent() { }
        
        public CraftCraftChainerCrafterComponent(Dictionary<string, string> componentStates) : this()
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerCrafterComponentSerializeObject>(state);
            CraftingSolverRecipe = jsonObject.Recipe.ToCraftingSolverRecipe();
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        public void SetRecipe(List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
        {
            var id = CraftingSolverRecipeId.Create();
            CraftingSolverRecipe = new CraftingSolverRecipe(id, inputItems, outputItem);
        }
        
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public BlockStateDetail GetBlockStateDetail()
        {
            var bytes = MessagePackSerializer.Serialize(new ChainerCrafterComponentSerializeObject(this));
            return new BlockStateDetail(ChainerCrafterComponentSerializeObject.StateDetailKey, bytes);
        }
        
        public string SaveKey { get; } = typeof(CraftCraftChainerCrafterComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerCrafterComponentSerializeObject(this));
        }
    }
    
    [JsonObject, MessagePackObject]
    public class ChainerCrafterComponentSerializeObject
    {
        public const string StateDetailKey = "ChainerCrafterComponent";
        
        [JsonProperty("recipe"), Key(0)] public CraftingSolverRecipeJsonObjectMessagePack Recipe { get; set; }
        [JsonProperty("nodeId"), Key(1)] public int NodeId { get; set; }
        
        public ChainerCrafterComponentSerializeObject(){}
        public ChainerCrafterComponentSerializeObject(CraftCraftChainerCrafterComponent component)
        {
            Recipe = new CraftingSolverRecipeJsonObjectMessagePack(component.CraftingSolverRecipe);
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/MainInventoryUpdateEventPacket.cs
```cs
using System;
using Core.Item.Interface;
using Game.PlayerInventory.Interface.Event;
using MessagePack;
using Server.Util.MessagePack;

namespace Server.Event.EventReceive
{
    public class MainInventoryUpdateEventPacket
    {
        public const string EventTag = "va:event:mainInvUpdate";
        private readonly EventProtocolProvider _eventProtocolProvider;
        
        public MainInventoryUpdateEventPacket(IMainInventoryUpdateEvent mainInventoryUpdateEvent,
            EventProtocolProvider eventProtocolProvider)
        {
            _eventProtocolProvider = eventProtocolProvider;
            mainInventoryUpdateEvent.Subscribe(ReceivedEvent);
        }
        
        
        private void ReceivedEvent(PlayerInventoryUpdateEventProperties playerInventoryUpdateEvent)
        {
            var messagePack = new MainInventoryUpdateEventMessagePack(playerInventoryUpdateEvent.InventorySlot, playerInventoryUpdateEvent.ItemStack);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            _eventProtocolProvider.AddEvent(playerInventoryUpdateEvent.PlayerId, EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class MainInventoryUpdateEventMessagePack
    {
        [Obsolete("")]
        public MainInventoryUpdateEventMessagePack()
        {
        }
        
        public MainInventoryUpdateEventMessagePack(int slot, IItemStack itemStack)
        {
            Slot = slot;
            Item = new ItemMessagePack(itemStack.Id, itemStack.Count);
        }
        
        [Key(0)] public int Slot { get; set; }
        
        [Key(1)] public ItemMessagePack Item { get; set; }
    }
}
```

moorestech_client/Assets/Scripts/Editor/MapExportAndSetting.cs
```cs
using System.Collections.Generic;
using System.IO;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Map.MapVein;
using Game.Map.Interface.Json;
using Newtonsoft.Json;
using UnityEditor;
using UnityEngine;

public class MapExportAndSetting : EditorWindow
{
    private void OnGUI()
    {
        if (!GUILayout.Button("Export and Setting Map")) return;
        
        var mapObjectConfig = new MapInfoJson
        {
            MapObjects = SetUpMapObjectInfos(),
            MapVeins = GetMapVeinInfo(),
        };
        
        // json
        var json = JsonConvert.SerializeObject(mapObjectConfig, Formatting.Indented);
        
        //
        var path = EditorUtility.SaveFilePanel("Save map object config", "../../Server/map/", "map", "json");
        if (path.Length != 0) File.WriteAllText(path, json);
        
        
        #region Internal
        
        List<MapObjectInfoJson> SetUpMapObjectInfos()
        {
            var datastore = FindObjectOfType<MapObjectGameObjectDatastore>();
            datastore.FindMapObjects();
            EditorUtility.SetDirty(datastore);
            
            var instanceId = 0;
            var result = new List<MapObjectInfoJson>();
            
            foreach (var mapObject in datastore.MapObjects)
            {
                mapObject.SetMapObjectData(instanceId);
                instanceId++;
                
                var config = new MapObjectInfoJson
                {
                    MapObjectGuidStr = mapObject.MapObjectGuid.ToString(),
                    InstanceId = mapObject.InstanceId,
                    X = mapObject.GetPosition().x,
                    Y = mapObject.GetPosition().y,
                    Z = mapObject.GetPosition().z,
                };
                result.Add(config);
            }
            
            return result;
        }
        
        List<MapVeinInfoJson> GetMapVeinInfo()
        {
            var veins = FindObjectsOfType<MapVeinGameObject>();
            var result = new List<MapVeinInfoJson>();
            
            foreach (var vein in veins)
            {
                var config = new MapVeinInfoJson
                {
                    VeinItemGuidStr = vein.VeinItemGuid.ToString(),
                    MinX = vein.MinPosition.x,
                    MinY = vein.MinPosition.y,
                    MinZ = vein.MinPosition.z,
                    
                    MaxX = vein.MaxPosition.x,
                    MaxY = vein.MaxPosition.y,
                    MaxZ = vein.MaxPosition.z,
                };
                result.Add(config);
            }
            
            return result;
        }
        
        #endregion
    }
    
    [MenuItem("moorestech/MapExportAndSetting")]
    private static void ShowWindow()
    {
        var window = GetWindow<MapExportAndSetting>();
        window.titleContent = new GUIContent("MapExportAndSetting");
        window.Show();
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/MapObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.Map.Interface.Json;
using Game.Map.Interface.MapObject;
using Game.SaveLoad.Json;

namespace Game.Map
{
    public class MapObjectDatastore : IMapObjectDatastore
    {
        private readonly IMapObjectFactory _mapObjectFactory;
        
        /// <summary>
        ///     
        ///     mapObject
        ///     <see cref="WorldLoaderFromJson" />
        /// </summary>
        private readonly Dictionary<int, IMapObject> _mapObjects = new();
        
        public MapObjectDatastore(IMapObjectFactory mapObjectFactory, MapInfoJson mapInfoJson)
        {
            _mapObjectFactory = mapObjectFactory;
            
            foreach (var mapObjectInfo in mapInfoJson.MapObjects)
            {
                var mapObjectConfig = MasterHolder.MapObjectMaster.GetMapObjectElement(mapObjectInfo.MapObjectGuid);
                var hp = mapObjectConfig.Hp;
                
                var mapObject = _mapObjectFactory.Create(mapObjectInfo.InstanceId, mapObjectInfo.MapObjectGuid, hp, false, mapObjectInfo.Position);
                _mapObjects.Add(mapObject.InstanceId, mapObject);
                mapObject.OnDestroy += () => OnDestroyMapObject?.Invoke(mapObject);
            }
        }
        
        public event Action<IMapObject> OnDestroyMapObject;
        
        public IReadOnlyList<IMapObject> MapObjects => _mapObjects.Values.ToList();
        
        public void Add(IMapObject mapObject)
        {
            _mapObjects.Add(mapObject.InstanceId, mapObject);
            mapObject.OnDestroy += () => OnDestroyMapObject?.Invoke(mapObject);
        }
        
        public IMapObject Get(int instanceId)
        {
            return _mapObjects[instanceId];
        }
        
        public void LoadMapObject(List<MapObjectJsonObject> savedMapObjects)
        {
            foreach (var savedMapObject in savedMapObjects)
            {
                if (!_mapObjects.TryGetValue(savedMapObject.instanceId, out var loadedMapObject)) throw new KeyNotFoundException($"ID: {savedMapObject.instanceId} mapObject");
                
                //
                if (savedMapObject.isDestroyed) loadedMapObject.Destroy();
                if (savedMapObject.hp != loadedMapObject.CurrentHp) loadedMapObject.Attack(loadedMapObject.CurrentHp - savedMapObject.hp);
            }
        }
        
        public List<MapObjectJsonObject> GetSaveJsonObject()
        {
            return _mapObjects.Select(m => new MapObjectJsonObject(m.Value)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/RequestWorldDataProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Context;
using Game.Entity.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse.Util;
using Server.Util.MessagePack;

namespace Server.Protocol.PacketResponse
{
    public class RequestWorldDataProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:getWorldData";
        private readonly IEntityFactory _entityFactory;
        
        public RequestWorldDataProtocol(ServiceProvider serviceProvider)
        {
            _entityFactory = serviceProvider.GetService<IEntityFactory>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var blockMasterDictionary = ServerContext.WorldBlockDatastore.BlockMasterDictionary;
            var blockResult = new List<BlockDataMessagePack>();
            foreach (var blockMaster in blockMasterDictionary)
            {
                var block = blockMaster.Value.Block;
                var pos = blockMaster.Value.BlockPositionInfo.OriginalPos;
                var blockDirection = blockMaster.Value.BlockPositionInfo.BlockDirection;
                blockResult.Add(new BlockDataMessagePack(block.BlockId, pos, blockDirection));
            }
            
            //TODO  entity
            var items = CollectBeltConveyorItems.CollectItemFromWorld(_entityFactory);
            var entities = new List<EntityMessagePack>();
            entities.AddRange(items.Select(item => new EntityMessagePack(item)));
            
            
            return new ResponseWorldDataMessagePack(blockResult.ToArray(), entities.ToArray());
        }
        
        
        [MessagePackObject]
        public class RequestWorldDataMessagePack : ProtocolMessagePackBase
        {
            public RequestWorldDataMessagePack()
            {
                Tag = ProtocolTag;
            }
        }
        
        [MessagePackObject]
        public class ResponseWorldDataMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public BlockDataMessagePack[] Blocks { get; set; }
            [Key(3)] public EntityMessagePack[] Entities { get; set; }
            
            [Obsolete("")]
            public ResponseWorldDataMessagePack() { }
            public ResponseWorldDataMessagePack(BlockDataMessagePack[] Block, EntityMessagePack[] entities)
            {
                Tag = ProtocolTag;
                Blocks = Block;
                Entities = entities;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaChestTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.Service;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaChestTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var chest = blockMasterElement.BlockParam as ChestBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(chest.InventoryConnectors, blockPositionInfo);
            var inserter = new ConnectingInventoryListPriorityInsertItemService(inputConnectorComponent);
            
            var chestComponent = componentStates == null ?
                new VanillaChestComponent(blockInstanceId, chest.ChestItemSlotCount, inserter) :
                new VanillaChestComponent(componentStates, blockInstanceId, chest.ChestItemSlotCount, inserter);
            
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Sequence/ChallengeManager.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.BackgroundSkit;
using Client.Game.InGame.Context;
using Client.Game.InGame.Tutorial;
using Client.Network.API;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Challenge;
using Game.Context;
using MessagePack;
using Mooresmaster.Model.ChallengesModule;
using Server.Event.EventReceive;
using TMPro;
using UnityEngine;
using VContainer;

namespace Client.Game.Sequence
{
    public class ChallengeManager : MonoBehaviour
    {
        [SerializeField] private TMP_Text currentChallengeSummary;
        [SerializeField] private BackgroundSkitManager backgroundSkitManager;
        
        [SerializeField] private List<ChallengeTextAsset> challengeTextAssets;
        
        private TutorialManager _tutorialManager;
        
        [Inject]
        public void Construct(InitialHandshakeResponse initialHandshakeResponse, TutorialManager tutorialManager)
        {
            _tutorialManager = tutorialManager;
            
            //TODO 
            if (initialHandshakeResponse.Challenge.CurrentChallenges.Count != 0)
            {
                var currentChallenge = initialHandshakeResponse.Challenge.CurrentChallenges.First();
                if (currentChallenge != null) currentChallengeSummary.text = currentChallenge.Summary;
                
                ClientContext.VanillaApi.Event.SubscribeEventResponse(CompletedChallengeEventPacket.EventTag, OnCompletedChallenge);
                
                // 
                // Apply tutorial
                initialHandshakeResponse.Challenge.CurrentChallenges.ForEach(c => _tutorialManager.ApplyTutorial(c.ChallengeGuid));
            }
        }
        
        private void OnCompletedChallenge(byte[] packet)
        {
            var message = MessagePackSerializer.Deserialize<CompletedChallengeEventMessage>(packet);
            var challengeInfo = MasterHolder.ChallengeMaster.GetChallenge(message.CompletedChallengeGuid);
            var nextChallenges = MasterHolder.ChallengeMaster.GetNextChallenges(challengeInfo.ChallengeGuid);
            
            // 
            _tutorialManager.CompleteChallenge(message.CompletedChallengeGuid);
            
            // 
            // Play background skit
            PlaySkit(nextChallenges).Forget();
            
            //  TODO 
            // Update challenge text TODO Correspond to multiple challenges
            if (nextChallenges.Count != 0)
            {
                var nextChallenge = nextChallenges.First();
                currentChallengeSummary.text = nextChallenge.Summary;
            }
            
            // 
            // Apply tutorial
            nextChallenges.ForEach(id => _tutorialManager.ApplyTutorial(id.ChallengeGuid));
        }
        
        private async UniTask PlaySkit(List<ChallengeMasterElement> nextChallenges)
        {
            foreach (var challenge in nextChallenges)
            {
                if (challenge.PlaySkitType == "BackgroundSkit") // TODO 
                {
                    var skitParam = (BackgroundSkitPlaySkitParam) challenge.PlaySkitParam;
                    var challengeTextAsset = challengeTextAssets.FirstOrDefault(x => x.SkitName == skitParam.FireSkitName);
                    if (challengeTextAsset == null) continue;
                    
                    await backgroundSkitManager.StartBackgroundSkit(challengeTextAsset.TextAsset);
                }
            }
        }
    }
    
    [Serializable]
    public class ChallengeTextAsset
    {
        public string SkitName;
        public TextAsset TextAsset;
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/PlayerInventoryDataStore.cs
```cs
using System.Collections.Generic;
using Game.PlayerInventory.Event;
using Game.PlayerInventory.Interface;
using Game.PlayerInventory.Interface.Event;
using Game.PlayerInventory.ItemManaged;

namespace Game.PlayerInventory
{
    /// <summary>
    ///     
    /// </summary>
    public class PlayerInventoryDataStore : IPlayerInventoryDataStore
    {
        private readonly GrabInventoryUpdateEvent _grabInventoryUpdateEvent;
        
        
        private readonly MainInventoryUpdateEvent _mainInventoryUpdateEvent;
        private readonly Dictionary<int, PlayerInventoryData> _playerInventoryData = new();
        
        public PlayerInventoryDataStore(IMainInventoryUpdateEvent mainInventoryUpdateEvent, IGrabInventoryUpdateEvent grabInventoryUpdateEvent)
        {
            //
            _mainInventoryUpdateEvent = (MainInventoryUpdateEvent)mainInventoryUpdateEvent;
            _grabInventoryUpdateEvent = (GrabInventoryUpdateEvent)grabInventoryUpdateEvent;
        }
        
        public PlayerInventoryData GetInventoryData(int playerId)
        {
            if (!_playerInventoryData.ContainsKey(playerId))
            {
                var main = new MainOpenableInventoryData(playerId, _mainInventoryUpdateEvent);
                var grab = new GrabInventoryData(playerId, _grabInventoryUpdateEvent);
                
                _playerInventoryData.Add(playerId, new PlayerInventoryData(main, grab));
            }
            
            return _playerInventoryData[playerId];
        }
        
        public List<PlayerInventorySaveJsonObject> GetSaveJsonObject()
        {
            var savePlayerInventoryList = new List<PlayerInventorySaveJsonObject>();
            //
            foreach (var inventory in _playerInventoryData)
            {
                var saveInventoryData = new PlayerInventorySaveJsonObject(inventory.Key, inventory.Value);
                savePlayerInventoryList.Add(saveInventoryData);
            }
            
            return savePlayerInventoryList;
        }
        
        /// <summary>
        ///     
        /// </summary>
        public void LoadPlayerInventory(List<PlayerInventorySaveJsonObject> saveInventoryDataList)
        {
            foreach (var saveInventory in saveInventoryDataList)
            {
                var playerId = saveInventory.PlayerId;
                (var mainItems, var grabItem) = saveInventory.GetPlayerInventoryData();
                
                //
                var main = new MainOpenableInventoryData(playerId, _mainInventoryUpdateEvent, mainItems);
                var grab = new GrabInventoryData(playerId, _grabInventoryUpdateEvent, grabItem);
                
                var playerInventory = new PlayerInventoryData(main, grab);
                
                //
                _playerInventoryData[playerId] = playerInventory;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/RendererMaterialReplacer.cs
```cs
using System;
using System.Collections.Generic;
using Client.Common;
using Client.Game.InGame.Context;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Client.Game.InGame.Block
{
    public class RendererMaterialReplacer
    {
        /// <summary>
        ///     
        ///     Do not replace materials if the game object's path contains any of the strings in this list.
        /// </summary>
        private readonly List<string> _ignoreGameObjectPathKeyWords = new() { "/VFX/"};
        
        private readonly Renderer _renderer;
        private readonly List<Material> _originalMaterials = new();
        private readonly List<Material> _replacedMaterials = new();
        
        public RendererMaterialReplacer(Renderer renderer)
        {
            var path = renderer.gameObject.GetFullPath();
            foreach (var keyWord in _ignoreGameObjectPathKeyWords)
            {
                if (!path.Contains(keyWord)) continue;
                return;
            }
            
            _renderer = renderer;
            _originalMaterials = new List<Material>();
            foreach (var material in renderer.sharedMaterials) _originalMaterials.Add(material);
        }
        
        public void CopyAndSetMaterial(Material placeMaterial)
        {
            if (_renderer == null) return;
            // TODO 
            if (placeMaterial == null) throw new NullReferenceException("The specified material is null.");
            
            // TODO 
            ResetMaterial();
            
            foreach (var material in _renderer.sharedMaterials)
            {
                var mainTexture = material.mainTexture;
                var mainColor = material.color;
                
                var newMaterial = new Material(placeMaterial)
                {
                    mainTexture = mainTexture,
                    mainTextureOffset = material.mainTextureOffset,
                    mainTextureScale = material.mainTextureScale,
                    color = mainColor,
                };
                
                _replacedMaterials.Add(newMaterial);
            }
            
            _renderer.materials = _replacedMaterials.ToArray();
        }
        
        public void SetPlaceMaterialProperty(string propertyName, float value)
        {
            foreach (var material in _replacedMaterials) material.SetFloat(propertyName, value);
        }
        
        public void SetColor(string propertyName, Color color)
        {
            foreach (var material in _replacedMaterials) material.SetColor(propertyName, color);
        }
        
        public void ResetMaterial()
        {
            if (_renderer == null) return;
            
            //
            foreach (var material in _replacedMaterials) Object.Destroy(material);
            _replacedMaterials.Clear();
            _renderer.materials = _originalMaterials.ToArray();
        }
        
        public void DestroyMaterial()
        {
            _replacedMaterials.Clear();
            _originalMaterials.Clear();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Util/UIEnterExplainerController.cs
```cs
using UnityEngine;
using UnityEngine.EventSystems;

namespace Client.Game.InGame.UI.Util
{
    /// <summary>
    ///     UIUI
    /// </summary>
    public class UIEnterExplainerController : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerMoveHandler
    {
        /// <summary>
        ///     
        /// </summary>
        [SerializeField] private string textKey;
        
        /// <summary>
        ///     
        /// </summary>
        [SerializeField] private bool displayEnable;
        
        [SerializeField] private int fontSize = IMouseCursorExplainer.DefaultFontSize;
        private bool _isLocalize;
        
        private bool _pointerStay;
        
        public void OnPointerMove(PointerEventData eventData)
        {
            _pointerStay = true;
            UpdateMouseCursorExplainer();
        }
        
        
        public void SetText(string text, bool isLocalize = true)
        {
            _isLocalize = isLocalize;
            textKey = text;
        }
        
        /// <summary>
        ///     
        /// </summary>
        private void UpdateMouseCursorExplainer()
        {
            //
            if (_pointerStay && displayEnable)
            {
                MouseCursorExplainer.Instance.Show(textKey, fontSize, _isLocalize);
                return;
            }
            
            if (!_pointerStay || //
                _pointerStay && !displayEnable) //
                MouseCursorExplainer.Instance.Hide();
        }
        
        
        #region 
        
        public void DisplayEnable(bool enable)
        {
            displayEnable = enable;
            if (_pointerStay) UpdateMouseCursorExplainer();
        }
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            _pointerStay = true;
            UpdateMouseCursorExplainer();
        }
        
        public void OnPointerExit(PointerEventData eventData)
        {
            _pointerStay = false;
            UpdateMouseCursorExplainer();
        }
        
        private void OnDestroy()
        {
            _pointerStay = false;
            UpdateMouseCursorExplainer();
        }
        
        private void OnDisable()
        {
            _pointerStay = false;
            UpdateMouseCursorExplainer();
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/DisconnectTwoOrMoreElectricPoleFromSegmentService.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class DisconnectTwoOrMoreElectricPoleFromSegmentService<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        public static void Disconnect(IElectricTransformer removedElectricPole,
            EnergyServiceDependencyContainer<TSegment> container)
        {
            //
            var removedSegment = container.WorldEnergySegmentDatastore.GetEnergySegment(removedElectricPole);
            
            //
            var connectedElectricPoles = new List<IElectricTransformer>();
            foreach (var onePole in removedSegment.EnergyTransformers) connectedElectricPoles.Add(onePole.Value);
            //
            connectedElectricPoles.Remove(removedElectricPole);
            
            
            //
            container.WorldEnergySegmentDatastore.RemoveEnergySegment(removedSegment);
            
            
            //
            //1
            //
            //
            while (connectedElectricPoles.Count != 0)
            {
                (var newElectricPoles, var newBlocks, var newGenerators) =
                    GetElectricPoles(
                        connectedElectricPoles[0],
                        removedElectricPole,
                        new Dictionary<BlockInstanceId, IElectricTransformer>(),
                        new Dictionary<BlockInstanceId, IElectricConsumer>(),
                        new Dictionary<BlockInstanceId, IElectricGenerator>(), container);
                
                
                //
                var newElectricSegment = container.WorldEnergySegmentDatastore.CreateEnergySegment();
                foreach (var newElectric in newElectricPoles)
                {
                    newElectricSegment.AddEnergyTransformer(newElectric.Value);
                    //
                    connectedElectricPoles.Remove(newElectric.Value);
                }
                
                foreach (var newBlock in newBlocks) newElectricSegment.AddEnergyConsumer(newBlock.Value);
                foreach (var newGenerator in newGenerators) newElectricSegment.AddGenerator(newGenerator.Value);
            }
        }
        
        // 
        private static (Dictionary<BlockInstanceId, IElectricTransformer>, Dictionary<BlockInstanceId, IElectricConsumer>,
            Dictionary<BlockInstanceId, IElectricGenerator>)
            GetElectricPoles(
                IElectricTransformer electricPole,
                IElectricTransformer removedElectricPole,
                Dictionary<BlockInstanceId, IElectricTransformer> electricPoles,
                Dictionary<BlockInstanceId, IElectricConsumer> blockElectrics,
                Dictionary<BlockInstanceId, IElectricGenerator> powerGenerators,
                EnergyServiceDependencyContainer<TSegment> container)
        {
            var pos = ServerContext.WorldBlockDatastore.GetBlockPosition(electricPole.BlockInstanceId);
            var block = ServerContext.WorldBlockDatastore.GetBlock(pos);
            var poleConfig = block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            
            
            //
            var (newBlocks, newGenerators) =
                FindMachineAndGeneratorFromPeripheralService.Find(pos, poleConfig);
            //
            foreach (var newBlock in newBlocks)
            {
                if (blockElectrics.ContainsKey(newBlock.BlockInstanceId)) continue;
                blockElectrics.Add(newBlock.BlockInstanceId, newBlock);
            }
            
            foreach (var generator in newGenerators)
            {
                if (powerGenerators.ContainsKey(generator.BlockInstanceId)) continue;
                powerGenerators.Add(generator.BlockInstanceId, generator);
            }
            
            
            //
            var peripheralElectricPoles = FindElectricPoleFromPeripheralService.Find(pos, poleConfig);
            //
            peripheralElectricPoles.Remove(removedElectricPole);
            //
            electricPoles.Add(electricPole.BlockInstanceId, electricPole);
            //
            if (peripheralElectricPoles.Count == 0) return (electricPoles, blockElectrics, powerGenerators);
            
            
            //
            foreach (var peripheralElectricPole in peripheralElectricPoles)
            {
                //
                if (electricPoles.ContainsKey(peripheralElectricPole.BlockInstanceId)) continue;
                //
                (electricPoles, blockElectrics, powerGenerators) =
                    GetElectricPoles(peripheralElectricPole, removedElectricPole, electricPoles, blockElectrics,
                        powerGenerators, container);
            }
            
            return (electricPoles, blockElectrics, powerGenerators);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponseCreator.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Event;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Server.Protocol
{
    public class PacketResponseCreator
    {
        private readonly Dictionary<string, IPacketResponse> _packetResponseDictionary = new();
        
        //TODO DI?
        public PacketResponseCreator(ServiceProvider serviceProvider)
        {
            _packetResponseDictionary.Add(InitialHandshakeProtocol.ProtocolTag, new InitialHandshakeProtocol(serviceProvider));
            _packetResponseDictionary.Add(RequestWorldDataProtocol.ProtocolTag, new RequestWorldDataProtocol(serviceProvider));
            _packetResponseDictionary.Add(PlayerInventoryResponseProtocol.ProtocolTag, new PlayerInventoryResponseProtocol(serviceProvider));
            _packetResponseDictionary.Add(SetPlayerCoordinateProtocol.ProtocolTag, new SetPlayerCoordinateProtocol(serviceProvider));
            _packetResponseDictionary.Add(EventProtocol.ProtocolTag, new EventProtocol(serviceProvider.GetService<EventProtocolProvider>()));
            _packetResponseDictionary.Add(InventoryItemMoveProtocol.ProtocolTag, new InventoryItemMoveProtocol(serviceProvider));
            _packetResponseDictionary.Add(SendPlaceHotBarBlockProtocol.ProtocolTag, new SendPlaceHotBarBlockProtocol(serviceProvider));
            _packetResponseDictionary.Add(BlockInventoryRequestProtocol.ProtocolTag, new BlockInventoryRequestProtocol(serviceProvider));
            _packetResponseDictionary.Add(RemoveBlockProtocol.ProtocolTag, new RemoveBlockProtocol(serviceProvider));
            _packetResponseDictionary.Add(SendCommandProtocol.ProtocolTag, new SendCommandProtocol(serviceProvider));
            _packetResponseDictionary.Add(BlockInventoryOpenCloseProtocol.ProtocolTag, new BlockInventoryOpenCloseProtocol(serviceProvider));
            _packetResponseDictionary.Add(SaveProtocol.ProtocolTag, new SaveProtocol(serviceProvider));
            _packetResponseDictionary.Add(GetMapObjectInfoProtocol.ProtocolTag, new GetMapObjectInfoProtocol(serviceProvider));
            _packetResponseDictionary.Add(MapObjectAcquisitionProtocol.ProtocolTag, new MapObjectAcquisitionProtocol(serviceProvider));
            _packetResponseDictionary.Add(OneClickCraft.ProtocolTag, new OneClickCraft(serviceProvider));
            _packetResponseDictionary.Add(GetChallengeInfoProtocol.ProtocolTag, new GetChallengeInfoProtocol(serviceProvider));
            _packetResponseDictionary.Add(AllBlockStateProtocol.ProtocolTag, new AllBlockStateProtocol(serviceProvider));
            _packetResponseDictionary.Add(BlockStateProtocol.ProtocolTag, new BlockStateProtocol(serviceProvider));
            _packetResponseDictionary.Add(DebugBlockInfoRequestProtocol.ProtocolTag, new DebugBlockInfoRequestProtocol(serviceProvider));
            _packetResponseDictionary.Add(SetCraftChainerCrafterRecipeProtocol.ProtocolTag, new SetCraftChainerCrafterRecipeProtocol(serviceProvider));
            _packetResponseDictionary.Add(SetCraftChainerMainComputerRequestItemProtocol.ProtocolTag, new SetCraftChainerMainComputerRequestItemProtocol(serviceProvider));
        }
        
        public List<List<byte>> GetPacketResponse(List<byte> payload)
        {
            ProtocolMessagePackBase request = null;
            ProtocolMessagePackBase response = null;
            try
            {
                request = MessagePackSerializer.Deserialize<ProtocolMessagePackBase>(payload.ToArray());
                response = _packetResponseDictionary[request.Tag].GetResponse(payload);
            }
            catch (Exception e)
            {
                // TODO 
                Debug.LogError($"PacketResponseCreator Error:{e.Message}\n{e.StackTrace}");
            }
            
            if (response == null) return new List<List<byte>>();
            
            response.SequenceId = request.SequenceId;
            var responseBytes = MessagePackSerializer.Serialize(Convert.ChangeType(response, response.GetType()));
            
            return new List<List<byte>> { responseBytes.ToList() };
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.SaveLoad/Json/WorldLoaderFromJson.cs
```cs
using System;
using System.IO;
using Game.Challenge;
using Game.Context;
using Game.Entity.Interface;
using Game.Map.Interface.MapObject;
using Game.PlayerInventory.Interface;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json.WorldVersions;
using Game.World.Interface.DataStore;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.SaveLoad.Json
{
    public class WorldLoaderFromJson : IWorldSaveDataLoader
    {
        private readonly ChallengeDatastore _challengeDatastore;
        private readonly ChallengeJsonObject _challengeJsonObject;
        private readonly IEntitiesDatastore _entitiesDatastore;
        private readonly IPlayerInventoryDataStore _inventoryDataStore;
        private readonly IMapObjectDatastore _mapObjectDatastore;
        
        private readonly SaveJsonFileName _saveJsonFileName;
        private readonly IWorldBlockDatastore _worldBlockDatastore;
        private readonly IWorldSettingsDatastore _worldSettingsDatastore;
        
        public WorldLoaderFromJson(SaveJsonFileName saveJsonFileName,
            IPlayerInventoryDataStore inventoryDataStore, IEntitiesDatastore entitiesDatastore, IWorldSettingsDatastore worldSettingsDatastore,
            IMapObjectDatastore mapObjectDatastore, ChallengeDatastore challengeDatastore)
        {
            _saveJsonFileName = saveJsonFileName;
            _worldBlockDatastore = ServerContext.WorldBlockDatastore;
            _inventoryDataStore = inventoryDataStore;
            _entitiesDatastore = entitiesDatastore;
            _worldSettingsDatastore = worldSettingsDatastore;
            _mapObjectDatastore = mapObjectDatastore;
            _challengeDatastore = challengeDatastore;
        }
        
        public void LoadOrInitialize()
        {
            if (File.Exists(_saveJsonFileName.FullSaveFilePath))
            {
                var json = File.ReadAllText(_saveJsonFileName.FullSaveFilePath);
                try
                {
                    Load(json);
                    Debug.Log("");
                    return;
                }
                catch (Exception e)
                {
                    //TODO 
                    Debug.Log("Discord ( https://discord.gg/ekFYmY3rDP ) ");
                    Debug.Log($" {_saveJsonFileName.FullSaveFilePath}");
                    throw new Exception(
                        $"\n Message : {e.Message} \n StackTrace : {e.StackTrace}");
                }
            }
            
            Debug.Log("");
            WorldInitialize();
        }
        
        public void Load(string jsonText)
        {
            var load = JsonConvert.DeserializeObject<WorldSaveAllInfoV1>(jsonText);
            
            _worldBlockDatastore.LoadBlockDataList(load.World);
            _inventoryDataStore.LoadPlayerInventory(load.Inventory);
            _entitiesDatastore.LoadBlockDataList(load.Entities);
            _worldSettingsDatastore.LoadSettingData(load.Setting);
            _mapObjectDatastore.LoadMapObject(load.MapObjects);
            _challengeDatastore.LoadChallenge(load.Challenge);
        }
        
        public void WorldInitialize()
        {
            _worldSettingsDatastore.Initialize();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/master/challenges.json
```cs
{
  "data": [
    {
      "summary": "1",
      "title": "1",
      "taskCompletionType": "createItem",
      "taskParam": {
        "itemGuid": "00000000-0000-0000-1234-000000000003"
      },
      "challengeGuid": "00000000-0000-0000-4567-000000000001",
      "playSkitType": "None",
      "playSkitParam": {},
      "tutorials": []
    },
    {
      "summary": "2",
      "title": "2",
      "taskCompletionType": "inInventoryItem",
      "taskParam": {
        "itemCount": 3,
        "itemGuid": "00000000-0000-0000-1234-000000000001"
      },
      "challengeGuid": "00000000-0000-0000-4567-000000000002",
      "playSkitType": "None",
      "playSkitParam": {},
      "tutorials": []
    },
    {
      "summary": "3",
      "title": "3",
      "taskCompletionType": "blockPlace",
      "taskParam": {
        "itemCount": 1,
        "blockGuid": "00000000-0000-0000-0000-000000000001"
      },
      "challengeGuid": "00000000-0000-0000-4567-000000000003",
      "playSkitType": "None",
      "playSkitParam": {},
      "tutorials": []
    },
    {
      "summary": "1",
      "title": "4",
      "taskCompletionType": "inInventoryItem",
      "taskParam": {
        "itemCount": 3,
        "itemGuid": "00000000-0000-0000-1234-000000000003"
      },
      "prevChallengeGuid": "00000000-0000-0000-4567-000000000001",
      "challengeGuid": "00000000-0000-0000-4567-000000000004",
      "playSkitType": "None",
      "playSkitParam": {},
      "tutorials": []
    }
  ]
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockGameObject.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Common;
using Client.Common.Asset;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.Context;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;
using UnityEngine.VFX;

namespace Client.Game.InGame.Block
{
    public class BlockGameObject : MonoBehaviour
    {
        public BlockId BlockId { get; private set; }
        public BlockMasterElement BlockMasterElement { get; private set; }
        public BlockPositionInfo BlockPosInfo { get; private set; }
        public List<IBlockStateChangeProcessor> BlockStateChangeProcessors { get; private set; }
        
        public IObservable<BlockGameObject> OnFinishedPlaceAnimation => _onFinishedPlaceAnimation;
        private readonly Subject<BlockGameObject> _onFinishedPlaceAnimation = new();
        
        private BlockShaderAnimation _blockShaderAnimation;
        private RendererMaterialReplacerController _rendererMaterialReplacerController;
        private List<VisualEffect> _visualEffects = new();
        private List<PreviewOnlyObject> _previewOnlyObjects = new();
        private const string PreviewBoundingBoxAddressablePath = "Vanilla/Block/Util/BlockPreviewBoundingBox";
        
        private bool _isShaderAnimating;
        
        public void Initialize(BlockMasterElement blockMasterElement, BlockPositionInfo posInfo)
        {
            BlockPosInfo = posInfo;
            BlockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            BlockMasterElement = blockMasterElement;
            BlockStateChangeProcessors = gameObject.GetComponentsInChildren<IBlockStateChangeProcessor>().ToList();
            _visualEffects = gameObject.GetComponentsInChildren<VisualEffect>(true).ToList();
            _blockShaderAnimation = gameObject.AddComponent<BlockShaderAnimation>();
           
            _rendererMaterialReplacerController = new RendererMaterialReplacerController(gameObject);
            
            // BlockGameObjectChild
            foreach (var child in gameObject.GetComponentsInChildren<BlockGameObjectChild>()) child.Init(this);
            
            // 
            foreach (var groundCollisionDetector in gameObject.GetComponentsInChildren<GroundCollisionDetector>(true))
            {
                groundCollisionDetector.enabled = false;
            }
            
            // 
            // Turn off preview-only object
            _previewOnlyObjects = gameObject.GetComponentsInChildren<PreviewOnlyObject>(true).ToList();
            _previewOnlyObjects.ForEach(obj =>
            {
                obj.Initialize();
                obj.SetActive(false);
            });
            
            LoadBoundingBox().Forget();
            
            // 
            // Create a bounding box object
            #region Internal
            
            async UniTask LoadBoundingBox()
            {
                var previewBoundingBoxPrefab = await AddressableLoader.LoadAsyncDefault<GameObject>(PreviewBoundingBoxAddressablePath);
                var previewBoundingBoxObj = Instantiate(previewBoundingBoxPrefab, transform);
                previewBoundingBoxObj.GetComponent<BlockPreviewBoundingBox>().SetBoundingBox(blockMasterElement.BlockSize, posInfo.BlockDirection);
                
                var previewOnlyObject = previewBoundingBoxObj.GetComponent<PreviewOnlyObject>();
                previewOnlyObject.Initialize();
                previewOnlyObject.SetActive(false);
                _previewOnlyObjects.Add(previewOnlyObject);
            }
            
            #endregion
        }
        
        public async UniTask PlayPlaceAnimation()
        {
            _isShaderAnimating = true;
            SetVfxActive(false);
            await _blockShaderAnimation.PlaceAnimation();
            _isShaderAnimating = false;
            SetVfxActive(true);
            _onFinishedPlaceAnimation.OnNext(this);
        }
        
        public void SetRemovePreviewing()
        {
            if (_isShaderAnimating) return;
            var placePreviewMaterial = Resources.Load<Material>(MaterialConst.PreviewPlaceBlockMaterial);
            
            _rendererMaterialReplacerController.CopyAndSetMaterial(placePreviewMaterial);
            _rendererMaterialReplacerController.SetColor(MaterialConst.PreviewColorPropertyName ,MaterialConst.NotPlaceableColor);
            Resources.UnloadAsset(placePreviewMaterial);
        }
        
        public void ResetMaterial()
        {
            if (_isShaderAnimating) return;
            _rendererMaterialReplacerController.ResetMaterial();
        }
        
        public void EnablePreviewOnlyObjects(bool active, bool renderEnable)
        {
            _previewOnlyObjects.ForEach(obj =>
            {
                obj.SetActive(active);
                obj.SetEnableRenderers(renderEnable);
            });
        }
        
        public async UniTask DestroyBlock()
        {
            _isShaderAnimating = true;
            SetVfxActive(false);
            await _blockShaderAnimation.RemoveAnimation();
            Destroy(gameObject);
        }
        
        private void SetVfxActive(bool isActive)
        {
            foreach (var vfx in _visualEffects) vfx.gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaShaftTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaShaftTemplate : IBlockTemplate
    {
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return CreateGear(blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock CreateGear(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var configParam = blockMasterElement.BlockParam as ShaftBlockParam;
            var connectSetting = configParam.Gear.GearConnects;
            var blockComponent = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var gearEnergyTransformer = new GearEnergyTransformer(new Torque(configParam.RequireTorque), blockInstanceId, blockComponent);
            
            var components = new List<IBlockComponent>
            {
                gearEnergyTransformer,
                blockComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaMinerTemplate.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.Miner;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaMinerTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockOpenableInventoryUpdateEvent;
        
        public VanillaMinerTemplate(BlockOpenableInventoryUpdateEvent blockOpenableInventoryUpdateEvent)
        {
            _blockOpenableInventoryUpdateEvent = blockOpenableInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var (requestPower, outputSlot) = GetData(blockMasterElement);
            
            var minerParam = blockMasterElement.BlockParam as ElectricMinerBlockParam;
            var miningSettings = minerParam.MineSettings;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(minerParam.InventoryConnectors, blockPositionInfo);
            
            var minerProcessorComponent = new VanillaMinerProcessorComponent(blockInstanceId, requestPower, outputSlot, _blockOpenableInventoryUpdateEvent, inputConnectorComponent, blockPositionInfo, miningSettings);
            var electricMinerComponent = new VanillaElectricMinerComponent(blockInstanceId, requestPower, minerProcessorComponent);
            var components = new List<IBlockComponent>
            {
                minerProcessorComponent,
                electricMinerComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var (requestPower, outputSlot) = GetData(blockMasterElement);
            
            var minerParam = blockMasterElement.BlockParam as ElectricMinerBlockParam;
            var miningSettings = minerParam.MineSettings;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(minerParam.InventoryConnectors, blockPositionInfo);
            
            var minerProcessorComponent = new VanillaMinerProcessorComponent(componentStates, blockInstanceId, requestPower, outputSlot, _blockOpenableInventoryUpdateEvent, inputConnectorComponent, blockPositionInfo, miningSettings);
            var electricMinerComponent = new VanillaElectricMinerComponent(blockInstanceId, requestPower, minerProcessorComponent);
            var components = new List<IBlockComponent>
            {
                minerProcessorComponent,
                electricMinerComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        private (ElectricPower requestPower, int outputSlot) GetData(BlockMasterElement blockMasterElement)
        {
            var minerParam = blockMasterElement.BlockParam as ElectricMinerBlockParam;
            
            var requestPower = minerParam.RequiredPower;
            
            return (new ElectricPower(requestPower), minerParam.OutputItemSlotCount);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/MapObject/IMapObject.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using UnityEngine;

namespace Game.Map.Interface.MapObject
{
    /// <summary>
    ///     
    /// </summary>
    public interface IMapObject
    {
        /// <summary>
        ///     ID
        ///     
        /// </summary>
        public int InstanceId { get; }
        
        /// <summary>
        ///     ID
        /// </summary>
        public Guid MapObjectGuid { get; }
        
        /// <summary>
        ///     true
        /// </summary>
        public bool IsDestroyed { get; }
        
        /// <summary>
        ///     
        /// </summary>
        Vector3 Position { get; }
        
        /// <summary>
        ///     MapObjectHP
        /// </summary>
        public int CurrentHp { get; }
        
        /// <summary>
        ///     
        /// </summary>
        public List<IItemStack> EarnItems { get; }
        
        public event Action OnDestroy;
        
        /// <summary>
        ///     HP
        ///     0Destroy
        /// </summary>
        public List<IItemStack> Attack(int damage);
        
        /// <summary>
        ///     
        /// </summary>
        public void Destroy();
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPreviewBoundingBox.cs
```cs
using Game.Block.Interface;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPreviewBoundingBox : MonoBehaviour
    {
        [SerializeField] private GameObject x_Origin_Edge;
        [SerializeField] private GameObject x_Y_Edge;
        [SerializeField] private GameObject x_YZ_Edge;
        [SerializeField] private GameObject x_Z_Edge;
        
        [SerializeField] private GameObject y_Origin_Edge;
        [SerializeField] private GameObject y_X_Edge;
        [SerializeField] private GameObject y_Z_Edge;
        [SerializeField] private GameObject y_XZ_Edge;
        
        [SerializeField] private GameObject z_Origin_Edge;
        [SerializeField] private GameObject z_Y_Edge;
        [SerializeField] private GameObject z_X_Edge;
        [SerializeField] private GameObject z_XY_Edge;
        
        [SerializeField] private GameObject xy_Origin_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface xy_Origin_SurfaceScript;
        [SerializeField] private GameObject xy_Z_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface xy_Z_SurfaceScript;
        
        [SerializeField] private GameObject yz_Origin_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface yz_Origin_SurfaceScript;
        [SerializeField] private GameObject yz_X_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface yz_X_SurfaceScript;
        
        [SerializeField] private GameObject zx_Origin_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface zx_Origin_SurfaceScript;
        [SerializeField] private GameObject zx_Y_Surface;
        [SerializeField] private BlockPreviewBoundingBoxSurface zx_Y_SurfaceScript;
        
        public void SetBoundingBox(Vector3Int blockSize, BlockDirection blockDirection)
        {
            // ========== X ==========
            x_Origin_Edge.transform.localScale = new Vector3(blockSize.x, 1, 1);
            x_Origin_Edge.transform.localPosition = new Vector3(0, 0, 0);
            
            x_Y_Edge.transform.localScale = new Vector3(blockSize.x, 1, 1);
            x_Y_Edge.transform.localPosition = new Vector3(0, blockSize.y, 0);
            
            x_YZ_Edge.transform.localScale = new Vector3(blockSize.x, 1, 1);
            x_YZ_Edge.transform.localPosition = new Vector3(0, blockSize.y, blockSize.z);
            
            x_Z_Edge.transform.localScale = new Vector3(blockSize.x, 1, 1);
            x_Z_Edge.transform.localPosition = new Vector3(0, 0, blockSize.z);
            
            
            // ========== Y ==========
            y_Origin_Edge.transform.localScale = new Vector3(blockSize.y, 1, 1);
            y_Origin_Edge.transform.localPosition = new Vector3(0, 0, 0);
            
            y_X_Edge.transform.localScale = new Vector3(blockSize.y, 1, 1);
            y_X_Edge.transform.localPosition = new Vector3(blockSize.x, 0, 0);
            
            y_Z_Edge.transform.localScale = new Vector3(blockSize.y, 1, 1);
            y_Z_Edge.transform.localPosition = new Vector3(0, 0, blockSize.z);
            
            y_XZ_Edge.transform.localScale = new Vector3(blockSize.y, 1, 1);
            y_XZ_Edge.transform.localPosition = new Vector3(blockSize.x, 0, blockSize.z);
            
            
            // ========== Z ==========
            z_Origin_Edge.transform.localScale = new Vector3(blockSize.z, 1, 1);
            z_Origin_Edge.transform.localPosition = new Vector3(0, 0, 0);
            
            z_Y_Edge.transform.localScale = new Vector3(blockSize.z, 1, 1);
            z_Y_Edge.transform.localPosition = new Vector3(0, blockSize.y, 0);
            
            z_X_Edge.transform.localScale = new Vector3(blockSize.z, 1, 1);
            z_X_Edge.transform.localPosition = new Vector3(blockSize.x, 0, 0);
            
            z_XY_Edge.transform.localScale = new Vector3(blockSize.z, 1, 1);
            z_XY_Edge.transform.localPosition = new Vector3(blockSize.x, blockSize.y, 0);
            
            
            // ========== x-y  ==========
            xy_Origin_Surface.transform.localScale = new Vector3(blockSize.x, blockSize.y, 1);
            xy_Origin_Surface.transform.localPosition = new Vector3(0, 0, 0);
            xy_Origin_SurfaceScript.SetPreviewSurfaceType(blockDirection switch
            { 
                BlockDirection.North => PreviewSurfaceType.YX_Origin,
                BlockDirection.East => PreviewSurfaceType.YZ_Origin,
                BlockDirection.South => PreviewSurfaceType.YX_Z,
                BlockDirection.West => PreviewSurfaceType.YZ_X,
            });
            
            xy_Z_Surface.transform.localScale = new Vector3(blockSize.x, blockSize.y, 1);
            xy_Z_Surface.transform.localPosition = new Vector3(0, 0, blockSize.z);
            xy_Z_SurfaceScript.SetPreviewSurfaceType(blockDirection switch
            {
                BlockDirection.North => PreviewSurfaceType.YX_Z,
                BlockDirection.East => PreviewSurfaceType.YZ_X,
                BlockDirection.South => PreviewSurfaceType.YX_Origin,
                BlockDirection.West => PreviewSurfaceType.YZ_Origin,
            });
            
            
            // ========== y-z  ==========
            yz_Origin_Surface.transform.localScale = new Vector3(1, blockSize.y, blockSize.z);
            yz_Origin_Surface.transform.localPosition = new Vector3(0, 0, 0);
            yz_Origin_SurfaceScript.SetPreviewSurfaceType(blockDirection switch
            {
                BlockDirection.North => PreviewSurfaceType.YZ_Origin,
                BlockDirection.East => PreviewSurfaceType.YX_Z,
                BlockDirection.South => PreviewSurfaceType.YZ_X,
                BlockDirection.West => PreviewSurfaceType.YX_Origin,
            });
            
            yz_X_Surface.transform.localScale = new Vector3(1, blockSize.y, blockSize.z);
            yz_X_Surface.transform.localPosition = new Vector3(blockSize.x, 0, 0);
            yz_X_SurfaceScript.SetPreviewSurfaceType(blockDirection switch
            {
                BlockDirection.North => PreviewSurfaceType.YZ_X,
                BlockDirection.East => PreviewSurfaceType.YX_Origin,
                BlockDirection.South => PreviewSurfaceType.YZ_Origin,
                BlockDirection.West => PreviewSurfaceType.YX_Z,
            });
            
            
            // ========== z-x  ==========
            zx_Origin_Surface.transform.localScale = new Vector3(blockSize.x, 1, blockSize.z);
            zx_Origin_Surface.transform.localPosition = new Vector3(0, 0, 0);
            
            zx_Y_Surface.transform.localScale = new Vector3(blockSize.x, 1, blockSize.z);
            zx_Y_Surface.transform.localPosition = new Vector3(0, blockSize.y, 0);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World/DataStore/WorldEnergySegmentDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Game.EnergySystem;
using Game.World.Interface.DataStore;

namespace Game.World.DataStore
{
    public class WorldEnergySegmentDatastore<TSegment> : IWorldEnergySegmentDatastore<TSegment>
        where TSegment : EnergySegment, new()
    {
        private readonly List<TSegment> _segmentDictionary = new();
        
        //
        public TSegment GetEnergySegment(IElectricTransformer transformer)
        {
            foreach (var segment in _segmentDictionary)
            {
                if (!segment.EnergyTransformers.ContainsKey(transformer.BlockInstanceId)) continue;
                return segment;
            }
            
            throw new Exception("");
        }
        
        public TSegment GetEnergySegment(int index)
        {
            return _segmentDictionary[index];
        }
        
        public TSegment CreateEnergySegment()
        {
            var electricSegment = new TSegment();
            _segmentDictionary.Add(electricSegment);
            return electricSegment;
        }
        
        public void SetEnergySegment(TSegment energySegment)
        {
            _segmentDictionary.Add(energySegment);
        }
        
        public void RemoveEnergySegment(TSegment energySegment)
        {
            _segmentDictionary.Remove(energySegment);
        }
        
        public int GetEnergySegmentListCount()
        {
            return _segmentDictionary.Count;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/IBlockStateChangeProcessor.cs
```cs
using Server.Event.EventReceive;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    /// <summary>
    ///     interface
    ///     
    /// </summary>
    public interface IBlockStateChangeProcessor
    {
        /// <summary>
        ///     
        ///     
        /// </summary>
        public void OnChangeState(BlockStateMessagePack blockState);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/NullBlockStateChangeProcessor.cs
```cs
using Server.Event.EventReceive;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    /// <summary>
    ///     
    /// </summary>
    public class NullBlockStateChangeProcessor : IBlockStateChangeProcessor
    {
        public void OnChangeState(BlockStateMessagePack blockState)
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/PlaceHotBarBlockProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.SendPlaceHotBarBlockProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class PlaceHotBarBlockProtocolTest
    {
        private const int PlacedBlockId = 1;
        private static readonly ItemId BlockItemId = new(1);
        private const int PlayerId = 3;
        private const int HotBarSlot = 3;
        
        [Test]
        public void BlockPlaceTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //
            
            //
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(HotBarSlot);
            var inventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            inventory.MainOpenableInventory.SetItem(slot, itemStackFactory.Create(BlockItemId, 3));
            
            //
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 4, 0));
            
            //
            var world = ServerContext.WorldBlockDatastore;
            Assert.AreEqual(PlacedBlockId, world.GetBlock(new Vector3Int(2, 4)).BlockId.AsPrimitive());
            //
            Assert.AreEqual(2, inventory.MainOpenableInventory.GetItem(slot).Count);
            
            
            //
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 4, 0));
            //
            Assert.AreEqual(2,
                inventory.MainOpenableInventory.GetItem(slot).Count);
            
            //
            packet.GetPacketResponse(CreateUseHotBarProtocol(3, 4, 0));
            packet.GetPacketResponse(CreateUseHotBarProtocol(4, 4, 0));
            //
            Assert.AreEqual(itemStackFactory.CreatEmpty(), inventory.MainOpenableInventory.GetItem(slot));
            
            
            //
            packet.GetPacketResponse(CreateUseHotBarProtocol(10, 10, 0));
            Assert.True(world.GetBlock(new Vector3Int(10, 10)) == null);
        }
        
        
        //
        [Test]
        public void PlaceDirectionTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //
            
            //
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(HotBarSlot);
            var inventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            inventory.MainOpenableInventory.SetItem(slot, itemStackFactory.Create(BlockItemId, 4));
            
            
            //
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 4, BlockDirection.North));
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 5, BlockDirection.East));
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 6, BlockDirection.South));
            packet.GetPacketResponse(CreateUseHotBarProtocol(2, 7, BlockDirection.West));
            
            //
            Assert.AreEqual(BlockDirection.North, worldBlockDatastore.GetBlockDirection(new Vector3Int(2, 4)));
            Assert.AreEqual(BlockDirection.East, worldBlockDatastore.GetBlockDirection(new Vector3Int(2, 5)));
            Assert.AreEqual(BlockDirection.South, worldBlockDatastore.GetBlockDirection(new Vector3Int(2, 6)));
            Assert.AreEqual(BlockDirection.West, worldBlockDatastore.GetBlockDirection(new Vector3Int(2, 7)));
        }
        
        private List<byte> CreateUseHotBarProtocol(int x, int y, BlockDirection blockDirection)
        {
            var placeInfo = new List<PlaceInfo>
            {
                new()
                {
                    Position = new Vector3Int(x, y),
                    Direction = blockDirection,
                    VerticalDirection = BlockVerticalDirection.Horizontal
                }
            };
            
            return MessagePackSerializer
                .Serialize(new SendPlaceHotBarBlockProtocolMessagePack(PlayerId, HotBarSlot, placeInfo))
                .ToList();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Presenter/Player/PlayerPositionSender.cs
```cs
using Client.Common.Server;
using Client.Game.InGame.Context;
using Client.Game.InGame.Player;
using UnityEngine;
using VContainer.Unity;

namespace Client.Game.InGame.Presenter.Player
{
    public class PlayerPositionSender : ITickable
    {
        private readonly IPlayerObjectController _playerObjectController;
        
        private float _timer;
        
        public PlayerPositionSender(IPlayerObjectController playerObjectController)
        {
            _playerObjectController = playerObjectController;
        }
        
        /// <summary>
        ///     Update
        /// </summary>
        public void Tick()
        {
            _timer += Time.deltaTime;
            if (_timer < NetworkConst.UpdateIntervalSeconds) return;
            _timer = 0;
            ClientContext.VanillaApi.SendOnly.SendPlayerPosition(_playerObjectController.Position);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Util/MouseCursorExplainer.cs
```cs
using Client.Localization;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.UI.Util
{
    public interface IMouseCursorExplainer
    {
        public const int DefaultFontSize = 36;
        
        // TODO hotbarfalse
        public void Hide();
        public void Show(string key, int fontSize = DefaultFontSize, bool isLocalize = true);
    }
    
    /// <summary>
    ///     Tips
    /// </summary>
    public class MouseCursorExplainer : MonoBehaviour, IMouseCursorExplainer
    {
        [SerializeField] private GameObject itemNameBar;
        [SerializeField] private TMP_Text itemName;
        [SerializeField] private CanvasGroup canvasGroup;
        
        
        public static IMouseCursorExplainer Instance { get; private set; }
        
        private void Awake()
        {
            Instance = this;
        }
        
        public void Show(string key, int fontSize = IMouseCursorExplainer.DefaultFontSize, bool isLocalize = true)
        {
            canvasGroup.alpha = 1;
            itemName.text = isLocalize ? Localize.Get(key) : key;
            itemName.fontSize = fontSize;
        }
        
        public void Hide()
        {
            canvasGroup.alpha = 0;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/VanillaBeltConveyorInventoryItem.cs
```cs
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Newtonsoft.Json;

namespace Game.Block.Blocks.BeltConveyor
{
    public interface IOnBeltConveyorItem
    {
        public double RemainingPercent { get; }
        public ItemId ItemId { get; }
        public ItemInstanceId ItemInstanceId { get; }
    }
    
    public class VanillaBeltConveyorInventoryItem : IOnBeltConveyorItem
    {
        public double RemainingPercent { get; set; }
        public ItemId ItemId { get; }
        public ItemInstanceId ItemInstanceId { get; }
        
        public VanillaBeltConveyorInventoryItem(ItemId itemId, ItemInstanceId itemInstanceId)
        {
            ItemId = itemId;
            ItemInstanceId = itemInstanceId;
            RemainingPercent = 1;
        }
        
        public string GetSaveJsonString()
        {
            return JsonConvert.SerializeObject(new VanillaBeltConveyorInventoryItemJsonObject(this));
        }
        
        public static VanillaBeltConveyorInventoryItem LoadItem(string jsonString)
        {
            if (jsonString == null) return null;
            
            var jsonData = JsonConvert.DeserializeObject<VanillaBeltConveyorInventoryItemJsonObject>(jsonString);
            if (jsonData.ItemStack == null) return null;
            
            var itemId = MasterHolder.ItemMaster.GetItemId(jsonData.ItemStack.ItemGuid);
            var remainingPercent = jsonData.RemainingPercent;
            var itemInstanceId = ItemInstanceId.Create();
            
            return new VanillaBeltConveyorInventoryItem(itemId, itemInstanceId)
            {
                RemainingPercent = remainingPercent
            };
        }
    }
    
    public class VanillaBeltConveyorInventoryItemJsonObject
    {
        [JsonProperty("itemStack")] public ItemStackSaveJsonObject ItemStack;
        
        [JsonProperty("remainingTime")] public double RemainingPercent;
        
        public VanillaBeltConveyorInventoryItemJsonObject(VanillaBeltConveyorInventoryItem vanillaBeltConveyorInventoryItem)
        {
            if (vanillaBeltConveyorInventoryItem == null)
            {
                ItemStack = null;
                RemainingPercent = 1;
                return;
            }
            
            var item = ServerContext.ItemStackFactory.Create(vanillaBeltConveyorInventoryItem.ItemId, 1);
            ItemStack = new ItemStackSaveJsonObject(item);
            RemainingPercent = vanillaBeltConveyorInventoryItem.RemainingPercent;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Map/VanillaStaticMapObject.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.Map.Interface.MapObject;
using UnityEngine;
using Random = System.Random;

namespace Game.Map
{
    /// <summary>
    ///     
    /// </summary>
    public class VanillaStaticMapObject : IMapObject
    {
        public int InstanceId { get; }
        public Guid MapObjectGuid { get; }
        public bool IsDestroyed { get; private set; }
        public Vector3 Position { get; }
        public int CurrentHp { get; private set; }
        
        public List<IItemStack> EarnItems { get; }
        
        public event Action OnDestroy;
        
        private readonly int[] _earnItemHps;
        
        public VanillaStaticMapObject(int instanceId, Guid mapObjectGuid, bool isDestroyed, int currentHp, Vector3 position)
        {
            var mapObjectConfig = MasterHolder.MapObjectMaster.GetMapObjectElement(mapObjectGuid);
            InstanceId = instanceId;
            MapObjectGuid = mapObjectGuid;
            IsDestroyed = isDestroyed;
            Position = position;
            CurrentHp = currentHp;
            
            
            _earnItemHps = mapObjectConfig.EarnItemHps;
            
            var random = new Random(instanceId);
            EarnItems = new List<IItemStack>();
            foreach (var earnItemConfig in mapObjectConfig.EarnItems)
            {
                var itemCount = random.Next(earnItemConfig.MinCount, earnItemConfig.MaxCount + 1);
                var itemStack = ServerContext.ItemStackFactory.Create(earnItemConfig.ItemGuid, itemCount);
                
                EarnItems.Add(itemStack);
            }
        }
        
        public List<IItemStack> Attack(int damage)
        {
            var lastHp = CurrentHp;
            CurrentHp -= damage;
            if (CurrentHp <= 0) Destroy();
            
            var earnedCount = _earnItemHps.Count(hp => lastHp > hp && CurrentHp <= hp);
            if (earnedCount == 0) return new List<IItemStack>();
            
            var earnedItems = new List<IItemStack>();
            foreach (var item in EarnItems)
            {
                var id = item.Id;
                var count = item.Count * earnedCount;
                
                earnedItems.Add(ServerContext.ItemStackFactory.Create(id, count));
            }
            
            return earnedItems;
        }
        
        public void Destroy()
        {
            CurrentHp = 0;
            IsDestroyed = true;
            OnDestroy?.Invoke();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/CommandProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;

namespace Server.Protocol.PacketResponse
{
    public class SendCommandProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:sendCommand";
        
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public SendCommandProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SendCommandProtocolMessagePack>(payload.ToArray());
            
            var command = data.Command.Split(' '); //command text
            
            //
            if (command[0] == "give")
            {
                var inventory = _playerInventoryDataStore.GetInventoryData(int.Parse(command[1]));
                
                var itemId = new ItemId(int.Parse(command[2]));
                var count = int.Parse(command[3]);
                
                var item = ServerContext.ItemStackFactory.Create(itemId, count);
                inventory.MainOpenableInventory.InsertItem(item);
            }
            
            return null;
        }
        
        [MessagePackObject]
        public class SendCommandProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public string Command { get; set; }
            
            [Obsolete("")]
            public SendCommandProtocolMessagePack()
            {
            }
            
            public SendCommandProtocolMessagePack(string command)
            {
                Tag = ProtocolTag;
                Command = command;
            }
        }
    }
    
}
```

moorestech_server/Assets/Scripts/Game.Map.Interface/Json/MapObjectJsonObject.cs
```cs
using System;
using Game.Map.Interface.MapObject;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Map.Interface.Json
{
    [Serializable]
    public class MapObjectJsonObject
    {
        [JsonProperty("instanceId")] public int instanceId;
        [JsonProperty("isDestroyed")] public bool isDestroyed;
        [JsonProperty("hp")] public int hp;
        [JsonProperty("guid")] public string guidStr;
        [JsonIgnore] public Guid MapObjectGuid => new(guidStr);
        
        [JsonProperty("x")] public float x;
        [JsonProperty("y")] public float y;
        [JsonProperty("z")] public float z;
        
        [Obsolete("Json")]
        public MapObjectJsonObject()
        {
        }
        
        public MapObjectJsonObject(IMapObject mapObject)
        {
            instanceId = mapObject.InstanceId;
            isDestroyed = mapObject.IsDestroyed;
            guidStr = mapObject.MapObjectGuid.ToString();
            hp = mapObject.CurrentHp;
            x = mapObject.Position.x;
            y = mapObject.Position.y;
            z = mapObject.Position.z;
        }
        
        [JsonIgnore] public Vector3 Position => new(x, y, z);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningFocusState.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.UI.Util;
using Client.Input;
using Core.Master;
using Game.PlayerInventory.Interface;
using Mooresmaster.Model.MapObjectsModule;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningFocusState : IMapObjectMiningState
    {
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            // Idle
            // If the focus is lost, transition to Idle
            if (context.CurrentFocusMapObjectGameObject == null)
            {
                return new MapObjectMiningIdleState();
            }
            
            var currentMapObjectMaster = context.CurrentFocusMapObjectGameObject.MapObjectMasterElement;
            var miningType = currentMapObjectMaster.MiningType;
            
            if (miningType == MapObjectMasterElement.MiningTypeConst.PickUp)
            {
                return PickUpProcess(context);
            }
            if (miningType == MapObjectMasterElement.MiningTypeConst.Mining)
            {
                return MiningProcess(currentMapObjectMaster, context);
            }
            
            throw new System.Exception("MiningType is not defined");
        }
        
        private IMapObjectMiningState PickUpProcess(MapObjectMiningControllerContext context)
        {
            if (InputManager.Playable.ScreenLeftClick.GetKey)
            {
                MouseCursorExplainer.Instance.Hide();
                return new MapObjectMiningMiningCompleteState(context.CurrentFocusMapObjectGameObject, int.MaxValue);
            }
            
            // 
            // If left click is not pressed, maintain the current state
            MouseCursorExplainer.Instance.Show("", isLocalize: false);
            return this;
        }
        
        private IMapObjectMiningState MiningProcess(MapObjectMasterElement masterElement,MapObjectMiningControllerContext context)
        {
            // 
            // Check if the item you are currently holding is registered as a mining tool
            var hotBarInventoryIndex = PlayerInventoryConst.HotBarSlotToInventorySlot(context.HotBarView.SelectIndex);
            var inventoryItem = context.LocalPlayerInventory[hotBarInventoryIndex];
                
            
            // 
            // If nothing is selected, maintain focus
            var miningTools = ((MiningMiningParam)masterElement.MiningParam).MiningTools;
            if (inventoryItem.Id == ItemMaster.EmptyItemId)
            {
                ShowRecommendMiningTools(miningTools);
                return this;
            }
            
            
            // 
            // Check if it is registered as a mining tool
            MiningToolsElement usableMiningTool = null; 
            var currentItemGuid = MasterHolder.ItemMaster.GetItemMaster(inventoryItem.Id).ItemGuid;
            foreach (var miningTool in miningTools)
            {
                if (miningTool.ToolItemGuid != currentItemGuid) continue;
                
                usableMiningTool = miningTool;
                break;
            }
            
            // 
            // If it is not registered as a mining tool, maintain focus
            if (usableMiningTool == null)
            {
                ShowRecommendMiningTools(miningTools);
                return this;
            }
            
            // 
            // If not clicked, maintain focus
            if (!InputManager.Playable.ScreenLeftClick.GetKey)
            {
                MouseCursorExplainer.Instance.Show("", isLocalize: false);
                return this;
            }
            
            // 
            // Transition to mining state
            MouseCursorExplainer.Instance.Hide();
            return new MapObjectMiningMiningState(usableMiningTool, context.PlayerObjectController);
        }
        
        
        private void ShowRecommendMiningTools(MiningToolsElement[] miningTools)
        {
            var result = new List<string>();
            
            foreach (var tool in miningTools)
            {
                var itemMaster = MasterHolder.ItemMaster.GetItemMaster(tool.ToolItemGuid);
                result.Add(itemMaster.Name);
            }
            
            var text = ":" + string.Join(", ",result);
            
            MouseCursorExplainer.Instance.Show(text, isLocalize: false);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/World/WorldDataHandler.cs
```cs
using System.Threading;
using Client.Common;
using Client.Common.Server;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Entity;
using Client.Game.InGame.SoundEffect;
using Client.Network.API;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;
using VContainer.Unity;

namespace Client.Game.InGame.World
{
    /// <summary>
    ///     View
    ///     IInitializableDI
    /// </summary>
    public class WorldDataHandler : IInitializable
    {
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        private readonly EntityObjectDatastore _entitiesDatastore;
        
        public WorldDataHandler(BlockGameObjectDataStore blockGameObjectDataStore, EntityObjectDatastore entitiesDatastore, InitialHandshakeResponse initialHandshakeResponse)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            _entitiesDatastore = entitiesDatastore;
            //
            ClientContext.VanillaApi.Event.SubscribeEventResponse(PlaceBlockEventPacket.EventTag, OnBlockUpdate);
            ClientContext.VanillaApi.Event.SubscribeEventResponse(RemoveBlockToSetEventPacket.EventTag, OnBlockRemove);
        }
        
        public void Initialize()
        {
            UpdateWorldData().Forget();
        }
        
        /// <summary>
        ///     
        /// </summary>
        private void OnBlockUpdate(byte[] payload)
        {
            var data = MessagePackSerializer.Deserialize<PlaceBlockEventMessagePack>(payload);
            
            var blockPos = (Vector3Int)data.BlockData.BlockPos;
            var blockId = data.BlockData.BlockId;
            var blockDirection = data.BlockData.BlockDirection;
            
            //view
            PlaceBlock(blockPos, blockId, blockDirection);
        }
        
        private void OnBlockRemove(byte[] packet)
        {
            var data = MessagePackSerializer.Deserialize<RemoveBlockEventMessagePack>(packet);
            
            //view
            SoundEffectManager.Instance.PlaySoundEffect(SoundEffectType.DestroyBlock);
            _blockGameObjectDataStore.RemoveBlock(data.Position);
        }
        
        /// <summary>
        ///     0.51
        /// </summary>
        private async UniTask UpdateWorldData()
        {
            var ct = new CancellationTokenSource().Token;
            
            while (true)
            {
                await GetAndApplyWorldData();
                await UniTask.Delay(NetworkConst.UpdateIntervalMilliseconds, cancellationToken: ct); //TODO 0.51
            }
            
            #region Internal
            
            async UniTask GetAndApplyWorldData()
            {
                var data = await ClientContext.VanillaApi.Response.GetWorldData(ct);
                if (data == null) return;
                
                ApplyWorldData(data);
            }
            
            #endregion
        }
        
        
        private void ApplyWorldData(WorldDataResponse worldData)
        {
            foreach (var block in worldData.Blocks) PlaceBlock(block.BlockPos, block.BlockId, block.BlockDirection);
            
            if (worldData.Entities == null)
            {
                return;
            }
            
            _entitiesDatastore.OnEntitiesUpdate(worldData.Entities);
        }
        
        private void PlaceBlock(Vector3Int position, BlockId id, BlockDirection blockDirection)
        {
            if (id == BlockConstant.NullBlockId)
            {
                _blockGameObjectDataStore.RemoveBlock(position);
                return;
            }
            
            _blockGameObjectDataStore.PlaceBlock(position, id, blockDirection);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/ItemShooter/ShooterInventoryItem.cs
```cs
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.BeltConveyor;

namespace Game.Block.Blocks.ItemShooter
{
    public class ShooterInventoryItem : IOnBeltConveyorItem
    {
        public ItemId ItemId { get; }
        
        public ItemInstanceId ItemInstanceId { get; }
        
        public double RemainingPercent { get; set; }
        
        public float CurrentSpeed { get; set; }
        
        public ShooterInventoryItem(ItemId itemId, ItemInstanceId itemInstanceId, float currentSpeed)
        {
            ItemId = itemId;
            ItemInstanceId = itemInstanceId;
            CurrentSpeed = currentSpeed;
            RemainingPercent = 1;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/LocalPlayerInventory.cs
```cs
using System;
using System.Collections;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Main
{
    public interface ILocalPlayerInventory : IEnumerable<IItemStack>
    {
        public IItemStack this[int index] { get; }
        public IObservable<int> OnItemChange { get; }
        
        public int Count { get; }
        public bool IsItemExist(ItemId itemId, int itemSlot);
    }
    
    /// <summary>
    ///     
    /// </summary>
    public class LocalPlayerInventory : ILocalPlayerInventory
    {
        public IObservable<int> OnItemChange => _onItemChange;
        private readonly Subject<int> _onItemChange = new();
        
        public int Count => _mainInventory.Count + _subInventory.Count;
        
        private readonly List<IItemStack> _mainInventory;
        private ISubInventory _subInventory;
        
        public LocalPlayerInventory()
        {
            _mainInventory = new List<IItemStack>();
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++) _mainInventory.Add(itemStackFactory.CreatEmpty());
            
            _subInventory = new EmptySubInventory();
        }
        
        public IEnumerator<IItemStack> GetEnumerator()
        {
            var merged = new List<IItemStack>();
            merged.AddRange(_mainInventory);
            merged.AddRange(_subInventory.SubInventory);
            return merged.GetEnumerator();
        }
        
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
        
        public bool IsItemExist(ItemId itemId, int itemSlot)
        {
            if (itemSlot < _mainInventory.Count) return _mainInventory[itemSlot].Id == itemId;
            
            var subIndex = itemSlot - _mainInventory.Count;
            var subItemId = _subInventory.SubInventory[itemSlot - _mainInventory.Count].Id;
            
            if (subIndex < _subInventory.Count) return subItemId == itemId;
            
            Debug.LogError("sub inventory index out of range  SubInventoryCount:" + _subInventory.Count + " index:" + itemSlot);
            return false;
        }
        
        public IItemStack this[int index]
        {
            get
            {
                if (index < _mainInventory.Count) return _mainInventory[index];
                var subIndex = index - _mainInventory.Count;
                if (subIndex < _subInventory.Count) return _subInventory.SubInventory[index - _mainInventory.Count];
                
                Debug.LogError("sub inventory index out of range  SubInventoryCount:" + _subInventory.Count + " index:" + index);
                return ServerContext.ItemStackFactory.CreatEmpty();
            }
            set
            {
                if (index < _mainInventory.Count)
                {
                    _mainInventory[index] = value;
                    _onItemChange.OnNext(index);
                    return;
                }
                
                var subIndex = index - _mainInventory.Count;
                if (subIndex < _subInventory.Count)
                {
                    _subInventory.SubInventory[subIndex] = value;
                    _onItemChange.OnNext(index);
                    return;
                }
                
                Debug.LogError("sub inventory index out of range  SubInventoryCount:" + _subInventory.Count + " index:" + index);
            }
        }
        
        public void SetSubInventory(ISubInventory subInventory)
        {
            _subInventory = subInventory;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Element/ItemSlotObject.cs
```cs
using System;
using Client.Game.InGame.UI.Util;
using Client.Mod.Texture;
using Core.Const;
using Core.Master;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Element
{
    public class ItemSlotObject : MonoBehaviour, IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerClickHandler, IPointerExitHandler, IPointerMoveHandler
    {
        [SerializeField] private Image itemImage;
        
        [SerializeField] private GameObject normalFrame;
        [SerializeField] private GameObject machineSlotFrame;
        [SerializeField] private GameObject craftRecipeFrame;
        
        [SerializeField] private GameObject hotBarSelect;
        
        [SerializeField] private GameObject grayOutImage;
        [SerializeField] private GameObject hoverImage; // TODO 
        [SerializeField] private GameObject clickImage; // TODO 
        
        [SerializeField] private GameObject normalItemSlotObject;
        [SerializeField] private GameObject noneCrossObject;
        
        [SerializeField] private TMP_Text countText;
        [SerializeField] private UIEnterExplainerController uiEnterExplainerController;
        
        private bool _onPointing;
        
        public ItemViewData ItemViewData { get; private set; }
        public int Count { get; private set; }
        
        private void Awake()
        {
            OnPointerEvent.Subscribe(OnInvokeOtherEvent).AddTo(this);
            SubscribeHover();
            SubscribeClick();
        }
        
        private void SubscribeHover()
        {
            _onCursorEnter.Subscribe(_ => hoverImage.SetActive(true)).AddTo(this);
            _onCursorExit.Subscribe(_ => hoverImage.SetActive(false)).AddTo(this);
        }
        
        private void SubscribeClick()
        {
            _onLeftClickDown.Subscribe(_ => clickImage.SetActive(true)).AddTo(this);
            _onLeftClickUp.Subscribe(_ => clickImage.SetActive(false)).AddTo(this);
        }
        
        
        public void SetItem(ItemViewData itemView, int count)
        {
            ItemViewData = itemView;
            
            Count = count;
            countText.text = count != 0 ? count.ToString() : string.Empty;
            
            if (itemView == null || itemView.ItemId == ItemMaster.EmptyItemId)
            {
                itemImage.gameObject.SetActive(false);
                
                uiEnterExplainerController.DisplayEnable(false);
            }
            else
            {
                itemImage.gameObject.SetActive(true);
                itemImage.sprite = itemView.ItemImage;
                
                uiEnterExplainerController.SetText($"{itemView.ItemName}\n<size=25>ID:{itemView.ItemId}</size>", false);
                uiEnterExplainerController.DisplayEnable(true);
            }
        }
        
        public void SetGrayOut(bool active)
        {
            grayOutImage.SetActive(active);
        }
        
        public void SetFrame(ItemSlotFrameType frameType)
        {
            normalFrame.SetActive(frameType == ItemSlotFrameType.Normal);
            machineSlotFrame.SetActive(frameType == ItemSlotFrameType.MachineSlot);
            craftRecipeFrame.SetActive(frameType == ItemSlotFrameType.CraftRecipe);
        }
        
        public void SetItemSlotType(ItemSlotType slotType)
        {
            normalItemSlotObject.SetActive(slotType == ItemSlotType.Normal);
            noneCrossObject.SetActive(slotType == ItemSlotType.NoneCross);
        }
        
        public void SetHotBarSelect(bool active)
        {
            hotBarSelect.SetActive(active);
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        
        #region PointerEvents
        
        public IObservable<(ItemSlotObject, ItemUIEventType)> OnPointerEvent => _onPointerEvent;
        private readonly Subject<(ItemSlotObject, ItemUIEventType)> _onPointerEvent = new();
        
        public IObservable<ItemSlotObject> OnRightClickDown => _onRightClickDown;
        private readonly Subject<ItemSlotObject> _onRightClickDown = new();
        public IObservable<ItemSlotObject> OnLeftClickDown => _onLeftClickDown;
        private readonly Subject<ItemSlotObject> _onLeftClickDown = new();
        public IObservable<ItemSlotObject> OnRightClickUp => _onRightClickUp;
        private readonly Subject<ItemSlotObject> _onRightClickUp = new();
        public IObservable<ItemSlotObject> OnLeftClickUp => _onLeftClickUp;
        private readonly Subject<ItemSlotObject> _onLeftClickUp = new();
        public IObservable<ItemSlotObject> OnCursorEnter => _onCursorEnter;
        private readonly Subject<ItemSlotObject> _onCursorEnter = new();
        public IObservable<ItemSlotObject> OnCursorExit => _onCursorExit;
        private readonly Subject<ItemSlotObject> _onCursorExit = new();
        public IObservable<ItemSlotObject> OnCursorMove => _onCursorMove;
        private readonly Subject<ItemSlotObject> _onCursorMove = new();
        public IObservable<ItemSlotObject> OnDoubleClick => _onDoubleClick;
        private readonly Subject<ItemSlotObject> _onDoubleClick = new();
        
        private void OnInvokeOtherEvent((ItemSlotObject, ItemUIEventType) data)
        {
            var type = data.Item2;
            var slot = data.Item1;
            switch (type)
            {
                case ItemUIEventType.RightClickDown:
                    _onRightClickDown.OnNext(slot);
                    break;
                case ItemUIEventType.LeftClickDown:
                    _onLeftClickDown.OnNext(slot);
                    break;
                case ItemUIEventType.RightClickUp:
                    _onRightClickUp.OnNext(slot);
                    break;
                case ItemUIEventType.LeftClickUp:
                    _onLeftClickUp.OnNext(slot);
                    break;
                case ItemUIEventType.CursorEnter:
                    _onCursorEnter.OnNext(slot);
                    break;
                case ItemUIEventType.CursorExit:
                    _onCursorExit.OnNext(slot);
                    break;
                case ItemUIEventType.CursorMove:
                    _onCursorMove.OnNext(slot);
                    break;
                case ItemUIEventType.DoubleClick:
                    _onDoubleClick.OnNext(slot);
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
        
        public void OnPointerClick(PointerEventData eventData)
        {
            if (2 == eventData.clickCount && eventData.button == PointerEventData.InputButton.Left) _onPointerEvent.OnNext((this, ItemUIEventType.DoubleClick));
        }
        
        public void OnPointerDown(PointerEventData eventData)
        {
            switch (eventData.button)
            {
                case PointerEventData.InputButton.Left:
                    _onPointerEvent.OnNext((this, ItemUIEventType.LeftClickDown));
                    break;
                case PointerEventData.InputButton.Right:
                    _onPointerEvent.OnNext((this, ItemUIEventType.RightClickDown));
                    break;
            }
        }
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            _onPointing = true;
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorEnter));
        }
        
        public void OnPointerExit(PointerEventData eventData)
        {
            _onPointing = false;
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorExit));
        }
        
        public void OnPointerMove(PointerEventData eventData)
        {
            _onPointerEvent.OnNext((this, ItemUIEventType.CursorMove));
        }
        
        public void OnPointerUp(PointerEventData eventData)
        {
            switch (eventData.button)
            {
                case PointerEventData.InputButton.Left:
                    _onPointerEvent.OnNext((this, ItemUIEventType.LeftClickUp));
                    break;
                case PointerEventData.InputButton.Right:
                    _onPointerEvent.OnNext((this, ItemUIEventType.RightClickUp));
                    break;
            }
        }
        
        #endregion
    }
    
    public enum ItemUIEventType
    {
        RightClickDown,
        LeftClickDown,
        RightClickUp,
        LeftClickUp,
        
        CursorEnter,
        CursorExit,
        CursorMove,
        
        DoubleClick,
    }
    
    public enum ItemSlotType
    {
        Normal, // 
        NoneCross, // 
    }
    
    public enum ItemSlotFrameType
    {
        Normal,
        MachineSlot,
        CraftRecipe,
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory/BlockInventoryOpenStateDataStore.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using UnityEngine;

namespace Game.PlayerInventory
{
    public class BlockInventoryOpenStateDataStore : IBlockInventoryOpenStateDataStore
    {
        //key playerId, value block entity id
        private readonly Dictionary<int, BlockInstanceId> _openCoordinates = new();
        
        public List<int> GetBlockInventoryOpenPlayers(BlockInstanceId blockBlockInstanceId)
        {
            return _openCoordinates.Where(x => x.Value == blockBlockInstanceId).Select(x => x.Key).ToList();
        }
        
        public void Open(int playerId, Vector3Int pos)
        {
            //
            if (!ServerContext.WorldBlockDatastore.TryGetBlock<IOpenableBlockInventoryComponent>(pos, out _)) return;
            
            var entityId = ServerContext.WorldBlockDatastore.GetBlock(pos).BlockInstanceId;
            _openCoordinates[playerId] = entityId;
        }
        
        public void Close(int playerId)
        {
            if (_openCoordinates.ContainsKey(playerId)) _openCoordinates.Remove(playerId);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Util/AllGameObjectEnterExplainerController.cs
```cs
using Client.Input;
using UnityEngine;
using UnityEngine.EventSystems;

namespace Client.Game.InGame.UI.Util
{
    /// <summary>
    ///     GameObject
    ///     TODO 
    /// </summary>
    public class AllGameObjectEnterExplainerController : MonoBehaviour
    {
        private GameObjectEnterExplainer _lastTargetExplainer;
        
        private void Awake()
        {
        }
        
        private void Update()
        {
            if (TryGetOnCursorExplainer(out var explainer))
            {
                if (_lastTargetExplainer == explainer) return;
                
                if (_lastTargetExplainer != null) _lastTargetExplainer.OnCursorExit();
                explainer.OnCursorEnter();
                _lastTargetExplainer = explainer;
            }
            else
            {
                if (_lastTargetExplainer != null) _lastTargetExplainer.OnCursorExit();
                _lastTargetExplainer = null;
            }
        }
        
        private bool TryGetOnCursorExplainer(out GameObjectEnterExplainer explainer)
        {
            explainer = null;
            if (Camera.main == null) return false;
            if (EventSystem.current.IsPointerOverGameObject()) return false;
            
            var mousePosition = InputManager.Playable.ClickPosition.ReadValue<Vector2>();
            var ray = Camera.main.ScreenPointToRay(mousePosition);
            if (!Physics.Raycast(ray, out var hit, 100)) return false;
            
            if (!hit.collider.gameObject.TryGetComponent<GameObjectEnterExplainer>(out var gameObjectEnterExplainer)) return false;
            
            explainer = gameObjectEnterExplainer;
            return true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/State/BlockState.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface.Component;

namespace Game.Block.Interface.State
{
    /// <summary>
    ///     
    ///     <see cref="CurrentState" /><see cref="PreviousState" />String
    ///     
    /// </summary>
    public class BlockState
    {
        public readonly Dictionary<string, byte[]> CurrentStateDetails;
        
        public BlockState(Dictionary<string, byte[]> currentStateDetails)
        {
            CurrentStateDetails = currentStateDetails;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Skit/SkitManager.cs
```cs
using System.Collections.Generic;
using Client.Skit.Define;
using Client.Skit.Skit;
using Client.Skit.SkitTrack;
using Client.Skit.UI;
using Cysharp.Threading.Tasks;
using UnityEngine;

namespace Client.Game.Skit
{
    public class SkitManager : MonoBehaviour
    {
        [SerializeField] private SkitUI skitUI;
        
        [SerializeField] private SkitCamera skitCamera;
        
        [SerializeField] private CharacterDefine characterDefine;
        [SerializeField] private VoiceDefine voiceDefine;
        
        public bool IsPlayingSkit { get; private set; }
        
        public async UniTask StartSkit(TextAsset storyCsv)
        {
            IsPlayingSkit = true;
            
            // Pre process
            var storyContext = PreProcess();
            var lines = storyCsv.text.Split('\n');
            var tagIndexTable = CreateTagIndexTable(storyCsv.text.Split('\n'));
            
            // Execute track
            for (var i = 0; i < lines.Length; i++)
            {
                var values = lines[i].Split(',');
                
                //
                var trackKey = values[1];
                if (trackKey == string.Empty) continue; //
                if (trackKey == "End") break;
                
                var track = StoryTrackDefine.GetStoryTrack(trackKey);
                if (track == null)
                {
                    Debug.LogError($" : {trackKey}\n : {string.Join(", ", values)}");
                    break;
                }
                
                //
                var parameters = CreateParameter(values);
                var nextTag = await track.ExecuteTrack(storyContext, parameters);
                
                //
                if (nextTag == null) continue;
                
                //
                if (!tagIndexTable.TryGetValue(nextTag, out var nextIndex))
                {
                    Debug.LogError($" :  : {trackKey}  : {nextTag}\n : {string.Join(", ", values)}");
                    break;
                }
                
                i = nextIndex - 1;
            }
            
            // Post process
            skitUI.gameObject.SetActive(false);
            storyContext.DestroyCharacter();
            IsPlayingSkit = false;
            
            #region Internal
            
            StoryContext PreProcess()
            {
                //
                var characters = new Dictionary<string, SkitCharacter>();
                foreach (var characterInfo in characterDefine.CharacterInfos)
                {
                    var character = Instantiate(characterInfo.CharacterPrefab);
                    character.Initialize(transform, characterInfo.CharacterKey);
                    characters.Add(characterInfo.CharacterKey, character);
                }
                
                // 
                skitUI.gameObject.SetActive(true);
                
                return new StoryContext(skitUI, characters, skitCamera, voiceDefine);
            }
            
            List<string> CreateParameter(string[] values)
            {
                var parameters = new List<string>();
                for (var j = 2; j < values.Length; j++) parameters.Add(values[j]);
                
                return parameters;
            }
            
            Dictionary<string, int> CreateTagIndexTable(string[] lines)
            {
                var tagIndex = new Dictionary<string, int>();
                for (var i = 0; i < lines.Length; i++)
                {
                    var values = lines[i].Split(',');
                    var tag = values[0];
                    if (tag == string.Empty) continue;
                    
                    if (tagIndex.ContainsKey(tag))
                    {
                        Debug.LogError($" : {tag} {i}");
                        break;
                    }
                    
                    tagIndex.Add(tag, i);
                }
                
                return tagIndex;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/WorldInstallationDatastoreTest.cs
```cs
using Game.Block.Interface;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Random = System.Random;

namespace Tests.UnitTest.Game
{
    public class WorldBlockDatastoreTest
    {
        [Test]
        public void RegisteredDataCoordinateFromFetchTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldData = ServerContext.WorldBlockDatastore;
            
            var random = new Random(131513);
            for (var i = 0; i < 10; i++)
            {
                var x = random.Next(-1000, 1000);
                var z = random.Next(-1000, 1000);
                var pos = new Vector3Int(x, 0, z);
                
                worldData.TryAddBlock(ForUnitTestModBlockId.MachineId, pos, BlockDirection.North, out var block);
                
                var output = worldData.GetBlock(pos);
                Assert.AreEqual(block.BlockInstanceId, output.BlockInstanceId);
            }
        }
        
        
        [Test]
        public void AlreadyRegisteredEntityIdSecondTimeFailTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldData = ServerContext.WorldBlockDatastore;
            
            var entityId = BlockInstanceId.Create();
            
            //TODO ID
            worldData.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(1, 1), BlockDirection.North, out var originalBlock);
            var blockGuid = originalBlock.BlockGuid;
            var state = originalBlock.GetSaveState();
            
            //intID
            var result = worldData.TryAddLoadedBlock(blockGuid, originalBlock.BlockInstanceId, state, new Vector3Int(10, 10), BlockDirection.North, out _);
            Assert.False(result);
        }
        
        [Test]
        public void AlreadyCoordinateSecondTimeFailTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldData = ServerContext.WorldBlockDatastore;
            
            worldData.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(1, 1), BlockDirection.North, out _);
            
            //id
            var result = worldData.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(1, 1), BlockDirection.North, out _);
            Assert.False(result);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/ItemInstanceId.cs
```cs
using System;
using UnitGenerator;

namespace Core.Item.Interface
{
    [UnitOf(typeof(long))]
    public partial struct ItemInstanceId
    {
        //TODO random
        private static readonly Random Random = new();
        
        public static ItemInstanceId Create()
        {
            long result = Random.Next(int.MinValue, int.MaxValue);
            result <<= 32;
            result |= (uint)Random.Next(int.MinValue, int.MaxValue);
            return new ItemInstanceId(result);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/SendCommandProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.SendCommandProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class SendCommandProtocolTest
    {
        [Test]
        public void GiveCommandTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            //
            //ID25
            var commandPacket = GetGiveCommandPacket(10, 2, 5);
            //
            packet.GetPacketResponse(commandPacket);
            
            
            //
            
            //
            var playerInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(10);
            
            //0
            var id2Slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            Assert.AreEqual(2, playerInventory.MainOpenableInventory.GetItem(id2Slot).Id.AsPrimitive());
            Assert.AreEqual(5, playerInventory.MainOpenableInventory.GetItem(id2Slot).Count);
            
            
            //ID1
            packet.GetPacketResponse(GetGiveCommandPacket(10, 3, 7));
            var id3Slot = PlayerInventoryConst.HotBarSlotToInventorySlot(1);
            Assert.AreEqual(3, playerInventory.MainOpenableInventory.GetItem(id3Slot).Id.AsPrimitive());
            Assert.AreEqual(7, playerInventory.MainOpenableInventory.GetItem(id3Slot).Count);
            
            //ID20
            packet.GetPacketResponse(GetGiveCommandPacket(10, 2, 3));
            Assert.AreEqual(2, playerInventory.MainOpenableInventory.GetItem(id2Slot).Id.AsPrimitive());
            Assert.AreEqual(8, playerInventory.MainOpenableInventory.GetItem(id2Slot).Count);
        }
        
        private List<byte> GetGiveCommandPacket(int playerId, int itemId, int count)
        {
            var giveCommand = $"give {playerId} {itemId} {count}"; //give <playerId> <itemId> <count>
            
            
            return MessagePackSerializer.Serialize(new SendCommandProtocolMessagePack(giveCommand)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World/DataStore/WorldBlockDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Block.Interface.State;
using Game.Context;
using Game.World.Interface.DataStore;
using UniRx;
using UnityEngine;

namespace Game.World.DataStore
{
    /// <summary>
    ///     
    /// </summary>
    public class WorldBlockDatastore : IWorldBlockDatastore
    {
        //
        public IReadOnlyDictionary<BlockInstanceId, WorldBlockData> BlockMasterDictionary => _blockMasterDictionary;
        private readonly Dictionary<BlockInstanceId, WorldBlockData> _blockMasterDictionary = new(); //EntityId
        //
        public IObservable<(BlockState state, WorldBlockData blockData)> OnBlockStateChange => _onBlockStateChange;
        private readonly Subject<(BlockState state, WorldBlockData blockData)> _onBlockStateChange = new();
        
        private readonly Dictionary<IBlockComponent, IBlock> _blockComponentDictionary = new(); //
        
        //
        private readonly Dictionary<Vector3Int, BlockInstanceId> _coordinateDictionary = new();
        private readonly IBlockFactory _blockFactory;
        
        public WorldBlockDatastore(IBlockFactory blockFactory)
        {
            _blockFactory = blockFactory;
        }
        
        public bool TryAddLoadedBlock(Guid blockGuid, BlockInstanceId blockInstanceId, Dictionary<string,string> componentStates, Vector3Int position, BlockDirection direction, out IBlock block)
        {
            var blockSize = MasterHolder.BlockMaster.GetBlockMaster(blockGuid).BlockSize;
            var blockPositionInfo = new BlockPositionInfo(position, direction, blockSize);
            block = _blockFactory.Load(blockGuid, blockInstanceId, componentStates, blockPositionInfo);
            return TryAddBlock(block);
        }
        public bool RemoveBlock(Vector3Int pos)
        {
            if (!this.Exists(pos)) return false;
            
            var entityId = GetEntityId(pos);
            if (!_blockMasterDictionary.ContainsKey(entityId)) return false;
            
            var data = _blockMasterDictionary[entityId];
            ((WorldBlockUpdateEvent)ServerContext.WorldBlockUpdateEvent).OnBlockRemoveEventInvoke(pos, data);
            
            data.Block.Destroy();
            _blockMasterDictionary.Remove(entityId);
            _coordinateDictionary.Remove(pos);
            return true;
        }
        
        
        public IBlock GetBlock(Vector3Int pos)
        {
            return GetBlockData(pos)?.Block;
        }
        
        public IBlock GetBlock(IBlockComponent component)
        {
            return _blockComponentDictionary.GetValueOrDefault(component);
        }
        
        public WorldBlockData GetOriginPosBlock(Vector3Int pos)
        {
            return _coordinateDictionary.TryGetValue(pos, out var entityId)
                ? _blockMasterDictionary.TryGetValue(entityId, out var data) ? data : null
                : null;
        }
        
        public BlockDirection GetBlockDirection(Vector3Int pos)
        {
            var block = GetBlockData(pos);
            //TODO 
            return block?.BlockPositionInfo.BlockDirection ?? BlockDirection.North;
        }
        
        public IBlock GetBlock(BlockInstanceId blockInstanceId)
        {
            return _blockMasterDictionary.TryGetValue(blockInstanceId, out var data) ? data.Block : null;
        }
        
        public Vector3Int GetBlockPosition(BlockInstanceId blockInstanceId)
        {
            if (_blockMasterDictionary.TryGetValue(blockInstanceId, out var data)) return data.BlockPositionInfo.OriginalPos;
            
            throw new Exception("");
        }
        
        public bool TryAddBlock(BlockId blockId, Vector3Int position, BlockDirection direction, out IBlock block)
        {
            var blockSize = MasterHolder.BlockMaster.GetBlockMaster(blockId).BlockSize;
            var blockPositionInfo = new BlockPositionInfo(position, direction, blockSize);
            block = _blockFactory.Create(blockId, BlockInstanceId.Create(), blockPositionInfo);
            return TryAddBlock(block);
        }
        
        private bool TryAddBlock(IBlock block)
        {
            var pos = block.BlockPositionInfo.OriginalPos;
            var blockDirection = block.BlockPositionInfo.BlockDirection;
            
            //
            if (!_blockMasterDictionary.ContainsKey(block.BlockInstanceId) &&
                !_coordinateDictionary.ContainsKey(pos))
            {
                var data = new WorldBlockData(block, pos, blockDirection);
                _blockMasterDictionary.Add(block.BlockInstanceId, data);
                _coordinateDictionary.Add(pos, block.BlockInstanceId);
                ((WorldBlockUpdateEvent)ServerContext.WorldBlockUpdateEvent).OnBlockPlaceEventInvoke(pos, data);
                
                block.BlockStateChange.Subscribe(state => { _onBlockStateChange.OnNext((state, data)); });
                
                foreach (var component in block.ComponentManager.GetComponents<IBlockComponent>())
                {
                    _blockComponentDictionary.Add(component, block);
                }
                
                return true;
            }
            
            return false;
        }
        
        private BlockInstanceId GetEntityId(Vector3Int pos)
        {
            return GetBlockData(pos).Block.BlockInstanceId;
        }
        
        /// <summary>
        ///     TODO GetBlock
        /// </summary>
        private WorldBlockData GetBlockData(Vector3Int pos)
        {
            foreach (KeyValuePair<BlockInstanceId, WorldBlockData> block in
                     _blockMasterDictionary.Where(block => block.Value.BlockPositionInfo.IsContainPos(pos)))
                return block.Value;
            
            return null;
        }
        
        #region Save&Load
        
        public List<BlockJsonObject> GetSaveJsonObject()
        {
            var list = new List<BlockJsonObject>();
            foreach (KeyValuePair<BlockInstanceId, WorldBlockData> block in _blockMasterDictionary)
                list.Add(new BlockJsonObject(
                    block.Value.BlockPositionInfo.OriginalPos,
                    block.Value.Block.BlockGuid.ToString(),
                    block.Value.Block.BlockInstanceId.AsPrimitive(),
                    block.Value.Block.GetSaveState(),
                    (int)block.Value.BlockPositionInfo.BlockDirection));
            
            return list;
        }
        
        //TODO 
        public void LoadBlockDataList(List<BlockJsonObject> saveBlockDataList)
        {
            var blockFactory = ServerContext.BlockFactory;
            foreach (var blockSave in saveBlockDataList)
            {
                var blockId = MasterHolder.BlockMaster.GetBlockId(blockSave.BlockGuid);
                
                var pos = blockSave.Pos;
                var direction = (BlockDirection)blockSave.Direction;
                var size = MasterHolder.BlockMaster.GetBlockMaster(blockId).BlockSize;
                
                var blockData = new BlockPositionInfo(pos, direction, size);
                var block = blockFactory.Load(blockSave.BlockGuid, new BlockInstanceId(blockSave.EntityId), blockSave.ComponentStates, blockData);
                
                TryAddBlock(block);
            }
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/ICraftChainerNode.cs
```cs
using Game.Block.Interface.Component;
using UnitGenerator;
using UnityEngine;
using Random = System.Random;

namespace Game.CraftChainer.CraftNetwork
{
    /// <summary>
    /// CraftChainer
    /// IDIBlockSaveState
    ///
    /// An interface to indicate that it is a block that makes up the CraftChainer network.
    /// Inherits IBlockSaveState because the ID needs to be persisted
    /// </summary>
    public interface ICraftChainerNode : IBlockSaveState 
    {
        public CraftChainerNodeId NodeId { get; }
    }
    
    [UnitOf(typeof(int))]
    public partial struct CraftChainerNodeId
    {
        public static CraftChainerNodeId Invalid => new(-1); 
            
        private static readonly Random _random = new();
        
        public static CraftChainerNodeId Create()
        {
            var id = _random.Next(int.MinValue, int.MaxValue);
            while (id == Invalid.value)
            {
                id = _random.Next(int.MinValue, int.MaxValue);
            }
            
            return new CraftChainerNodeId(id);
        } 
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventProtocolProvider.cs
```cs
using System;
using System.Collections.Generic;
using MessagePack;
using Server.Event.EventReceive;

namespace Server.Event
{
    /// <summary>
    ///     
    ///     EventReceive
    ///     TODO 
    /// </summary>
    public class EventProtocolProvider
    {
        private readonly Dictionary<int, List<EventMessagePack>> _events = new();
        
        public void AddEvent(int playerId, string tag, byte[] payload)
        {
            lock (_events)
            {
                var eventMessagePack = new EventMessagePack(tag, payload);
                
                if (_events.TryGetValue(playerId, out var eventList))
                    eventList.Add(eventMessagePack);
                else
                    _events.Add(playerId, new List<EventMessagePack> { eventMessagePack });
            }
        }
        
        public void AddBroadcastEvent(string tag, byte[] payload)
        {
            lock (_events)
            {
                var eventMessagePack = new EventMessagePack(tag, payload);
                
                foreach (var key in _events.Keys) _events[key].Add(eventMessagePack);
            }
        }
        
        public List<EventMessagePack> GetEventBytesList(int playerId)
        {
            lock (_events)
            {
                if (_events.ContainsKey(playerId))
                {
                    var events = _events[playerId];
                    var data = new List<EventMessagePack>();
                    data.AddRange(events);
                    
                    _events[playerId].Clear();
                    return data;
                }
                
                //Dictionary
                _events.Add(playerId, new List<EventMessagePack>());
                
                return new List<EventMessagePack>();
            }
        }
    }
    
    
    [MessagePackObject]
    public class EventMessagePack
    {
        public EventMessagePack(string tag, byte[] payload)
        {
            Tag = tag;
            Payload = payload;
        }
        
        [Obsolete("")]
        public EventMessagePack()
        {
        }
        
        [Key(0)] public string Tag { get; set; }
        
        [Key(1)] public byte[] Payload { get; set; }
        
        [Key(2)] public Dictionary<string,BlockStateMessagePack> MessagePacks { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/RemoveBlockProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.RemoveBlockProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class RemoveBlockProtocolTest
    {
        private const int MachineBlockId = 1;
        private const int PlayerId = 0;
        
        [Test]
        public void RemoveTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlock = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            
            //
            worldBlock.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var block);
            var blockInventory = block.GetComponent<IBlockInventory>();
            blockInventory.InsertItem(itemStackFactory.Create(new ItemId(10), 7));
            var blockElement = MasterHolder.BlockMaster.GetBlockMaster(block.BlockId);
            
            //
            packet.GetPacketResponse(RemoveBlock(new Vector3Int(0, 0), PlayerId));
            
            
            //
            Assert.False(worldBlock.Exists(new Vector3Int(0, 0)));
            
            
            var playerSlotIndex = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            //
            Assert.AreEqual(10, playerInventoryData.MainOpenableInventory.GetItem(playerSlotIndex).Id.AsPrimitive());
            Assert.AreEqual(7, playerInventoryData.MainOpenableInventory.GetItem(playerSlotIndex).Count);
            
            //
            var blockItemId = MasterHolder.ItemMaster.GetItemId(blockElement.ItemGuid);
            Assert.AreEqual(blockItemId, playerInventoryData.MainOpenableInventory.GetItem(playerSlotIndex + 1).Id);
            Assert.AreEqual(1, playerInventoryData.MainOpenableInventory.GetItem(playerSlotIndex + 1).Count);
        }
        
        
        //
        [Test]
        public void InventoryFullToRemoveBlockSomeItemRemainTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlock = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId).MainOpenableInventory;
            
            //2
            for (var i = 2; i < mainInventory.GetSlotSize(); i++)
                mainInventory.SetItem(i, itemStackFactory.Create(new ItemId(10), 1));
            
            //ID31
            var id3MaxStack = MasterHolder.ItemMaster.GetItemMaster(new ItemId(3)).MaxStack;
            mainInventory.SetItem(0, itemStackFactory.Create(new ItemId(3), id3MaxStack - 1));
            //ID41
            mainInventory.SetItem(1, itemStackFactory.Create(new ItemId(4), 1));
            
            
            //
            worldBlock.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var block);
            var blockInventory = block.GetComponent<IBlockInventory>();
            //ID32ID45
            //ID31
            blockInventory.SetItem(0, itemStackFactory.Create(new ItemId(3), 2));
            blockInventory.SetItem(1, itemStackFactory.Create(new ItemId(4), 5));
            
            
            //
            packet.GetPacketResponse(RemoveBlock(new Vector3Int(0, 0), PlayerId));
            
            
            //
            Assert.True(worldBlock.Exists(new Vector3Int(0, 0)));
            
            //
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), id3MaxStack), mainInventory.GetItem(0));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(4), 6), mainInventory.GetItem(1));
            
            //
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 1), blockInventory.GetItem(0));
            Assert.AreEqual(itemStackFactory.CreatEmpty(), blockInventory.GetItem(1));
        }
        
        //
        [Test]
        public void InventoryFullToCantRemoveBlockTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlock = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var mainInventory =
                serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId)
                    .MainOpenableInventory;
            
            //
            for (var i = 0; i < mainInventory.GetSlotSize(); i++)
                mainInventory.SetItem(i, itemStackFactory.Create(new ItemId(10), 1));
            
            //
            worldBlock.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out _);
            
            
            //
            packet.GetPacketResponse(RemoveBlock(new Vector3Int(0, 0), PlayerId));
            
            
            //
            Assert.True(worldBlock.Exists(new Vector3Int(0, 0)));
        }
        
        
        private List<byte> RemoveBlock(Vector3Int pos, int playerId)
        {
            return MessagePackSerializer.Serialize(new RemoveBlockProtocolMessagePack(playerId, pos)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Mod.Base/MoorestechServerModEntryPoint.cs
```cs
using Core.Update;
using UniRx;

namespace Mod.Base
{
    public abstract class MoorestechServerModEntryPoint
    {
        public MoorestechServerModEntryPoint()
        {
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        /// <summary>
        ///     
        /// </summary>
        private void Update()
        {
        }
        
        /// <summary>
        ///     Mod
        /// </summary>
        /// <param name="serverModEntryInterface">DI</param>
        public abstract void OnLoad(ServerModEntryInterface serverModEntryInterface);
    }
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearStateDetail.cs
```cs
using System;
using MessagePack;

namespace Game.Gear.Common
{
    [MessagePackObject]
    public class GearStateDetail
    {
        [Key(0)] public float CurrentRpm { get; set; }
        
        [Key(1)] public bool IsClockwise { get; set; }
        
        public const string BlockStateDetailKey = "GearStateData";
        public GearStateDetail(float currentRpm, bool isClockwise)
        {
            CurrentRpm = currentRpm;
            IsClockwise = isClockwise;
        }
        
        [Obsolete("")]
        public GearStateDetail()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/AssemblePlayerInventorySaveJsonTextTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class AssemblePlayerInventorySaveJsonTextTest
    {
        [Test]
        public void OnePlayerTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventory = saveServiceProvider.GetService<IPlayerInventoryDataStore>();
            var itemStackFactory = ServerContext.ItemStackFactory;
            var assembleJsonText = saveServiceProvider.GetService<AssembleSaveJsonText>();
            
            var playerEntityId = 100;
            
            //
            var inventory = playerInventory.GetInventoryData(playerEntityId);
            
            //
            var mainItems = new Dictionary<int, IItemStack>();
            mainItems.Add(0, itemStackFactory.Create(new ItemId(2), 10));
            mainItems.Add(10, itemStackFactory.Create(new ItemId(5), 1));
            mainItems.Add(30, itemStackFactory.Create(new ItemId(10), 10));
            mainItems.Add(PlayerInventoryConst.MainInventorySize - 1, itemStackFactory.Create(new ItemId(12), 11));
            
            var craftItems = new Dictionary<int, IItemStack>();
            craftItems.Add(0, itemStackFactory.Create(new ItemId(2), 5));
            craftItems.Add(1, itemStackFactory.Create(new ItemId(3), 4));
            craftItems.Add(7, itemStackFactory.Create(new ItemId(4), 7));
            
            //
            foreach (var item in mainItems) inventory.MainOpenableInventory.SetItem(item.Key, item.Value);
            
            
            //
            var json = assembleJsonText.AssembleSaveJson();
            
            
            //
            var (_, loadServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            (loadServiceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(json);
            var loadedPlayerInventory = loadServiceProvider.GetService<IPlayerInventoryDataStore>()
                .GetInventoryData(playerEntityId);
            
            //
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                if (mainItems.ContainsKey(i))
                {
                    Assert.AreEqual(mainItems[i], loadedPlayerInventory.MainOpenableInventory.GetItem(i));
                    continue;
                }
                
                Assert.AreEqual(itemStackFactory.CreatEmpty(), loadedPlayerInventory.MainOpenableInventory.GetItem(i));
            }
        }
        
        /// <summary>
        ///     
        /// </summary>
        [Test]
        public void MultiplePlayerSaveTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventory = saveServiceProvider.GetService<IPlayerInventoryDataStore>();
            var itemStackFactory = ServerContext.ItemStackFactory;
            var seed = 13143;
            
            //
            var playerItems = new Dictionary<int, Dictionary<int, IItemStack>>();
            var random = new Random(seed);
            for (var i = 0; i < 20; i++)
            {
                var playerId = random.Next();
                playerItems.Add(playerId, CreateSetItems(random, itemStackFactory));
            }
            
            //
            foreach (var playerItem in playerItems)
            {
                var inventory = playerInventory.GetInventoryData(playerItem.Key);
                foreach (var item in playerItem.Value) inventory.MainOpenableInventory.SetItem(item.Key, item.Value);
            }
            
            //
            var json = saveServiceProvider.GetService<AssembleSaveJsonText>().AssembleSaveJson();
            
            
            //
            var (_, loadServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            (loadServiceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(json);
            var loadedPlayerInventory = loadServiceProvider.GetService<IPlayerInventoryDataStore>();
            
            //
            foreach (var playerItem in playerItems)
            {
                var loadedInventory = loadedPlayerInventory.GetInventoryData(playerItem.Key);
                //
                for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
                {
                    if (playerItem.Value.ContainsKey(i))
                    {
                        Assert.AreEqual(playerItem.Value[i], loadedInventory.MainOpenableInventory.GetItem(i));
                        continue;
                    }
                    
                    Assert.AreEqual(itemStackFactory.CreatEmpty(), loadedInventory.MainOpenableInventory.GetItem(i));
                }
            }
        }
        
        private Dictionary<int, IItemStack> CreateSetItems(Random random, IItemStackFactory itemStackFactory)
        {
            var items = new Dictionary<int, IItemStack>();
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                if (random.Next(0, 2) == 0) continue;
                var id = new ItemId(random.Next(1, 20));
                var count = random.Next(1, 20);
                items.Add(i, itemStackFactory.Create(id, count));
            }
            
            return items;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/BlockInventoryState.cs
```cs
using System.Threading;
using Client.Common.Asset;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Control;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Block;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Input;
using Cysharp.Threading.Tasks;
using Game.Context;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState
{
    public class BlockInventoryState : IUIState
    {
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        private readonly PlayerInventoryViewController _playerInventoryViewController;
        
        private CancellationTokenSource _loadBlockInventoryCts;
        private IBlockInventoryView _iIBlockInventoryView;
        private Vector3Int _openBlockPos;
        
        public BlockInventoryState(BlockGameObjectDataStore blockGameObjectDataStore, PlayerInventoryViewController playerInventoryViewController)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            _playerInventoryViewController = playerInventoryViewController;
            
            ClientContext.VanillaApi.Event.SubscribeEventResponse(OpenableBlockInventoryUpdateEventPacket.EventTag, OnOpenableBlockInventoryUpdateEvent);
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.CloseUI.GetKeyDown || InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.GameScreen;
            
            return UIStateEnum.Current;
        }
        
        // ReSharper disable Unity.PerformanceAnalysis
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            BlockGameObject blockGameObject = null;
            if (!IsExistBlock())
            {
                return;
            }
            
            _loadBlockInventoryCts = new CancellationTokenSource();
            LoadBlockInventory().Forget();
            
            #region Internal
            
            bool IsExistBlock()
            {
                if (!BlockClickDetect.TryGetCursorOnBlockPosition(out _openBlockPos))
                {
                    // TODO 
                    Debug.LogError("UI");
                    return false;
                }
                
                if (!_blockGameObjectDataStore.TryGetBlockGameObject(_openBlockPos, out blockGameObject))
                {
                    // TODO 
                    Debug.LogError("");
                    return false;
                }
                
                var blockMaster = blockGameObject.BlockMasterElement;
                var inventoryPath = blockMaster.BlockUIAddressablesPath;
                if (string.IsNullOrEmpty(inventoryPath))
                {
                    // TODO 
                    Debug.LogError($"Addressable Guid:{blockMaster.BlockGuid} Name:{blockMaster.Name}");

                    return false;
                }
                
                return true;
            }
            
            async UniTask LoadBlockInventory()
            {
                //
                var blockMaster = blockGameObject.BlockMasterElement;
                var path = blockMaster.BlockUIAddressablesPath;
                using var loadedInventory = await AddressableLoader.LoadAsync<GameObject>(path);
                if (loadedInventory == null)
                {
                    // TODO 
                    Debug.LogError($" Guid:{blockMaster.BlockGuid} Name:{blockMaster.Name} Path:{path}");
                    return;
                }
                if (!loadedInventory.Asset.TryGetComponent(out IBlockInventoryView _))
                {
                    // TODO 
                    Debug.LogError($" Guid:{blockMaster.BlockGuid} Name:{blockMaster.Name} Path:{path}");
                    return;
                }
                
                // check cts
                if (_loadBlockInventoryCts.IsCancellationRequested) return;
                
                // 
                // Show cursor
                InputManager.MouseCursorVisible(true);
                
                // UI
                // Generate and turn on the UI object
                _iIBlockInventoryView = ClientContext.DIContainer.Instantiate(loadedInventory.Asset, _playerInventoryViewController.SubInventoryParent).GetComponent<IBlockInventoryView>();
                _iIBlockInventoryView.Initialize(blockGameObject);
                _playerInventoryViewController.SetActive(true);
                _playerInventoryViewController.SetSubInventory(_iIBlockInventoryView);
                
                // check cts
                if (_loadBlockInventoryCts.IsCancellationRequested) return;
                
                // 
                // Get block inventory data
                ClientContext.VanillaApi.SendOnly.SetOpenCloseBlock(_openBlockPos, true);
                var response = await ClientContext.VanillaApi.Response.GetBlockInventory(_openBlockPos, _loadBlockInventoryCts.Token);
                _iIBlockInventoryView?.UpdateItemList(response);
            }
            
            #endregion
        }
        
        public void OnExit()
        {
            _loadBlockInventoryCts?.Cancel();
            
            // 
            // Close block settings
            ClientContext.VanillaApi.SendOnly.SetOpenCloseBlock(_openBlockPos, false);
            
            // 
            // Set the sub inventory to empty
            _playerInventoryViewController.SetSubInventory(new EmptySubInventory());
            
            // 
            // Close the block inventory
            _playerInventoryViewController.SetActive(false);
            _iIBlockInventoryView?.DestroyUI();
            _iIBlockInventoryView = null;
        }
        
        private void OnOpenableBlockInventoryUpdateEvent(byte[] payload)
        {
            if (_iIBlockInventoryView == null) return;
            
            var packet = MessagePackSerializer.Deserialize<OpenableBlockInventoryUpdateEventMessagePack>(payload);
            var item = ServerContext.ItemStackFactory.Create(packet.Item.Id, packet.Item.Count);
            _iIBlockInventoryView.UpdateInventorySlot(packet.Slot, item);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/UtilTest.cs
```cs
using Game.Block;
using NUnit.Framework;

namespace Tests.UnitTest.Core.Other
{
    public class UtilTest
    {
        //1
        //+-5%
        [TestCase(0.0)]
        [TestCase(0.1)]
        [TestCase(0.2)]
        [TestCase(0.3)]
        [TestCase(0.3)]
        [TestCase(0.5)]
        [TestCase(0.6)]
        [TestCase(0.7)]
        [TestCase(0.8)]
        [TestCase(0.9)]
        [TestCase(1)]
        public void DetectFromPercentTest(double percent)
        {
            var trueCnt = 0;
            for (var i = 0; i < 10000; i++)
                if (ProbabilityCalculator.DetectFromPercent(percent))
                    trueCnt++;
            
            var truePercent = trueCnt / 10000.0;
            Assert.True(percent - 0.5 < truePercent);
            Assert.True(truePercent < percent + 0.5);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerMainComputerSaveLoadTest.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerMainComputerSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);
            
            // ChainerMainComputer
            // Create a ChainerMainComputer block
            var mainComputerBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerMainComputer, new BlockInstanceId(1), posInfo);
            var originalMainComputerComponent = mainComputerBlock.GetComponent<CraftChainerMainComputerComponent>();
            
            
            // 
            // Get the save data
            var saveState = mainComputerBlock.GetSaveState();
            
            // 
            // Load the block
            var loadedBlock = blockFactory.Load(mainComputerBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedMainComputerComponent = loadedBlock.GetComponent<CraftChainerMainComputerComponent>();
            
            // NodeId
            // Check if NodeId is correctly saved and loaded
            Assert.AreEqual(originalMainComputerComponent.NodeId, loadedMainComputerComponent.NodeId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/VanillaBeltConveyorBlockInventoryInserter.cs
```cs
using System.Linq;
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;

namespace Game.Block.Blocks.BeltConveyor
{
    public class VanillaBeltConveyorBlockInventoryInserter : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        public VanillaBeltConveyorBlockInventoryInserter(BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockConnectorComponent = blockConnectorComponent;
        }

        public IItemStack InsertItem(IItemStack itemStack)
        {
            var targets = _blockConnectorComponent.ConnectedTargets;
            if (targets.Count == 0) return itemStack;
            
            var connector = targets.First();
            var output = connector.Key.InsertItem(itemStack);
            
            return output;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/IItemCollectableBeltConveyor.cs
```cs
using System.Collections.Generic;
using Game.Block.Interface.Component;

namespace Game.Block.Blocks.BeltConveyor
{
    public interface IItemCollectableBeltConveyor : IBlockComponent
    {
        public BeltConveyorSlopeType SlopeType { get; }
        public IReadOnlyList<IOnBeltConveyorItem> BeltConveyorItems { get; }
    }
    
    public enum BeltConveyorSlopeType
    {
        Straight,
        Up,
        Down
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaItemShooterTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.ItemShooter;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaItemShooterTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var itemShooter = blockMasterElement.BlockParam as ItemShooterBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(itemShooter.InventoryConnectors, blockPositionInfo);
            
            var direction = blockPositionInfo.BlockDirection;
            var chestComponent = new ItemShooterComponent(inputConnectorComponent, itemShooter);
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var itemShooter = blockMasterElement.BlockParam as ItemShooterBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(itemShooter.InventoryConnectors, blockPositionInfo);
            
            var direction = blockPositionInfo.BlockDirection;
            var chestComponent = new ItemShooterComponent(componentStates, inputConnectorComponent, itemShooter);
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/RecipeTabView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Sub;
using Core.Master;
using Game.CraftChainer.Util;
using UniRx;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class RecipeTabView : MonoBehaviour
    {
        [SerializeField] private RecipeViewerTabElement tabElementPrefab;
        [SerializeField] private Transform tabElementParent;
        [SerializeField] private HorizontalLayoutGroup tabElementLayoutGroup; 
        
        public IObservable<BlockId?> OnClickTab => onClickTab; // nullCraft
        private readonly Subject<BlockId?> onClickTab = new(); // If null, it means that Craft is selected
        
        private readonly List<RecipeViewerTabElement> _currentTabs = new();
        
        public void SetRecipeTabView(RecipeViewerItemRecipes recipes)
        {
            foreach (var tab in _currentTabs)
            {
                Destroy(tab.gameObject);
            }
            
            _currentTabs.Clear();
            
            // 
            // If there is a craft tab, select it preferentially
            var isFirstCraft = false;
            if (recipes.CraftRecipes.Count != 0)
            {
                var tabElement = Instantiate(tabElementPrefab, tabElementParent);
                tabElement.Initialize();
                tabElement.SetCraftIcon();
                tabElement.SetSelected(true);
                tabElement.OnClickTab.Subscribe(OnClickTabAction);
                _currentTabs.Add(tabElement);
                isFirstCraft = true;
            }
            
            var isFirst = true;
            foreach (var machineRecipe in recipes.MachineRecipes)
            {
                var blockId = machineRecipe.Key;
                var itemId = MasterHolder.BlockMaster.GetItemId(blockId);
                var blockItemView = ClientContext.ItemImageContainer.GetItemView(itemId);
                
                var tabElement = Instantiate(tabElementPrefab, tabElementParent);
                tabElement.Initialize();
                tabElement.SetMachineItem(blockId, blockItemView);
                tabElement.OnClickTab.Subscribe(OnClickTabAction);
                _currentTabs.Add(tabElement);
                
                // 
                // If there is no craft tab, select the first tab
                tabElement.SetSelected(isFirst && !isFirstCraft);
                isFirst = false;
            }
            
            //   
            // Force the layout to be applied
            UpdateLayoutGroup();
        }
        
        
        private void OnClickTabAction(RecipeViewerTabElement tabElement)
        {
            tabElement.SetSelected(true);
            foreach (var tab in _currentTabs)
            {
                if (tab == tabElement) continue;
                tab.SetSelected(false);
            }
            
            onClickTab.OnNext(tabElement.CurrentBlockId);
            
            UpdateLayoutGroup();
        }
        
        private void UpdateLayoutGroup()
        {
            tabElementLayoutGroup.CalculateLayoutInputHorizontal();
            tabElementLayoutGroup.CalculateLayoutInputVertical();
            
            tabElementLayoutGroup.SetLayoutHorizontal();
            tabElementLayoutGroup.SetLayoutVertical();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/CraftChain/CraftingSolverRecipe.cs
```cs
using System;
using System.Collections.Generic;
using MessagePack;
using Newtonsoft.Json;
using UnitGenerator;

namespace Game.CraftChainer.CraftChain
{
    public class CraftingSolverRecipe
    {
        public readonly CraftingSolverRecipeId CraftingSolverRecipeId;
        public readonly List<CraftingSolverItem> Inputs;
        public readonly List<CraftingSolverItem> Outputs;
        
        public CraftingSolverRecipe(CraftingSolverRecipeId craftingSolverRecipeId, List<CraftingSolverItem> inputs, List<CraftingSolverItem> outputs)
        {
            CraftingSolverRecipeId = craftingSolverRecipeId;
            Inputs = inputs;
            Outputs = outputs;
        }
        
        public CraftingSolverRecipe()
        {
            CraftingSolverRecipeId = CraftingSolverRecipeId.InvalidId;
            Inputs = new List<CraftingSolverItem>();
            Outputs = new List<CraftingSolverItem>();
        }
    }
    
    [UnitOf(typeof(int), UnitGenerateOptions.Comparable)]
    public partial struct CraftingSolverRecipeId
    {
        public static readonly CraftingSolverRecipeId InvalidId = new(0);
        
        private static readonly Random Random = new();
        public static CraftingSolverRecipeId Create()
        {
            // 1  int.Max
            var id = Random.Next(1, int.MaxValue);
            return new CraftingSolverRecipeId(id);
        }
    }
    
    [JsonObject, MessagePackObject]
    public class CraftingSolverRecipeJsonObjectMessagePack
    {
        [JsonProperty("recipeId"), Key(0)] public int RecipeId;
        [JsonProperty("inputs"), Key(1)] public List<CraftingSolverItemJsonObjectMessagePack> Inputs;
        [JsonProperty("outputs"), Key(2)] public List<CraftingSolverItemJsonObjectMessagePack> Outputs;
        
        public CraftingSolverRecipeJsonObjectMessagePack() { }

        public CraftingSolverRecipeJsonObjectMessagePack(CraftingSolverRecipe craftingSolverRecipe)
        {
            RecipeId = craftingSolverRecipe.CraftingSolverRecipeId.AsPrimitive();
            Inputs = new List<CraftingSolverItemJsonObjectMessagePack>();
            foreach (var input in craftingSolverRecipe.Inputs)
            {
                Inputs.Add(new CraftingSolverItemJsonObjectMessagePack(input));
            }
            Outputs = new List<CraftingSolverItemJsonObjectMessagePack>();
            foreach (var output in craftingSolverRecipe.Outputs)
            {
                Outputs.Add(new CraftingSolverItemJsonObjectMessagePack(output));
            }
        }
        
        public CraftingSolverRecipe ToCraftingSolverRecipe()
        {
            var inputs = new List<CraftingSolverItem>();
            foreach (var input in Inputs)
            {
                inputs.Add(input.ToCraftingSolverItem());
            }
            var outputs = new List<CraftingSolverItem>();
            foreach (var output in Outputs)
            {
                outputs.Add(output.ToCraftingSolverItem());
            }
            
            return new CraftingSolverRecipe(new CraftingSolverRecipeId(RecipeId), inputs, outputs);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/BlockInventoryRequestProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Interface.Component;
using Game.Context;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlocksModule;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class BlockInventoryRequestProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:blockInvReq";
        
        public BlockInventoryRequestProtocol(ServiceProvider serviceProvider)
        {
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestBlockInventoryRequestProtocolMessagePack>(payload.ToArray());
            
            //
            var blockDatastore = ServerContext.WorldBlockDatastore;
            if (!blockDatastore.ExistsComponent<IOpenableBlockInventoryComponent>(data.Pos))
                return null;
            
            
            //ID
            var blockId = blockDatastore.GetBlock(data.Pos).BlockId;
            
            return new BlockInventoryResponseProtocolMessagePack(blockId, blockDatastore.GetBlock<IOpenableBlockInventoryComponent>(data.Pos).InventoryItems);
        }
        
        //delegate
        private delegate byte[] InventoryResponse(Vector3Int pos, IBlockParam blockParam);
        
        
        [MessagePackObject]
        public class RequestBlockInventoryRequestProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack Pos { get; set; }
            
            [Obsolete("")]
            public RequestBlockInventoryRequestProtocolMessagePack()
            {
            }
            
            public RequestBlockInventoryRequestProtocolMessagePack(Vector3Int pos)
            {
                Tag = ProtocolTag;
                Pos = new Vector3IntMessagePack(pos);
            }
        }
        
        [MessagePackObject]
        public class BlockInventoryResponseProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int BlockId { get; set; }
            [Key(3)] public ItemMessagePack[] Items { get; set; }
            
            
            [Obsolete("")]
            public BlockInventoryResponseProtocolMessagePack() { }
            
            public BlockInventoryResponseProtocolMessagePack(BlockId blockId, IReadOnlyList<IItemStack> items)
            {
                Tag = ProtocolTag;
                BlockId = (int)blockId;
                Items = items.Select(item => new ItemMessagePack(item)).ToArray();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/OneClickCraft.cs
```cs
using System;
using System.Collections.Generic;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.Crafting.Interface;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.CraftRecipesModule;

namespace Server.Protocol.PacketResponse
{
    public class OneClickCraft : IPacketResponse
    {
        public const string ProtocolTag = "va:oneClickCraft";
        private readonly CraftEvent _craftEvent;
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public OneClickCraft(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
            _craftEvent = serviceProvider.GetService<CraftEvent>();
        }
        
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<RequestOneClickCraftProtocolMessagePack>(payload.ToArray());
            
            var craftConfig = MasterHolder.CraftRecipeMaster.GetCraftRecipe(data.CraftRecipeGuid);
            //
            var playerInventory = _playerInventoryDataStore.GetInventoryData(data.PlayerId);
            var mainInventory = playerInventory.MainOpenableInventory;
            
            //
            if (!IsCraftable(mainInventory, craftConfig))
                //
                return null;
            
            //
            
            //
            ConsumptionItem(mainInventory, craftConfig);
            //
            var resultItem = ServerContext.ItemStackFactory.Create(craftConfig.CraftResultItemGuid, craftConfig.CraftResultCount);
            playerInventory.MainOpenableInventory.InsertItem(resultItem);
            
            _craftEvent.InvokeCraftItem(craftConfig);
            
            return null;
        }
        
        private static bool IsCraftable(IOpenableInventory mainInventory, CraftRecipeMasterElement recipe)
        {
            //
            var resultItem = ServerContext.ItemStackFactory.Create(recipe.CraftResultItemGuid, recipe.CraftResultCount);
            var resultItemList = new List<IItemStack> { resultItem };
            if (!mainInventory.InsertionCheck(resultItemList))
                return false;
            
            //
            //key itemId value count
            var requiredItems = new Dictionary<ItemId, int>();
            foreach (var requiredItem in recipe.RequiredItems)
            {
                var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (requiredItems.ContainsKey(requiredItemId))
                {
                    requiredItems[requiredItemId] += requiredItem.Count;
                }
                else
                {
                    requiredItems.Add(requiredItemId, requiredItem.Count);
                }
            }
            
            //
            var checkResult = new Dictionary<ItemId, int>();
            foreach (var itemStack in mainInventory.InventoryItems)
            {
                if (!requiredItems.ContainsKey(itemStack.Id)) continue;
                
                if (checkResult.ContainsKey(itemStack.Id))
                    checkResult[itemStack.Id] += itemStack.Count;
                else
                    checkResult[itemStack.Id] = itemStack.Count;
            }
            
            //
            foreach (var requiredItem in requiredItems)
            {
                if (!checkResult.ContainsKey(requiredItem.Key)) return false;
                if (checkResult[requiredItem.Key] < requiredItem.Value) return false;
            }
            
            
            return true;
        }
        
        
        /// <summary>
        ///     
        /// </summary>
        private static void ConsumptionItem(IOpenableInventory mainInventory, CraftRecipeMasterElement recipe)
        {
            //
            //key itemId value count
            var requiredItems = new Dictionary<ItemId, int>();
            foreach (var requiredItem in recipe.RequiredItems)
            {
                if (requiredItem.IsRemain.HasValue && requiredItem.IsRemain.Value) 
                {
                    continue;
                }
                
                var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (requiredItems.ContainsKey(requiredItemId))
                    requiredItems[requiredItemId] += requiredItem.Count;
                else
                    requiredItems.Add(requiredItemId, requiredItem.Count);
            }
            
            //
            for (var i = 0; i < mainInventory.InventoryItems.Count; i++)
            {
                var inventoryItem = mainInventory.InventoryItems[i];
                if (!requiredItems.TryGetValue(inventoryItem.Id, out var subCount)) continue;
                
                if (inventoryItem.Count <= subCount)
                {
                    mainInventory.SetItem(i, inventoryItem.SubItem(inventoryItem.Count));
                    requiredItems[inventoryItem.Id] -= inventoryItem.Count;
                }
                else
                {
                    mainInventory.SetItem(i, inventoryItem.SubItem(subCount));
                    requiredItems[inventoryItem.Id] -= subCount;
                }
            }
        }
        
        [MessagePackObject]
        public class RequestOneClickCraftProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Key(3)] public string CraftRecipeGuidStr { get; set; }
            [IgnoreMember] public Guid CraftRecipeGuid => Guid.Parse(CraftRecipeGuidStr);
            
            public RequestOneClickCraftProtocolMessagePack(int playerId, Guid craftRecipeGuid)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                CraftRecipeGuidStr = craftRecipeGuid.ToString();
            }
            
            [Obsolete("")]
            public RequestOneClickCraftProtocolMessagePack() { }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Server/PacketBufferParserTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using MessagePack;
using NUnit.Framework;
using Server.Util;

namespace Tests.UnitTest.Server
{
    /// <summary>
    ///     <see cref="PacketBufferParser" />
    /// </summary>
    public class PacketBufferParserTest
    {
        /// <summary>
        ///     
        ///     12
        /// </summary>
        [Test]
        public void PacketBufferPasserNoOverflowTest()
        {
            //5
            var testMessageBytes = MessagePackSerializer.Serialize(new PasserTestMessagePack { t = "t" });
            
            
            //
            // 4B + 2B + 4B + 5B
            var parser = new PacketBufferParser();
            var sendBytes = new List<byte>();
            sendBytes.AddRange(BitConverter.GetBytes(2).Reverse()); //4B
            sendBytes.Add(0); //2B
            sendBytes.Add(0);
            sendBytes.AddRange(BitConverter.GetBytes(5).Reverse()); //4B
            sendBytes.AddRange(testMessageBytes); //5B
            
            var result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            //
            Assert.AreEqual("t", MessagePackSerializer.Deserialize<PasserTestMessagePack>(result[1].ToArray()).t);
            
            
            //1
            //1
            parser = new PacketBufferParser();
            sendBytes.Clear();
            var header = BitConverter.GetBytes(5).Reverse().ToList();
            sendBytes.Add(header[0]);
            sendBytes.Add(header[1]);
            sendBytes.Add(header[2]);
            //1
            result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            Assert.AreEqual(0, result.Count); //2
            
            //2
            //
            sendBytes.Clear();
            sendBytes.Add(header[3]); //
            sendBytes.AddRange(testMessageBytes); //5B
            //2
            result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            Assert.AreEqual("t", MessagePackSerializer.Deserialize<PasserTestMessagePack>(result[0].ToArray()).t);
            
            
            PacketBufferPasserNoOverflowTestSendOnly(1);
            PacketBufferPasserNoOverflowTestSendOnly(2);
            PacketBufferPasserNoOverflowTestSendOnly(3);
        }
        
        
        /// <summary>
        ///     <see cref="PacketBufferPasserNoOverflowTest" />
        ///     
        /// </summary>
        private void PacketBufferPasserNoOverflowTestSendOnly(int overflowCountByte)
        {
            //5
            var testMessageBytes = MessagePackSerializer.Serialize(new PasserTestMessagePack { t = "t" });
            
            var parser = new PacketBufferParser();
            var sendBytes = new List<byte>();
            var header = BitConverter.GetBytes(5).Reverse().ToList();
            for (var i = 0; i < 4 - overflowCountByte; i++) sendBytes.Add(header[i]);
            //1
            var result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            Assert.AreEqual(0, result.Count); //2
            
            //2
            //
            sendBytes.Clear();
            for (var i = 4 - overflowCountByte; i < 4; i++) sendBytes.Add(header[i]);
            sendBytes.AddRange(testMessageBytes); //5B
            //2
            result = parser.Parse(sendBytes.ToArray(), sendBytes.Count);
            Assert.AreEqual("t", MessagePackSerializer.Deserialize<PasserTestMessagePack>(result[0].ToArray()).t);
        }
    }
    
    [MessagePackObject(true)]
    public class PasserTestMessagePack
    {
        public string t;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Mining/MapObjectMiningMiningState.cs
```cs
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.ProgressBar;
using Client.Input;
using Mooresmaster.Model.MapObjectsModule;

namespace Client.Game.InGame.Mining
{
    public class MapObjectMiningMiningState : IMapObjectMiningState
    {
        private readonly MiningToolsElement _miningToolsElement;
        
        private float _currentMiningProgressTime;
        
        public MapObjectMiningMiningState(MiningToolsElement miningToolsElement, IPlayerObjectController playerObjectController)
        {
            _miningToolsElement = miningToolsElement;
            _currentMiningProgressTime = 0;
            
            playerObjectController.SetAnimationState(PlayerAnimationState.Axe);
            ProgressBarView.Instance.Show();
        }
        
        
        public IMapObjectMiningState GetNextUpdate(MapObjectMiningControllerContext context, float dt)
        {
            var next = GetNextUpdateInternal(context, dt);
            if (next != this)
            {
                context.PlayerObjectController.SetAnimationState(PlayerAnimationState.IdleWalkRunBlend);
                ProgressBarView.Instance.Hide();
            }
            return next;
        }
        
        private IMapObjectMiningState GetNextUpdateInternal(MapObjectMiningControllerContext context, float dt)
        {
            // idle
            // if focus is lost, transition to idle
            if (context.CurrentFocusMapObjectGameObject == null)
            {
                return new MapObjectMiningFocusState();
            }
            
            // 
            // If left click is not pressed, transition to focus state
            if (!InputManager.Playable.ScreenLeftClick.GetKey)
            {
                return new MapObjectMiningFocusState();
            }
            
            _currentMiningProgressTime += dt;
            ProgressBarView.Instance.SetProgress(_currentMiningProgressTime / _miningToolsElement.AttackSpeed);
            
            // 
            // If mining is complete, transition to mining complete state
            if (_miningToolsElement.AttackSpeed <= _currentMiningProgressTime)
            {
                var attackDamage = _miningToolsElement.Damage;
                return new MapObjectMiningMiningCompleteState(context.CurrentFocusMapObjectGameObject, attackDamage);
            }
            
            return this;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/InventoryItemMoveProtocolTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.InventoryItemMoveProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class InventoryItemMoveProtocolTest
    {
        private const int PlayerId = 0;
        
        [Test]
        public void MainInventoryMoveTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).MainOpenableInventory;
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //
            mainInventory.SetItem(0, new ItemId(1), 10);
            
            //
            packet.GetPacketResponse(GetPacket(7,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory), 0,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory), 0));
            
            //
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 3), mainInventory.GetItem(0));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 7), grabInventory.GetItem(0));
            
            
            //
            packet.GetPacketResponse(GetPacket(5,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory), 0,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.MainInventory), 0));
            
            
            //
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 8), mainInventory.GetItem(0));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 2), grabInventory.GetItem(0));
        }
        
        
        [Test]
        public void BlockInventoryTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            var worldDataStore = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var chestPosition = new Vector3Int(5, 10);
            
            worldDataStore.TryAddBlock(ForUnitTestModBlockId.ChestId, chestPosition, BlockDirection.North, out var chest);
            var chestComponent = chest.GetComponent<VanillaChestComponent>();
            
            //
            chestComponent.SetItem(1, new ItemId(1), 10);
            
            //
            packet.GetPacketResponse(GetPacket(7,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.BlockInventory, new Vector3Int(5, 10)), 1 + PlayerInventoryConst.MainInventorySize,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory), 0));
            
            //
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 3), chestComponent.GetItem(1));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 7), grabInventory.GetItem(0));
            
            
            //
            packet.GetPacketResponse(GetPacket(5,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.GrabInventory), 0,
                new ItemMoveInventoryInfo(ItemMoveInventoryType.BlockInventory, new Vector3Int(5, 10)), 1 + PlayerInventoryConst.MainInventorySize));
            
            //
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 8), chestComponent.GetItem(1));
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 2), grabInventory.GetItem(0));
        }
        
        
        private List<byte> GetPacket(int count, ItemMoveInventoryInfo from, int fromSlot, ItemMoveInventoryInfo to, int toSlot,
            ItemMoveType itemMoveType = ItemMoveType.SwapSlot)
        {
            return MessagePackSerializer.Serialize(
                new InventoryItemMoveProtocolMessagePack(PlayerId, count, itemMoveType, from, fromSlot, to, toSlot)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/PlayerInventoryProtocolTest.cs
```cs
using System.Linq;
using Core.Const;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.PlayerInventoryResponseProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class PlayerInventoryProtocolTest
    {
        [Test]
        public void GetPlayerInventoryProtocolTest()
        {
            var playerId = 1;
            
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            
            //
            var payload = MessagePackSerializer.Serialize(new RequestPlayerInventoryProtocolMessagePack(playerId))
                .ToList();
            //
            var data = MessagePackSerializer.Deserialize<PlayerInventoryResponseProtocolMessagePack>(
                packet.GetPacketResponse(payload)[0].ToArray());
            Assert.AreEqual(playerId, data.PlayerId);
            
            //
            for (var i = 0; i < PlayerInventoryConst.MainInventoryColumns; i++)
            {
                Assert.AreEqual(ItemMaster.EmptyItemId, data.Main[i].Id);
                Assert.AreEqual(0, data.Main[i].Count);
            }
            
            //
            Assert.AreEqual(0, data.Grab.Id.AsPrimitive());
            Assert.AreEqual(0, data.Grab.Count);
            
            
            //
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(playerId);
            var itemStackFactory = ServerContext.ItemStackFactory;
            playerInventoryData.MainOpenableInventory.SetItem(0, itemStackFactory.Create(new ItemId(1), 5));
            playerInventoryData.MainOpenableInventory.SetItem(20, itemStackFactory.Create(new ItemId(3), 1));
            playerInventoryData.MainOpenableInventory.SetItem(34, itemStackFactory.Create(new ItemId(10), 7));
            
            
            //2
            data = MessagePackSerializer.Deserialize<PlayerInventoryResponseProtocolMessagePack>(
                packet.GetPacketResponse(payload)[0].ToArray());
            Assert.AreEqual(playerId, data.PlayerId);
            
            //
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
                if (i == 0)
                {
                    Assert.AreEqual(1, data.Main[i].Id.AsPrimitive());
                    Assert.AreEqual(5, data.Main[i].Count);
                }
                else if (i == 20)
                {
                    Assert.AreEqual(3, data.Main[i].Id.AsPrimitive());
                    Assert.AreEqual(1, data.Main[i].Count);
                }
                else if (i == 34)
                {
                    Assert.AreEqual(10, data.Main[i].Id.AsPrimitive());
                    Assert.AreEqual(7, data.Main[i].Count);
                }
                else
                {
                    Assert.AreEqual(ItemMaster.EmptyItemId, data.Main[i].Id);
                    Assert.AreEqual(0, data.Main[i].Count);
                }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/HotBarView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.Define;
using Client.Game.InGame.Player;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Input;
using Core.Const;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.Inventory
{
    public class HotBarView : MonoBehaviour
    {
        [SerializeField] private List<HotBarItem> hotBarItems;
        [SerializeField] private ItemObjectContainer itemObjectContainer;
        [SerializeField] private PlayerGrabItemManager playerGrabItemManager;
        
        private GameObject _currentGrabItem;
        private ILocalPlayerInventory _localPlayerInventory;
        
        public IItemStack CurrentItem => _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(SelectIndex)];
        public int SelectIndex { get; private set; }
        
        private void Start()
        {
            SelectIndex = 0;
            UpdateSelectedView(0, 0);
            for (var i = 0; i < hotBarItems.Count; i++)
            {
                var keyBordText = (i + 1).ToString();
                hotBarItems[i].SetKeyBoardText(keyBordText);
            }
        }
        
        private void Update()
        {
            UpdateHotBarItem();
            var nextSelectIndex = SelectedHotBar();
            if (nextSelectIndex != -1 && nextSelectIndex != SelectIndex)
            {
                UpdateSelectedView(SelectIndex, nextSelectIndex);
                UpdateHoldItem(nextSelectIndex); //
                
                SelectIndex = nextSelectIndex;
            }
            
            #region Internal
            
            void UpdateHotBarItem()
            {
                for (var i = 0; i < _localPlayerInventory.Count; i++) UpdateHotBarElement(i, _localPlayerInventory[i]);
            }
            
            void UpdateHotBarElement(int slot, IItemStack item)
            {
                //
                var c = PlayerInventoryConst.MainInventoryColumns;
                var r = PlayerInventoryConst.MainInventoryRows;
                var startHotBarSlot = c * (r - 1);
                
                if (slot < startHotBarSlot || PlayerInventoryConst.MainInventorySize <= slot) return;
                
                var viewData = ClientContext.ItemImageContainer.GetItemView(item.Id);
                slot -= startHotBarSlot;
                hotBarItems[slot].SetItem(viewData, item.Count);
            }
            
            int SelectedHotBar()
            {
                //
                if (InputManager.UI.HotBar.ReadValue<int>() == 0) return -1;
                
                //19-1
                var selected = InputManager.UI.HotBar.ReadValue<int>() - 1;
                
                OnSelectHotBar?.Invoke(selected);
                return selected;
            }
            
            
            void UpdateHoldItem(int selectIndex)
            {
                if (_currentGrabItem != null) Destroy(_currentGrabItem.gameObject);
                
                var itemId = _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(selectIndex)].Id;
                
                if (itemId == ItemMaster.EmptyItemId) return;
                
                var itemObjectData = itemObjectContainer.GetItemPrefab(itemId);
                if (itemObjectData != null)
                {
                    _currentGrabItem = Instantiate(itemObjectData.ItemPrefab);
                    playerGrabItemManager.SetItem(_currentGrabItem, false, itemObjectData.Position, Quaternion.Euler(itemObjectData.Rotation));
                }
            }
            
            #endregion
        }
        
        public event Action<int> OnSelectHotBar;
        
        [Inject]
        public void Construct(ILocalPlayerInventory localPlayerInventory)
        {
            _localPlayerInventory = localPlayerInventory;
        }
        
        private void UpdateSelectedView(int prevIndex, int nextIndex)
        {
            hotBarItems[prevIndex].SetSelect(false);
            hotBarItems[nextIndex].SetSelect(true);
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPreviewObject.cs
```cs
using System.Linq;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Core.Master;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using UnityEngine.VFX;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPreviewObject : MonoBehaviour
    {
        public BlockMasterElement BlockMasterElement { get; private set; }
        
        public bool IsCollisionGround
        {
            get
            {
                foreach (var collisionDetector in _collisionDetectors)
                {
                    if (collisionDetector.IsCollision) return true;
                }
                return false;
            }
        }
        private GroundCollisionDetector[] _collisionDetectors;
        private RendererMaterialReplacerController _rendererMaterialReplacerController;
        
        public void Initialize(BlockId blockId)
        {
            BlockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            
            var placeMaterial = Resources.Load<Material>(MaterialConst.PreviewPlaceBlockMaterial);
            _rendererMaterialReplacerController = new RendererMaterialReplacerController(gameObject);
            _rendererMaterialReplacerController.CopyAndSetMaterial(placeMaterial);
            
            _collisionDetectors = GetComponentsInChildren<GroundCollisionDetector>(true);
            
            SetPlaceableColor(true);
            
            var visualEffects = GetComponentsInChildren<VisualEffect>(false);
            foreach (var visualEffect in visualEffects) visualEffect.gameObject.SetActive(false);
            
            // 
            // Turn on preview-only object
            var previewOnlyObjects = gameObject.GetComponentsInChildren<PreviewOnlyObject>(true).ToList();
            previewOnlyObjects.ForEach(obj =>
            {
                obj.Initialize();
                obj.SetActive(true);
            });
        }
        
        public void SetPlaceableColor(bool isPlaceable)
        {
            var color = isPlaceable ? MaterialConst.PlaceableColor : MaterialConst.NotPlaceableColor;
            _rendererMaterialReplacerController.SetColor(MaterialConst.PreviewColorPropertyName, color);
        }
        
        public void SetTriggerCollider(bool isTrigger)
        {
            var childrenColliders = GetComponentsInChildren<Collider>();
            foreach (var childrenCollider in childrenColliders) childrenCollider.isTrigger = isTrigger;
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        public void SetTransform(Vector3 pos, Quaternion rotation)
        {
            transform.position = pos;
            transform.rotation = rotation;
        }
        
        public void Destroy()
        {
            _rendererMaterialReplacerController.DestroyMaterial();
            Destroy(gameObject);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/DisconnectElectricPoleToFromElectricSegment.cs
```cs
using Game.Context;
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UniRx;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     
    /// </summary>
    public class DisconnectElectricPoleToFromElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        private readonly EnergyServiceDependencyContainer<TSegment> _dependencyContainer;
        private readonly IWorldEnergySegmentDatastore<TSegment> _worldEnergySegmentDatastore;
        
        
        public DisconnectElectricPoleToFromElectricSegment(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore)
        {
            _worldEnergySegmentDatastore = worldEnergySegmentDatastore;
            
            _dependencyContainer = new EnergyServiceDependencyContainer<TSegment>(worldEnergySegmentDatastore);
            ServerContext.WorldBlockUpdateEvent.OnBlockRemoveEvent.Subscribe(OnBlockRemove);
        }
        
        private void OnBlockRemove(BlockUpdateProperties updateProperties)
        {
            var pos = updateProperties.Pos;
            
            //
            //
            if (!ServerContext.WorldBlockDatastore.TryGetBlock<TTransformer>(pos, out var removedElectricPole)) return;
            
            
            //
            var electricPoleConfigParam = updateProperties.BlockData.Block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            var electricPoles = FindElectricPoleFromPeripheralService.Find(pos, electricPoleConfigParam);
            
            //
            var removedSegment = _worldEnergySegmentDatastore.GetEnergySegment(removedElectricPole);
            
            
            switch (electricPoles.Count)
            {
                //
                case 0:
                    //
                    _worldEnergySegmentDatastore.RemoveEnergySegment(removedSegment);
                    return;
                //1
                case 1:
                    DisconnectOneElectricPoleFromSegmentService<TSegment, TConsumer, TGenerator, TTransformer>
                        .Disconnect(removedElectricPole, _dependencyContainer);
                    return;
                //2
                case >= 2:
                    DisconnectTwoOrMoreElectricPoleFromSegmentService<TSegment, TConsumer, TGenerator, TTransformer>
                        .Disconnect(removedElectricPole, _dependencyContainer);
                    break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Template/CraftChainerMainComputerTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Chest;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.CraftChainer.BlockComponent.Computer;
using Mooresmaster.Model.BlocksModule;

namespace Game.CraftChainer.BlockComponent.Template
{
    public class CraftChainerMainComputerTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var chest = blockMasterElement.BlockParam as CraftChainerMainComputerBlockParam;
            var connector = BlockTemplateUtil.CreateInventoryConnector(chest.InventoryConnectors, blockPositionInfo);
            var inserter = new CraftChainerMainComputerInserter();
            
            var chestComponent = componentStates == null ?
                new VanillaChestComponent(blockInstanceId, chest.ItemSlotCount, inserter) :
                new VanillaChestComponent(componentStates, blockInstanceId, chest.ItemSlotCount, inserter);
            
            var mainComputerComponent = componentStates == null ?
                new CraftChainerMainComputerComponent(connector) :
                new CraftChainerMainComputerComponent(componentStates, connector);
            
            
            var components = new List<IBlockComponent>
            {
                chestComponent,
                connector,
                mainComputerComponent
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Transporter/CraftChainerTransporterComponent.cs
```cs
using System.Collections.Generic;
using Game.CraftChainer.CraftNetwork;
using Newtonsoft.Json;

namespace Game.CraftChainer.BlockComponent
{
    public class CraftChainerTransporterComponent : ICraftChainerNode
    {
        public CraftChainerNodeId NodeId { get; } = CraftChainerNodeId.Create();
        
        public CraftChainerTransporterComponent() { }
        public CraftChainerTransporterComponent(Dictionary<string, string> componentStates) : this()
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerTransporterComponentJsonObject>(state);
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        
        public string SaveKey { get; } = typeof(CraftChainerTransporterComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerTransporterComponentJsonObject(this));
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
    
    public class ChainerTransporterComponentJsonObject 
    {
        [JsonProperty("nodeId")] public int NodeId { get; set; }
        
        public ChainerTransporterComponentJsonObject(){}
        public ChainerTransporterComponentJsonObject(CraftChainerTransporterComponent component)
        {
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/Implementation/ItemStack.cs
```cs
#nullable enable
using System;
using System.Collections.Generic;
using Core.Const;
using Core.Item.Interface;
using Core.Master;

namespace Core.Item.Implementation
{
    internal class ItemStack : IItemStack
    {
        public ItemId Id { get; }
        public int Count { get; }
        public ItemInstanceId ItemInstanceId { get; }
        private readonly Dictionary<string, ItemStackMetaData> _metaData;
        
        public ItemStack(ItemId id, int count, Dictionary<string, ItemStackMetaData> metaData)
        {
            if (id == ItemMaster.EmptyItemId) throw new ArgumentException("Item id cannot be null");
            if (count < 1) throw new ArgumentOutOfRangeException();
            
            var itemMaster = MasterHolder.ItemMaster.GetItemMaster(id);
            if (itemMaster.MaxStack < count)
                throw new ArgumentOutOfRangeException($" ID:{id} Count:{count} MaxStack:{itemMaster.MaxStack}");
            
            Id = id;
            Count = count;
            ItemInstanceId = ItemInstanceId.Create();
            _metaData = metaData;
        }
        
        public ItemStack(ItemId id, int count, ItemInstanceId instanceId, Dictionary<string, ItemStackMetaData> metaData) : this(id, count, metaData)
        {
            ItemInstanceId = instanceId;
        }
        
        public ItemProcessResult AddItem(IItemStack receiveItemStack)
        {
            var factory = InternalItemContext.ItemStackFactory;
            //null
            if (receiveItemStack.GetType() == typeof(NullItemStack))
            {
                // ID
                var newItem = factory.Create(Id, Count, _metaData);
                return new ItemProcessResult(newItem, factory.CreatEmpty());
            }
            
            // 
            if (!Addable((ItemStack)receiveItemStack))
            {
                var newItem = factory.Create(Id, Count, _metaData);
                return new ItemProcessResult(newItem, receiveItemStack);
            }
            
            
            var newCount = ((ItemStack)receiveItemStack).Count + Count;
            var tmpStack = MasterHolder.ItemMaster.GetItemMaster(Id).MaxStack;
            
            //
            if (tmpStack < newCount)
            {
                var tmpItem = factory.Create(Id, tmpStack, _metaData);
                var tmpReceive = factory.Create(Id, newCount - tmpStack, _metaData);
                
                return new ItemProcessResult(tmpItem, tmpReceive);
            }
            
            return new ItemProcessResult(factory.Create(Id, newCount), factory.CreatEmpty());
        }
        
        public IItemStack SubItem(int subCount)
        {
            var factory = InternalItemContext.ItemStackFactory;
            if (0 < Count - subCount) return factory.Create(Id, Count - subCount, _metaData);
            
            return factory.CreatEmpty();
        }
        
        public bool IsAllowedToAdd(IItemStack item)
        {
            var tmpStack = MasterHolder.ItemMaster.GetItemMaster(Id).MaxStack;
            
            return (Id == item.Id || item.Id == ItemMaster.EmptyItemId) &&
                   item.Count + Count <= tmpStack;
        }
        
        public bool IsAllowedToAddWithRemain(IItemStack item)
        {
            return Id == item.Id || item.Id == ItemMaster.EmptyItemId;
        }
        
        public ItemStackMetaData GetMeta(string key)
        {
            return _metaData.GetValueOrDefault(key);
        }
        
        public bool TryGetMeta(string key, out ItemStackMetaData value)
        {
            return _metaData.TryGetValue(key, out value);
        }
        
        public IItemStack SetMeta(string key, ItemStackMetaData value)
        {
            var copiedMeta = new Dictionary<string, ItemStackMetaData>(_metaData)
            {
                [key] = value,
            };
            return new ItemStack(Id, Count, copiedMeta);
        }
        
        private bool Addable(ItemStack target)
        {
            return Id == target.Id && CompareMeta(target);
        }
        
        public override bool Equals(object? obj)
        {
            if (typeof(ItemStack) != obj?.GetType()) return false;
            var other = (ItemStack)obj;
            
            return Id == other.Id &&
                   Count == other.Count &&
                   CompareMeta(other);
        }
        
        private bool CompareMeta(ItemStack other)
        {
            if (_metaData.Count != other._metaData.Count) return false;
            
            foreach (var (key, value) in _metaData)
            {
                if (!other._metaData.TryGetValue(key, out var otherValue)) return false;
                if (!value.Equals(otherValue)) return false;
            }
            foreach (var (key, value) in other._metaData)
            {
                if (!_metaData.TryGetValue(key, out var otherValue)) return false;
                if (!value.Equals(otherValue)) return false;
            }
            
            return true;
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(Id, Count, ItemInstanceId);
        }
        
        public override string ToString()
        {
            return $"ID:{Id} Count:{Count}";
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/SoundEffect/SoundEffectManager.cs
```cs
using System.Collections.Generic;
using UnityEngine;

namespace Client.Game.InGame.SoundEffect
{
    /// <summary>
    ///     TODO SE 
    /// </summary>
    public class SoundEffectManager : MonoBehaviour
    {
        [SerializeField] private AudioClip destroyBlockSound;
        [SerializeField] private AudioClip destroyStoneSound;
        [SerializeField] private AudioClip destroyTreeSound;
        [SerializeField] private AudioClip destroyBushSound;
        [SerializeField] private AudioClip placeBlockSound;
        
        [SerializeField] private AudioSource audioSource;
        
        private readonly Dictionary<SoundEffectType, AudioClip> _soundEffectTypeToAudioClip = new();
        
        /// <summary>
        ///     static
        /// </summary>
        public static SoundEffectManager Instance { get; private set; }
        
        private void Awake()
        {
            _soundEffectTypeToAudioClip.Add(SoundEffectType.DestroyBlock, destroyBlockSound);
            _soundEffectTypeToAudioClip.Add(SoundEffectType.DestroyStone, destroyStoneSound);
            _soundEffectTypeToAudioClip.Add(SoundEffectType.DestroyTree, destroyTreeSound);
            _soundEffectTypeToAudioClip.Add(SoundEffectType.DestroyBush, destroyBushSound);
            _soundEffectTypeToAudioClip.Add(SoundEffectType.PlaceBlock, placeBlockSound);
            
            Instance = this;
        }
        
        public void PlaySoundEffect(SoundEffectType soundEffectType)
        {
            audioSource.PlayOneShot(_soundEffectTypeToAudioClip[soundEffectType]);
        }
    }
    
    public enum SoundEffectType
    {
        DestroyBlock,
        DestroyStone,
        DestroyTree,
        DestroyBush,
        PlaceBlock,
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/CraftButton.cs
```cs
using System;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Util;
using UniRx;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    public class CraftButton : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler
    {
        [SerializeField] private RectTransform rectTransform;
        
        [SerializeField] private Image buttonImage;
        [SerializeField] private Color interactableColor = Color.white;
        [SerializeField] private Color nonInteractableColor = Color.gray;
        
        [SerializeField] private ProgressArrowView progressArrow;
        
        public IObservable<Unit> OnCraftFinish => _onCraftFinishSubject;
        private readonly Subject<Unit> _onCraftFinishSubject = new();
        
        private float _currentCraftTime;
        private float _buttonDownElapsed;
        private bool _isButtonDown;
        private bool _isCursorStay = true;
        private bool _isInteractable = true;
        
        private void Update()
        {
            if (_isButtonDown && _isCursorStay) _buttonDownElapsed += Time.deltaTime;
            
            if (_buttonDownElapsed >= _currentCraftTime)
            {
                _buttonDownElapsed = 0;
                _onCraftFinishSubject.OnNext(Unit.Default);
            }
            
            if (_isButtonDown)
            {
                var percent = Mathf.Clamp(_buttonDownElapsed, 0, _currentCraftTime) / _currentCraftTime;
                progressArrow.SetProgress(percent);
            }
            else
            {
                progressArrow.SetProgress(1);
            }
        }
        
        public void SetCraftTime(float craftTime)
        {
            _currentCraftTime = craftTime;
        }
        
        private void OnDestroy()
        {
            _onCraftFinishSubject.Dispose();
        }
        
        public void SetInteractable(bool interactable)
        {
            _isInteractable = interactable;
            buttonImage.color = interactable ? interactableColor : nonInteractableColor;
            
            if (!_isInteractable)
            {
                ResetButton();
            }
        }
        
        #region 
        
        [SerializeField] private bool resetElapsedTimeOnPointerExit;
        [SerializeField] private bool stopElapsedTimeUpdateOnPointerExit;
        [SerializeField] private bool restartElapsedTimeUpdateOnPointerEnter;
        
        #endregion
        
        
        public void OnPointerDown(PointerEventData eventData)
        {
            if (_isInteractable)
            {
                _isButtonDown = true;
            }
        }
        
        public void OnPointerUp(PointerEventData eventData)
        {
            if (_isInteractable)
            {
                _isButtonDown = false;
                _buttonDownElapsed = 0;
            }
        }
        
        public void OnPointerEnter(PointerEventData eventData)
        {
            if (!_isInteractable)
            {
                MouseCursorExplainer.Instance.Show("", isLocalize: false);
            }
            
            if (restartElapsedTimeUpdateOnPointerEnter) _isCursorStay = true;
        }
        
        public void OnPointerExit(PointerEventData eventData)
        {
            MouseCursorExplainer.Instance.Hide();
            if (resetElapsedTimeOnPointerExit) _buttonDownElapsed = 0;
            if (stopElapsedTimeUpdateOnPointerExit) _isCursorStay = false;
        }
        
        private void OnDisable()
        {
            ResetButton();
        }
        
        private void ResetButton()
        {
            MouseCursorExplainer.Instance.Hide();
            _buttonDownElapsed = 0;
            _isCursorStay = false;
            _isButtonDown = false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Editor/SchemaWatcher.cs
```cs
using UnityEditor;
using UnityEngine;
using System.IO;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using UnityEditor.Compilation;

[InitializeOnLoad]
public static class SchemaWatcher
{
    private static readonly string schemaFolderPath;
    private static readonly string cacheFilePath;
    private static Dictionary<string, string> cachedFileHashes = new Dictionary<string, string>();
    
    // Core.Master
    private static readonly string coreMasterFolderPath;
    
    static SchemaWatcher()
    {
        // /../schema 
        schemaFolderPath = Path.GetFullPath(Path.Combine(Application.dataPath, "../../schema"));
        // Library
        cacheFilePath = Path.Combine(Application.dataPath, "../Library/SchemaCache.txt");
        // Core.MasterAssets/Core.Master
        coreMasterFolderPath = Path.GetFullPath(Path.Combine(Application.dataPath, "../../moorestech_server/Assets/Scripts/Core.Master"));
        
        LoadCache();
        
        // 
        EditorApplication.update += Update;
        
        #region Internal
        
        // 
        void LoadCache()
        {
            if (!File.Exists(cacheFilePath)) return;
            
            cachedFileHashes = new Dictionary<string, string>();
            var lines = File.ReadAllLines(cacheFilePath);
            foreach (var line in lines)
            {
                var split = line.Split('|');
                if (split.Length == 2)
                {
                    cachedFileHashes[split[0]] = split[1];
                }
            }
        }
        
  #endregion
    }
    
    private const float CheckInterval = 1f; // 1
    private static float timer = 0f;
    private static void Update()
    {
        timer += Time.deltaTime;
        if (timer >= CheckInterval)
        {
            timer = 0f;
            CheckForChanges();
        }
    }
    
    // 
    [MenuItem("moorestech/Check Schema Changes")]
    public static void CheckForChanges()
    {
        var currentFileHashes = new Dictionary<string, string>();
        
        if (Directory.Exists(schemaFolderPath))
        {
            var files = Directory.GetFiles(schemaFolderPath, "*.*", SearchOption.AllDirectories);
            foreach (var file in files)
            {
                var relativePath = file.Substring(schemaFolderPath.Length + 1).Replace('\\', '/');
                var hash = ComputeHash(file);
                currentFileHashes[relativePath] = hash;
            }
        }
        else
        {
            Debug.LogWarning($"Schema: {schemaFolderPath}");
            return;
        }
        
        bool hasChanged = HasFolderChanged(cachedFileHashes, currentFileHashes);
        
        if (hasChanged)
        {
            Debug.Log("SchemaCore.Master");
            
            // 
            cachedFileHashes = currentFileHashes;
            SaveCache();
            
            // Core.MasterDummy.cs
            UpdateDummyScript();
            CompilationPipeline.RequestScriptCompilation();
        }
        
        #region Internal
        
        // 
        string ComputeHash(string filePath)
        {
            using var md5 = MD5.Create();
            
            var content = File.ReadAllBytes(filePath);
            var hash = md5.ComputeHash(content);
            return System.BitConverter.ToString(hash);
        }
        
        // 
        void SaveCache()
        {
            var lines = new List<string>();
            foreach (var kvp in cachedFileHashes)
            {
                lines.Add($"{kvp.Key}|{kvp.Value}");
            }
            
            File.WriteAllLines(cacheFilePath, lines.ToArray());
        }
        
        // 
        static bool HasFolderChanged(Dictionary<string, string> oldHashes, Dictionary<string, string> newHashes)
        {
            if (oldHashes.Count != newHashes.Count)
                return true;
            
            foreach (var kvp in newHashes)
            {
                if (!oldHashes.TryGetValue(kvp.Key, out string oldHash) || oldHash != kvp.Value)
                    return true;
            }
            
            return false;
        }
        
        // Dummy.csCore.Master
        static void UpdateDummyScript()
        {
            // Core.Master
            if (!Directory.Exists(coreMasterFolderPath))
            {
                Debug.LogError($"Core.Master: {coreMasterFolderPath}");
                return;
            }
            
            // Dummy.cs
            string dummyFilePath = Path.Combine(coreMasterFolderPath, "Dummy.cs");
            
            // 
            string currentDateTime = System.DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss");
            
            // Dummy.cs
            string dummyScriptContent = $@"
// Core.Mastergitignore
// This code is a script to recompile the Core.Master assembly. It is set in gitignore.
public class Dummy
{{
    private const string dummyText = ""{currentDateTime}"";
}}";
            
            // Dummy.cs
            File.WriteAllText(dummyFilePath, dummyScriptContent);
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/PacketHandle/UserResponse.cs
```cs
using System;
using System.Net.Sockets;
using Server.Protocol;
using Server.Util;
using UnityEngine;

namespace Server.Boot.PacketHandle
{
    public class UserResponse
    {
        private readonly Socket _client;
        private readonly PacketResponseCreator _packetResponseCreator;
        private int _byteCount;
        
        private DateTime _startTime;
        
        public UserResponse(Socket client, PacketResponseCreator packetResponseCreator)
        {
            _packetResponseCreator = packetResponseCreator;
            _client = client;
        }
        
        
        public void StartListen()
        {
            _startTime = DateTime.Now;
            
            var buffer = new byte[4096];
            //
            try
            {
                var parser = new PacketBufferParser();
                while (true)
                {
                    var error = ReceiveProcess(parser, buffer);
                    if (error)
                    {
                        Debug.Log("");
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                _client.Close();
                Debug.LogError("moorestech");
                Debug.LogException(e);
            }
        }
        
        
        private bool ReceiveProcess(PacketBufferParser parser, byte[] buffer)
        {
            var length = _client.Receive(buffer);
            if (length == 0) return true;
            
            //
            var packets = parser.Parse(buffer, length);
            
            foreach (var packet in packets)
            {
                var results = _packetResponseCreator.GetPacketResponse(packet);
                foreach (var result in results)
                {
                    result.InsertRange(0, ToByteList.Convert(result.Count));
                    var array = result.ToArray();
                    _byteCount += array.Length;
                    _client.Send(array);
                }
            }
            
            //LogDataConsumption(_byteCount, _startTime);
            
            return false;
        }
        
        public static void LogDataConsumption(int bytesSent, DateTime startTime)
        {
            // Convert bytes to Megabytes
            var megabytesSent = (double)bytesSent / 1024;
            
            // Calculate elapsed time in seconds
            var elapsedTimeSeconds = (DateTime.Now - startTime).TotalSeconds;
            
            // Calculate avg bandwidth in MB/s
            var avgBandwidth = megabytesSent / elapsedTimeSeconds;
            
            // Output the result
            Debug.Log($" {megabytesSent:F1} KB  {avgBandwidth:F1} KB/s  {elapsedTimeSeconds}");
        }
    }
}
```

moorestech_server/Assets/Scripts/Mod.Base/ServerModEntryInterface.cs
```cs
using Microsoft.Extensions.DependencyInjection;
using Server.Protocol;

namespace Mod.Base
{
    public class ServerModEntryInterface
    {
        /// <summary>
        ///     
        /// </summary>
        public readonly PacketResponseCreator PacketResponseCreator;
        
        /// <summary>
        ///     DI
        /// </summary>
        public readonly ServiceProvider ServiceProvider;
        
        public ServerModEntryInterface(ServiceProvider serviceProvider, PacketResponseCreator packetResponseCreator)
        {
            ServiceProvider = serviceProvider;
            PacketResponseCreator = packetResponseCreator;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/ItemProcessResult.cs
```cs
namespace Core.Item.Interface
{
    public class ItemProcessResult
    {
        public ItemProcessResult(IItemStack processResultItemStack, IItemStack remainderItemStack)
        {
            ProcessResultItemStack = processResultItemStack;
            RemainderItemStack = remainderItemStack;
        }
        
        /// <summary>
        ///     
        /// </summary>
        public IItemStack RemainderItemStack { get; }
        
        /// <summary>
        ///     
        /// </summary>
        public IItemStack ProcessResultItemStack { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Template/CraftChainerCrafterTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.Service;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.CraftChainer.BlockComponent.Crafter;
using Mooresmaster.Model.BlocksModule;

namespace Game.CraftChainer.BlockComponent.Template
{
    public class CraftChainerCrafterTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var param = blockMasterElement.BlockParam as CraftChainerCrafterBlockParam;
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(param.InventoryConnectors, blockPositionInfo);
            var inserter = new CraftChainerCrafterInserter(inputConnectorComponent);
            
            var chestComponent = componentStates == null ? 
                new VanillaChestComponent(blockInstanceId, param.ItemSlotCount, inserter) : 
                new VanillaChestComponent(componentStates, blockInstanceId, param.ItemSlotCount, inserter);
            
            var chainerCrafter = componentStates == null ?
                new CraftCraftChainerCrafterComponent() :
                new CraftCraftChainerCrafterComponent(componentStates);
            
            var components = new List<IBlockComponent>
            {
                chestComponent,
                inputConnectorComponent,
                chainerCrafter
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Const/xxHashConst.cs
```cs
namespace Core.Const
{
    /// <summary>
    ///     xxHash
    /// </summary>
    // ReSharper disable once InconsistentNaming
    public class xxHashConst
    {
        /// <summary>
        ///     
        ///     TODO 
        /// </summary>
        public const ulong DefaultSeed = 1235131;
        
        public const int DefaultSize = 64;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Map/MapObject/MapObjectGameObject.cs
```cs
using System;
using Core.Master;
using Mooresmaster.Model.MapObjectsModule;
using UniRx;
using UnityEditor;
using UnityEngine;

namespace Client.Game.InGame.Map.MapObject
{
    /// <summary>
    ///     MapObjectGameObject
    ///     TODO Unity
    /// </summary>
    public class MapObjectGameObject : MonoBehaviour
    {
        public int InstanceId => instanceId;
        public Guid MapObjectGuid => new(mapObjectGuid);
        public MapObjectMasterElement MapObjectMasterElement => MasterHolder.MapObjectMaster.GetMapObjectElement(MapObjectGuid);
        
        [SerializeField] private GameObject outlineObject;
        [SerializeField] private int instanceId;
        [SerializeField] private string mapObjectGuid;
        
        public bool IsDestroyed { get; private set; }
        
        public IObservable<Unit> OnDestroyMapObject => _onDestroyMapObject;
        private readonly Subject<Unit> _onDestroyMapObject = new();
        
        public void OutlineEnable(bool enable)
        {
            if (outlineObject != null)
            {
                outlineObject.SetActive(enable);
            }
        }
        
        public void DestroyMapObject()
        {
            IsDestroyed = true;
            //
            foreach (var child in GetComponentsInChildren<Transform>())
            {
                var collider = child.GetComponent<Collider>();
                if (collider != null) collider.enabled = false;
                var renderer = child.GetComponent<Renderer>();
                if (renderer != null) renderer.enabled = false;
            }
            
            _onDestroyMapObject.OnNext(Unit.Default);
        }
        
        public Vector3 GetPosition()
        {
            return transform.position;
        }
        
#if UNITY_EDITOR
        public void SetMapObjectData(int instanceId)
        {
            Undo.RecordObject(this, "SetMapObjectData");
            
            this.instanceId = instanceId;
            
            //Dirty
            EditorUtility.SetDirty(this);
        }
        
#endif
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/Common/SkitFireManager.cs
```cs
using Client.CutScene;
using Client.Game.Skit;
using Client.Game.Skit.Starter;
using Cysharp.Threading.Tasks;
using UnityEngine;
using UnityEngine.Playables;

namespace Client.Game.Common
{
    public class SkitFireManager : MonoBehaviour
    {
        [SerializeField] private PlayerSkitStarterDetector playerSkitStarterDetector;
        [SerializeField] private SkitManager skitManager;
        
        
        [SerializeField] private TimelinePlayer timelinePlayer; // TODO 
        [SerializeField] private PlayableAsset trailerMovie;
        
        
        private void Update()
        {
            if (playerSkitStarterDetector.IsStartReady && UnityEngine.Input.GetKeyDown(KeyCode.F))
            {
                PlayCutscene().Forget();
            }
        }
        
        private async UniTask PlayStory() // TODo 
        {
            GameStateController.ChangeState(GameStateType.Skit);
            
            var csv = playerSkitStarterDetector.CurrentSkitStarterObject.ScenarioCsv;
            await skitManager.StartSkit(csv);
            
            GameStateController.ChangeState(GameStateType.InGame);
        }
        
        
        
        private async UniTask PlayCutscene()
        {
            GameStateController.ChangeState(GameStateType.CutScene);
            
            await timelinePlayer.Play(trailerMovie);
            
            GameStateController.ChangeState(GameStateType.InGame);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Event/IBlockOpenableInventoryUpdateEvent.cs
```cs
using System;
using Core.Item.Interface;

namespace Game.Block.Interface.Event
{
    /// <summary>
    ///     Subscribe
    ///     Invoke
    /// </summary>
    public interface IBlockOpenableInventoryUpdateEvent
    {
        public void Subscribe(Action<BlockOpenableInventoryUpdateEventProperties> blockInventoryEvent);
    }
    
    public class BlockOpenableInventoryUpdateEventProperties
    {
        public readonly BlockInstanceId BlockInstanceId;
        public readonly IItemStack ItemStack;
        public readonly int Slot;
        
        public BlockOpenableInventoryUpdateEventProperties(BlockInstanceId blockInstanceId, int slot, IItemStack itemStack)
        {
            ItemStack = itemStack;
            Slot = slot;
            BlockInstanceId = blockInstanceId;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/UIStateControl.cs
```cs
using System;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.UIState
{
    public class UIStateControl : MonoBehaviour
    {
        private UIStateDictionary _uiStateDictionary;
        public UIStateEnum CurrentState { get; private set; } = UIStateEnum.GameScreen;
        
        private void Start()
        {
            _uiStateDictionary.GetState(CurrentState).OnEnter(UIStateEnum.Current);
        }
        
        //UI
        private void Update()
        {
            //UI
            var state = _uiStateDictionary.GetState(CurrentState).GetNextUpdate();
            if (state == UIStateEnum.Current) return;
            
            var lastState = CurrentState;
            CurrentState = state;
            
            //UI
            _uiStateDictionary.GetState(lastState).OnExit();
            _uiStateDictionary.GetState(CurrentState).OnEnter(lastState);
            
            OnStateChanged?.Invoke(CurrentState);
        }
        
        public event Action<UIStateEnum> OnStateChanged;
        
        [Inject]
        public void Construct(UIStateDictionary uiStateDictionary)
        {
            _uiStateDictionary = uiStateDictionary;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/FindMachineAndGeneratorFromPeripheralService.cs
```cs
using System.Collections.Generic;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class FindMachineAndGeneratorFromPeripheralService
    {
        public static (List<IElectricConsumer>, List<IElectricGenerator>) Find(Vector3Int pos, ElectricPoleBlockParam poleConfigParam)
        {
            var blocks = new List<IElectricConsumer>();
            var generators = new List<IElectricGenerator>();
            var machineRange = poleConfigParam.MachineConnectionRange;
            
            var startMachineX = pos.x - machineRange / 2;
            var startMachineY = pos.y - machineRange / 2;
            for (var i = startMachineX; i < startMachineX + machineRange; i++)
            for (var j = startMachineY; j < startMachineY + machineRange; j++)
            {
                var machinePos = new Vector3Int(i, j);
                
                var worldBlockDatastore = ServerContext.WorldBlockDatastore;
                //
                if (worldBlockDatastore.TryGetBlock<IElectricConsumer>(machinePos, out var consumer))
                    //
                    blocks.Add(consumer);
                
                //
                if (worldBlockDatastore.TryGetBlock<IElectricGenerator>(machinePos, out var generator))
                    //
                    generators.Add(generator);
            }
            
            return (blocks, generators);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/AssembleEntitySaveJsonTextTest.cs
```cs
using Game.Entity.Interface;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class AssembleEntitySaveJsonTextTest
    {
        [Test]
        public void EntitySaveTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var entitiesDatastore = serviceProvider.GetService<IEntitiesDatastore>();
            var entityFactory = serviceProvider.GetService<IEntityFactory>();
            
            
            //
            var entity1 = entityFactory.CreateEntity(VanillaEntityType.VanillaPlayer, new EntityInstanceId(10));
            var entityPosition = new Vector3(1, 2, 3);
            entity1.SetPosition(entityPosition);
            entitiesDatastore.Add(entity1);
            
            var entity2 = entityFactory.CreateEntity(VanillaEntityType.VanillaPlayer, new EntityInstanceId(30));
            var entityPosition2 = new Vector3(4, 5, 6);
            entity2.SetPosition(entityPosition2);
            entitiesDatastore.Add(entity2);
            
            
            //
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            
            //
            var (_, loadServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            (loadServiceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(json);
            
            
            //
            var loadedEntity1 = entitiesDatastore.Get(new EntityInstanceId(10));
            Assert.AreEqual(entity1.InstanceId, loadedEntity1.InstanceId);
            Assert.AreEqual(entityPosition, loadedEntity1.Position);
            Assert.AreEqual(entity1.EntityType, loadedEntity1.EntityType);
            
            var loadedEntity2 = entitiesDatastore.Get(new EntityInstanceId(30));
            Assert.AreEqual(entity2.InstanceId, loadedEntity2.InstanceId);
            Assert.AreEqual(entityPosition2, loadedEntity2.Position);
            Assert.AreEqual(entity2.EntityType, loadedEntity2.EntityType);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/BlockStateEventHandler.cs
```cs
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Network.API;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;
using VContainer.Unity;

namespace Client.Game.InGame.BlockSystem
{
    public class BlockStateEventHandler : IPostStartable
    {
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        private readonly InitialHandshakeResponse _initialHandshakeResponse;
        
        public BlockStateEventHandler(BlockGameObjectDataStore blockGameObjectDataStore, InitialHandshakeResponse initialHandshakeResponse)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            _initialHandshakeResponse = initialHandshakeResponse;
            
            ClientContext.VanillaApi.Event.SubscribeEventResponse(ChangeBlockStateEventPacket.EventTag,
                payload =>
                {
                    var data = MessagePackSerializer.Deserialize<BlockStateMessagePack>(payload);
                    ChangeState(data);
                });
        }
        
        public void PostStart()
        {
            foreach (var state in _initialHandshakeResponse.BlockStates) ChangeState(state);
        }
        
        private void ChangeState(BlockStateMessagePack state)
        {
            var pos = state.Position;
            if (!_blockGameObjectDataStore.BlockGameObjectDictionary.TryGetValue(pos, out var _))
            {
                Debug.Log(" : " + pos);
            }
            else
            {
                var blockObject = _blockGameObjectDataStore.BlockGameObjectDictionary[pos];
                foreach (var processor in blockObject.BlockStateChangeProcessors)
                {
                    processor.OnChangeState(state);
                }
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ItemStackMetaTest.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Other
{
    public class ItemStackMetaTest
    {
        [Test]
        // 
        public void MetaDataEqualityTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemsStackFactory = ServerContext.ItemStackFactory;
            
            var meta = new Dictionary<string, ItemStackMetaData> { { "test1", new TestMeta1() } };
            
            var itemStack1 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            var itemStack2 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            
            Assert.IsTrue(itemStack1.Equals(itemStack2));
            
            meta.Add("test2", new TestMeta2());
            
            Assert.IsTrue(itemStack1.Equals(itemStack2));
            
            var itemStack3 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            
            Assert.IsFalse(itemStack1.Equals(itemStack3));
            Assert.IsFalse(itemStack2.Equals(itemStack3));
        }
        
        [Test]
        // Add
        public void AddTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemsStackFactory = ServerContext.ItemStackFactory;
            
            var meta = new Dictionary<string, ItemStackMetaData> { { "test1", new TestMeta1() } };
            
            var itemStack1 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            var itemStack2 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            
            var result = itemStack1.AddItem(itemStack2);
            Assert.AreEqual(result.ProcessResultItemStack.Count, 2);
            
            meta.Add("test2", new TestMeta2());
            
            var itemStack3 = itemsStackFactory.Create(new ItemId(1), 1, meta);
            
            var result2 = itemStack1.AddItem(itemStack3);
            Assert.AreEqual(1, result2.ProcessResultItemStack.Count);
            Assert.AreEqual(1, result2.RemainderItemStack.Count);
        }
        
        [Test]
        // 
        public void SaveLoadTest()
        {
            //TODO 
        }
        
        //TODO 
    }
    
    public class TestMeta1 : ItemStackMetaData
    {
        public override bool Equals(ItemStackMetaData target)
        {
            return target is TestMeta1;
        }
    }
    
    public class TestMeta2 : ItemStackMetaData
    {
        public override bool Equals(ItemStackMetaData target)
        {
            return target is TestMeta2;
        }
    }
}
```

moorestech_server/Assets/Scripts/Mod.Loader/ModsResource.cs
```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using Game.Paths;
using Mod.Base;
using Newtonsoft.Json;
using UnityEngine;

namespace Mod.Loader
{
    public class ModsResource
    {
        private const string ModMetaFilePath = "modMeta.json";
        public readonly Dictionary<string, Mod> Mods;
        
        /// <summary>
        ///     Mod
        ///     TODO 
        /// </summary>
        public ModsResource(string modDirectory)
        {
            Mods = LoadModFromZip(modDirectory);
            foreach (var mod in LoadModFromFolder(modDirectory)) Mods.Add(mod.Key, mod.Value);
        }
        
        /// <summary>
        ///     Zipmod
        ///     Zip
        /// </summary>
        private static Dictionary<string, Mod> LoadModFromZip(string modDirectory)
        {
            var loadedMods = new Dictionary<string, Mod>();
            // zipmod
            foreach (var zipFile in Directory.GetFiles(modDirectory, "*.zip").ToList())
            {
                var zip = ZipFile.Open(zipFile, ZipArchiveMode.Read);
                var modMeta = JsonConvert.DeserializeObject<ModMetaJson>(LoadConfigFromZip(zip, ModMetaFilePath));
                
                if (modMeta == null)
                {
                    Debug.Log("Mod meta file not found in " + zipFile);
                    continue;
                }
                
                //extract zip
                var extractedDir = ExtractModZip(zipFile, modMeta);
                zip.Dispose();
                
                loadedMods.Add(modMeta.ModId, new Mod(modMeta, extractedDir));
            }
            
            return loadedMods;
        }
        
        /// <summary>
        ///     mod
        /// </summary>
        private static Dictionary<string, Mod> LoadModFromFolder(string modDirectory)
        {
            var loadedMods = new Dictionary<string, Mod>();
            // mod
            foreach (var modDir in Directory.GetDirectories(modDirectory))
            {
                //mod meta
                var modMetaFile = Path.Combine(modDir, ModMetaFilePath);
                if (!File.Exists(modMetaFile))
                {
                    //TODO 
                    Debug.Log("Mod meta file not found in " + modDir);
                    continue;
                }
                
                var modMeta = JsonConvert.DeserializeObject<ModMetaJson>(File.ReadAllText(modMetaFile));
                
                loadedMods.Add(modMeta.ModId, new Mod(modMeta, modDir));
            }
            
            return loadedMods;
        }
        
        /// <summary>
        ///     Zip
        /// </summary>
        /// <param name="zip">Zip</param>
        /// <param name="configPath">Zip</param>
        /// <returns>JSON</returns>
        private static string LoadConfigFromZip(ZipArchive zip, string configPath)
        {
            var config = zip.GetEntry(configPath);
            if (config == null) return string.Empty;
            
            using var itemJsonStream = config.Open();
            using var itemJsonString = new StreamReader(itemJsonStream);
            return itemJsonString.ReadToEnd();
        }
        
        /// <summary>
        ///     Zip
        /// </summary>
        /// <returns>mod</returns>
        private static string ExtractModZip(string zipPath, ModMetaJson modMetaJson)
        {
            var fixModId = modMetaJson.ModId.ReplaceFileNotAvailableCharacter("-");
            var fixModVersion = modMetaJson.ModVersion.ReplaceFileNotAvailableCharacter("-");
            var sha1Hash = CalcFileHash.GetSha1Hash(zipPath);
            
            var folderName = $"{fixModId}_ver_{fixModVersion}_sha1_{sha1Hash}";
            
            var path = GameSystemPaths.GetExtractedModDirectory(folderName);
            // 
            if (Directory.Exists(path)) return path;
            
            //
            ZipFile.ExtractToDirectory(zipPath, path, true);
            return path;
        }
    }
    
    public class Mod
    {
        public readonly string ExtractedPath;
        
        public readonly List<MoorestechServerModEntryPoint> ModEntryPoints;
        
        public readonly ModMetaJson ModMetaJson;
        
        public Mod(ModMetaJson modMetaJson, string extractedPath)
        {
            ModMetaJson = modMetaJson;
            ExtractedPath = extractedPath;
            ModEntryPoints = LoadEntryPoints(extractedPath);
        }
        
        private static List<MoorestechServerModEntryPoint> LoadEntryPoints(string modDirectory)
        {
            var entryPoints = new List<MoorestechServerModEntryPoint>();
            
            try
            {
                //moddllModBase
                foreach (var dllPath in Directory.GetFiles(modDirectory, "*.dll", SearchOption.AllDirectories))
                {
                    var assembly = Assembly.LoadFrom(dllPath);
                    var modBaseTypes = assembly.GetTypes()
                        .Where(t => t.IsSubclassOf(typeof(MoorestechServerModEntryPoint)));
                    foreach (var modBaseType in modBaseTypes)
                    {
                        var modBase = (MoorestechServerModEntryPoint)Activator.CreateInstance(modBaseType);
                        entryPoints.Add(modBase);
                    }
                }
            }
            catch (ReflectionTypeLoadException)
            {
                //
            }
            
            return entryPoints;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/FindElectricPoleFromPeripheralService.cs
```cs
using System.Collections.Generic;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    public static class FindElectricPoleFromPeripheralService
    {
        /// <summary>
        ///     
        ///     
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="electricPoleConfigParam"></param>
        /// <returns></returns>
        public static List<IElectricTransformer> Find(Vector3Int pos, ElectricPoleBlockParam electricPoleConfigParam)
        {
            var electricPoles = new List<IElectricTransformer>();
            //for
            var poleRange = electricPoleConfigParam.PoleConnectionRange;
            var blockDatastore = ServerContext.WorldBlockDatastore;
            blockDatastore.GetBlock(pos);
            var startElectricX = pos.x - poleRange / 2;
            var startElectricY = pos.y - poleRange / 2;
            
            //
            for (var i = startElectricX; i < startElectricX + poleRange; i++)
            for (var j = startElectricY; j < startElectricY + poleRange; j++)
            {
                // 
                var electricPolePos = new Vector3Int(i, j);
                if (!blockDatastore.ExistsComponent<IElectricTransformer>(electricPolePos) || i == pos.x && j == pos.y) continue;
                
                //
                electricPoles.Add(blockDatastore.GetBlock<IElectricTransformer>(electricPolePos));
            }
            
            return electricPoles;
        }
    }
}
```

moorestech_client/Server/mods/moorestechAlphaMod/modMeta.json
```cs
{
    "id":"moorestechAlphaMod",
    "name":"moorestech Alpha Mod",
    "version":"1.0",
    "author":"sakastudio",
    "description":"moorestechAlphamod"
}
```

moorestech_server/Assets/Scripts/Tests.Module/DummyBlockInventory.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Const;
using Core.Item.Interface;
using Core.Item.Util;
using Core.Master;
using Game.Block.Interface.Component;

namespace Tests.Module
{
    public class DummyBlockInventory : IBlockInventory
    {
        private readonly List<IItemStack> _insertedItems;
        
        private int _endInsertCnt;
        
        public DummyBlockInventory(int insertToEndNum = 1, int maxSlot = 100)
        {
            IsItemExists = false;
            InsertToEndNum = insertToEndNum;
            _endInsertCnt = 0;
            _insertedItems = CreateEmptyItemStacksList.Create(maxSlot).ToList();
        }
        
        public bool IsItemExists { get; private set; }
        
        public List<IItemStack> InsertedItems
        {
            get
            {
                var a = _insertedItems.Where(i => i.Id != ItemMaster.EmptyItemId).ToList();
                a.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
                return a.ToList();
            }
        }
        
        private int InsertToEndNum { get; }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            for (var i = 0; i < _insertedItems.Count; i++)
            {
                if (!_insertedItems[i].IsAllowedToAdd(itemStack)) continue;
                var r = _insertedItems[i].AddItem(itemStack);
                _insertedItems[i] = r.ProcessResultItemStack;
                _endInsertCnt++;
                IsItemExists = InsertToEndNum <= _endInsertCnt;
                
                return r.RemainderItemStack;
            }
            
            return itemStack;
        }
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return true;
        }
        
        public IItemStack GetItem(int slot)
        {
            return _insertedItems[slot];
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _insertedItems[slot] = itemStack;
        }
        
        public int GetSlotSize()
        {
            return _insertedItems.Count;
        }
        
        public bool IsDestroy => false;
        
        public void Destroy()
        {
        }
        
        public void AddOutputConnector(IBlockInventory blockInventory)
        {
        }
        
        public void RemoveOutputConnector(IBlockInventory blockInventory)
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World/DataStore/WorldSettings/WorldSettingsDatastore.cs
```cs
using Game.World.Interface.DataStore;
using UnityEngine;

namespace Game.World.DataStore.WorldSettings
{
    /// <summary>
    ///     
    ///     TODO 
    /// </summary>
    public class WorldSettingsDatastore : IWorldSettingsDatastore
    {
        public Vector3Int WorldSpawnPoint { get; private set; }
        
        public void Initialize()
        {
            WorldSpawnPoint = Vector3Int.zero;
        }
        
        public WorldSettingJsonObject GetSaveJsonObject()
        {
            return new WorldSettingJsonObject(WorldSpawnPoint);
        }
        
        public void LoadSettingData(WorldSettingJsonObject worldSettingJsonObject)
        {
            WorldSpawnPoint = new Vector3Int(worldSettingJsonObject.SpawnX, worldSettingJsonObject.SpawnY);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ForUnitTest/mods/forUnitTest/config/challenge.json
```cs
{
  "challenges": [
    {
      "id": 1000,
      "prevId": -1,
      "taskCompletionType": "createItem",
      "taskParam": {
        "itemModId": "Test Author:forUniTest",
        "itemName": "Test3"
      },
      "summary": "1",
      "playSkitType": "None",
      "playSkitParam": {}
    },
    {
      "id": 1010,
      "prevId": -1,
      "taskCompletionType": "inInventoryItem",
      "taskParam": {
        "itemModId": "Test Author:forUniTest",
        "itemName": "Test1",
        "itemCount": 3
      },
      "summary": "2",
      "playSkitType": "None",
      "playSkitParam": {}
    },
    {
      "id": 1020,
      "prevId": -1,
      "taskCompletionType": "blockPlace",
      "taskParam": {
        "blockModId": "Test Author:forUniTest",
        "blockName": "TestElectricMachine"
      },
      "summary": "2",
      "playSkitType": "None",
      "playSkitParam": {}
    },
    {
      "id": 1030,
      "prevId": 1000,
      "taskCompletionType": "inInventoryItem",
      "taskParam": {
        "itemModId": "Test Author:forUniTest",
        "itemName": "Test3",
        "itemCount": 3
      },
      "summary": "1",
      "playSkitType": "None",
      "playSkitParam": {}
    }
  ]
}
```

moorestech_client/Assets/Scripts/Client.Network/ServerCommunicator.cs
```cs
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;
using Client.Network.API;
using Client.Network.Settings;
using Cysharp.Threading.Tasks;
using MessagePack;
using Server.Util;
using UniRx;
using UnityEngine;

namespace Client.Network
{
    /// <summary>
    ///     C#<see cref="Socket" />
    ///     <see cref="PacketExchangeManager" />
    /// </summary>
    public class ServerCommunicator
    {
        private readonly IPAddress _ipAddress;
        private readonly Subject<Unit> _onDisconnect = new();
        
        private readonly Socket _socket;
        
        private ServerCommunicator(Socket connectedSocket)
        {
            //
            _socket = connectedSocket;
        }
        
        public IObservable<Unit> OnDisconnect => _onDisconnect;
        
        public static async UniTask<ServerCommunicator> CreateConnectedInstance(ConnectionServerConfig connectionServerConfig)
        {
            //IP
            if (!IPAddress.TryParse(connectionServerConfig.IP, out var ipAddress)) throw new ArgumentException("IP");
            
            var socket = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            
            //
            socket.Connect(ipAddress, connectionServerConfig.Port);
            
            // 10
            await UniTask.WaitUntil(() => socket.Connected).Timeout(TimeSpan.FromSeconds(10));
            
            Debug.Log("");
            
            return new ServerCommunicator(socket);
        }
        
        
        public Task StartCommunicat(PacketExchangeManager packetExchangeManager)
        {
            var buffer = new byte[4096];
            
            var parser = new PacketBufferParser();
            try
            {
                while (true)
                {
                    //Receive
                    var length = _socket.Receive(buffer);
                    if (length == 0)
                    {
                        Debug.LogError("");
                        break;
                    }
                    
                    //unity view
                    var packets = parser.Parse(buffer, length);
                    foreach (var packet in packets) packetExchangeManager.ExchangeReceivedPacket(packet).Forget();
                }
            }
            catch (Exception e)
            {
                Debug.LogError("");
                Debug.LogError($"Message {e.Message} StackTrace {e.StackTrace}");
                if (_socket.Connected) _socket.Close();
                
                try
                {
                    var json = MessagePackSerializer.ConvertToJson(buffer);
                    Debug.LogError(" JSON:" + json);
                }
                catch (Exception exception)
                {
                    Debug.LogError(" JSON:");
                }
                
                throw;
            }
            finally
            {
                Debug.Log("");
                InvokeDisconnect().Forget();
            }
            
            return Task.CompletedTask;
        }
        
        private async UniTask InvokeDisconnect()
        {
            await UniTask.SwitchToMainThread();
            _onDisconnect.OnNext(Unit.Default);
        }
        
        public void Send(byte[] data)
        {
            //
            var byteCount = ToByteList.Convert(data.Length);
            var newData = new byte[byteCount.Count + data.Length];
            
            byteCount.CopyTo(newData, 0);
            data.CopyTo(newData, byteCount.Count);
            
            _socket.Send(newData);
        }
        
        public void Close()
        {
            _socket.Close();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetCraftChainerCrafterRecipeProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SetCraftChainerCrafterRecipeProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:setChainerRecipe";
        
        public SetCraftChainerCrafterRecipeProtocol(ServiceProvider serviceProvider) { }
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SetCraftChainerCrafterRecipeProtocolMessagePack>(payload.ToArray());
            
            var blockPos = data.BlockPos.Vector3Int;
            
            var crafterBlock = ServerContext.WorldBlockDatastore.GetBlock(blockPos);
            if (crafterBlock == null) return null;
            
            var chainerCrafter = crafterBlock.ComponentManager.GetComponent<CraftCraftChainerCrafterComponent>();
            
            var inputs = data.GetInputs();
            var outputs = data.GetOutputs();
            chainerCrafter.SetRecipe(inputs, outputs);
            
            return null;
        }
        
        [MessagePackObject]
        public class SetCraftChainerCrafterRecipeProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            [Key(3)] public List<CraftingSolverItemJsonObjectMessagePack> Inputs { get; set; }
            [Key(4)] public List<CraftingSolverItemJsonObjectMessagePack> Outputs { get; set; }
            
            [Obsolete("")]
            public SetCraftChainerCrafterRecipeProtocolMessagePack() { }
            
            public SetCraftChainerCrafterRecipeProtocolMessagePack(Vector3Int blockPos, List<CraftingSolverItem> inputs, List<CraftingSolverItem> outputs)
            {
                Tag = ProtocolTag;
                BlockPos = new Vector3IntMessagePack(blockPos);
                Inputs = inputs.Select(item => new CraftingSolverItemJsonObjectMessagePack(item)).ToList();
                Outputs = outputs.Select(item => new CraftingSolverItemJsonObjectMessagePack(item)).ToList();
            }
            
            public List<CraftingSolverItem> GetInputs()
            {
                return Inputs.Select(item => item.ToCraftingSolverItem()).ToList();
            }
            public List<CraftingSolverItem> GetOutputs()
            {
                return Outputs.Select(item => item.ToCraftingSolverItem()).ToList();
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaMachineTemplate.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaMachineTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdateEvent;
        
        public VanillaMachineTemplate(BlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            _blockInventoryUpdateEvent = blockInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var machineParam = blockMasterElement.BlockParam as ElectricMachineBlockParam;
            
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(machineParam.InventoryConnectors, blockPositionInfo);
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            var (input, output) = BlockTemplateUtil.GetMachineIOInventory(blockId, blockInstanceId, machineParam, inputConnectorComponent, _blockInventoryUpdateEvent);

            var processor = new VanillaMachineProcessorComponent(input, output, null, new ElectricPower(machineParam.RequiredPower));
            
            var blockInventory = new VanillaMachineBlockInventoryComponent(input, output);
            var machineSave = new VanillaMachineSaveComponent(input, output, processor);
            var machineComponent = new VanillaElectricMachineComponent(blockInstanceId, processor);
            
            var components = new List<IBlockComponent>
            {
                blockInventory,
                machineSave,
                processor,
                machineComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var machineParam = blockMasterElement.BlockParam as ElectricMachineBlockParam;
            
            var inputConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(machineParam.InventoryConnectors, blockPositionInfo);
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            var (input, output) = BlockTemplateUtil.GetMachineIOInventory(blockId, blockInstanceId, machineParam, inputConnectorComponent, _blockInventoryUpdateEvent);
            
            var processor = BlockTemplateUtil.MachineLoadState(componentStates, input, output, new ElectricPower(machineParam.RequiredPower));
            
            var blockInventory = new VanillaMachineBlockInventoryComponent(input, output);
            var machineSave = new VanillaMachineSaveComponent(input, output, processor);
            var machineComponent = new VanillaElectricMachineComponent(blockInstanceId, processor);
            
            var components = new List<IBlockComponent>
            {
                blockInventory,
                machineSave,
                processor,
                machineComponent,
                inputConnectorComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/IBlock.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface.State;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Interface
{
    public interface IBlock : IEquatable<IBlock>
    {
        public BlockInstanceId BlockInstanceId { get; }
        public BlockId BlockId { get; }
        public Guid BlockGuid { get; }
        public BlockMasterElement BlockMasterElement { get; }
        public IBlockComponentManager ComponentManager { get; }
        public BlockPositionInfo BlockPositionInfo { get; }
        
        /// <summary>
        ///     
        ///     
        ///     
        /// </summary>
        public IObservable<BlockState> BlockStateChange { get; }
        
        public BlockState GetBlockState();
        
        public Dictionary<string,string> GetSaveState();
        
        public void Destroy();
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Entity/EntityObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Network.API;
using Core.Master;
using Game.Entity.Interface;
using UnityEngine;

namespace Client.Game.InGame.Entity
{
    public class EntityObjectDatastore : MonoBehaviour
    {
        [SerializeField] private ItemEntityObject itemPrefab;
        
        private readonly Dictionary<long, (DateTime lastUpdate, IEntityObject objectEntity)> _entities = new();
        
        /// <summary>
        ///     
        /// </summary>
        private void Update()
        {
            //1
            var removeEntities = new List<long>();
            foreach (var entity in _entities)
                if ((DateTime.Now - entity.Value.lastUpdate).TotalSeconds > 1)
                    removeEntities.Add(entity.Key);
            foreach (var removeEntity in removeEntities)
            {
                _entities[removeEntity].objectEntity.Destroy();
                _entities.Remove(removeEntity);
            }
        }
        
        /// <summary>
        ///     
        /// </summary>
        public void OnEntitiesUpdate(List<EntityResponse> entities)
        {
            foreach (var entity in entities)
                if (_entities.ContainsKey(entity.InstanceId))
                {
                    _entities[entity.InstanceId].objectEntity.SetInterpolationPosition(entity.Position);
                    _entities[entity.InstanceId] = (DateTime.Now, _entities[entity.InstanceId].objectEntity);
                }
                else
                {
                    var entityObject = CreateEntity(entity);
                    _entities.Add(entity.InstanceId, (DateTime.Now, entityObject));
                }
        }
        
        /// <summary>
        ///     
        /// </summary>
        private IEntityObject CreateEntity(EntityResponse entity)
        {
            if (entity.Type == VanillaEntityType.VanillaItem)
            {
                var item = Instantiate(itemPrefab, entity.Position, Quaternion.identity, transform);
                
                var id = new ItemId(int.Parse(entity.State.Split(',')[0]));
                var viewData = ClientContext.ItemImageContainer.GetItemView(id);
                Texture texture = null;
                if (viewData == null)
                {
                    Debug.LogError("ItemTexture Not Found  ItemId:" + id);
                }
                else
                {
                    texture = viewData.ItemTexture;
                }
                item.SetTexture(texture);
                return item;
            }
            
            throw new ArgumentException("");
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/InventoryItemMoveProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Core.Inventory;
using Game.Block.Interface.Component;
using Game.Context;
using Game.PlayerInventory.Interface;
using Game.World.Interface.DataStore;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using Server.Protocol.PacketResponse.Util.InventoryService;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    /// <summary>
    ///     
    /// </summary>
    public class InventoryItemMoveProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:invItemMove";
        
        private readonly IPlayerInventoryDataStore _playerInventoryDataStore;
        
        public InventoryItemMoveProtocol(ServiceProvider serviceProvider)
        {
            _playerInventoryDataStore = serviceProvider.GetService<IPlayerInventoryDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<InventoryItemMoveProtocolMessagePack>(payload.ToArray());
            
            var fromInventory = GetInventory(data.FromInventory.InventoryType, data.PlayerId, data.FromInventory.Pos);
            if (fromInventory == null) return null;
            
            var fromSlot = data.FromInventory.Slot;
            if (data.FromInventory.InventoryType == ItemMoveInventoryType.BlockInventory)
                fromSlot -= PlayerInventoryConst.MainInventorySize;
            
            
            var toInventory = GetInventory(data.ToInventory.InventoryType, data.PlayerId, data.ToInventory.Pos);
            if (toInventory == null) return null;
            
            var toSlot = data.ToInventory.Slot;
            if (data.ToInventory.InventoryType == ItemMoveInventoryType.BlockInventory)
                toSlot -= PlayerInventoryConst.MainInventorySize;
            
            
            switch (data.ItemMoveType)
            {
                case ItemMoveType.SwapSlot:
                    InventoryItemMoveService.Move(fromInventory, fromSlot, toInventory, toSlot, data.Count);
                    break;
                case ItemMoveType.InsertSlot:
                    InventoryItemInsertService.Insert(fromInventory, fromSlot, toInventory, data.Count);
                    break;
            }
            
            return null;
        }
        
        private IOpenableInventory GetInventory(ItemMoveInventoryType inventoryType, int playerId, Vector3Int pos)
        {
            IOpenableInventory inventory = null;
            switch (inventoryType)
            {
                case ItemMoveInventoryType.MainInventory:
                    inventory = _playerInventoryDataStore.GetInventoryData(playerId).MainOpenableInventory;
                    break;
                case ItemMoveInventoryType.GrabInventory:
                    inventory = _playerInventoryDataStore.GetInventoryData(playerId).GrabInventory;
                    break;
                case ItemMoveInventoryType.BlockInventory:
                    inventory = ServerContext.WorldBlockDatastore.ExistsComponent<IOpenableBlockInventoryComponent>(pos)
                        ? ServerContext.WorldBlockDatastore.GetBlock<IOpenableBlockInventoryComponent>(pos)
                        : null;
                    break;
            }
            
            return inventory;
        }
        
        [MessagePackObject]
        public class InventoryItemMoveProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            [Key(3)] public int Count { get; set; }
            [Key(4)] public int ItemMoveTypeId { get; set; }
            [IgnoreMember] public ItemMoveType ItemMoveType => (ItemMoveType)ItemMoveTypeId;
            [Key(5)] public ItemMoveInventoryInfoMessagePack FromInventory { get; set; }
            [Key(6)] public ItemMoveInventoryInfoMessagePack ToInventory { get; set; }
            
            
            [Obsolete("")]
            public InventoryItemMoveProtocolMessagePack() { }
            public InventoryItemMoveProtocolMessagePack(int playerId, int count, ItemMoveType itemMoveType,
                ItemMoveInventoryInfo inventory, int fromSlot,
                ItemMoveInventoryInfo toInventory, int toSlot)
            {
                Tag = ProtocolTag;
                PlayerId = playerId;
                Count = count;
                
                ItemMoveTypeId = (int)itemMoveType;
                FromInventory = new ItemMoveInventoryInfoMessagePack(inventory, fromSlot);
                ToInventory = new ItemMoveInventoryInfoMessagePack(toInventory, toSlot);
            }
        }
        
        [MessagePackObject]
        public class ItemMoveInventoryInfoMessagePack
        {
            [Obsolete("InventoryType")]
            [Key(2)] public int InventoryId { get; set; }
            
            [IgnoreMember] public ItemMoveInventoryType InventoryType => (ItemMoveInventoryType)Enum.ToObject(typeof(ItemMoveInventoryType), InventoryId);
            
            [Key(3)] public int Slot { get; set; }
            
            [Key(4)] public Vector3IntMessagePack Pos { get; set; }
            
            [Obsolete("")]
            public ItemMoveInventoryInfoMessagePack() { }
            public ItemMoveInventoryInfoMessagePack(ItemMoveInventoryInfo info, int slot)
            {
                //enumint
                InventoryId = (int)info.ItemMoveInventoryType;
                Slot = slot;
                Pos = new Vector3IntMessagePack(info.Pos);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/BlockInventoryOpenCloseProtocol.cs
```cs
using System;
using System.Collections.Generic;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class BlockInventoryOpenCloseProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:blockInvOpen";
        private readonly IBlockInventoryOpenStateDataStore _inventoryOpenState;
        
        public BlockInventoryOpenCloseProtocol(ServiceProvider serviceProvider)
        {
            _inventoryOpenState = serviceProvider.GetService<IBlockInventoryOpenStateDataStore>();
        }
        
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<BlockInventoryOpenCloseProtocolMessagePack>(payload.ToArray());
            
            //
            if (data.IsOpen)
                _inventoryOpenState.Open(data.PlayerId, data.Pos);
            else
                _inventoryOpenState.Close(data.PlayerId);
            
            return null;
        }
        
        
        [MessagePackObject]
        public class BlockInventoryOpenCloseProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public int PlayerId { get; set; }
            
            [Key(3)] public Vector3IntMessagePack Pos { get; set; }
            
            [Key(4)] public bool IsOpen { get; set; }
            
            [Obsolete("")]
            public BlockInventoryOpenCloseProtocolMessagePack() { }
            /// <summary>
            ///     TODO 
            /// </summary>
            /// <param name="playerId"></param>
            /// <param name="x"></param>
            /// <param name="y"></param>
            /// <param name="isOpen"></param>
            public BlockInventoryOpenCloseProtocolMessagePack(int playerId, Vector3Int pos, bool isOpen)
            {
                Tag = ProtocolTag;
                Pos = new Vector3IntMessagePack(pos);
                PlayerId = playerId;
                IsOpen = isOpen;
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/BlockShaderAnimation.cs
```cs
using System;
using Client.Common;
using Cysharp.Threading.Tasks;
using DG.Tweening;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class BlockShaderAnimation : MonoBehaviour
    {
        private const string WorldMinY = "_WorldMinY";
        private const string WorldMaxY = "_WorldMaxY";
        private const string DevolveRate = "_DevolveRate";
        private const string LightPower = "_LightPower";
        
        private RendererMaterialReplacerController _rendererMaterialReplacerController;
        
        public async UniTask PlaceAnimation()
        {
            _rendererMaterialReplacerController ??= new RendererMaterialReplacerController(gameObject);
            
            //
            var placeAnimationMaterial = Resources.Load<Material>(MaterialConst.PlaceBlockAnimationMaterial);
            _rendererMaterialReplacerController.CopyAndSetMaterial(placeAnimationMaterial);
            
            //
            var (worldMinY, worldMaxY) = GetWorldMinMaxY();
            SetMaterialProperty(WorldMinY, worldMinY);
            SetMaterialProperty(WorldMaxY, worldMaxY);
            SetMaterialProperty(DevolveRate, 0);
            SetMaterialProperty(LightPower, 0.6f);
            
            //
            TweenMaterialProperty(DevolveRate, 0, 1, 2.5f, Ease.InOutSine);
            TweenMaterialProperty(LightPower, 0.6f, 1, 2.0f, Ease.InOutSine);
            
            await UniTask.Delay(2000);
            
            //
            SetMaterialProperty(LightPower, 1);
            TweenMaterialProperty(LightPower, 1, 2, 0.4f, Ease.InOutSine);
            await UniTask.Delay(200);
            
            TweenMaterialProperty(LightPower, 2, 0.5f, 0.2f, Ease.InOutSine);
            await UniTask.Delay(200);
            
            //
            _rendererMaterialReplacerController.ResetMaterial();
        }
        
        public async UniTask RemoveAnimation()
        {
            _rendererMaterialReplacerController ??= new RendererMaterialReplacerController(gameObject);
            
            //
            var placeAnimationMaterial = Resources.Load<Material>(MaterialConst.PlaceBlockAnimationMaterial);
            _rendererMaterialReplacerController.CopyAndSetMaterial(placeAnimationMaterial);
            
            //
            var (worldMinY, worldMaxY) = GetWorldMinMaxY();
            SetMaterialProperty(WorldMinY, worldMinY);
            SetMaterialProperty(WorldMaxY, worldMaxY);
            SetMaterialProperty(DevolveRate, 1);
            SetMaterialProperty(LightPower, 0);
            
            //
            TweenMaterialProperty(LightPower, 0, 1, 0.5f, Ease.InOutSine);
            
            await UniTask.Delay(250);
            
            TweenMaterialProperty(DevolveRate, 1, 0, 0.55f, Ease.InOutSine);
            
            await UniTask.Delay(500);
        }
        
        private (float worldMinY, float worldMaxY) GetWorldMinMaxY()
        {
            var worldMinY = float.MaxValue;
            var worldMaxY = float.MinValue;
            foreach (var renderer in GetComponentsInChildren<Renderer>())
            {
                worldMinY = Mathf.Min(worldMinY, renderer.bounds.min.y);
                worldMaxY = Mathf.Max(worldMaxY, renderer.bounds.max.y);
            }
            
            return (worldMinY, worldMaxY);
        }
        
        private void TweenMaterialProperty(string keyword, float startValue, float endValue, float duration, Ease ease)
        {
            var value = startValue;
            DOTween.To(() => value, x => value = x, endValue, duration).SetEase(ease).OnUpdate(() =>
            {
                _rendererMaterialReplacerController.SetPlaceMaterialProperty(keyword, value);
            });
        }
        
        private void SetMaterialProperty(string keyword, float value)
        {
            _rendererMaterialReplacerController.SetPlaceMaterialProperty(keyword, value);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/SaveJsonFileTest.cs
```cs
using System;
using System.IO;
using System.Reflection;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    /// <summary>
    ///     
    /// </summary>
    public class SaveJsonFileTest
    {
        [Test]
        public void SaveJsonAndLoadTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            
            //
            ChangeFilePath(saveServiceProvider.GetService<SaveJsonFileName>(), "SaveJsonAndLoadTest.json");
            Debug.Log(saveServiceProvider.GetService<SaveJsonFileName>().FullSaveFilePath);
            
            
            //
            worldBlockDatastore.TryAddBlock((BlockId)1, new Vector3Int(0, 0), BlockDirection.North, out var block0);
            worldBlockDatastore.TryAddBlock((BlockId)2, new Vector3Int(0, 1), BlockDirection.East, out var block1);
            worldBlockDatastore.TryAddBlock((BlockId)3, new Vector3Int(30, -10), BlockDirection.West, out var block2);
            
            saveServiceProvider.GetService<IWorldSaveDataSaver>().Save();
            
            
            var (_, loadServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            
            //
            //
            ChangeFilePath(loadServiceProvider.GetService<SaveJsonFileName>(), "SaveJsonAndLoadTest.json");
            Debug.Log(loadServiceProvider.GetService<SaveJsonFileName>().FullSaveFilePath);
            
            loadServiceProvider.GetService<IWorldSaveDataLoader>().LoadOrInitialize();
            var loadWorldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            // 
            File.Delete(saveServiceProvider.GetService<SaveJsonFileName>().FullSaveFilePath);
            
            //
            var block = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            Assert.AreEqual(1, block.BlockId.AsPrimitive());
            Assert.AreEqual(block0.BlockInstanceId, block.BlockInstanceId.AsPrimitive());
            Assert.AreEqual(BlockDirection.North, loadWorldBlockDatastore.GetBlockDirection(new Vector3Int(0, 0)));
            
            block = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 1));
            Assert.AreEqual(2, block.BlockId.AsPrimitive());
            Assert.AreEqual(block1.BlockInstanceId, block.BlockInstanceId.AsPrimitive());
            Assert.AreEqual(BlockDirection.East, loadWorldBlockDatastore.GetBlockDirection(new Vector3Int(0, 1)));
            
            block = loadWorldBlockDatastore.GetBlock(new Vector3Int(30, -10));
            Assert.AreEqual(3, block.BlockId.AsPrimitive());
            Assert.AreEqual(block2.BlockInstanceId, block.BlockInstanceId.AsPrimitive());
            Assert.AreEqual(BlockDirection.West, loadWorldBlockDatastore.GetBlockDirection(new Vector3Int(30, -10)));
            
        }
        
        private void ChangeFilePath(SaveJsonFileName instance, string fileName)
        {
            // 
            var fieldInfo = typeof(SaveJsonFileName).GetField("<FullSaveFilePath>k__BackingField",
                BindingFlags.Instance | BindingFlags.NonPublic);
            
            // 
            var path = Path.Combine(Environment.CurrentDirectory, "../", "moorestech_server", fileName);
            fieldInfo.SetValue(instance, path);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyService/DisconnectOneElectricPoleFromSegmentService.cs
```cs
using System;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;

namespace Game.World.EventHandler.EnergyEvent.EnergyService
{
    /// <summary>
    ///     TODo 
    /// </summary>
    /// <typeparam name="TSegment"></typeparam>
    /// <typeparam name="TConsumer"></typeparam>
    /// <typeparam name="TGenerator"></typeparam>
    /// <typeparam name="TTransformer"></typeparam>
    public static class DisconnectOneElectricPoleFromSegmentService<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        public static void Disconnect(IElectricTransformer removedElectricPole, EnergyServiceDependencyContainer<TSegment> container)
        {
            //
            var pos = ServerContext.WorldBlockDatastore.GetBlockPosition(removedElectricPole.BlockInstanceId);
            var removedBlock = ServerContext.WorldBlockDatastore.GetBlock(pos);
            var poleConfig = removedBlock.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            
            var removedSegment = container.WorldEnergySegmentDatastore.GetEnergySegment(removedElectricPole);
            var electricPoles = FindElectricPoleFromPeripheralService.Find(
                pos, poleConfig);
            
            if (electricPoles.Count != 1) throw new Exception("1");
            
            
            //
            removedSegment.RemoveEnergyTransformer(removedElectricPole);
            
            //
            (var blocks, var generators) =
                FindMachineAndGeneratorFromPeripheralService.Find(pos, poleConfig);
            
            //
            blocks.ForEach(removedSegment.RemoveEnergyConsumer);
            generators.ForEach(removedSegment.RemoveGenerator);
            
            
            //1
            var connectedPos = ServerContext.WorldBlockDatastore.GetBlockPosition(electricPoles[0].BlockInstanceId);
            var connectedBlock = ServerContext.WorldBlockDatastore.GetBlock(connectedPos);
            var connectedPoleConfig = connectedBlock.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            
            (var connectedBlocks, var connectedGenerators) = FindMachineAndGeneratorFromPeripheralService.Find(connectedPos, connectedPoleConfig);
            
            //
            connectedBlocks.ForEach(removedSegment.AddEnergyConsumer);
            connectedGenerators.ForEach(removedSegment.AddGenerator);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Block/GroundCollisionDetector.cs
```cs
using Client.Game.InGame.BlockSystem;
using UnityEngine;

namespace Client.Game.InGame.Block
{
    public class GroundCollisionDetector : MonoBehaviour
    {
        public bool IsCollision { get; private set; }
        
        private void FixedUpdate()
        {
            // Exit
            IsCollision = false;
        }
        
        private void OnTriggerStay(Collider other)
        {
            if (other.gameObject.TryGetComponent<GroundGameObject>(out _))
            {
                IsCollision = true;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/DisconnectElectricSegmentTest.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    //
    public class DisconnectElectricSegmentTest
    {
        [Test]
        public void RemoveElectricPoleToDisconnectSegment()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            /*
             * M    G    M
             * P    P    P
             * G
             */
            
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(3, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(6, 0), BlockDirection.North, out _);
            
            //
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 1), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GeneratorId, new Vector3Int(0, -1), BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GeneratorId, new Vector3Int(3, 1), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(6, 1), BlockDirection.North, out _);
            
            IWorldEnergySegmentDatastore<EnergySegment> worldElectricSegment = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            //
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            
            //
            worldBlockDatastore.RemoveBlock(new Vector3Int(6, 0));
            //
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            //
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(6, 0), BlockDirection.North, out _);
            //
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            
            
            //
            worldBlockDatastore.RemoveBlock(new Vector3Int(3, 0));
            //
            Assert.AreEqual(2, worldElectricSegment.GetEnergySegmentListCount());
            
            //2
            Assert.AreEqual(false, worldElectricSegment.GetEnergySegment(0).Generators.ContainsKey(new BlockInstanceId(5)));
            Assert.AreEqual(false, worldElectricSegment.GetEnergySegment(1).Generators.ContainsKey(new BlockInstanceId(5)));
            
            //
            var segment1Block = worldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            var segment2Block = worldBlockDatastore.GetBlock(new Vector3Int(6, 0));
            var electricityTransformer1 = segment1Block.GetComponent<IElectricTransformer>();
            var electricityTransformer2 = segment2Block.GetComponent<IElectricTransformer>();
            var segment1 = worldElectricSegment.GetEnergySegment(electricityTransformer1);
            var segment2 = worldElectricSegment.GetEnergySegment(electricityTransformer2);
            
            Assert.AreNotEqual(segment1.GetHashCode(), segment2.GetHashCode());
            
            //
            worldBlockDatastore.RemoveBlock(new Vector3Int(6, 0));
            //
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
        }
        
        //1
        [Test]
        public void LoopedElectricSegmentRemoveElectricPoleTest()
        {
            /*
             * P   P   P
             * G      
             * M      M
             * P   P   P
             * G   G
             */
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            IWorldEnergySegmentDatastore<EnergySegment> worldElectricSegment = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            
            //
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(3, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(6, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(0, 3), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(3, 3), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricPoleId, new Vector3Int(6, 3), BlockDirection.North, out _);
            
            //
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 1), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GeneratorId, new Vector3Int(0, -1), BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GeneratorId, new Vector3Int(3, -1), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(6, 1), BlockDirection.North, out _);
            
            
            //
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            
            //
            worldBlockDatastore.RemoveBlock(new Vector3Int(3, 0));
            //
            Assert.AreEqual(1, worldElectricSegment.GetEnergySegmentListCount());
            
            //
            Assert.AreEqual(false, worldElectricSegment.GetEnergySegment(0).Generators.ContainsKey(new BlockInstanceId(105)));
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Map/MapObject/MapObjectGameObjectDatastore.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Context;
using Client.Network.API;
using MessagePack;
using Server.Event.EventReceive;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Map.MapObject
{
    /// <summary>
    ///     TODO 
    /// </summary>
    public class MapObjectGameObjectDatastore : MonoBehaviour
    {
        [SerializeField] private List<MapObjectGameObject> mapObjects;
        private readonly Dictionary<int, MapObjectGameObject> _allMapObjects = new();
        
        
        [Inject]
        public void Construct(InitialHandshakeResponse handshakeResponse)
        {
            //
            ClientContext.VanillaApi.Event.SubscribeEventResponse(MapObjectUpdateEventPacket.EventTag, OnUpdateMapObject);
            
            // mapObject
            foreach (var mapObject in mapObjects) _allMapObjects.Add(mapObject.InstanceId, mapObject);
            
            foreach (var mapObjectInfo in handshakeResponse.MapObjects)
            {
                var mapObject = _allMapObjects[mapObjectInfo.InstanceId];
                if (mapObjectInfo.IsDestroyed) mapObject.DestroyMapObject();
            }
        }
        
        private void OnUpdateMapObject(byte[] payLoad)
        {
            var data = MessagePackSerializer.Deserialize<MapObjectUpdateEventMessagePack>(payLoad);
            
            switch (data.EventType)
            {
                case MapObjectUpdateEventMessagePack.DestroyEventType:
                    _allMapObjects[data.InstanceId].DestroyMapObject();
                    break;
                default:
                    throw new Exception("MapObjectUpdateEventProtocol: EventType");
            }
        }
        
        public List<MapObjectGameObject> CreateMapObjectList(Guid mapObjectGuid)
        {
            return mapObjects.Where(x => x.MapObjectGuid == mapObjectGuid && !x.IsDestroyed).ToList();
        }
        
#if UNITY_EDITOR
        public List<MapObjectGameObject> MapObjects => mapObjects;
        
        public void FindMapObjects()
        {
            mapObjects = FindObjectsOfType<MapObjectGameObject>().ToList();
            mapObjects.Sort((a, b) => string.Compare(a.gameObject.name, b.gameObject.name, StringComparison.Ordinal));
        }
#endif
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailPosition.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Game.Train.RailGraph
{
    public class RailPosition
    {
        // RailNode
        private List<RailNode> _railNodes;

        // 
        private int _distanceToNextNode;

        // 
        private int _trainLength;

        public RailPosition(List<RailNode> railNodes, int trainLength, int initialDistanceToNextNode)
        {
            if (railNodes == null || railNodes.Count < 1)
            {
                throw new ArgumentException("RailNode1");
            }

            if (trainLength <= 0)
            {
                throw new ArgumentException("");
            }

            _railNodes = railNodes;
            _trainLength = trainLength;
            _distanceToNextNode = initialDistanceToNextNode;

            ValidatePosition();
        }

        private void ValidatePosition()
        {
            // RailNode
            int totalDistance = CalculateTotalDistance();

            if (totalDistance + _distanceToNextNode < _trainLength)
            {
                throw new InvalidOperationException("");
            }
        }

        private int CalculateTotalDistance()
        {
            int totalDistance = 0;
            for (int i = 0; i < _railNodes.Count - 1; i++) 
            {
                totalDistance += _railNodes[i + 1].GetDistanceToNode(_railNodes[i]);
            }
            //int max
            if (totalDistance < 0) 
            {
                throw new InvalidOperationException("int");
            }   
            return totalDistance;
        }

        // 
        // 
        //RailNodeRailNode
        //
        public int MoveForward(int distance)
        {
            // foward
            if (distance < 0) 
            {
                Reverse();
                var result = MoveForward(-distance);
                Reverse();
                return -result;
            }

            // 
            if (distance <= _distanceToNextNode)
            {
                _distanceToNextNode -= distance;
                RemoveUnnecessaryNodes();
                return 0;
            }
            else 
            {
                distance -= _distanceToNextNode;
                _distanceToNextNode = 0;
                RemoveUnnecessaryNodes();
                return distance;
            }
        }

        // 
        public void Reverse()
        {
            _railNodes.Reverse();
            for (int i = 0; i < _railNodes.Count; i++)
            {
                _railNodes[i] = _railNodes[i].OppositeNode; // RailNode
            }
            //_distanceToNextNode
            _distanceToNextNode = CalculateTotalDistance() - _distanceToNextNode - _trainLength;
        }

        // 
        // NodeNode
        public void RemoveUnnecessaryNodes()
        {
            //list[0]
            int distanceFromFront = _trainLength + _distanceToNextNode;
            if (distanceFromFront == 0) 
            {
                //index removeRange
                _railNodes.RemoveRange(1, _railNodes.Count - 1);
                return;
            }
            //2
            int totalListDistance = 0;
            for (int i = 0; i < _railNodes.Count - 1; i++)
            {
                totalListDistance += _railNodes[i + 1].GetDistanceToNode(_railNodes[i]);
                //totalListDistancedistanceFromFront
                if (totalListDistance > distanceFromFront)
                {
                    if (i + 2 == _railNodes.Count) break;
                    //
                    _railNodes.RemoveRange(i + 2, _railNodes.Count - i - 2);
                    break;
                }
            }
            return;
        }

        // RailNode
        public RailNode GetNodeApproaching()
        {
            return _railNodes.FirstOrDefault();
        }

        // RailNode
        public RailNode GetNodeJustPassed()
        {
            return _railNodes.Count > 1 ? _railNodes[1] : null;
        }

        
        // 
        public int GetDistanceToNextNode()
        {
            return _distanceToNextNode;
        }

        //_railNodes()
        public List<RailNode> TestGet_railNodes() 
        {
            return _railNodes;
        }


    }
}

```

moorestech_client/Assets/Scripts/Editor/BuildPipeline.cs
```cs
using System;
using System.Linq;
using UnityEditor;
using UnityEditor.Build.Reporting;
using UnityEngine;

public class BuildPipeline
{
    private const string OutputPathKey = "WindowsBuildOutputPath";
    
    [MenuItem("moorestech/Build/WindowsBuild")]
    public static void WindowsBuild()
    {
        Pipeline(BuildTarget.StandaloneWindows64, false, true);
    }
    
    [MenuItem("moorestech/Build/MacOsBuild")]
    public static void MacOsBuild()
    {
        Pipeline(BuildTarget.StandaloneOSX, false, true);
    }
    
    [MenuItem("moorestech/Build/LinuxBuild")]
    public static void LinuxBuild()
    {
        Pipeline(BuildTarget.StandaloneLinux64, false, true);
    }
    
    private static void Pipeline(BuildTarget buildTarget, bool isErrorExit, bool isSelectOutputPath)
    {
        Debug.Log("Build Start Time : " + DateTime.Now);
        var buildStartTime = DateTime.Now;
        
        var path = "Output_" + buildTarget;
        if (isSelectOutputPath)
        {
            var playerPrefsKey = OutputPathKey + buildTarget;
            path = EditorUtility.OpenFolderPanel("Build", PlayerPrefs.GetString(playerPrefsKey, ""), "");
            
            if (path == string.Empty) return;
            
            PlayerPrefs.SetString(playerPrefsKey, path);
            PlayerPrefs.Save();
        }
        
        
        //DirectoryProcessor.CopyAndReplace(ServerConst.ServerDirectory, Path.Combine(path, ServerConst.ServerDirName));
        
        var buildOptions = new BuildPlayerOptions
        {
            target = buildTarget,
            locationPathName = path + (buildTarget == BuildTarget.StandaloneWindows64 ? "/moorestech.exe" : "/moorestech"),
            scenes = EditorBuildSettings.scenes.Select(s => s.path).ToArray(),
        };
        
        var report = UnityEditor.BuildPipeline.BuildPlayer(buildOptions);
        
        if (isSelectOutputPath) EditorUtility.RevealInFinder(path);
        
        Debug.Log("Build Result :" + report.summary.result);
        
        Debug.Log("Build Output Path :" + report.summary.outputPath);
        Debug.Log("Build Summary TotalSize :" + report.summary.totalSize);
        
        Debug.Log("Build Finish Time : " + DateTime.Now);
        // hh:mm:ss 
        Debug.Log("Build Time : " + (DateTime.Now - buildStartTime).ToString(@"hh\:mm\:ss"));
        
        
        if (isErrorExit) EditorApplication.Exit(report.summary.result == BuildResult.Succeeded ? 0 : 1);
    }
    
    #region from Github Action
    
    public static void WindowsBuildFromGithubAction()
    {
        Pipeline(BuildTarget.StandaloneWindows64, true, false);
    }
    
    public static void MacOsBuildFromGithubAction()
    {
        Pipeline(BuildTarget.StandaloneOSX, true, false);
    }
    
    public static void LinuxBuildFromGithubAction()
    {
        Pipeline(BuildTarget.StandaloneLinux64, true, false);
    }
    
    #endregion
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ConfigOnly/mods/testConfigOnlyMod2/master/craftRecipe.json
```cs
testCraftRecipeJson1
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/BlockInventoryUpdateEventPacketTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    /// <summary>
    ///     
    /// </summary>
    public class BlockInventoryUpdateEventPacketTest
    {
        private const int PlayerId = 3;
        private const short PacketId = 16;
        
        //
        [Test]
        public void BlockInventoryUpdatePacketTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDataStore = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            Vector3Int pos = new(5, 7);
            
            //
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, pos, BlockDirection.North, out var block);
            var blockInventory = block.GetComponent<IBlockInventory>();
            
            
            //
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), true));
            //
            blockInventory.SetItem(1, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //
            //
            List<List<byte>> eventPacket = packetResponse.GetPacketResponse(GetEventPacket());
            
            
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(eventPacket[0].ToArray());
            //
            Assert.AreEqual(1, eventMessagePack.Events.Count);
            var payLoad = eventMessagePack.Events[0].Payload;
            var data = MessagePackSerializer.Deserialize<OpenableBlockInventoryUpdateEventMessagePack>(payLoad);
            
            Assert.AreEqual(1, data.Slot); // slot id
            Assert.AreEqual(4, data.Item.Id.AsPrimitive()); // item id
            Assert.AreEqual(8, data.Item.Count); // item count
            Assert.AreEqual(5, data.Position.X); // x
            Assert.AreEqual(7, data.Position.Y); // y
            
            
            //
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), false));
            
            //
            blockInventory.SetItem(2, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //
            //
            eventPacket = packetResponse.GetPacketResponse(GetEventPacket());
            eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(eventPacket[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        
        //
        [Test]
        public void OnlyOneInventoryCanBeOpenedTest()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDataStore = ServerContext.WorldBlockDatastore;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //1
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(5, 7), BlockDirection.North, out var block1);
            
            //2
            worldBlockDataStore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(10, 20), BlockDirection.North, out var block2);
            
            
            //
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(5, 7), true));
            //
            packetResponse.GetPacketResponse(OpenCloseBlockInventoryPacket(new Vector3Int(10, 20), true));
            
            
            //
            var block1Inventory = block1.GetComponent<VanillaMachineBlockInventoryComponent>();
            block1Inventory.SetItem(2, itemStackFactory.Create(new ItemId(4), 8));
            
            
            //
            List<List<byte>> response = packetResponse.GetPacketResponse(GetEventPacket());
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            Assert.AreEqual(0, eventMessagePack.Events.Count);
        }
        
        
        private List<byte> OpenCloseBlockInventoryPacket(Vector3Int pos, bool isOpen)
        {
            return MessagePackSerializer
                .Serialize(new BlockInventoryOpenCloseProtocol.BlockInventoryOpenCloseProtocolMessagePack(PlayerId, pos, isOpen)).ToList();
        }
        
        private List<byte> GetEventPacket()
        {
            return MessagePackSerializer.Serialize(new EventProtocolMessagePack(PlayerId)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/PacketHandle/PacketHandler.cs
```cs
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Server.Protocol;
using UnityEngine;

namespace Server.Boot.PacketHandle
{
    public class PacketHandler
    {
        private const int Port = 11564;
        
        public void StartServer(PacketResponseCreator packetResponseCreator)
        {
            //
            var listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            //
            listener.Bind(new IPEndPoint(IPAddress.Any, Port));
            listener.Listen(10);
            Debug.Log("moorestech ");
            
            while (true)
            {
                //
                var client = listener.Accept();
                Debug.Log("");
                
                var receiveThread = new Thread(() => new UserResponse(client, packetResponseCreator).StartListen());
                receiveThread.Name = "[moorestech] ";
                
                receiveThread.Start();
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerCrafterItemSelectModal.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Master;
using Cysharp.Threading.Tasks;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Block.ChainerCrafter
{
    public class CraftChainerCrafterItemSelectModal : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        [SerializeField] private RectTransform itemsParent;
        [SerializeField] private TMP_InputField countInputField;
        
        [SerializeField] private Button okButton;
        [SerializeField] private Button cancelButton;
        [SerializeField] private Button clearButton;
        
        private readonly List<ItemSlotObject> _itemSlotObjects = new();
        
        private ItemId _selectedItemId;
        
        public void Initialize()
        {
            gameObject.SetActive(false);
            // 
            // Initialize item list
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemView = ClientContext.ItemImageContainer.GetItemView(itemId);
                var slotObject = Instantiate(itemSlotObjectPrefab, itemsParent);
                slotObject.OnLeftClickUp.Subscribe(ClickItem);
                slotObject.SetItem(itemView, 0);
                _itemSlotObjects.Add(slotObject);
            }
            
            countInputField.onValueChanged.AddListener(UpdateOkButton);
        }
        
        public async UniTask<(ItemId,int)> GetSelectItem(ItemId currentItemId, int currentCount)
        {
            currentCount = Mathf.Max(1, currentCount);
            _selectedItemId = currentItemId;
            SetupUI();
            
            var result = await WaitPushButton();
            
            gameObject.SetActive(false);
            return result;
            
            #region Internal
            
            void SetupUI()
            {
                gameObject.SetActive(true);
                
                foreach (var slotObject in _itemSlotObjects)
                {
                    slotObject.SetHotBarSelect(false);
                    if (slotObject.ItemViewData.ItemId == currentItemId)
                    {
                        slotObject.SetHotBarSelect(true);
                    }
                }
                
                okButton.interactable = currentItemId != ItemMaster.EmptyItemId;
                countInputField.text = currentCount.ToString();
            }
            
            async UniTask<(ItemId, int)> WaitPushButton()
            {
                var ok = okButton.OnClickAsync();
                var cancel = cancelButton.OnClickAsync();
                var clear = clearButton.OnClickAsync();
                await UniTask.WhenAny(ok, cancel, clear);
                
                if (cancel.Status == UniTaskStatus.Succeeded)
                {
                    return (currentItemId, currentCount);
                }
                if (clear.Status == UniTaskStatus.Succeeded)
                {
                    return (ItemMaster.EmptyItemId, 0);
                }
                
                if (int.TryParse(countInputField.text, out var count))
                {
                    return (_selectedItemId, count);
                }
                
                return (_selectedItemId, 1);
            }
            
  #endregion
        }
        
        private void ClickItem(ItemSlotObject itemSlotObject)
        {
            foreach (var slotObject in _itemSlotObjects)
            {
                slotObject.SetHotBarSelect(false);
            }
            
            itemSlotObject.SetHotBarSelect(true);
            _selectedItemId = itemSlotObject.ItemViewData.ItemId;
            
            UpdateOkButton(countInputField.text);
        }
        
        private void UpdateOkButton(string inputFieldText)
        {
            if (int.TryParse(inputFieldText, out var count))
            {
                okButton.interactable = 0 < count;
                return;
            }
            okButton.interactable = false;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Component/BlockConnectorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.ComponentAttribute;
using Game.Context;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlockConnectInfoModule;
using UnityEngine;

namespace Game.Block.Component
{
    [DisallowMultiple]
    public class BlockConnectorComponent<TTarget> : IBlockConnectorComponent<TTarget> where TTarget : IBlockComponent
    {
        public IReadOnlyDictionary<TTarget, ConnectedInfo> ConnectedTargets => _connectedTargets;
        private readonly Dictionary<TTarget, ConnectedInfo> _connectedTargets = new();
        
        private readonly List<IDisposable> _blockUpdateEvents = new();
        
        private readonly Dictionary<Vector3Int, List<(Vector3Int position, IConnectOption targetOption)>> _inputConnectPoss; // key  value 
        private readonly Dictionary<Vector3Int, (Vector3Int position, IConnectOption selfOption)> _outputTargetToOutputConnector; // key  value 
        
        public BlockConnectorComponent(BlockConnectInfo inputConnectInfo, BlockConnectInfo outputConnectInfo, BlockPositionInfo blockPositionInfo)
        {
            var worldBlockUpdateEvent = ServerContext.WorldBlockUpdateEvent;
            
            _inputConnectPoss = BlockConnectorConnectPositionCalculator.CalculateConnectorToConnectPosList(inputConnectInfo, blockPositionInfo);
            _outputTargetToOutputConnector = BlockConnectorConnectPositionCalculator.CalculateConnectPosToConnector(outputConnectInfo, blockPositionInfo);
            
            foreach (var outputPos in _outputTargetToOutputConnector.Keys)
            {
                _blockUpdateEvents.Add(worldBlockUpdateEvent.SubscribePlace(outputPos, b => OnPlaceBlock(b.Pos)));
                _blockUpdateEvents.Add(worldBlockUpdateEvent.SubscribeRemove(outputPos, OnRemoveBlock));
                
                //
                if (ServerContext.WorldBlockDatastore.Exists(outputPos)) OnPlaceBlock(outputPos);
            }
        }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            _connectedTargets.Clear();
            _blockUpdateEvents.ForEach(x => x.Dispose());
            _blockUpdateEvents.Clear();
            IsDestroy = true;
        }
        
        /// <summary>
        ///     
        ///     
        ///      TODO 
        /// </summary>
        private void OnPlaceBlock(Vector3Int outputTargetPos)
        {
            //BlockInventory
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            if (!worldBlockDatastore.TryGetBlock(outputTargetPos, out BlockConnectorComponent<TTarget> targetConnector)) return;
            if (!worldBlockDatastore.TryGetBlock<TTarget>(outputTargetPos, out var targetComponent)) return;
            
            // 
            var isConnect = false;
            IConnectOption selfOption = null;
            IConnectOption targetOption = null;
            foreach (var targetInput in targetConnector._inputConnectPoss)
            {
                // 
                if (targetInput.Key != outputTargetPos) continue;
                
                // 
                if (targetInput.Value == null)
                {
                    isConnect = true;
                    break;
                }
                
                // 
                var outputConnector = _outputTargetToOutputConnector[outputTargetPos];
                
                // 
                foreach (var target in targetInput.Value)
                    if (target.position == outputConnector.position)
                    {
                        isConnect = true;
                        selfOption = outputConnector.selfOption;
                        targetOption = target.targetOption;
                        break;
                    }
            }
            
            if (!isConnect) return;
            
            //
            if (!_connectedTargets.ContainsKey(targetComponent))
            {
                var block = ServerContext.WorldBlockDatastore.GetBlock(outputTargetPos);
                var connectedInfo = new ConnectedInfo(selfOption, targetOption, block);
                _connectedTargets.Add(targetComponent, connectedInfo);
            }
        }
        
        private void OnRemoveBlock(BlockUpdateProperties updateProperties)
        {
            //InputConnectorComponent
            if (!ServerContext.WorldBlockDatastore.TryGetBlock<TTarget>(updateProperties.Pos, out var component)) return;
            
            _connectedTargets.Remove(component);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlacePointCalculator.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPlacePointCalculator
    {
        private readonly BlockGameObjectDataStore _blockGameObjectDataStore;
        
        public BlockPlacePointCalculator(BlockGameObjectDataStore blockGameObjectDataStore)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
        }
        
        public List<PlaceInfo> CalculatePoint(Vector3Int startPoint, Vector3Int endPoint, bool isStartDirectionZ, BlockDirection blockDirection, BlockMasterElement holdingBlockMasterElement)
        {
            // XZ1
            var startToCornerDistance = 0;
            var positions = CalcPositions();
            
            var result = CalcPlaceDirection(positions);
            result = CalcPlaceable(result);
            
            return result;
            
            #region Internal
            
            // TODO statci
            // TODO 
            List<Vector3Int> CalcPositions()
            {
                // XZ1
                var pointList = new List<Vector3Int>();
                var currentPoint = startPoint;
                
                // XZ
                pointList.Add(currentPoint);
                while (currentPoint.x != endPoint.x || currentPoint.z != endPoint.z)
                {
                    // X or Z
                    if (isStartDirectionZ && currentPoint.z != endPoint.z)
                    {
                        currentPoint.z += endPoint.z > currentPoint.z ? 1 : -1;
                        startToCornerDistance++;
                    }
                    else if (!isStartDirectionZ && currentPoint.x != endPoint.x)
                    {
                        currentPoint.x += endPoint.x > currentPoint.x ? 1 : -1;
                        startToCornerDistance++;
                    }
                    else
                    {
                        // 
                        if (currentPoint.z != endPoint.z)
                        {
                            currentPoint.z += endPoint.z > currentPoint.z ? 1 : -1;
                        }
                        else
                        {
                            currentPoint.x += endPoint.x > currentPoint.x ? 1 : -1;
                        }
                    }
                    
                    pointList.Add(currentPoint);
                }
                
                // Y
                // set Y axis
                
                // 
                // return as it is if the same height
                if (startPoint.y == endPoint.y) return pointList;
                
                var yDelta = Mathf.Abs(startPoint.y - endPoint.y);
                var currentYDelta = yDelta;
                
                // 
                // if going up
                if (startPoint.y < endPoint.y)
                {
                    // Y
                    for (var i = pointList.Count - 1; i >= 0 && currentYDelta > 0; i--)
                    {
                        var point = pointList[i];
                        point.y += currentYDelta;
                        
                        if (startToCornerDistance + 1 != i) currentYDelta--; // Y
                        
                        pointList[i] = point;
                    }
                    
                    return pointList;
                }
                
                // 
                // if going down
                
                // 
                // In case of going down, the last point is not set here because the point where it ends is one before the last.
                // TODo 
                var minusIndex = 2;
                for (var i = pointList.Count - minusIndex; i >= 0 && currentYDelta > 0; i--)
                {
                    var point = pointList[i];
                    
                    if (startToCornerDistance != i)
                    {
                        point.y -= currentYDelta;
                        currentYDelta--; // Y
                    }
                    else
                    {
                        point.y -= currentYDelta;
                    }
                    
                    pointList[i] = point;
                }
                
                // 
                // set the last point
                var lastPoint = pointList[^1];
                lastPoint.y = endPoint.y;
                pointList[^1] = lastPoint;
                
                return pointList;
            }
            
            List<PlaceInfo> CalcPlaceDirection(List<Vector3Int> placePositions)
            {
                if (placePositions.Count == 1)
                {
                    return new List<PlaceInfo>()
                    {
                        new()
                        {
                            Position = placePositions[0],
                            Direction = blockDirection,
                            VerticalDirection = BlockVerticalDirection.Horizontal,
                        }
                    };
                }
                
                var results = new List<PlaceInfo>(placePositions.Count);
                for (int i = 0; i < placePositions.Count; i++)
                {
                    BlockDirection direction;
                    BlockVerticalDirection verticalDirection;
                    var currentPoint = placePositions[i];
                    
                    
                    // TODo 
                    if (startPoint.y < endPoint.y)
                        //if (true)
                    {
                        // 
                        if (i == placePositions.Count - 1)
                        {
                            var prevPoint = placePositions[i - 1];
                            (direction, _) = GetBlockDirectionWithNextBlock(prevPoint, currentPoint);
                            verticalDirection = BlockVerticalDirection.Horizontal; // 
                        }
                        else
                        {
                            var nextPoint = placePositions[i + 1];
                            (direction, verticalDirection) = GetBlockDirectionWithNextBlock(currentPoint, nextPoint);
                        }
                    }
                    else
                    {
                        // 
                        if ((i == 0 || i == startToCornerDistance) && i != placePositions.Count - 1)
                        {
                            var nextPoint = placePositions[i + 1];
                            (direction, verticalDirection) = GetBlockDirectionWithNextBlock(currentPoint, nextPoint);
                            if (i == startToCornerDistance)
                            {
                                verticalDirection = BlockVerticalDirection.Horizontal; // 
                            }
                        }
                        else
                        {
                            var prevPoint = placePositions[i - 1];
                            (direction, verticalDirection) = GetBlockDirectionWithNextBlock(prevPoint, currentPoint);
                        }
                    }
                    
                    results.Add(new PlaceInfo()
                    {
                        Position = currentPoint,
                        Direction = direction,
                        VerticalDirection = verticalDirection,
                    });
                }
                
                return results;
            }
            
            (BlockDirection direction, BlockVerticalDirection verticalDirection) GetBlockDirectionWithNextBlock(Vector3Int currentPoint, Vector3Int nextPoint)
            {
                var horizonDirection = BlockDirection.North;
                if (currentPoint.x == nextPoint.x)
                {
                    horizonDirection = nextPoint.z > currentPoint.z ? BlockDirection.North : BlockDirection.South;
                }
                else
                {
                    horizonDirection = nextPoint.x > currentPoint.x ? BlockDirection.East : BlockDirection.West;
                }
                
                BlockVerticalDirection verticalDirection;
                if (currentPoint.y == nextPoint.y)
                {
                    verticalDirection = BlockVerticalDirection.Horizontal;
                }
                else
                {
                    verticalDirection = currentPoint.y < nextPoint.y ? BlockVerticalDirection.Up : BlockVerticalDirection.Down;
                }
                
                return (horizonDirection, verticalDirection);
            }
            
            List<PlaceInfo> CalcPlaceable(List<PlaceInfo> infos)
            {
                foreach (var info in infos)
                {
                    //TODO 
                    info.Placeable = IsNotExistBlock(info);
                }
                
                return infos;
            }
            
            // 
            bool IsNotExistBlock(PlaceInfo placeInfo)
            {
                // guid
                var blockId = holdingBlockMasterElement.BlockGuid.GetVerticalOverrideBlockId(placeInfo.VerticalDirection);
                
                var size = MasterHolder.BlockMaster.GetBlockMaster(blockId).BlockSize;
                var previewPositionInfo = new BlockPositionInfo(placeInfo.Position, placeInfo.Direction, size);
                
                return !_blockGameObjectDataStore.IsOverlapPositionInfo(previewPositionInfo);
            }
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/ConnectElectricPoleToElectricSegment.cs
```cs
using Game.Context;
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     
    /// </summary>
    public class ConnectElectricPoleToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    
    {
        private readonly IWorldEnergySegmentDatastore<TSegment> _worldEnergySegmentDatastore;
        
        
        public ConnectElectricPoleToElectricSegment(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore)
        {
            _worldEnergySegmentDatastore = worldEnergySegmentDatastore;
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlace);
        }
        
        private void OnBlockPlace(BlockUpdateProperties updateProperties)
        {
            var pos = updateProperties.Pos;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //
            if (!worldBlockDatastore.ExistsComponent<IElectricTransformer>(pos)) return;
            
            var poleBlockParam = updateProperties.BlockData.Block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            
            //
            var electricSegment = GetAndConnectElectricSegment(pos, poleBlockParam, worldBlockDatastore.GetBlock<IElectricTransformer>(pos));
            
            //
            ConnectMachine(pos, electricSegment, poleBlockParam);
        }
        
        /// <summary>
        ///     
        ///      
        ///     
        /// </summary>
        private EnergySegment GetAndConnectElectricSegment(Vector3Int pos, ElectricPoleBlockParam poleBlockParam, IElectricTransformer blockElectric)
        {
            //
            var electricPoles = FindElectricPoleFromPeripheralService.Find(pos, poleBlockParam);
            
            //
            var electricSegment = electricPoles.Count switch
            {
                //
                0 => _worldEnergySegmentDatastore.CreateEnergySegment(),
                //1
                1 => _worldEnergySegmentDatastore.GetEnergySegment(electricPoles[0]),
                //2
                _ => ElectricSegmentMergeService.MergeAndSetDatastoreElectricSegments(_worldEnergySegmentDatastore,
                    electricPoles),
            };
            //
            electricSegment.AddEnergyTransformer(blockElectric);
            
            return electricSegment;
        }
        
        /// <summary>
        ///     
        /// </summary>
        private void ConnectMachine(Vector3Int pos, EnergySegment segment, ElectricPoleBlockParam poleParam)
        {
            (var blocks, var generators) = FindMachineAndGeneratorFromPeripheralService.Find(pos, poleParam);
            
            //
            blocks.ForEach(segment.AddEnergyConsumer);
            generators.ForEach(segment.AddGenerator);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/ItemMaster.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Mooresmaster.Loader.ItemsModule;
using Mooresmaster.Model.ItemsModule;
using Newtonsoft.Json.Linq;
using UnitGenerator;

namespace Core.Master
{
    // Id
    // NOTE ID
    [UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter | UnitGenerateOptions.Comparable)]
    public partial struct ItemId { }
    
    public class ItemMaster
    {
        public static readonly ItemId EmptyItemId = new(0);
        
        public readonly Items Items;
        
        private readonly Dictionary<ItemId,ItemMasterElement> _itemElementTableById; 
        private readonly Dictionary<Guid,ItemId> _itemGuidToItemId;
        
        public ItemMaster(JToken itemJToken)
        {
            // GUIDintItemId
            Items = ItemsLoader.Load(itemJToken);
            
            // GUID
            var sortedItemElements = Items.Data.ToList().
                OrderBy(x => x.SortPriority ?? float.MaxValue).
                ThenBy(x => x.ItemGuid).
                ToList();
            
            _itemElementTableById = new Dictionary<ItemId,ItemMasterElement>();
            _itemGuidToItemId = new Dictionary<Guid,ItemId>();
            for (var i = 0; i < sortedItemElements.Count; i++)
            {
                var itemId = new ItemId(i+1); // ID 01
                _itemElementTableById.Add(itemId, sortedItemElements[i]);
                _itemGuidToItemId.Add(sortedItemElements[i].ItemGuid, itemId);
            }
        }
        
        public ItemMasterElement GetItemMaster(ItemId itemId)
        {
            if (!_itemElementTableById.TryGetValue(itemId, out var element))
            {
                throw new InvalidOperationException($"ItemElement not found. ItemId:{itemId}");
            }
            return element;
        }
        
        public ItemMasterElement GetItemMaster(Guid itemGuid)
        {
            var itemId = GetItemId(itemGuid);
            return GetItemMaster(itemId);
        }
        
        public ItemId GetItemId(Guid itemGuid)
        {
            if (itemGuid == Guid.Empty)
            {
                return EmptyItemId;
            }
            
            if (!_itemGuidToItemId.TryGetValue(itemGuid, out var itemId))
            {
                throw new InvalidOperationException($"ItemElement not found. ItemGuid:{itemGuid}");
            }
            return itemId;
        }
        
        public IEnumerable<ItemId> GetItemAllIds()
        {
            return _itemElementTableById.Keys;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/ChestBlockInventoryView.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class ChestBlockInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            
            // 
            // Initialize item list
            var itemList = new List<IItemStack>();
            
            var param = blockGameObject.BlockMasterElement.BlockParam;
            var slotSize =  param switch
            {
                ChestBlockParam blockParam => blockParam.ChestItemSlotCount, // TODO master interface
                CraftChainerProviderChestBlockParam blockParam => blockParam.ItemSlotCount,
                CraftChainerMainComputerBlockParam blockParam => blockParam.ItemSlotCount,
                _ => 0
            };
            for (var i = 0; i < slotSize; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            UpdateItemList(itemList);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/Main.cs
```cs

public class Test
{
    public void Hoge()
    {
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/ProbabilityCalculator.cs
```cs
using System;

namespace Game.Block
{
    public static class ProbabilityCalculator
    {
        public static bool DetectFromPercent(double percent)
        {
            percent *= 100;
            //
            var digitNum = 0;
            
            //
            var rate = (int)Math.Pow(10, digitNum);
            
            //
            var randomValueLimit = 100 * rate;
            var border = (int)(rate * percent);
            var r = new Random();
            return r.Next(0, randomValueLimit) < border;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Inventory/IOpenableInventory.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Item.Interface;
using Core.Master;

namespace Core.Inventory
{
    /// <summary>
    ///     
    ///     
    /// </summary>
    public interface IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems { get; }
        
        public IItemStack GetItem(int slot);
        void SetItem(int slot, IItemStack itemStack);
        void SetItem(int slot, ItemId itemId, int count);
        public IItemStack ReplaceItem(int slot, IItemStack itemStack);
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count);
        
        public IItemStack InsertItem(IItemStack itemStack);
        public IItemStack InsertItem(ItemId itemId, int count);
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks);
        public bool InsertionCheck(List<IItemStack> itemStacks);
        public int GetSlotSize();
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems();
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerTransporterSaveLoadTest.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerTransporterSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);

            // Transporter block
            // Create a Transporter block
            var transporterBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerTransporter, new BlockInstanceId(1), posInfo);
            var originalTransporter = transporterBlock.GetComponent<CraftChainerTransporterComponent>();

            // 
            // Get the save data
            var saveState = transporterBlock.GetSaveState();

            // 
            // Load the block
            var loadedBlock = blockFactory.Load(transporterBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedTransporterComponent = loadedBlock.GetComponent<CraftChainerTransporterComponent>();

            // ID
            // Check the node ID
            Assert.AreEqual(originalTransporter.NodeId, loadedTransporterComponent.NodeId);
        }
    }
}

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/Event/ChangeBlockEventPacketTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Block.Interface.State;
using Game.Context;
using Game.EnergySystem;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Server.Event.EventReceive;
using Server.Protocol.PacketResponse;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.EventProtocol;

namespace Tests.CombinedTest.Server.PacketTest.Event
{
    public class ChangeBlockEventPacketTest
    {
        [Test]
        public void MachineChangeStateEvent()
        {
            var (packetResponse, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            Vector3Int pos = new(0, 0);
            
            //
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, pos, BlockDirection.North, out var machine);
            //
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var item1 = itemStackFactory.Create(new ItemId(1), 3);
            var item2 = itemStackFactory.Create(new ItemId(2), 1);
            
            var blockInventory = machine.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            blockInventory.InsertItem(item1);
            blockInventory.InsertItem(item2);
            
            
            //
            var electricMachineComponent = machine.GetComponent<VanillaElectricMachineComponent>();
            electricMachineComponent.SupplyEnergy(new ElectricPower(100));
            
            //
            packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(0));
            
            //
            GameUpdater.UpdateWithWait();
            
            
            //
            List<List<byte>> response = packetResponse.GetPacketResponse(EventTestUtil.EventRequestData(0));
            var eventMessagePack = MessagePackSerializer.Deserialize<ResponseEventProtocolMessagePack>(response[0].ToArray());
            var payLoad = eventMessagePack.Events[0].Payload;
            
            var changeStateData = MessagePackSerializer.Deserialize<BlockStateMessagePack>(payLoad);
            var stateDetail = changeStateData.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            
            Assert.AreEqual(VanillaMachineBlockStateConst.IdleState, stateDetail.PreviousStateType);
            Assert.AreEqual(VanillaMachineBlockStateConst.ProcessingState, stateDetail.CurrentStateType);
            Assert.AreEqual(0, changeStateData.Position.X);
            Assert.AreEqual(0, changeStateData.Position.Y);
            
            var detailChangeData = changeStateData.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            Assert.AreEqual(1.0f, detailChangeData.PowerRate);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/SetCraftChainerMainComputerRequestItemProtocol.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Context;
using Game.CraftChainer.BlockComponent.Computer;
using Game.CraftChainer.BlockComponent.Crafter;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Protocol.PacketResponse
{
    public class SetCraftChainerMainComputerRequestItemProtocol : IPacketResponse
    {
        public const string ProtocolTag = "va:setReuqestComputer";
        
        public SetCraftChainerMainComputerRequestItemProtocol(ServiceProvider serviceProvider) { }
        public ProtocolMessagePackBase GetResponse(List<byte> payload)
        {
            var data = MessagePackSerializer.Deserialize<SetCraftChainerMainComputerRequestItemProtocolMessagePack>(payload.ToArray());
            
            var blockPos = data.BlockPos.Vector3Int;
            
            var crafterBlock = ServerContext.WorldBlockDatastore.GetBlock(blockPos);
            if (crafterBlock == null) return null;
            
            var itemId = data.ItemId;
            var count = data.Count;
            var computerComponent = crafterBlock.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
            computerComponent.StartCreateItem(itemId, count);
            
            return null;
        }
        
        [MessagePackObject]
        public class SetCraftChainerMainComputerRequestItemProtocolMessagePack : ProtocolMessagePackBase
        {
            [Key(2)] public Vector3IntMessagePack BlockPos { get; set; }
            [Key(3)] public int ItemIdInt { get; set; }
            [IgnoreMember] public ItemId ItemId => new(ItemIdInt);
            [Key(4)] public int Count { get; set; }
            
            [Obsolete("")]
            public SetCraftChainerMainComputerRequestItemProtocolMessagePack() { }
            
            public SetCraftChainerMainComputerRequestItemProtocolMessagePack(Vector3Int blockPos, ItemId itemId, int count)
            {
                Tag = ProtocolTag;
                BlockPos = new Vector3IntMessagePack(blockPos);
                ItemIdInt = itemId.AsPrimitive();
                Count = count;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/OneClickCraftProtocolTest.cs
```cs
using System.Linq;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using static Server.Protocol.PacketResponse.OneClickCraft;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class OneClickCraftProtocolTest
    {
        private const int PlayerId = 0;
        private const int CraftRecipeId = 1;
        
        [Test]
        public void CanNotCraftTest()
        {
            //
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Id.AsPrimitive());
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void CanCraftTest()
        {
            //
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            //
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = ServerContext.ItemStackFactory.Create(info.ItemGuid, info.Count);
                playerInventoryData.MainOpenableInventory.SetItem(i, item);
            }
            
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            var resultItemGuid = MasterHolder.ItemMaster.GetItemId(craftElement.CraftResultItemGuid);
            Assert.AreEqual(resultItemGuid, playerInventoryData.MainOpenableInventory.GetItem(slot).Id);
            Assert.AreEqual(craftElement.CraftResultCount, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void CanNotOneItemIsMissingTest()
        {
            //
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInventoryData = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            //
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = ServerContext.ItemStackFactory.Create(info.ItemGuid, info.Count);
                playerInventoryData.MainOpenableInventory.SetItem(i, item);
            }
            
            //
            var oneSubItem = playerInventoryData.MainOpenableInventory.GetItem(0).SubItem(1);
            playerInventoryData.MainOpenableInventory.SetItem(0, oneSubItem);
            
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftElement.CraftRecipeGuid)).ToList());
            
            //
            var slot = PlayerInventoryConst.HotBarSlotToInventorySlot(0);
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Id.AsPrimitive());
            Assert.AreEqual(0, playerInventoryData.MainOpenableInventory.GetItem(slot).Count);
        }
        
        [Test]
        public void ItemFullToCanNotCraftTest()
        {
            //
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var playerInv = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(PlayerId);
            var itemStackFactory = ServerContext.ItemStackFactory;
            var craftElement = MasterHolder.CraftRecipeMaster.CraftRecipes.Data[CraftRecipeId];
            
            
            //
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var item = itemStackFactory.Create(new ItemId(10), 100);
                playerInv.MainOpenableInventory.SetItem(i, item);
            }
            
            
            //
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var item = itemStackFactory.Create(info.ItemGuid, info.Count);
                playerInv.MainOpenableInventory.SetItem(i, item);
            }
            
            
            //
            var craftGuid = craftElement.CraftRecipeGuid;
            packet.GetPacketResponse(MessagePackSerializer.Serialize(new RequestOneClickCraftProtocolMessagePack(PlayerId, craftGuid)).ToList());
            
            //
            for (var i = 0; i < craftElement.RequiredItems.Length; i++)
            {
                var info = craftElement.RequiredItems[i];
                var itemId = MasterHolder.ItemMaster.GetItemId(info.ItemGuid);
                Assert.AreEqual(itemId, playerInv.MainOpenableInventory.GetItem(i).Id.AsPrimitive());
                Assert.AreEqual(info.Count, playerInv.MainOpenableInventory.GetItem(i).Count);
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/BlockSlopeDeformationType.cs
```cs
using System.Collections.Generic;

namespace Client.Game.InGame.BlockSystem
{
    public class BlockSlopeDeformationType
    {
        private static readonly List<string> deformationTypes = new()
        {
            "BeltConveyor",
        };
        
        
        /// <summary>
        ///     
        ///     truefalse
        /// </summary>
        /// <param name="type"></param>
        /// <returns></returns>
        public static bool IsDeformation(string type)
        {
            return deformationTypes.Contains(type);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailGraphDatastore.cs
```cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Game.Train.RailGraph
{
    public class RailGraphDatastore
    {
        private readonly Dictionary<RailNode, int> railIdDic;//RailNodeId
        private readonly List<RailNode> railNodes;//IdRailNode
        MinHeap<int> nextidQueue;//Idminheap

        //
        private readonly List<List<(int, int)>> connectNodes;//connectNodes[NodeId_A]:NodeId_ANodeId(Id,)

        public RailGraphDatastore()
        {
            railIdDic = new Dictionary<RailNode, int>();
            railNodes = new List<RailNode>();
            nextidQueue = new MinHeap<int>();
            connectNodes = new List<List<(int, int)>>();
        }

        public void AddNode(RailNode node)
        {
            //node
            if (railIdDic.ContainsKey(node))
                return;

            int nextid;
            if ((nextidQueue.IsEmpty) || (railNodes.Count < nextidQueue.Peek()))
                nextidQueue.Insert(railNodes.Count);
            nextid = nextidQueue.RemoveMin();//Id
            //nextid<=railNodes.Count
            if (nextid == railNodes.Count)
            {
                railNodes.Add(node);
                connectNodes.Add(new List<(int, int)>());
            }
            else
            {
                railNodes[nextid] = node;
            }

            railIdDic[node] = nextid;
        }

        //RailNodeRailNodeint
        public void ConnectNode(RailNode node, RailNode targetNode, int distance)
        {
            //node
            if (!railIdDic.ContainsKey(node))
                AddNode(node);
            var nodeid = railIdDic[node];
            //target
            if (!railIdDic.ContainsKey(targetNode))
                AddNode(targetNode);
            var targetid = railIdDic[targetNode];
            connectNodes[nodeid].Add((targetid, distance));
        }
        //
        public void DisconnectNode(RailNode node, RailNode targetNode)
        {
            var nodeid = railIdDic[node];
            var targetid = railIdDic[targetNode];
            connectNodes[nodeid].RemoveAll(x => x.Item1 == targetid);
        }

        //
        public void RemoveNode(RailNode node)
        {
            var nodeid = railIdDic[node];
            railIdDic.Remove(node);
            railNodes[nodeid] = null;
            nextidQueue.Insert(nodeid);
            connectNodes[nodeid].Clear();
        }

        //RailNodeRailNode<Nod>
        //RailNodeRailNode
        public List<RailNode> GetConnectedNodes(RailNode node)
        {
            if (!railIdDic.ContainsKey(node))
                return new List<RailNode>();
            int nodeId = railIdDic[node];
            return connectNodes[nodeId].Select(x => railNodes[x.Item1]).ToList();
        }
        //RailNodeRailNode<Node,int>
        public List<(RailNode, int)> GetConnectedNodesWithDistance(RailNode node)
        {
            if (!railIdDic.ContainsKey(node))
                return new List<(RailNode, int)>();
            int nodeId = railIdDic[node];
            return connectNodes[nodeId].Select(x => (railNodes[x.Item1], x.Item2)).ToList();
        }


        //railnode2 start  target 2
        //-1
        public int GetDistanceBetweenNodes(RailNode start, RailNode target)
        {
            if (!railIdDic.ContainsKey(start) || !railIdDic.ContainsKey(target)) 
            {
                Debug.LogWarning("RailNode");
                return -1;
            }
            int startid = railIdDic[start];
            int targetid = railIdDic[target];
            foreach (var (neighbor, distance) in connectNodes[startid])
            {
                if (neighbor == targetid)
                    return distance;
            }
            //
            Debug.LogWarning("RailNode" + startid + "to" + targetid + "");
            return -1;
        }


        /// <summary>
        /// 
        /// intID
        /// generated by chat gpt 4o
        /// <returns></returns>
        public List<RailNode> FindShortestPath(RailNode startNode, RailNode targetNode)
        {
            return FindShortestPath(railIdDic[startNode], railIdDic[targetNode]);
        }

        public List<RailNode> FindShortestPath(int startid, int targetid)
        {
            // 
            var priorityQueue = new PriorityQueue<int, int>();
            //  int.MaxValue
            List<int> distances = new List<int>();//  int.MaxValue
            List<int> previousNodes = new List<int>();// 
            for (int i = 0; i < railNodes.Count; i++)
                distances.Add(int.MaxValue);
            for (int i = 0; i < railNodes.Count; i++)
                previousNodes.Add(-1);


            // 0
            distances[startid] = 0;
            priorityQueue.Enqueue(startid, 0);

            while (priorityQueue.Count > 0)
            {
                // 
                var currentNodecnt = priorityQueue.Dequeue();
                // 
                if (currentNodecnt == targetid)
                {
                    break;
                }

                // 
                foreach (var (neighbor, distance) in connectNodes[currentNodecnt])
                {
                    int newDistance = distances[currentNodecnt] + distance;
                    // int()
                    if (newDistance < 0)
                        continue;
                    // 
                    if (newDistance < distances[neighbor])
                    {
                        distances[neighbor] = newDistance;
                        previousNodes[neighbor] = currentNodecnt;
                        // 
                        priorityQueue.Enqueue(neighbor, newDistance);
                    }
                }
            }

            // 
            var path = new List<int>();
            var current = targetid;
            while (current != -1)
            {
                path.Add(current);
                current = previousNodes[current];
            }

            // 
            if (path.Last() != startid)
            {
                return new List<RailNode>();
            }

            // 
            path.Reverse();
            var pathNodes = path.Select(id => railNodes[id]).ToList();
            return pathNodes;
        }











    }
}

```

moorestech_client/Assets/Scripts/Client.Skit/Character/BlinkSystem.cs
```cs
using DG.Tweening;
using UnityEngine;

namespace Client.Skit.Character
{
    public class BlinkSystem : MonoBehaviour
    {
        [SerializeField] private SkinnedMeshRenderer faceSkinnedMeshRenderer;
        [SerializeField] private string blinkBlendShapeName = "Blink";
        
        private int _blinkBlendShapeIndex;
        
        private float _blinkTimer;
        private bool _isBlinking;
        
        private void Start()
        {
            _blinkBlendShapeIndex = faceSkinnedMeshRenderer.sharedMesh.GetBlendShapeIndex(blinkBlendShapeName);
        }
        
        private void Update()
        {
            _blinkTimer -= Time.deltaTime;
            if (_blinkTimer <= 0)
            {
                _blinkTimer = Random.Range(2f, 4f);
                
                // DoTween
                DOTween.To(
                    () => faceSkinnedMeshRenderer.GetBlendShapeWeight(_blinkBlendShapeIndex),
                    x => faceSkinnedMeshRenderer.SetBlendShapeWeight(_blinkBlendShapeIndex, x),
                    100,
                    0.1f).OnComplete(() =>
                {
                    DOTween.To(
                        () => faceSkinnedMeshRenderer.GetBlendShapeWeight(_blinkBlendShapeIndex),
                        x => faceSkinnedMeshRenderer.SetBlendShapeWeight(_blinkBlendShapeIndex, x),
                        0,
                        0.1f);
                });
            }
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerCrafterInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Block.ChainerCrafter;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class CraftChainerCrafterInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        [SerializeField] private List<ItemSlotObject> recipeInputItemSlotObjects;
        [SerializeField] private List<ItemSlotObject> recipeOutputItemSlotObjects;
        
        [SerializeField] private CraftChainerCrafterItemSelectModal itemSelectModal;
        
        private BlockGameObject _blockGameObject;
        private CancellationToken _gameObjectCancellationToken;
        
        private CraftingSolverRecipe _currentRecipe;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            _gameObjectCancellationToken = this.GetCancellationTokenOnDestroy();
            
            // 
            // Initialize item list
            InitializeItemList();
            
            // 
            // Get recipe information
            InitializeRecipeSlots().Forget();
            
            itemSelectModal.Initialize();
            
            #region Internal
            
            void InitializeItemList()
            {
                var itemList = new List<IItemStack>();
                var param = (CraftChainerCrafterBlockParam)blockGameObject.BlockMasterElement.BlockParam;
                for (var i = 0; i < param.ItemSlotCount; i++)
                {
                    var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                    _blockItemSlotObjects.Add(slotObject);
                    itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
                }
                UpdateItemList(itemList);
            }
            
  #endregion
        }
        
        private async UniTask InitializeRecipeSlots()
        {
            _currentRecipe = await GetRecipe();
            if (_currentRecipe == null) return;
            
            SetRecipeUI(_currentRecipe);
            
            SetupRecipeSlotEvent();
            
            #region Internal
            
            async UniTask<CraftingSolverRecipe> GetRecipe()
            {
                var pos = _blockGameObject.BlockPosInfo.OriginalPos;
                var blockStates = await ClientContext.VanillaApi.Response.GetBlockState(pos, _gameObjectCancellationToken);
                if (blockStates == null) return null;
                
                var chainerState = blockStates.GetStateDetail<ChainerCrafterComponentSerializeObject>(ChainerCrafterComponentSerializeObject.StateDetailKey);
                if (chainerState == null) return null;
                
                return chainerState.Recipe.ToCraftingSolverRecipe();
            }
            
            void SetupRecipeSlotEvent()
            {
                for (var i = 0; i < recipeInputItemSlotObjects.Count; i++)
                {
                    var input = recipeInputItemSlotObjects[i];
                    var index = i;
                    input.OnLeftClickUp.Subscribe(item => ClickRecipeInputItem(item, index, true).Forget());
                }
                for (var i = 0; i < recipeOutputItemSlotObjects.Count; i++)
                {
                    var output = recipeOutputItemSlotObjects[i];
                    var index = i;
                    output.OnLeftClickUp.Subscribe(item => ClickRecipeInputItem(item, index, false).Forget());
                }
            }
            
            #endregion
        }
        
        private async UniTask ClickRecipeInputItem(ItemSlotObject itemSlotObject, int index, bool isInput)
        {
            // 
            // Select item
            var (resultId, resultCount) = await SelectItem();
            
            // 
            // Update recipe information
            UpdateRecipe();
            
            // UI
            // Update UI
            SetRecipeUI(_currentRecipe);
            
            // 
            // Send recipe information
            SendRecipeInfo();
            
            #region Internal
            
            async UniTask<(ItemId,int)> SelectItem()
            {
                // 
                var currentId = itemSlotObject.ItemViewData?.ItemId ?? ItemMaster.EmptyItemId;
                var currentCount = itemSlotObject.Count;
                
                var (id, count) = await itemSelectModal.GetSelectItem(currentId, currentCount);
                
                return (id, count);
            }
            
            void UpdateRecipe()
            {
                var recipeItems = isInput ? _currentRecipe.Inputs : _currentRecipe.Outputs;
                
                if (index < recipeItems.Count)
                {
                    recipeItems[index] = new CraftingSolverItem(resultId, resultCount);
                }
                else
                {
                    for (var i = recipeItems.Count; i < index; i++)
                    {
                        recipeItems.Add(new CraftingSolverItem(ItemMaster.EmptyItemId, 0));
                    }
                    
                    recipeItems.Add(new CraftingSolverItem(resultId, resultCount));
                }
            }
            
            void SendRecipeInfo()
            {
                // 
                var input = _currentRecipe.Inputs.Where(i => i.ItemId != ItemMaster.EmptyItemId).ToList();
                var output = _currentRecipe.Outputs.Where(i => i.ItemId != ItemMaster.EmptyItemId).ToList();
                
                var pos = _blockGameObject.BlockPosInfo.OriginalPos;
                ClientContext.VanillaApi.SendOnly.SetCraftChainerCrafterRecipe(pos, input, output);
            }
            
  #endregion
            
        }
        
        
        private void SetRecipeUI(CraftingSolverRecipe recipe)
        {
            SetItemSlot(recipeInputItemSlotObjects, recipe.Inputs);
            SetItemSlot(recipeOutputItemSlotObjects, recipe.Outputs);
            
            #region Internal
            
            void SetItemSlot(List<ItemSlotObject> itemSlots, List<CraftingSolverItem> items)
            {
                for (var i = 0; i < itemSlots.Count; i++)
                {
                    if (i >= items.Count)
                    {
                        itemSlots[i].SetItem(null, 0);
                        continue;
                    }
                    
                    var item = items[i];
                    var slotObject = itemSlots[i];
                    var itemView = ClientContext.ItemImageContainer.GetItemView(item.ItemId);
                    slotObject.SetItem(itemView, item.Count);
                }
            }
            
  #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.Interface/DataStore/WorldBlockData.cs
```cs
using Core.Master;
using Game.Block.Interface;
using UnityEngine;

namespace Game.World.Interface.DataStore
{
    /// <summary>
    ///     TODO interface
    /// </summary>
    public class WorldBlockData
    {
        public IBlock Block { get; }
        public BlockPositionInfo BlockPositionInfo { get; }
        
        public WorldBlockData(IBlock block, Vector3Int originalPos, BlockDirection blockDirection)
        {
            Block = block;
            var blockSize = MasterHolder.BlockMaster.GetBlockMaster(block.BlockId).BlockSize;
            BlockPositionInfo = new BlockPositionInfo(originalPos, blockDirection, blockSize);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/ItemListView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.Tutorial.UIHighlight;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Main;
using Core.Master;
using Game.CraftChainer.Util;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    public class ItemListView : MonoBehaviour
    {
        public const string ItemRecipeListHighlightKey = "itemRecipeList:{0}";
        
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        [SerializeField] private RectTransform itemListParent;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private ILocalPlayerInventory _localPlayerInventory;
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        private readonly List<ItemSlotObject> _itemListObjects = new();
        
        [Inject]
        public void Construct(ILocalPlayerInventory localPlayerInventory, ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            _localPlayerInventory = localPlayerInventory;
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;
            
            _localPlayerInventory.OnItemChange.Subscribe(OnInventoryItemChange);
            
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                
                // 
                // Set the item list
                var itemSlotObject = Instantiate(itemSlotObjectPrefab, itemListParent);
                itemSlotObject.SetItem(itemViewData, 0);
                itemSlotObject.OnLeftClickUp.Subscribe(OnClickItemList);
                _itemListObjects.Add(itemSlotObject);
                
                // 
                // Set the highlight object
                var target = itemSlotObject.gameObject.AddComponent<UIHighlightTutorialTargetObject>();
                var itemMaster = MasterHolder.ItemMaster.GetItemMaster(itemId);
                target.Initialize(string.Format(ItemRecipeListHighlightKey, itemMaster.Name));
            }
        }
        
        private void OnClickItemList(ItemSlotObject slot)
        {
            var itemId = slot.ItemViewData.ItemId;
            var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
            _onClickItem.OnNext(itemRecipes);
        }
        
        private void OnInventoryItemChange(int slot)
        {
            var enableItem = CheckAllItemCraftable();
            foreach (var itemUI in _itemListObjects)
            {
                var isGrayOut = !enableItem.Contains(itemUI.ItemViewData.ItemId);
                itemUI.SetGrayOut(isGrayOut);
            }
            
            #region Internal
            
            HashSet<ItemId> CheckAllItemCraftable()
            {
                var itemPerCount = new Dictionary<ItemId, int>();
                foreach (var item in _localPlayerInventory)
                {
                    if (item.Id == ItemMaster.EmptyItemId) continue;
                    if (itemPerCount.ContainsKey(item.Id))
                        itemPerCount[item.Id] += item.Count;
                    else
                        itemPerCount.Add(item.Id, item.Count);
                }
                
                var result = new HashSet<ItemId>();
                
                foreach (var craftMaster in MasterHolder.CraftRecipeMaster.GetAllCraftRecipes())
                {
                    var resultItemId = MasterHolder.ItemMaster.GetItemId(craftMaster.CraftResultItemGuid);
                    if (result.Contains(resultItemId)) continue; //
                    var isCraftable = true;
                    foreach (var requiredItem in craftMaster.RequiredItems)
                    {
                        var requiredItemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                        if (!itemPerCount.ContainsKey(requiredItemId) || itemPerCount[requiredItemId] < requiredItem.Count)
                        {
                            isCraftable = false;
                            break;
                        }
                    }
                    
                    if (isCraftable) result.Add(resultItemId);
                }
                
                return result;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Update/GameUpdater.cs
```cs
using System;
using System.Threading;
using UniRx;

namespace Core.Update
{
    public static class GameUpdater
    {
        private static Subject<Unit> _updateSubject = new();
        
        private static DateTime _lastUpdateTime = DateTime.Now;
        public static IObservable<Unit> UpdateObservable => _updateSubject;
        
        [Obsolete("")] public static double UpdateSecondTime { get; private set; }
        
        public static void Update()
        {
            //
            UpdateDeltaTime();
            _updateSubject.OnNext(Unit.Default);
        }
        
        public static void UpdateDeltaTime()
        {
            UpdateSecondTime = (DateTime.Now - _lastUpdateTime).TotalSeconds;
            _lastUpdateTime = DateTime.Now;
        }
        
        public static void ResetUpdate()
        {
            _updateSubject = new Subject<Unit>();
            UpdateSecondTime = 0;
            _lastUpdateTime = DateTime.Now;
        }
        
        public static void ResetTime()
        {
            _lastUpdateTime = DateTime.Now;
            UpdateSecondTime = 0;
        }
        
        public static void Dispose()
        {
            _updateSubject.Dispose();
        }
        
#if UNITY_EDITOR
        public static void UpdateWithWait()
        {
            //TODO 
            Update();
            Wait();
        }
        
        public static void SpecifiedDeltaTimeUpdate(double updateSecondTime)
        {
            UpdateSecondTime = updateSecondTime;
            _updateSubject.OnNext(Unit.Default);
        }
        
        public static void Wait()
        {
            Thread.Sleep(5);
        }
#endif
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/StartServer.cs
```cs
using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Game.SaveLoad.Interface;
using Microsoft.Extensions.DependencyInjection;
using Mod.Base;
using Mod.Loader;
using Server.Boot.PacketHandle;
using UnityEngine;

namespace Server.Boot
{
    public static class StartServer
    {
        private const int ArgsCount = 1;
        
        private static string DebugServerDirectory =>
            Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, "../moorestech_client/Server"));
        
        private static string StartupFromClientFolderPath
        {
            get
            {
                var di = new DirectoryInfo(Environment.CurrentDirectory);
                return Path.Combine(di.FullName, "server", "mods");
            }
        }
        
        public static (Thread serverUpdateThread, CancellationTokenSource autoSaveTokenSource) Start(string[] args)
        {
            //
#if DEBUG
            var serverDirectory = DebugServerDirectory;
#else
            var serverDirectory = Path.GetDirectoryName(Application.dataPath);
#endif
            
            Debug.Log(":" + serverDirectory);
            
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(serverDirectory);
            
            //
            serviceProvider.GetService<IWorldSaveDataLoader>().LoadOrInitialize();
            
            //modOnLoad
            var modsResource = serviceProvider.GetService<ModsResource>();
            modsResource.Mods.ToList().ForEach(
                m => m.Value.ModEntryPoints.ForEach(
                    e =>
                    {
                        Debug.Log("Mod modId:" + m.Value + " className:" + e.GetType().Name);
                        e.OnLoad(new ServerModEntryInterface(serviceProvider, packet));
                    }));
            
            
            //
            var serverUpdateThread = new Thread(() => new PacketHandler().StartServer(packet));
            serverUpdateThread.Name = "[moorestech]";
            
            var autoSaveTaskTokenSource = new CancellationTokenSource();
            Task.Run(
                () => new AutoSaveSystem(serviceProvider.GetService<IWorldSaveDataSaver>()).AutoSave(
                    autoSaveTaskTokenSource), autoSaveTaskTokenSource.Token);
            
            return (serverUpdateThread, autoSaveTaskTokenSource);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/Input/ScreenClickableCameraController.cs
```cs
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.Control;
using Client.Input;
using UnityEngine;

namespace Client.Game.InGame.UI.UIState.Input
{
    /// <summary>
    /// 
    /// Camera operation when elements on the screen can be clicked (e.g., block placement)
    /// </summary>
    public class ScreenClickableCameraController
    {
        private readonly InGameCameraController _inGameCameraController;
        
        private const float TargetCameraDistance = 9;
        private const float TweenDuration = 0.25f;
        
        private Vector3? _startCameraRotation;
        private float? _startCameraDistance;
        
        public ScreenClickableCameraController(InGameCameraController inGameCameraController)
        {
            _inGameCameraController = inGameCameraController;
        }
        
        public void OnEnter()
        {
            InputManager.MouseCursorVisible(true);
        }
        
        public void GetNextUpdate()
        {
            //TODO InputSystem
            if (UnityEngine.Input.GetMouseButtonDown(1))
            {
                InputManager.MouseCursorVisible(false);
                _inGameCameraController.SetControllable(true);
            }
            
            //TODO InputSystem
            if (UnityEngine.Input.GetMouseButtonUp(1))
            {
                InputManager.MouseCursorVisible(true);
                _inGameCameraController.SetControllable(false);
            }
        }
        
        public void OnExit()
        {
            if (_startCameraRotation.HasValue && _startCameraDistance.HasValue)
            {
                var startCameraRotation = _startCameraRotation.Value;
                var startCameraDistance = _startCameraDistance.Value;
                _inGameCameraController.StartTweenCamera(startCameraRotation, startCameraDistance, TweenDuration);
            }
            
            InputManager.MouseCursorVisible(false);
        }
        
        /// <summary>
        /// 
        /// Move the camera to a top view
        /// </summary>
        /// <returns>start camera position</returns>
        public TweenCameraInfo StartTweenFromTop()
        {
            _startCameraDistance = _inGameCameraController.CameraDistance;
            _startCameraRotation = _inGameCameraController.CameraEulerAngle;
            
            TweenCamera(new TweenCameraInfo(new Vector3(70, 0, 0), TargetCameraDistance));
            
            return new TweenCameraInfo(_inGameCameraController.CameraEulerAngle, _inGameCameraController.CameraDistance);
            
            #region Internal
            
            void TweenCamera()
            {
            }
            
            #endregion
        }
        
        public void TweenCamera(TweenCameraInfo tweenCameraInfo)
        {
            var currentRotation = _inGameCameraController.CameraEulerAngle;
            var targetCameraRotation = currentRotation;
            targetCameraRotation.x = 70f;
            targetCameraRotation.y = currentRotation.y switch
            {
                var y when y < 45 => 0,
                var y when y < 135 => 90,
                var y when y < 225 => 180,
                var y when y < 315 => 270,
                _ => 0
            };
            _inGameCameraController.StartTweenCamera(targetCameraRotation, TargetCameraDistance, TweenDuration);
        }
        
        public void TweenCamera()
        {
            
        }
    }
    
    public class TweenCameraInfo
    {
        public readonly Vector3 StartRotation;
        public readonly float StartDistance;
        
        public TweenCameraInfo(Vector3 startRotation, float startDistance)
        {
            StartRotation = startRotation;
            StartDistance = startDistance;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ItemStackTest.cs
```cs
using System;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Other
{
    public class ItemStackTest
    {
        private const int EmptyItemId = 0;
        private IItemStackFactory _itemStackFactory;
        
        [SetUp]
        public void Setup()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            _itemStackFactory = ServerContext.ItemStackFactory;
        }
        
        [TestCase(1, 1, 1, 1, 2, 0, 1, EmptyItemId)]
        [TestCase(1, 5, 1, 1, 6, 0, 1, EmptyItemId)]
        [TestCase(EmptyItemId, 0, 1, 3, 3, 0, 1, EmptyItemId)]
        [TestCase(EmptyItemId, 0, 2, 9, 9, 0, 2, EmptyItemId)]
        [TestCase(EmptyItemId, 5, 1, 1, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 1, EmptyItemId, 0, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 1, EmptyItemId, 0, 1, 0, 1, EmptyItemId)]
        [TestCase(1, 5, EmptyItemId, 0, 5, 0, 1, EmptyItemId)]
        [TestCase(3, 1, 1, 8, 1, 8, 3, 1)]
        [TestCase(1, 1, 3, 1, 1, 1, 1, 3)]
        [TestCase(2, 5, 5, 3, 5, 3, 2, 5)]
        public void AddTest(int mid, int mamo, int rid, int ramo, int ansMAmo, int ansRAmo, int ansMid, int ansRID)
        {
            IItemStack mineItemStack;
            if (mid == EmptyItemId)
                mineItemStack = _itemStackFactory.CreatEmpty();
            else
                mineItemStack = _itemStackFactory.Create(new ItemId(mid), mamo);
            
            IItemStack receivedItemStack;
            if (rid == EmptyItemId)
                receivedItemStack = _itemStackFactory.CreatEmpty();
            else
                receivedItemStack = _itemStackFactory.Create(new ItemId(rid), ramo);
            
            var result = mineItemStack.AddItem(receivedItemStack);
            Assert.AreEqual(result.ProcessResultItemStack.Count, ansMAmo);
            Assert.AreEqual(result.RemainderItemStack.Count, ansRAmo);
            Assert.AreEqual(result.ProcessResultItemStack.Id, ansMid);
            Assert.AreEqual(result.RemainderItemStack.Id, ansRID);
        }
        
        [TestCase(1, 5, 1, 4, 1)]
        [TestCase(EmptyItemId, 5, 1, 0, EmptyItemId)]
        [TestCase(1, 5, 10, 0, EmptyItemId)]
        [TestCase(1, 8, 8, 0, EmptyItemId)]
        [TestCase(1, 8, 9, 0, EmptyItemId)]
        public void SubTest(int mid, int mamo, int subamo, int ansamo, int ansID)
        {
            IItemStack mineItemStack;
            if (mid == EmptyItemId)
                mineItemStack = _itemStackFactory.CreatEmpty();
            else
                mineItemStack = _itemStackFactory.Create(new ItemId(mid), mamo);
            
            var result = mineItemStack.SubItem(subamo);
            Assert.AreEqual(ansamo, result.Count);
            Assert.AreEqual(ansID, result.Id.AsPrimitive());
        }
        
        
        [TestCase(3, 299, 0, 0)]
        [TestCase(3, 299, 1, 0)]
        [TestCase(3, 150, 150, 0)]
        [TestCase(3, 300, 1, 1)]
        [TestCase(3, 1, 300, 1)]
        [TestCase(3, 300, 300, 300)]
        public void ItemAddToOverFlowTest(int id, int baseAmount, int addAmount, int overflowAmount)
        {
            var baseItem = _itemStackFactory.Create(new ItemId(id), baseAmount);
            
            
            var result = baseItem.AddItem(_itemStackFactory.Create(new ItemId(id), addAmount));
            Assert.True(_itemStackFactory.Create(new ItemId(id), overflowAmount).Equals(result.RemainderItemStack));
        }
        
        [TestCase(1, 100, false)]
        [TestCase(1, 1001, true)]
        [TestCase(1, 200, true)]
        public void ItemAddToOverFlowThrowTest(int id, int baseAmo, bool isthrow)
        {
            try
            {
                _itemStackFactory.Create(new ItemId(id), baseAmo);
                Assert.False(isthrow);
            }
            catch (Exception e)
            {
                Assert.True(isthrow);
            }
        }
        
        
        //False
        [TestCase(0)]
        [TestCase(1.5)]
        [TestCase("aaa")]
        public void NotRelatedObjectPassFalseHaveTest(object obj)
        {
            var nullItem = _itemStackFactory.CreatEmpty();
            Assert.False(nullItem.Equals(obj));
            var item = _itemStackFactory.Create(new ItemId(5), 1);
            Assert.False(item.Equals(obj));
        }
        
        [Test]
        public void ToStringTest()
        {
            var item = _itemStackFactory.CreatEmpty();
            Assert.True(item.ToString() == "ID:0 Count:0");
            item = _itemStackFactory.Create(new ItemId(1), 5);
            Assert.True(item.ToString() == "ID:1 Count:5");
            item = _itemStackFactory.Create(new ItemId(13), 10);
            Assert.True(item.ToString() == "ID:13 Count:10");
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/BlockMaster.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Mooresmaster.Loader.BlocksModule;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json.Linq;
using UnitGenerator;
using UnityEngine;

namespace Core.Master
{
    // Id
    // NOTE ID
    [UnitOf(typeof(int), UnitGenerateOptions.MessagePackFormatter | UnitGenerateOptions.Comparable)]
    public partial struct BlockId
    {
    }
    
    public class BlockMaster
    {
        public readonly Blocks Blocks;
        
        private readonly Dictionary<BlockId, BlockMasterElement> _blockElementTableById;
        private readonly Dictionary<Guid, BlockId> _blockGuidToBlockId;
        
        private readonly Dictionary<ItemId, BlockId> _itemIdToBlockId;
        
        public BlockMaster(JToken blockJToken, ItemMaster itemMaster)
        {
            // GUIDintItemId
            Blocks = BlocksLoader.Load(blockJToken);
            var sortedBlockElements = Blocks.Data.ToList().OrderBy(x => x.BlockGuid).ToList();
            
            // ID 01
            _blockElementTableById = new Dictionary<BlockId, BlockMasterElement>();
            _blockGuidToBlockId = new Dictionary<Guid, BlockId>();
            for (var i = 0; i < sortedBlockElements.Count; i++)
            {
                var blockId = new BlockId(i + 1); // ID 01
                _blockElementTableById.Add(blockId, sortedBlockElements[i]);
                _blockGuidToBlockId.Add(sortedBlockElements[i].BlockGuid, blockId);
            }
            
            // itemId to blockId
            _itemIdToBlockId = new Dictionary<ItemId, BlockId>();
            foreach (var blockElement in Blocks.Data)
            {
                var itemId = itemMaster.GetItemId(blockElement.ItemGuid);
                if (_itemIdToBlockId.TryGetValue(itemId, out var blockId))
                {
                    throw new InvalidOperationException($"Duplicate itemId. ItemId:{blockElement.ItemGuid} BlockId:{blockElement.BlockGuid}");
                }
                else
                {
                    _itemIdToBlockId.Add(itemId, _blockGuidToBlockId[blockElement.BlockGuid]);
                }
            }
        }
        
        public BlockMasterElement GetBlockMaster(BlockId blockId)
        {
            if (!_blockElementTableById.TryGetValue(blockId, out var element))
            {
                throw new InvalidOperationException($"BlockElement not found. BlockId:{blockId}");
            }
            
            return element;
        }
        
        public BlockMasterElement GetBlockMaster(Guid blockGuid)
        {
            var blockId = GetBlockId(blockGuid);
            return GetBlockMaster(blockId);
        }
        
        public BlockId GetBlockId(Guid blockGuid)
        {
            if (!_blockGuidToBlockId.TryGetValue(blockGuid, out var blockId))
            {
                throw new InvalidOperationException($"ItemElement not found. ItemGuid:{blockGuid}");
            }
            
            return blockId;
        }
        
        public List<BlockId> GetBlockIds()
        {
            return _blockElementTableById.Keys.ToList();
        }
        
        public bool IsBlock(ItemId itemId)
        {
            return _itemIdToBlockId.ContainsKey(itemId);
        }
        
        public BlockId GetBlockId(ItemId itemId)
        {
            return _itemIdToBlockId[itemId];
        }
        
        public ItemId GetItemId(BlockId blockId)
        {
            foreach (var pair in _itemIdToBlockId)
            {
                if (pair.Value == blockId)
                {
                    return pair.Key;
                }
            }
            
            throw new InvalidOperationException($"ItemElement not found. BlockId:{blockId}");
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Inventory/InventoryInsertItem.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;

namespace Core.Inventory
{
    /// <summary>
    ///     
    /// </summary>
    internal static class InventoryInsertItem
    {
        /// <summary>
        ///     
        /// </summary>
        /// <param name="insertItemStack"></param>
        /// <param name="inventoryItems"></param>
        /// <param name="itemStackFactory">ItemStackFactory</param>
        /// <param name="onSlotUpdate"></param>
        /// <returns></returns>
        internal static List<IItemStack> InsertItem(List<IItemStack> insertItemStack, List<IItemStack> inventoryItems, IItemStackFactory itemStackFactory, Action<int> onSlotUpdate = null)
        {
            var reminderItemStacks = new List<IItemStack>();
            
            foreach (var item in insertItemStack)
            {
                var remindItemStack = InsertItem(item, inventoryItems, itemStackFactory, onSlotUpdate);
                if (remindItemStack.Equals(itemStackFactory.CreatEmpty())) continue;
                
                reminderItemStacks.Add(remindItemStack);
            }
            
            return reminderItemStacks;
        }
        
        
        /// <summary>
        ///     
        /// </summary>
        /// <param name="insertItemStack"></param>
        /// <param name="inventoryItems"></param>
        /// <param name="itemStackFactory">ItemStackFactory</param>
        /// <param name="onSlotUpdate"></param>
        /// <returns></returns>
        internal static IItemStack InsertItem(IItemStack insertItemStack, List<IItemStack> inventoryItems, IItemStackFactory itemStackFactory, Action<int> onSlotUpdate = null)
        {
            for (var i = 0; i < inventoryItems.Count; i++)
            {
                //
                if (!inventoryItems[i].IsAllowedToAddWithRemain(insertItemStack)) continue;
                
                //
                var remain = InsertionItemBySlot(i, insertItemStack, inventoryItems, itemStackFactory, onSlotUpdate);
                
                //
                if (remain.Equals(itemStackFactory.CreatEmpty())) return remain;
                //
                insertItemStack = remain;
            }
            
            return insertItemStack;
        }
        
        /// <summary>
        ///     
        ///     
        /// </summary>
        public static IItemStack InsertItemWithPrioritySlot(IItemStack itemStack, List<IItemStack> inventory, IItemStackFactory itemStackFactory, int[] prioritySlots, Action<int> invokeEvent)
        {
            //
            var remainItem = itemStack;
            foreach (var prioritySlot in prioritySlots)
                remainItem = InsertionItemBySlot(prioritySlot, remainItem, inventory, itemStackFactory, invokeEvent);
            
            //
            return InsertItem(remainItem, inventory, itemStackFactory, invokeEvent);
        }
        
        /// <summary>
        ///     
        /// </summary>
        /// <returns> </returns>
        private static IItemStack InsertionItemBySlot(int slot, IItemStack itemStack, List<IItemStack> inventoryItems, IItemStackFactory itemStackFactory, Action<int> onSlotUpdate = null)
        {
            if (itemStack.Equals(itemStackFactory.CreatEmpty())) return itemStack;
            if (!inventoryItems[slot].IsAllowedToAddWithRemain(itemStack)) return itemStack;
            
            var result = inventoryItems[slot].AddItem(itemStack);
            
            //
            if (!inventoryItems[slot].Equals(result.ProcessResultItemStack))
            {
                inventoryItems[slot] = result.ProcessResultItemStack;
                onSlotUpdate?.Invoke(slot);
            }
            
            return result.RemainderItemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/RailNode.cs
```cs
using Game.Train.Blocks;
using System.Collections.Generic;
/// <summary>
/// intNotion
/// </summary>

namespace Game.Train.RailGraph
{
    public class RailNode
    {
        //public RailNodeId NodeId { get; }  // IDRailGraphNodeId
        //NodeIdId


        // null
        public StationComponent Station { get; private set; }
        // 
        public RailNode OppositeNode { get; private set; }
        private readonly RailGraphDatastore _railGraph; // Graph 


        ///  IEnumerable 
        //IEnumerable<RailNode> 
        //:
        //   foreach 
        //  
        //:
        //  
        //:
        //  List<T>  Array 
        /// </summary>
        public IEnumerable<RailNode> ConnectedNodes
        {
            get
            { return _railGraph.GetConnectedNodes(this); }
        }
        public IEnumerable<(RailNode, int)> ConnectedNodesWithDistance
        {
            get
            { return _railGraph.GetConnectedNodesWithDistance(this); }
        }

        public RailNode(RailGraphDatastore railGraph, StationComponent station = null)
        {
            _railGraph = railGraph;
            Station = station;
            railGraph.AddNode(this);
        }

        //RailNode oppositeNode setrailComponent
        public void SetOppositeNode(RailNode oppositeNode)
        {
            OppositeNode = oppositeNode;
        }


        //RailGraph
        public void ConnectNode(RailNode targetNode, int distance)
        {
            _railGraph.ConnectNode(this, targetNode, distance);
        }
        //node
        public int GetDistanceToNode(RailNode node)
        {
            return _railGraph.GetDistanceBetweenNodes(this, node);
        }


    }

}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/AssembleSaveJsonTextTest.cs
```cs
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class AssembleSaveJsonTextTest
    {
        //
        [Test]
        public void SimpleBlockPlacedTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            worldBlockDatastore.TryAddBlock((BlockId)1, Vector3Int.zero, BlockDirection.North, out var block0);
            worldBlockDatastore.TryAddBlock((BlockId)2, new Vector3Int(10, -15), BlockDirection.North, out var block1);
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            
            Debug.Log(json);
            
            var (_, loadServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            (loadServiceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson).Load(json);
            
            var worldLoadBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var b0 = worldLoadBlockDatastore.GetBlock(new Vector3Int(0, 0));
            Assert.AreEqual(1, b0.BlockId.AsPrimitive());
            Assert.AreEqual(block0.BlockInstanceId, b0.BlockInstanceId.AsPrimitive());
            
            var b1 = worldLoadBlockDatastore.GetBlock(new Vector3Int(10, -15));
            Assert.AreEqual(2, b1.BlockId.AsPrimitive());
            Assert.AreEqual(block1.BlockInstanceId, b1.BlockInstanceId.AsPrimitive());
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/EnergyConnectUpdaterContainer.cs
```cs
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     
    /// </summary>
    public class EnergyConnectUpdaterContainer<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        public EnergyConnectUpdaterContainer(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore, MaxElectricPoleMachineConnectionRange maxElectricPoleMachineConnectionRange)
        {
            new ConnectElectricPoleToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>(worldEnergySegmentDatastore);
            new ConnectMachineToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>(worldEnergySegmentDatastore, maxElectricPoleMachineConnectionRange);
            
            new DisconnectElectricPoleToFromElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>(worldEnergySegmentDatastore);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlacePreview.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Mooresmaster.Model.BlocksModule;
using Server.Protocol.PacketResponse;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    public class BlockPlacePreview : MonoBehaviour, IBlockPlacePreview
    {
        private BlockMasterElement _previewBlockMasterElement;
        private BlockPlacePreviewObjectPool _blockPlacePreviewObjectPool;
        
        public bool IsActive => gameObject.activeSelf;
        
        
        private void Awake()
        {
            _blockPlacePreviewObjectPool = new BlockPlacePreviewObjectPool(transform);
            SetActive(false);
        }
        
        public List<bool> SetPreviewAndGroundDetect(List<PlaceInfo> placePointInfos, BlockMasterElement holdingBlockMaster)
        {
            // 
            if (_previewBlockMasterElement == null || _previewBlockMasterElement.BlockGuid != holdingBlockMaster.BlockGuid)
            {
                _previewBlockMasterElement = holdingBlockMaster;
                _blockPlacePreviewObjectPool.AllDestroy();
            }
            
            _blockPlacePreviewObjectPool.AllUnUse();
            
            // 
            var isGroundDetectedList = new List<bool>();
            foreach (var placeInfo in placePointInfos)
            {
                var blockId = holdingBlockMaster.BlockGuid.GetVerticalOverrideBlockId(placeInfo.VerticalDirection);
                
                var pos = SlopeBlockPlaceSystem.GetBlockPositionToPlacePosition(placeInfo.Position, placeInfo.Direction, blockId);
                var rot = placeInfo.Direction.GetRotation();
                
                var previewBlock = _blockPlacePreviewObjectPool.GetObject(blockId);
                previewBlock.SetTransform(pos,rot);
                var isGroundDetected = previewBlock.IsCollisionGround;
                isGroundDetectedList.Add(isGroundDetected);
                
                previewBlock.SetPlaceableColor(!isGroundDetected && placeInfo.Placeable);
            }
            
            return isGroundDetectedList;
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/GearNetworkTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Blocks.Gear;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    public class GearNetworkTest
    {
        [Test]
        //NWRPM
        //Install a simple generator, make a simple gear NW, and test if RPM and direction of rotation are correct.
        public void SimpleGeneratorAndGearRpmTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, new Vector3Int(0, 0, 0), BlockDirection.North, out var generator);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Shaft, new Vector3Int(0, 0, 1), BlockDirection.North, out var shaft);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BigGear, new Vector3Int(-1, -1, 2), BlockDirection.North, out var bigGear);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, new Vector3Int(2, 0, 2), BlockDirection.North, out var smallGear);
            
            //
            //Update the network
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDatastore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            //
            //Is the generator supply correct?
            var generatorComponent = generator.GetComponent<IGearGenerator>();
            Assert.AreEqual(10.0f, generatorComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, generatorComponent.GenerateIsClockwise);
            
            //
            //Is the rotation of the shaft correct?
            var shaftComponent = shaft.GetComponent<GearEnergyTransformer>();
            Assert.AreEqual(10.0f, shaftComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, shaftComponent.IsCurrentClockwise);
            
            //BigGear
            //Is the rotation of BigGear correct?
            var bigGearComponent = bigGear.GetComponent<GearComponent>();
            Assert.AreEqual(10.0f, bigGearComponent.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, bigGearComponent.IsCurrentClockwise);
            
            //SmallGear
            //Is the rotation of SmallGear correct?
            var smallGearComponent = smallGear.GetComponent<GearComponent>();
            Assert.AreEqual(20.0f, smallGearComponent.CurrentRpm.AsPrimitive()); // 2:1 Gear ratio 2:1
            Assert.AreEqual(false, smallGearComponent.IsCurrentClockwise); //  Rotation is reversed
        }
        
        [Test]
        // NWRPM
        // Create a looped gear NW and test if RPM and direction of rotation are correct.
        public void LoopGearNetworkTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            // C - D
            // |   |
            // A - B
            //
            // A = 0,0,0
            // GeneratorGear
            
            const float rpm = 10.0f;
            
            var gearPositionA = new Vector3Int(0, 0, 0);
            var gearPositionB = new Vector3Int(1, 0, 0);
            var gearPositionC = new Vector3Int(0, 0, 1);
            var gearPositionD = new Vector3Int(1, 0, 1);
            var generatorPosition = new Vector3Int(0, 0, -1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.InfinityTorqueSimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionA, BlockDirection.North, out var smallGearABlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionB, BlockDirection.North, out var smallGearBBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionC, BlockDirection.North, out var smallGearCBlock);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPositionD, BlockDirection.North, out var smallGearDBlock);
            
            var generator = generatorBlock.GetComponent<IGearGenerator>();
            var smallGearA = smallGearABlock.GetComponent<GearComponent>();
            var smallGearB = smallGearBBlock.GetComponent<GearComponent>();
            var smallGearC = smallGearCBlock.GetComponent<GearComponent>();
            var smallGearD = smallGearDBlock.GetComponent<GearComponent>();
            
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            // GeneratorRPM
            Assert.AreEqual(rpm, generator.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, generator.IsCurrentClockwise);
            
            // smallGearARPM
            Assert.AreEqual(rpm, smallGearA.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, smallGearA.IsCurrentClockwise);
            
            // smallGearBRPM
            Assert.AreEqual(rpm, smallGearB.CurrentRpm.AsPrimitive());
            Assert.AreEqual(false, smallGearB.IsCurrentClockwise);
            
            // smallGearCRPM
            Assert.AreEqual(rpm, smallGearC.CurrentRpm.AsPrimitive());
            Assert.AreEqual(true, smallGearC.IsCurrentClockwise);
            
            // smallGearDRPM
            Assert.AreEqual(rpm, smallGearD.CurrentRpm.AsPrimitive());
            Assert.AreEqual(false, smallGearD.IsCurrentClockwise);
        }
        
        [Test]
        // BigGearRPMSmallGearRPMSmallGear
        // Using BigGear, forcibly connect SmallGear with a different RPM and SmallGear with an unchanged RPM, and test that it locks.
        public void DifferentRpmGearNetworkToRockTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPos = new Vector3Int(1, 1, 0); // RPM
            var bigGearPos = new Vector3Int(0, 0, 1); // Gears on the side that changed RPM with large gears
            var smallGear1Pos = new Vector3Int(3, 1, 1);
            
            var smallGear2Pos = new Vector3Int(1, 1, 2); // RPM2
            
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPos, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BigGear, bigGearPos, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear2Pos, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear1Pos, BlockDirection.North, out var smallGear1);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGear2Pos, BlockDirection.North, out var smallGear2);
            
            //RPM
            //Force connection between gears with different RPM
            ForceConnectGear(smallGear1, smallGear2);
            
            // find the network
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDatastore.GearNetworks.First().Value;
            
            Assert.NotNull(gearNetwork);
            
            //
            //Update the network
            gearNetwork.ManualUpdate();
            
            // 
            Assert.IsTrue(gearNetwork.GearTransformers.All(g => g.IsRocked));
            Assert.IsTrue(gearNetwork.GearGenerators.All(g => g.IsRocked));
        }
        
        [Test]
        public void DifferentDirectionGearNetworkToRockTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 0);
            
            var gearPosition3 = new Vector3Int(0, 0, -1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out var gear2);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition3, BlockDirection.North, out var gear3);
            
            //
            //Forced connection of gears with different directions of rotation
            ForceConnectGear(gear2, gear3);
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            // 
            Assert.IsTrue(gearNetwork.GearTransformers.All(g => g.IsRocked));
            Assert.IsTrue(gearNetwork.GearGenerators.All(g => g.IsRocked));
        }
        
        [Test]
        public void MultiGeneratorOverrideRpmTest()
        {
            // RPM
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var fastGeneratorPosition = new Vector3Int(0, 0, 0);
            var fastGeneratorGearPosition = new Vector3Int(0, 0, 1);
            var smallGearAPosition = new Vector3Int(1, 0, 1);
            var generatorPosition = new Vector3Int(2, 0, 0);
            var generatorGearPosition = new Vector3Int(2, 0, 1);
            var smallGearBPosition = new Vector3Int(3, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleFastGearGenerator, fastGeneratorPosition, BlockDirection.North, out var fastGeneratorBlock);
            var fastGenerator = fastGeneratorBlock.GetComponent<IGearGenerator>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, fastGeneratorGearPosition, BlockDirection.North, out _);
            
            // SmallGearA
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGearAPosition, BlockDirection.North, out var smallGearABlock);
            var smallGearA = smallGearABlock.GetComponent<GearComponent>();
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            var generator = generatorBlock.GetComponent<IGearGenerator>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, generatorGearPosition, BlockDirection.North, out _);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, smallGearBPosition, BlockDirection.North, out var smallGearBBlock);
            var smallGearB = smallGearBBlock.GetComponent<GearComponent>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(fastGenerator.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(smallGearA.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(generator.CurrentRpm.AsPrimitive(), 20f);
            Assert.AreEqual(smallGearB.CurrentRpm.AsPrimitive(), 20f);
        }
        
        [Test]
        public void MultiGeneratorDifferentDirectionToRockTest()
        {
            // 
            // Gen1 - Gear1 
            //        Gear2
            // Gen2 - Gear3
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generator1Position = new Vector3Int(0, 0, 0);
            var generator2Position = new Vector3Int(1, 0, 0);
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generator1Position, BlockDirection.North, out var generator1Block);
            var generator1 = generator1Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generator2Position, BlockDirection.North, out var generator2Block);
            var generator2 = generator2Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out var gear1Block);
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out var gear2Block);
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.IsTrue(generator1.IsRocked);
            Assert.IsTrue(generator2.IsRocked);
            Assert.IsTrue(gear1.IsRocked);
            Assert.IsTrue(gear2.IsRocked);
        }
        
        [Test]
        public void ServeTorqueTest()
        {
            // 
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(1, 0, 1);
            var gearPosition3 = new Vector3Int(2, 0, 1);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition1, BlockDirection.North, out var gear1Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition2, BlockDirection.North, out var gear2Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition3, BlockDirection.North, out var gear3Block);
            
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            var gear3 = gear3Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(10, gear1.CurrentPower.AsPrimitive());
            Assert.AreEqual(10, gear2.CurrentPower.AsPrimitive());
            Assert.AreEqual(10, gear3.CurrentPower.AsPrimitive());
        }
        
        [Test]
        public void ServeTorqueOverTest()
        {
            //
            // 366
            // 3/6=0.5
            // Test that the supply torque decreases as the torque increases
            // The generator generates 3 torque, but since it is connected to 6 gears, the required torque becomes 6
            // As a result, the supplied torque becomes 3/6=0.5
            
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out var generatorBlock);
            var generator = generatorBlock.GetComponent<SimpleGearGeneratorComponent>();
            
            var gearPosition1 = new Vector3Int(0, 0, 1);
            var gearPosition2 = new Vector3Int(0, 0, 2);
            var gearPosition3 = new Vector3Int(1, 0, 2);
            var gearPosition4 = new Vector3Int(2, 0, 2);
            var gearPosition5 = new Vector3Int(2, 0, 3);
            var gearPosition6 = new Vector3Int(3, 0, 3);
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition1, BlockDirection.North, out var gear1Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth20RequireTorqueTestGear, gearPosition2, BlockDirection.North, out var gear2Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition3, BlockDirection.North, out var gear3Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition4, BlockDirection.North, out var gear4Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth20RequireTorqueTestGear, gearPosition5, BlockDirection.North, out var gear5Block);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.Teeth10RequireTorqueTestGear, gearPosition6, BlockDirection.North, out var gear6Block);
            
            var gear1 = gear1Block.GetComponent<IGearEnergyTransformer>();
            var gear2 = gear2Block.GetComponent<IGearEnergyTransformer>();
            var gear3 = gear3Block.GetComponent<IGearEnergyTransformer>();
            var gear4 = gear4Block.GetComponent<IGearEnergyTransformer>();
            var gear5 = gear5Block.GetComponent<IGearEnergyTransformer>();
            var gear6 = gear6Block.GetComponent<IGearEnergyTransformer>();
            
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var gearNetwork = gearNetworkDataStore.GearNetworks.First().Value;
            gearNetwork.ManualUpdate();
            
            Assert.AreEqual(5, gear1.CurrentRpm.AsPrimitive());
            Assert.AreEqual(5, gear2.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.5f, gear1.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.5f, gear2.CurrentTorque.AsPrimitive());
            
            Assert.AreEqual(10, gear3.CurrentRpm.AsPrimitive());
            Assert.AreEqual(10, gear4.CurrentRpm.AsPrimitive());
            Assert.AreEqual(10, gear5.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.25f, gear3.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.25f, gear4.CurrentTorque.AsPrimitive());
            Assert.AreEqual(0.25f, gear5.CurrentTorque.AsPrimitive());
            
            Assert.AreEqual(20, gear6.CurrentRpm.AsPrimitive());
            Assert.AreEqual(0.125f, gear6.CurrentTorque.AsPrimitive());
        }
        
        [Test]
        public void GearNetworkMergeTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var gearNetworkDataStore = serviceProvider.GetService<GearNetworkDatastore>();
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            var generatorPosition = new Vector3Int(0, 0, 0);
            var gearPosition1 = new Vector3Int(1, 0, 0);
            var gearPosition2 = new Vector3Int(2, 0, 0);
            var gearPosition3 = new Vector3Int(3, 0, 0);
            
            // 2
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition2, BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition3, BlockDirection.North, out _);
            Assert.AreEqual(2, gearNetworkDataStore.GearNetworks.Count);
            
            // 
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, gearPosition1, BlockDirection.North, out _);
            Assert.AreEqual(1, gearNetworkDataStore.GearNetworks.Count);
            
            // 
            ServerContext.WorldBlockDatastore.RemoveBlock(gearPosition2);
            Assert.AreEqual(2, gearNetworkDataStore.GearNetworks.Count);
        }
        
        private static void ForceConnectGear(IBlock gear1, IBlock gear2)
        {
            BlockConnectorComponent<IGearEnergyTransformer> gear1Connector = gear1.GetComponent<BlockConnectorComponent<IGearEnergyTransformer>>();
            var gear1Transform = gear1.GetComponent<IGearEnergyTransformer>();
            
            BlockConnectorComponent<IGearEnergyTransformer> gear2Connector = gear2.GetComponent<BlockConnectorComponent<IGearEnergyTransformer>>();
            var gear2Transform = gear2.GetComponent<IGearEnergyTransformer>();
            
            
            var gear1Info = new ConnectedInfo(new GearConnectOption(true), new GearConnectOption(true), gear1);
            var gear2Info = new ConnectedInfo(new GearConnectOption(true), new GearConnectOption(true), gear2);
            
            ((Dictionary<IGearEnergyTransformer, ConnectedInfo>)gear1Connector.ConnectedTargets).Add(gear2Transform, gear2Info);
            ((Dictionary<IGearEnergyTransformer, ConnectedInfo>)gear2Connector.ConnectedTargets).Add(gear1Transform, gear1Info);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Inventory/OpenableInventoryItemDataStoreService.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Item.Interface;
using Core.Master;

namespace Core.Inventory
{
    /// <summary>
    ///     
    /// </summary>
    public class OpenableInventoryItemDataStoreService : IOpenableInventory
    {
        public IReadOnlyList<IItemStack> InventoryItems => _inventory;
        private readonly List<IItemStack> _inventory;
        
        public delegate void InventoryUpdate(int slot, IItemStack itemStack);
        
        private readonly IItemStackFactory _itemStackFactory;
        private readonly InventoryUpdate _onInventoryUpdate;
        
        public OpenableInventoryItemDataStoreService(InventoryUpdate onInventoryUpdate, IItemStackFactory itemStackFactory, int slotNumber)
        {
            _itemStackFactory = itemStackFactory;
            _onInventoryUpdate = onInventoryUpdate;
            
            _inventory = new List<IItemStack>();
            for (var i = 0; i < slotNumber; i++) _inventory.Add(_itemStackFactory.CreatEmpty());
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            //
            var inventoryCopy = new List<IItemStack>(_inventory);
            //
            var result = InventoryInsertItem.InsertItem(itemStacks, inventoryCopy, _itemStackFactory);
            //0
            return result.Count == 0;
        }
        
        public int GetSlotSize()
        {
            return _inventory.Count;
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            return new(_inventory);
        }
        
        public IItemStack GetItem(int slot)
        {
            return _inventory[slot];
        }
        
        private void InvokeEvent(int slot)
        {
            _onInventoryUpdate(slot, _inventory[slot]);
        }
        
        #region Set
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            if (!_inventory[slot].Equals(itemStack))
            {
                _inventory[slot] = itemStack;
                InvokeEvent(slot);
            }
        }
        
        public void SetItemWithoutEvent(int slot, IItemStack itemStack)
        {
            _inventory[slot] = itemStack;
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            SetItem(slot, _itemStackFactory.Create(itemId, count));
        }
        
        #endregion
        
        
        #region Replace
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            //ID
            var item = _inventory[slot];
            if (item.Id == itemStack.Id)
            {
                var result = item.AddItem(itemStack);
                _inventory[slot] = result.ProcessResultItemStack;
                InvokeEvent(slot);
                return result.RemainderItemStack;
            }
            
            //
            _inventory[slot] = itemStack;
            InvokeEvent(slot);
            return item;
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            return ReplaceItem(slot, _itemStackFactory.Create(itemId, count));
        }
        
        #endregion
        
        
        #region Insert
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return InventoryInsertItem.InsertItem(itemStack, _inventory, _itemStackFactory, InvokeEvent);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            return InsertItem(_itemStackFactory.Create(itemId, count));
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return InventoryInsertItem.InsertItem(itemStacks, _inventory, _itemStackFactory, InvokeEvent);
        }
        
        /// <summary>
        ///     
        /// </summary>
        public IItemStack InsertItemWithPrioritySlot(IItemStack itemStack, int[] prioritySlots)
        {
            return InventoryInsertItem.InsertItemWithPrioritySlot(itemStack, _inventory, _itemStackFactory, prioritySlots, InvokeEvent);
        }
        
        public IItemStack InsertItemWithPrioritySlot(ItemId itemId, int count, int[] prioritySlots)
        {
            return InsertItemWithPrioritySlot(_itemStackFactory.Create(itemId, count), prioritySlots);
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/ConnectElectricSegmentTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using Game.EnergySystem;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    public class ConnectElectricSegmentTest
    {
        //ID
        private static readonly BlockId ElectricPoleId = ForUnitTestModBlockId.ElectricPoleId;
        private static readonly BlockId MachineId = ForUnitTestModBlockId.MachineId;
        private static readonly BlockId GenerateId = ForUnitTestModBlockId.GeneratorId;
        
        //
        [Test]
        public void PlaceElectricPoleToPlaceElectricPoleTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out var pole1);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(2, 0), BlockDirection.North, out var pole2);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(3, 0), BlockDirection.North, out var pole3);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(-3, 0), BlockDirection.North, out var pole4);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 3), BlockDirection.North, out var pole5);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, -3), BlockDirection.North, out var pole6);
            
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(7, 0), BlockDirection.North, out var pole7);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(-7, 0), BlockDirection.North, out var pole8);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 7), BlockDirection.North, out var pole9);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, -7), BlockDirection.North, out var pole10);
            
            IBlock[] poles =
            {
                pole1, pole2, pole3, pole4, pole5, pole6, pole7, pole8, pole9, pole10,
            };
            IBlock[] inRangePoles =
            {
                pole1,
                pole2,
                pole3,
                pole4,
                pole5,
                pole6,
            };
            IBlock[] outOfRangePoles =
            {
                pole7,
                pole8,
                pole9,
                pole10,
            };
            
            IWorldEnergySegmentDatastore<EnergySegment> worldElectricSegment = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            //
            Assert.AreEqual(5, worldElectricSegment.GetEnergySegmentListCount());
            
            var segment = worldElectricSegment.GetEnergySegment(0);
            //
            IReadOnlyDictionary<BlockInstanceId, IElectricTransformer> electricPoles = segment.EnergyTransformers;
            
            //
            //ID
            foreach (var pole in inRangePoles) Assert.AreEqual(true, electricPoles.ContainsKey(pole.BlockInstanceId));
            
            //ID
            foreach (var pole in outOfRangePoles) Assert.AreEqual(false, electricPoles.ContainsKey(pole.BlockInstanceId));
            
            //
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(5, 0), BlockDirection.North, out var pole11);
            //
            Assert.AreEqual(4, worldElectricSegment.GetEnergySegmentListCount());
            //
            segment = worldElectricSegment.GetEnergySegment(3);
            electricPoles = segment.EnergyTransformers;
            //
            Assert.AreEqual(8, electricPoles.Count);
            //ID
            Assert.AreEqual(true, electricPoles.ContainsKey(pole7.BlockInstanceId));
            Assert.AreEqual(true, electricPoles.ContainsKey(pole11.BlockInstanceId));
        }
        
        //
        [Test]
        public void PlaceElectricPoleToPlaceMachineTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out var originElectricPole);
            
            //
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(2, 0), BlockDirection.North, out var inRangeMachine0);
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(-2, 0), BlockDirection.North, out var inRangeMachine1);
            //
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, 2), BlockDirection.North, out var inRangeGenerator0);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -2), BlockDirection.North, out var inRangeGenerator1);
            
            //
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(3, 0), BlockDirection.North, out var outOfRangeMachine0);
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(-3, 0), BlockDirection.North, out var outOfRangeMachine1);
            //
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, 3), BlockDirection.North, out var outOfRangeGenerator0);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -3), BlockDirection.North, out var outOfRangeGenerator1);
            
            IWorldEnergySegmentDatastore<EnergySegment> segmentDatastore = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            //
            var segment = segmentDatastore.GetEnergySegment(0);
            //
            IReadOnlyDictionary<BlockInstanceId, IElectricConsumer> electricBlocks = segment.Consumers;
            IReadOnlyDictionary<BlockInstanceId, IElectricGenerator> powerGeneratorBlocks = segment.Generators;
            
            
            //
            Assert.AreEqual(2, electricBlocks.Count);
            Assert.AreEqual(2, powerGeneratorBlocks.Count);
            //ID
            Assert.AreEqual(true, electricBlocks.ContainsKey(inRangeMachine0.BlockInstanceId));
            Assert.AreEqual(true, electricBlocks.ContainsKey(inRangeMachine1.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(inRangeGenerator0.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(inRangeGenerator1.BlockInstanceId));
            
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(3, 1), BlockDirection.North, out var pole1);
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(1, 3), BlockDirection.North, out var pole2);
            
            segment = segmentDatastore.GetEnergySegment(0);
            electricBlocks = segment.Consumers;
            powerGeneratorBlocks = segment.Generators;
            //
            Assert.AreEqual(1, segmentDatastore.GetEnergySegmentListCount());
            Assert.AreEqual(3, electricBlocks.Count);
            Assert.AreEqual(3, powerGeneratorBlocks.Count);
            //ID
            Assert.AreEqual(true, electricBlocks.ContainsKey(outOfRangeMachine0.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(outOfRangeGenerator0.BlockInstanceId));
        }
        
        //
        [Test]
        public void PlaceMachineToPlaceElectricPoleTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            
            //
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(2, 0), BlockDirection.North, out var inRangeMachine0);
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(-2, 0), BlockDirection.North, out var inRangeMachine1);
            //
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, 2), BlockDirection.North, out var inRangeGenerator0);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -2), BlockDirection.North, out var inRangeGenerator1);
            
            //
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(3, 0), BlockDirection.North, out var outOfRangeMachine0);
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(-3, 0), BlockDirection.North, out var outOfRangeMachine1);
            //
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, 3), BlockDirection.North, out var outOfRangeGenerator0);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -3), BlockDirection.North, out var outOfRangeGenerator1);
            
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out var originPole);
            
            
            //
            var segment = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>()
                .GetEnergySegment(0);
            //
            IReadOnlyDictionary<BlockInstanceId, IElectricConsumer> electricBlocks = segment.Consumers;
            IReadOnlyDictionary<BlockInstanceId, IElectricGenerator> powerGeneratorBlocks = segment.Generators;
            
            
            //
            Assert.AreEqual(2, electricBlocks.Count);
            Assert.AreEqual(2, powerGeneratorBlocks.Count);
            //ID
            Assert.AreEqual(true, electricBlocks.ContainsKey(inRangeMachine0.BlockInstanceId));
            Assert.AreEqual(true, electricBlocks.ContainsKey(inRangeMachine1.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(inRangeGenerator0.BlockInstanceId));
            Assert.AreEqual(true, powerGeneratorBlocks.ContainsKey(inRangeGenerator1.BlockInstanceId));
        }
        
        //
        [Test]
        public void SegmentConnectionTest()
        {
            var (_, saveServiceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(0, 0), BlockDirection.North, out _);
            //
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(2, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(0, -2), BlockDirection.North, out _);
            
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(6, 0), BlockDirection.North, out _);
            //
            worldBlockDatastore.TryAddBlock(MachineId, new Vector3Int(7, 0), BlockDirection.North, out _);
            worldBlockDatastore.TryAddBlock(GenerateId, new Vector3Int(7, 1), BlockDirection.North, out _);
            
            IWorldEnergySegmentDatastore<EnergySegment> segmentDatastore = saveServiceProvider.GetService<IWorldEnergySegmentDatastore<EnergySegment>>();
            //
            Assert.AreEqual(2, segmentDatastore.GetEnergySegmentListCount());
            
            //
            worldBlockDatastore.TryAddBlock(ElectricPoleId, new Vector3Int(3, 0), BlockDirection.North, out _);
            //
            Assert.AreEqual(1, segmentDatastore.GetEnergySegmentListCount());
            //
            var segment = segmentDatastore.GetEnergySegment(0);
            //
            Assert.AreEqual(2, segment.Consumers.Count);
            Assert.AreEqual(2, segment.Generators.Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Editor/Inspector/PreviewOnlyObjectInspector.cs
```cs
using Client.Game.InGame.BlockSystem.PlaceSystem;
using UnityEditor;

[CustomEditor(typeof(PreviewOnlyObject))]
public class PreviewOnlyObjectInspector : Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        //TODO i18n
        
        EditorGUILayout.HelpBox("", MessageType.Info);
    }
}

```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryService/InventoryItemInsertService.cs
```cs
using System;
using Core.Inventory;

namespace Server.Protocol.PacketResponse.Util.InventoryService
{
    public static class InventoryItemInsertService
    {
        public static void Insert(IOpenableInventory fromInventory, int fromSlot, IOpenableInventory toInventory,
            int count)
        {
            var insertItemId = fromInventory.GetItem(fromSlot).Id;
            //insert
            var insertItemCount = Math.Min(fromInventory.GetItem(fromSlot).Count, count);
            
            var insertResult = toInventory.InsertItem(insertItemId, insertItemCount);
            
            //
            var returnItemCount = fromInventory.GetItem(fromSlot).Count - insertItemCount + insertResult.Count;
            
            fromInventory.SetItem(fromSlot, insertItemId, returnItemCount);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Inventory/InsertItemLogicTest.cs
```cs
using Core.Inventory;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Inventory
{
    /// <summary>
    ///     <see cref="InventoryInsertItem" /> 
    /// </summary>
    public class InsertItemLogicTest
    {
        [Test]
        public void InsertItemWithPrioritySlotTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var toInventory = new OpenableInventoryItemDataStoreService((_, _) => { }, itemStackFactory, 10);
            
            
            // 8,9
            var insertItem = itemStackFactory.Create(new ItemId(1), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //8
            Assert.AreEqual(insertItem, toInventory.GetItem(8));
            
            //ID29
            insertItem = itemStackFactory.Create(new ItemId(2), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //9
            Assert.AreEqual(insertItem, toInventory.GetItem(9));
            
            //ID38,90
            insertItem = itemStackFactory.Create(new ItemId(3), 10);
            toInventory.InsertItemWithPrioritySlot(insertItem, new[] { 8, 9 });
            //0
            Assert.AreEqual(insertItem, toInventory.GetItem(0));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockStateDetail.cs
```cs
namespace Game.Block.Interface.Component
{
    public interface IBlockStateDetail : IBlockComponent 
    {
        /// <summary>
        /// MessagePack
        /// TODO Convert.ChangeType
        /// The reason for returning a concrete class instead of an abstract class is that MessagePack conversions do not work with abstract classes.
        /// TODO It may be better to use Convert.ChangeType.
        /// </summary>
        /// <returns></returns>
        public BlockStateDetail GetBlockStateDetail();
    }
    
    public struct BlockStateDetail
    {
        public string Key { get; }
        public byte[] Value { get; }
        
        public BlockStateDetail(string key, byte[] value)
        {
            Key = key;
            Value = value;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CraftChainerMainComputerInventoryView.cs
```cs
using System.Collections.Generic;
using System.Threading;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using UnityEngine.UI;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class CraftChainerMainComputerInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform chestSlotsParent;
        
        [SerializeField] private Button requestButton;
        [SerializeField] private CraftChainerMainComputerSelectRequestItemModal selectRequestItemModal;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            selectRequestItemModal.Initialize();
            requestButton.onClick.AddListener(() => OnClickRequestButton().Forget());
            
            // 
            // Initialize item list
            InitializeItemList();
            
            #region Internal
            
            void InitializeItemList()
            {
                var itemList = new List<IItemStack>();
                var param = (CraftChainerMainComputerBlockParam)blockGameObject.BlockMasterElement.BlockParam;
                for (var i = 0; i < param.ItemSlotCount; i++)
                {
                    var slotObject = Instantiate(itemSlotObjectPrefab, chestSlotsParent);
                    _blockItemSlotObjects.Add(slotObject);
                    itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
                }
                UpdateItemList(itemList);
            }
            
  #endregion
        }
        
        private async UniTask OnClickRequestButton()
        {
            var (itemId, count) = await selectRequestItemModal.GetRequestItem();
            if (itemId == ItemMaster.EmptyItemId) return;
            
            var pos = _blockGameObject.BlockPosInfo.OriginalPos;
            ClientContext.VanillaApi.SendOnly.SetCraftChainerMainComputerRequestItem(pos, itemId, count);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/InventoryItemInsertServiceTest.cs
```cs
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util.InventoryService;
using Tests.Module.TestMod;

namespace Tests.CombinedTest.Game
{
    public class InventoryItemInsertServiceTest
    {
        /// <summary>
        ///     insert
        /// </summary>
        [Test]
        public void InsertTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).MainOpenableInventory;
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            
            //
            mainInventory.SetItem(PlayerInventoryConst.HotBarSlotToInventorySlot(0), new ItemId(1), 10);
            grabInventory.SetItem(0, new ItemId(1), 10);
            
            //id 1
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 5);
            
            Assert.AreEqual(15, mainInventory.GetItem(PlayerInventoryConst.HotBarSlotToInventorySlot(0)).Count);
            Assert.AreEqual(5, grabInventory.GetItem(0).Count);
        }
        
        
        /// <summary>
        ///     insert
        /// </summary>
        [Test]
        public void FullItemInsert()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var mainInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).MainOpenableInventory;
            var grabInventory = serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(0).GrabInventory;
            
            var id1MaxStack = MasterHolder.ItemMaster.GetItemMaster(new ItemId(1)).MaxStack;
            
            //
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++) mainInventory.SetItem(i, new ItemId(1), id1MaxStack);
            //
            grabInventory.SetItem(0, new ItemId(1), 10);
            
            //id 1
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 5);
            //
            Assert.AreEqual(10, grabInventory.GetItem(0).Count);
            
            
            //
            //5
            mainInventory.SetItem(0, new ItemId(1), id1MaxStack - 5);
            //id 1
            InventoryItemInsertService.Insert(grabInventory, 0, mainInventory, 10);
            //
            Assert.AreEqual(5, grabInventory.GetItem(0).Count);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ItemShooterSaveLoadTest.cs
```cs
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.ItemShooter;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ItemShooterSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var itemShooter = blockFactory.Create(ForUnitTestModBlockId.StraightItemShooter, new BlockInstanceId(1), posInfo);
            
            var shooter = itemShooter.GetComponent<ItemShooterComponent>();
            //_inventoryItems
            var inventoryItemsField = typeof(ItemShooterComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (ShooterInventoryItem[])inventoryItemsField.GetValue(shooter);
            
            //
            var item1Speed = 1.5f;
            var item2Speed = 2.2f;
            var item3Speed = 5f;
            var item1RemainingPercent = 0.5f;
            var item2RemainingPercent = 0.3f;
            var item3RemainingPercent = 0.0f;
            inventoryItems[0] = new ShooterInventoryItem(new ItemId(1), new ItemInstanceId(0), item1Speed);
            inventoryItems[0].RemainingPercent = item1RemainingPercent;
            inventoryItems[2] = new ShooterInventoryItem(new ItemId(2), new ItemInstanceId(0), item2Speed);
            inventoryItems[2].RemainingPercent = item2RemainingPercent;
            inventoryItems[3] = new ShooterInventoryItem(new ItemId(5), new ItemInstanceId(0), item3Speed);
            inventoryItems[3].RemainingPercent = item3RemainingPercent;
            
            
            //
            var str = shooter.GetSaveState();
            var states = new Dictionary<string, string>() { { shooter.SaveKey, str } };
            Debug.Log(str);
            
            //
            var newShooter = blockFactory.Load(itemShooter.BlockMasterElement.BlockGuid, new BlockInstanceId(0), states, posInfo).GetComponent<ItemShooterComponent>();
            var newInventoryItems = (ShooterInventoryItem[])inventoryItemsField.GetValue(newShooter);
            
            //
            Assert.AreEqual(inventoryItems.Length, newInventoryItems.Length);
            
            Assert.AreEqual(1, newInventoryItems[0].ItemId.AsPrimitive());
            Assert.AreEqual(item1Speed, newInventoryItems[0].CurrentSpeed);
            Assert.AreEqual(item1RemainingPercent, newInventoryItems[0].RemainingPercent);
            
            Assert.IsTrue(newInventoryItems[1] == null);
            
            Assert.AreEqual(2, newInventoryItems[2].ItemId.AsPrimitive());
            Assert.AreEqual(item2Speed, newInventoryItems[2].CurrentSpeed);
            Assert.AreEqual(item2RemainingPercent, newInventoryItems[2].RemainingPercent);
            
            Assert.AreEqual(5, newInventoryItems[3].ItemId.AsPrimitive());
            Assert.AreEqual(item3Speed, newInventoryItems[3].CurrentSpeed);
            Assert.AreEqual(item3RemainingPercent, newInventoryItems[3].RemainingPercent);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/CommonBlockInventoryViewBase.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Server.Protocol.PacketResponse.Util.InventoryMoveUtil;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    /// <summary>
    /// 
    /// <see cref="IBlockInventoryView"/>
    /// This is the class of the basic block with inventory. If you have a block that has a normal inventory, you can implement it by inheriting from this class.
    /// If you need to write dedicated processing to prevent class bloat, create a new class that implements <see cref="IBlockInventoryView"/>.
    /// </summary>
    public abstract class CommonBlockInventoryViewBase : MonoBehaviour, IBlockInventoryView
    {
        public IReadOnlyList<ItemSlotObject> SubInventorySlotObjects => _blockItemSlotObjects;
        public int Count => _blockItemSlotObjects.Count;
        protected readonly List<ItemSlotObject> _blockItemSlotObjects = new();
        public List<IItemStack> SubInventory { get; } = new();
        public ItemMoveInventoryInfo ItemMoveInventoryInfo { get; protected set; }
        
        public virtual void Initialize(BlockGameObject blockGameObject)
        {
            ItemMoveInventoryInfo = new ItemMoveInventoryInfo(ItemMoveInventoryType.BlockInventory, blockGameObject.BlockPosInfo.OriginalPos);
        }
        
        public void UpdateItemList(List<IItemStack> response)
        {
            SubInventory.Clear();
            SubInventory.AddRange(response);
        }
        public void UpdateInventorySlot(int slot, IItemStack item)
        {
            if (SubInventory.Count <= slot)
            {
                //TODO 
                Debug.LogError($"item:{item} slot:{slot}");
                return;
            }
            
            SubInventory[slot] = item;
        }
        public void DestroyUI()
        {
            Destroy(gameObject);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.PlayerInventory.Interface/PlayerInventoryConst.cs
```cs
using System;

namespace Game.PlayerInventory.Interface
{
    public static class PlayerInventoryConst
    {
        public const int MainInventoryColumns = 9;
        public const int MainInventoryRows = 5;
        public const int MainInventorySize = MainInventoryColumns * MainInventoryRows;
        
        /// <summary>
        ///     
        /// </summary>
        public static readonly int[] HotBarSlots =
        {
            HotBarSlotToInventorySlot(0),
            HotBarSlotToInventorySlot(1),
            HotBarSlotToInventorySlot(2),
            HotBarSlotToInventorySlot(3),
            HotBarSlotToInventorySlot(4),
            HotBarSlotToInventorySlot(5),
            HotBarSlotToInventorySlot(6),
            HotBarSlotToInventorySlot(7),
            HotBarSlotToInventorySlot(8),
        };
        
        
        /// <summary>
        ///     08ID
        /// </summary>
        /// <exception cref="Exception">08</exception>
        public static int HotBarSlotToInventorySlot(int slot)
        {
            if (slot < 0 || MainInventoryColumns <= slot)
                throw new Exception("08");
            //
            return (MainInventoryRows - 1) * MainInventoryColumns + slot;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/ProviderChest/CraftChainerProviderChestBlockInventoryInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.Context;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent.ProviderChest
{
    /// <summary>
    /// CraftChainerInsertItemCraftChainer
    /// InsertItemInsert
    ///
    /// Receive a request to supply an item to the CraftChainer network, and InsertItem will supply the matching item to the CraftChainer network.
    /// The InsertItem method is hit every frame from the chest, etc., so it does not explicitly call Insert.
    /// </summary>
    public class CraftChainerProviderChestBlockInventoryInserter : IBlockInventoryInserter
    {
        private readonly CraftChainerNodeId _providerChestNodeId;
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        public CraftChainerProviderChestBlockInventoryInserter(CraftChainerNodeId providerChestNodeId, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _providerChestNodeId = providerChestNodeId;
            _blockConnectorComponent = blockConnectorComponent;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var context = CraftChainerMainComputerManager.Instance.GetChainerNetworkContext(_providerChestNodeId);
            if (context == null)
            {
                return itemStack;
            }
            
            // 11
            // Insert items one by one and return them, so create an item for one item
            var oneItem = ServerContext.ItemStackFactory.Create(itemStack.Id, 1);
            
            var insertResult = context.InsertNodeNetworkNextBlock(oneItem, _providerChestNodeId, _blockConnectorComponent);
            
            // 1
            // To prevent the item from disappearing, return a composite of the item with one item subtracted and the inserted item
            var subOneItem = itemStack.SubItem(1);
            return insertResult.AddItem(subOneItem).ProcessResultItemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MasterJsonFileContainer.cs
```cs
using System.Collections.Generic;
using System.Linq;

namespace Core.Master
{
    public class MasterJsonFileContainer
    {        /// <summary>
        ///     
        ///     Key modId : Value ConfigJson
        /// </summary>
        public readonly Dictionary<string, string> BlockConfigs = new();
        
        /// <summary>
        ///     
        ///     Key modId : Value ConfigJson
        /// </summary>
        public readonly Dictionary<string, string> ItemConfigs = new();
        
        public readonly List<string> SortedChallengeConfigJsonList = new();
        
        public readonly List<string> SortedCraftRecipeConfigJsonList = new();
        
        public readonly List<string> SortedMachineRecipeConfigJsonList = new();
        
        public readonly List<string> SortedMapObjectConfigJsonList = new();
        public readonly List<string> SortedModIds;
        
        public readonly List<MasterJsonCpntens> ConfigJsons;
        
        public MasterJsonFileContainer(Dictionary<string, MasterJsonCpntens> configs)
        {
            ConfigJsons = configs.Values.ToList();
            
            var keys = configs.Keys.ToList();
            keys.Sort();
            SortedModIds = keys;
            
            foreach (var key in keys)
            {
                if (configs[key].ItemConfigJson != string.Empty) ItemConfigs.Add(key, configs[key].ItemConfigJson);
                if (configs[key].BlockConfigJson != string.Empty) BlockConfigs.Add(key, configs[key].BlockConfigJson);
                if (configs[key].CraftRecipeConfigJson != string.Empty) SortedCraftRecipeConfigJsonList.Add(configs[key].CraftRecipeConfigJson);
                if (configs[key].MachineRecipeConfigJson != string.Empty) SortedMachineRecipeConfigJsonList.Add(configs[key].MachineRecipeConfigJson);
                if (configs[key].MapObjectConfigJson != string.Empty) SortedMapObjectConfigJsonList.Add(configs[key].MapObjectConfigJson);
                if (configs[key].ChallengeConfigJson != string.Empty) SortedChallengeConfigJsonList.Add(configs[key].ChallengeConfigJson);
            }
        }
        
    }
}
```

moorestech_server/Assets/Scripts/Core.Const/AlphaMod.cs
```cs
using System;

namespace Core.Const
{
    public static class AlphaMod
    {
        [Obsolete("TODO Alpha2.0")] public const string ModId = "sakastudio:moorestechAlphaMod";
    }
}
```

moorestech_server/Assets/Scripts/Core.Item/Implementation/NullItemStack.cs
```cs
#nullable enable
using System;
using Core.Const;
using Core.Item.Interface;
using Core.Master;

namespace Core.Item.Implementation
{
    internal class NullItemStack : IItemStack
    {
        public ItemId Id => ItemMaster.EmptyItemId;
        public int Count => 0;
        public long ItemHash => 0;
        public ItemInstanceId ItemInstanceId { get; }
        
        public ItemProcessResult AddItem(IItemStack receiveItemStack)
        {
            //ID
            var tmpItem = InternalItemContext.ItemStackFactory.Create(receiveItemStack.Id, receiveItemStack.Count);
            var empty = InternalItemContext.ItemStackFactory.CreatEmpty();
            return new ItemProcessResult(tmpItem, empty);
        }
        
        public IItemStack SubItem(int subCount)
        {
            return this;
        }
        
        public bool IsAllowedToAdd(IItemStack item)
        {
            return true;
        }
        
        public bool IsAllowedToAddWithRemain(IItemStack item)
        {
            return true;
        }
        
        public ItemStackMetaData GetMeta(string key)
        {
            //TODO 
            throw new InvalidOperationException("");
        }
        
        public bool TryGetMeta(string key, out ItemStackMetaData value)
        {
            throw new InvalidOperationException("");
        }
        
        public IItemStack SetMeta(string key, ItemStackMetaData value)
        {
            throw new InvalidOperationException("");
        }
        
        public IItemStack Clone()
        {
            return InternalItemContext.ItemStackFactory.CreatEmpty();
        }
        
        public override bool Equals(object? obj)
        {
            if (typeof(NullItemStack) != obj?.GetType()) return false;
            return ((NullItemStack)obj).Id == Id && ((NullItemStack)obj).Count == Count;
        }
        
        protected bool Equals(NullItemStack other)
        {
            return ItemInstanceId == other.ItemInstanceId;
        }
        
        public override int GetHashCode()
        {
            return HashCode.Combine(ItemInstanceId);
        }
        
        public override string ToString()
        {
            return $"ID:{Id} Count:{Count}";
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/InventoryItemMoveServiceTest.cs
```cs
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util.InventoryService;
using Tests.Module.TestMod;

namespace Tests.CombinedTest.Game
{
    public class InventoryItemMoveServiceTest
    {
        [Test]
        public void MoveTest()
        {
            var playerId = 1;
            
            //----------------------------------------------------------
            
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            //
            var playerInventoryData =
                serviceProvider.GetService<IPlayerInventoryDataStore>().GetInventoryData(playerId);
            
            
            //
            var inventory = playerInventoryData.MainOpenableInventory;
            inventory.SetItem(0, itemStackFactory.Create(new ItemId(1), 5));
            inventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            inventory.SetItem(2, itemStackFactory.Create(new ItemId(2), 1));
            
            
            //
            //
            InventoryItemMoveService.Move(inventory,
                0, inventory, 3, 5);
            Assert.AreEqual(inventory.GetItem(0), itemStackFactory.CreatEmpty());
            Assert.AreEqual(inventory.GetItem(3), itemStackFactory.Create(new ItemId(1), 5));
            
            //
            InventoryItemMoveService.Move(inventory,
                3, inventory, 0, 3);
            Assert.AreEqual(inventory.GetItem(0), itemStackFactory.Create(new ItemId(1), 3));
            Assert.AreEqual(inventory.GetItem(3), itemStackFactory.Create(new ItemId(1), 2));
            
            //
            InventoryItemMoveService.Move(inventory,
                0, inventory, 2, 1);
            Assert.AreEqual(inventory.GetItem(0), itemStackFactory.Create(new ItemId(1), 3));
            Assert.AreEqual(inventory.GetItem(2), itemStackFactory.Create(new ItemId(2), 1));
            
            //
            InventoryItemMoveService.Move(inventory,
                0, inventory, 2, 3);
            Assert.AreEqual(inventory.GetItem(0), itemStackFactory.Create(new ItemId(2), 1));
            Assert.AreEqual(inventory.GetItem(2), itemStackFactory.Create(new ItemId(1), 3));
            
            //
            InventoryItemMoveService.Move(inventory,
                2, inventory, 1, 3);
            Assert.AreEqual(inventory.GetItem(2), itemStackFactory.CreatEmpty());
            Assert.AreEqual(inventory.GetItem(1), itemStackFactory.Create(new ItemId(1), 4));
            
            
            //
            InventoryItemMoveService.Move(inventory,
                1, inventory, 1, 4);
            Assert.AreEqual(inventory.GetItem(1), itemStackFactory.Create(new ItemId(1), 4));
        }
    }
}
```

schema/ref/blockConnectInfo.json
```cs
{
  "$id": "blockConnectInfo",

  "type": "array",
  "overrideCodeGeneratePropertyName": "blockConnectInfoElement",

  "items": {
    "type": "object",

    "properties": {

      "connectType": {
        "type": "string",
        "enum": ["Inventory", "Gear"],
        "description": "TODO "
      },

      "offset": {
        "type": "array",
        "pattern": "@vector3Int",
        "items": {
          "type": "integer"
        },
        "default": [
          0,
          0,
          0
        ]
      },

      "directions": {
        "type": "array",
        "optional": true,
        "items": {
          "type": "array",
          "pattern": "@vector3Int",
          "items": {
            "type": "integer"
          },
          "default": [
            0,
            0,
            0
          ]
        }
      },

      "connectOption": {
        "oneOf": [
          {
            "if": {
              "properties": {
                "connectType": { "const": "Inventory" }
              }
            },
            "then": {
              "type": "object",
              "optional": true,
              "properties": {
                "inventoryOptions" :{
                  "type": "array",
                  "optional": true,
                  
                  "items": {
                    "type": "object",
                    "properties": {
                      
                      "inventoryConnectOptionType": {
                        "type": "string",
                        "enum": ["CraftChainerCrafter"]
                      },
                      
                      "inventoryConnectOptionParam": {
                        "oneOf": [
                          {
                            "if": {
                              "properties": {
                                "inventoryConnectOptionType": { "const": "CraftChainerCrafter" }
                              }
                            },
                            "then": {
                              "type": "object",
                              "properties": {

                                "connectType": {
                                  "type": "string",
                                  "enum": ["Network", "Factory"]
                                }
                              }
                            }
                            
                          }
                        ]
                      }
                      
                    }
                  }
                  
                }
              }
            }
          },

          {
            "if": {
              "properties": {
                "connectType": { "const": "Gear" }
              }
            },
            "then": {
              "type": "object",
              "properties": {

                "isReverse": {
                  "type": "boolean",
                  "default": true
                }
              }
            }
          }

        ]
      }
    }
  }
}

```

moorestech_server/Assets/Scripts/Tests.Module/TestMod/ConfigOnly/mods/testConfigOnlyMod2/master/machineRecipe.json
```cs
testMachineRecipeJson1
```

moorestech_server/Assets/Scripts/Mod.Config/ModJsonStringLoader.cs
```cs
using System.Collections.Generic;
using System.IO;
using Core.Master;
using Mod.Loader;

namespace Mod.Config
{
    public class ModJsonStringLoader
    {
        //TODO 
        private const string ItemConfigPath = "config/item.json";
        private const string BlockConfigPath = "config/block.json";
        private const string MachineRecipeConfigPath = "config/machineRecipe.json";
        private const string CraftRecipeConfigPath = "config/craftRecipe.json";
        private const string MapObjectConfigPath = "config/mapObject.json";
        private const string ChallengeConfigPath = "config/challenge.json";
        
        public static Dictionary<string, MasterJsonCpntens> GetConfigString(ModsResource modResource)
        {
            // TODO 
            var configs = new List<MasterJsonCpntens>();
            
            //zipjson
            foreach (var mod in modResource.Mods)
            {
                var modId = new ModId(mod.Value.ModMetaJson.ModId);
                var extractedPath = mod.Value.ExtractedPath;
                
                // master/ json
                var masterJsonContents = new Dictionary<JsonFileName, string>();
                foreach (var masterJsonPath in Directory.GetFiles(extractedPath, "master/*.json"))
                {
                    var fileName = new JsonFileName(Path.GetFileNameWithoutExtension(masterJsonPath));
                    var jsonContents = File.ReadAllText(masterJsonPath);
                    masterJsonContents.Add(fileName, jsonContents);
                }
                configs.Add(new MasterJsonCpntens(modId,masterJsonContents));
            }
            
            //TODO return return configs;
            
            // -------------------------
            
            
            var configDict = new Dictionary<string, MasterJsonCpntens>();
            
            //zipjson
            foreach (var mod in modResource.Mods)
            {
                var modIdStr = mod.Value.ModMetaJson.ModId;
                var extractedPath = mod.Value.ExtractedPath;
                
                var itemConfigJson = LoadConfigFile(extractedPath, ItemConfigPath);
                var blockConfigJson = LoadConfigFile(extractedPath, BlockConfigPath);
                var machineRecipeConfigJson = LoadConfigFile(extractedPath, MachineRecipeConfigPath);
                var craftRecipeConfigJson = LoadConfigFile(extractedPath, CraftRecipeConfigPath);
                var mapObjectConfigJson = LoadConfigFile(extractedPath, MapObjectConfigPath);
                var challengeConfigJson = LoadConfigFile(extractedPath, ChallengeConfigPath);
                
                
                
                
                var modId = new ModId(mod.Value.ModMetaJson.ModId);
                
                // master/ json
                var masterJsonContents = new Dictionary<JsonFileName, string>();
                foreach (var masterJsonPath in Directory.GetFiles(extractedPath, "master/*.json"))
                {
                    var fileName = new JsonFileName(Path.GetFileNameWithoutExtension(masterJsonPath));
                    var jsonContents = File.ReadAllText(masterJsonPath);
                    masterJsonContents.Add(fileName, jsonContents);
                }
                configs.Add(new MasterJsonCpntens(modId,masterJsonContents));
                
                
                configDict.Add(modIdStr, new MasterJsonCpntens(itemConfigJson,
                    blockConfigJson,
                    machineRecipeConfigJson,
                    craftRecipeConfigJson,
                    mapObjectConfigJson,
                    challengeConfigJson,modId, masterJsonContents));
            }
            
            return configDict;
        }
        
        private static string LoadConfigFile(string extractedPath, string configPath)
        {
            var fullPath = Path.Combine(extractedPath, configPath);
            
            return !File.Exists(fullPath) ? string.Empty : File.ReadAllText(fullPath);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/RailGraph/PriorityQueue.cs
```cs
//Unity C#
//generated by Chat GPT 4o
using System;
using System.Collections.Generic;

namespace Game.Train.RailGraph 
{ 
    public class PriorityQueue<TElement, TPriority> where TPriority : IComparable<TPriority>
    {
        private List<(TElement Element, TPriority Priority)> _heap = new();

        public int Count => _heap.Count;

        public void Enqueue(TElement element, TPriority priority)
        {
            _heap.Add((element, priority));
            HeapifyUp(_heap.Count - 1);
        }

        public TElement Dequeue()
        {
            if (_heap.Count == 0)
            {
                throw new InvalidOperationException("The priority queue is empty.");
            }

            TElement element = _heap[0].Element;
            _heap[0] = _heap[^1]; // Move the last element to the root
            _heap.RemoveAt(_heap.Count - 1);
            if (_heap.Count > 0)
            {
                HeapifyDown(0);
            }
            return element;
        }

        public TElement Peek()
        {
            if (_heap.Count == 0)
            {
                throw new InvalidOperationException("The priority queue is empty.");
            }
            return _heap[0].Element;
        }

        private void HeapifyUp(int index)
        {
            while (index > 0)
            {
                int parentIndex = (index - 1) / 2;
                if (_heap[index].Priority.CompareTo(_heap[parentIndex].Priority) >= 0)
                {
                    break;
                }
                Swap(index, parentIndex);
                index = parentIndex;
            }
        }

        private void HeapifyDown(int index)
        {
            while (index < _heap.Count)
            {
                int leftChildIndex = 2 * index + 1;
                int rightChildIndex = 2 * index + 2;
                int smallestIndex = index;

                if (leftChildIndex < _heap.Count && _heap[leftChildIndex].Priority.CompareTo(_heap[smallestIndex].Priority) < 0)
                {
                    smallestIndex = leftChildIndex;
                }

                if (rightChildIndex < _heap.Count && _heap[rightChildIndex].Priority.CompareTo(_heap[smallestIndex].Priority) < 0)
                {
                    smallestIndex = rightChildIndex;
                }

                if (smallestIndex == index)
                {
                    break;
                }

                Swap(index, smallestIndex);
                index = smallestIndex;
            }
        }

        private void Swap(int indexA, int indexB)
        {
            (_heap[indexA], _heap[indexB]) = (_heap[indexB], _heap[indexA]);
        }
    }

}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearNetworkDatastore.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Update;
using Game.Block.Interface;
using UniRx;
using Random = System.Random;

namespace Game.Gear.Common
{
    public class GearNetworkDatastore
    {
        // TODO static
        private static GearNetworkDatastore _instance;
        
        private readonly Dictionary<BlockInstanceId, GearNetwork> _blockEntityToGearNetwork; // key EntityId value NW
        private readonly Dictionary<GearNetworkId, GearNetwork> _gearNetworks = new();
        private readonly Random _random = new(215180);
        
        public GearNetworkDatastore()
        {
            _instance = this;
            _blockEntityToGearNetwork = new Dictionary<BlockInstanceId, GearNetwork>();
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        public IReadOnlyDictionary<GearNetworkId, GearNetwork> GearNetworks => _gearNetworks;
        
        public static void AddGear(IGearEnergyTransformer gear)
        {
            _instance.AddGearInternal(gear);
        }
        
        private void AddGearInternal(IGearEnergyTransformer gear)
        {
            var connectedNetworkIds = new HashSet<GearNetworkId>();
            foreach (var connectedGear in gear.GetGearConnects())
                //NW
                if (_blockEntityToGearNetwork.ContainsKey(connectedGear.Transformer.BlockInstanceId))
                {
                    var networkId = _blockEntityToGearNetwork[connectedGear.Transformer.BlockInstanceId].NetworkId;
                    connectedNetworkIds.Add(networkId);
                }
            
            //NW1NW
            switch (connectedNetworkIds.Count)
            {
                case 0:
                    CreateNetwork();
                    break;
                case 1:
                    ConnectNetwork();
                    break;
                default:
                    MergeNetworks();
                    break;
            }
            
            #region Internal
            
            void CreateNetwork()
            {
                var networkId = GearNetworkId.CreateNetworkId();
                var network = new GearNetwork(networkId);
                network.AddGear(gear);
                _blockEntityToGearNetwork.Add(gear.BlockInstanceId, network);
                _gearNetworks.Add(networkId, network);
            }
            
            void ConnectNetwork()
            {
                var networkId = connectedNetworkIds.First();
                var network = _gearNetworks[networkId];
                network.AddGear(gear);
                _blockEntityToGearNetwork.Add(gear.BlockInstanceId, network);
            }
            
            void MergeNetworks()
            {
                // 
                var transformers = new List<IGearEnergyTransformer>();
                var generators = new List<IGearGenerator>();
                
                foreach (var networkId in connectedNetworkIds.ToList())
                {
                    var network = _gearNetworks[networkId];
                    transformers.AddRange(network.GearTransformers);
                    generators.AddRange(network.GearGenerators);
                    _gearNetworks.Remove(networkId);
                }
                
                var newNetworkId = GearNetworkId.CreateNetworkId();
                var newNetwork = new GearNetwork(newNetworkId);
                
                foreach (var transformer in transformers) newNetwork.AddGear(transformer);
                foreach (var generator in generators) newNetwork.AddGear(generator);
                
                transformers.Add(gear);
                newNetwork.AddGear(gear);
                _blockEntityToGearNetwork[gear.BlockInstanceId] = newNetwork;
                
                // NWNW
                for (var i = 0; i < _blockEntityToGearNetwork.Keys.Count; i++)
                {
                    var pair = _blockEntityToGearNetwork.ElementAt(i);
                    if (connectedNetworkIds.Contains(pair.Value.NetworkId)) _blockEntityToGearNetwork[pair.Key] = newNetwork;
                }
                
                _gearNetworks.Add(newNetworkId, newNetwork);
                foreach (var removeNetworkId in connectedNetworkIds) _gearNetworks.Remove(removeNetworkId);
            }
            
            #endregion
        }
        
        public static void RemoveGear(IGearEnergyTransformer gear)
        {
            // network
            var network = _instance._blockEntityToGearNetwork[gear.BlockInstanceId];
            network.RemoveGear(gear);
            _instance._blockEntityToGearNetwork.Remove(gear.BlockInstanceId);
            
            //
            var transformers = new List<IGearEnergyTransformer>();
            transformers.AddRange(network.GearTransformers);
            transformers.AddRange(network.GearGenerators);
            
            //
            _instance._gearNetworks.Remove(network.NetworkId);
            
            //geargearblockEntityToGearNetwork
            foreach (var transformer in transformers)
            {
                _instance._blockEntityToGearNetwork.Remove(transformer.BlockInstanceId);
            }
            
            // 
            foreach (var transformer in transformers) AddGear(transformer);
        }
        
        private void Update()
        {
            foreach (var gearNetwork in _gearNetworks.Values) // TODO 
                gearNetwork.ManualUpdate();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Player/PlayerObjectController.cs
```cs
using Client.Game.InGame.BlockSystem;
using Client.Network.API;
using StarterAssets;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.Player
{
    public interface IPlayerObjectController
    {
        public Vector3 Position { get; }
        public void SetPlayerPosition(Vector3 playerPos);
        public void SetActive(bool active);
        
        public void SetAnimationState(string state);
    }
    
    public class PlayerAnimationState
    {
        public const string IdleWalkRunBlend = "Idle Walk Run Blend";
        public const string JumpStart = "JumpStart";
        public const string JumpInAir = "JumpInAir";
        public const string JumpLand = "JumpLand";
        public const string Axe = "Axe";
    }
    
    public class PlayerObjectController : MonoBehaviour, IPlayerObjectController
    {
        public Vector3 Position => transform.position;
        public Vector2 Position2d => new(transform.position.x, transform.position.z);
        
        [SerializeField] private ThirdPersonController controller;
        [SerializeField] private Animator animator;
        
        [Inject]
        public void Construct(InitialHandshakeResponse initialHandshakeResponse)
        {
            controller.Initialize();
            SetPlayerPosition(initialHandshakeResponse.PlayerPos);
        }
        
        private void LateUpdate()
        {
            if (transform.localPosition.y < -10)
            {
                var height = SlopeBlockPlaceSystem.GetGroundPoint(transform.position).y;
                SetPlayerPosition(new Vector3(transform.localPosition.x, height, transform.localPosition.z));
            }
        }
        
        /// <summary>
        ///     ThirdPersonController.cs
        ///     ThirdPersonController.cs
        /// </summary>
        /// <param name="playerPos"></param>
        public void SetPlayerPosition(Vector3 playerPos)
        {
            controller.Warp(playerPos);
        }
        
        public void SetActive(bool active)
        {
            gameObject.SetActive(active);
        }
        
        public void SetAnimationState(string state)
        {
            animator.Play(state);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/InitialaizePipeline.cs
```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Define;
using Client.Mod.Texture;
using Client.Network;
using Client.Network.API;
using Client.Network.Settings;
using Core.Master;
using Cysharp.Threading.Tasks;
using Server.Boot;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using BlockObjectInfo = Client.Game.InGame.Context.BlockObjectInfo;
using Debug = UnityEngine.Debug;

namespace Client.Starter
{
    /// <summary>
    ///     
    ///     TODO 
    /// </summary>
    public class InitializeScenePipeline : MonoBehaviour
    {
        [SerializeField] private BlockIconImagePhotographer blockIconImagePhotographer;
        [SerializeField] private BlockGameObject missingBlockIdObject;
        
        [SerializeField] private TMP_Text loadingLog;
        [SerializeField] private Button backToMainMenuButton;
        
        private InitializeProprieties _proprieties;
        
        private void Awake()
        {
            backToMainMenuButton.onClick.AddListener(() => SceneManager.LoadScene(SceneConstant.MainMenuSceneName));
        }
        
        private void Start()
        {
            Initialize().Forget();
        }
        
        private async UniTask Initialize()
        {
            var loadingStopwatch = new Stopwatch();
            loadingStopwatch.Start();
            
            _proprieties ??= new InitializeProprieties(false, null, ServerConst.LocalServerIp, ServerConst.LocalServerPort, ServerConst.DefaultPlayerId);
            
            // DIServerContext
            new MoorestechServerDIContainerGenerator().Create(ServerConst.ServerDirectory);
            
            //Vanilla API
            var playerConnectionSetting = new PlayerConnectionSetting(_proprieties.PlayerId);
            VanillaApi vanillaApi = null;
            
            //
            BlockGameObjectContainer blockGameObjectContainer = null;
            ItemImageContainer itemImageContainer = null;
            AsyncOperation sceneLoadTask = null;
            InitialHandshakeResponse handshakeResponse = null;
            
            //
            try
            {
                await UniTask.WhenAll(CreateAndStartVanillaApi(), LoadBlockAndItemAssets(), MainGameSceneLoad());
            }
            catch (Exception e)
            {
                Debug.LogError($": {e.Message}\n{e.StackTrace}");
                // 
                SceneManager.LoadScene(SceneConstant.MainMenuSceneName);
                return;
            }
            
            //static
            var clientContext = new ClientContext(blockGameObjectContainer, itemImageContainer, playerConnectionSetting, vanillaApi);
            
            //
            SceneManager.sceneLoaded += MainGameSceneLoaded;
            sceneLoadTask.allowSceneActivation = true;
            
            
            #region Internal
            
            //
            void MainGameSceneLoaded(Scene scene, LoadSceneMode mode)
            {
                SceneManager.sceneLoaded -= MainGameSceneLoaded;
                var starter = FindObjectOfType<MainGameStarter>();
                var resolver = starter.StartGame(handshakeResponse);
                var diContainer = new DIContainer(resolver);
                clientContext.SetDIContainer(diContainer);
            }
            
            async UniTask CreateAndStartVanillaApi()
            {
                //
                var serverCommunicator = await ConnectionToServer();
                
                loadingLog.text += $"\n  {loadingStopwatch.Elapsed}";
                
                //
                var packetSender = new PacketSender(serverCommunicator);
                var exchangeManager = new PacketExchangeManager(packetSender);
                Task.Run(() => serverCommunicator.StartCommunicat(exchangeManager));
                
                //Vanilla API
                vanillaApi = new VanillaApi(exchangeManager, packetSender, serverCommunicator, playerConnectionSetting, _proprieties.LocalServerProcess);
                
                //
                handshakeResponse = await vanillaApi.Response.InitialHandShake(playerConnectionSetting.PlayerId, default);
                
                loadingLog.text += $"\n  {loadingStopwatch.Elapsed}";
            }
            
            async UniTask<ServerCommunicator> ConnectionToServer()
            {
                var serverConfig = new ConnectionServerConfig(_proprieties.ServerIp, _proprieties.ServerPort);
                try
                {
                    // 10
                    var serverCommunicator = await ServerCommunicator.CreateConnectedInstance(serverConfig)
                        .Timeout(TimeSpan.FromSeconds(10));
                    
                    Debug.Log("");
                    return serverCommunicator;
                }
                catch (TimeoutException)
                {
                    Debug.LogError("");
                    loadingLog.text += "\n";
                    await UniTask.Delay(2000);
                    SceneManager.LoadScene(SceneConstant.MainMenuSceneName);
                    throw; // 
                }
                catch (Exception e)
                {
                    Debug.LogError($": {e.Message}");
                    loadingLog.text += "\n";
                    await UniTask.Delay(2000);
                    SceneManager.LoadScene(SceneConstant.MainMenuSceneName);
                    throw;
                }
            }
            
            async UniTask LoadBlockAndItemAssets()
            {
                // 
                await UniTask.WhenAll(LoadBlockAssets(), LoadItemAssets());
                
                // 
                await TakeBlockItemImage();
            }
            
            async UniTask LoadBlockAssets()
            {
                // TODo 
                blockGameObjectContainer = await BlockGameObjectContainer.CreateAndLoadBlockGameObjectContainer(missingBlockIdObject);
                loadingLog.text += $"\n  {loadingStopwatch.Elapsed}";
            }
            
            async UniTask LoadItemAssets()
            {
                //
                //TODO 
                itemImageContainer = ItemImageContainer.CreateAndLoadItemImageContainer(ServerConst.ServerModsDirectory);
                loadingLog.text += $"\n  {loadingStopwatch.Elapsed}";
            }
            
            async UniTask TakeBlockItemImage()
            {
                // 
                // Collect the blocks that need to be screenshot.
                var takeBlockInfos = new List<BlockObjectInfo>();
                var itemIds = new List<ItemId>();
                foreach (var blockId in MasterHolder.BlockMaster.GetBlockIds())
                {
                    var itemId = MasterHolder.BlockMaster.GetItemId(blockId);
                    var itemViewData = itemImageContainer.GetItemView(itemId);
                    
                    if (itemViewData.ItemImage != null || !blockGameObjectContainer.BlockObjects.TryGetValue(blockId, out var blockObjectInfo)) continue;
                    
                    itemIds.Add(itemId);
                    takeBlockInfos.Add(blockObjectInfo);
                }
                
                // 
                // Set the icon.
                var texture2Ds = await blockIconImagePhotographer.TakeBlockIconImages(takeBlockInfos);
                for (var i = 0; i < itemIds.Count; i++)
                {
                    var itemViewData = new ItemViewData(texture2Ds[i], MasterHolder.ItemMaster.GetItemMaster(itemIds[i]));
                    itemImageContainer.AddItemView(itemIds[i], itemViewData);
                }
                
                loadingLog.text += $"\n  {loadingStopwatch.Elapsed}";
            }
            
            async UniTask MainGameSceneLoad()
            {
                sceneLoadTask = SceneManager.LoadSceneAsync(SceneConstant.MainGameSceneName, LoadSceneMode.Single);
                sceneLoadTask.allowSceneActivation = false;
                
                var sceneLoadCts = new CancellationTokenSource();
                
                try
                {
                    await sceneLoadTask.ToUniTask(Progress.Create<float>(
                            x =>
                            {
                                if (x < 0.9f) return;
                                sceneLoadCts.Cancel(); // allowSceneActivationfalse0.9f
                            })
                        , cancellationToken: sceneLoadCts.Token);
                }
                catch (OperationCanceledException)
                {
                    // 
                }
                
                loadingLog.text += $"\n  {loadingStopwatch.Elapsed}";
            }
            
            #endregion
        }
        
        
        public void SetProperty(InitializeProprieties proprieties)
        {
            _proprieties = proprieties;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Entity/ItemEntityObject.cs
```cs
using Client.Common.Server;
using UnityEngine;

namespace Client.Game.InGame.Entity
{
    public class ItemEntityObject : MonoBehaviour, IEntityObject
    {
        [SerializeField] private MeshRenderer meshRenderer;
        [SerializeField] private Material itemMaterial;
        private float _linerTime;
        private Vector3 _previousPosition;
        
        private Vector3 _targetPosition;
        
        private void Awake()
        {
            _targetPosition = transform.position;
            _previousPosition = transform.position;
        }
        
        //Liner
        private void Update()
        {
            //
            var rate = _linerTime / NetworkConst.UpdateIntervalSeconds;
            rate = Mathf.Clamp01(rate);
            transform.position = Vector3.Lerp(_previousPosition, _targetPosition, rate);
            _linerTime += Time.deltaTime;
        }
        
        public void SetDirectPosition(Vector3 position)
        {
            _targetPosition = position;
            _previousPosition = position;
            transform.position = position;
        }
        
        public void SetInterpolationPosition(Vector3 position)
        {
            _previousPosition = transform.position;
            _targetPosition = position;
            _linerTime = 0;
        }
        
        public void Destroy()
        {
            Destroy(gameObject);
        }
        
        public void SetTexture(Texture texture)
        {
            var material = new Material(itemMaterial) { mainTexture = texture };
            meshRenderer.material = material;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerComponent.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using Newtonsoft.Json;

namespace Game.CraftChainer.BlockComponent.Computer
{
    public class CraftChainerMainComputerComponent : ICraftChainerNode
    {
        public readonly CraftChainerNetworkContext CraftChainerNetworkContext;
        
        public CraftChainerNodeId NodeId { get; } = CraftChainerNodeId.Create();
        
        public CraftChainerMainComputerComponent(BlockConnectorComponent<IBlockInventory> mainComputerConnector)
        {
            CraftChainerNetworkContext = new CraftChainerNetworkContext(mainComputerConnector, this);
        }
        
        public CraftChainerMainComputerComponent(Dictionary<string, string> componentStates, BlockConnectorComponent<IBlockInventory> mainComputerConnector) : this(mainComputerConnector)
        {
            var state = componentStates[SaveKey];
            var jsonObject = JsonConvert.DeserializeObject<ChainerMainComputerComponentJsonObject>(state);
            NodeId = new CraftChainerNodeId(jsonObject.NodeId);
        }
        
        /// <summary>
        /// 
        /// Request to create an item
        /// </summary>
        /// <returns>
        /// 
        /// Whether the craft request was successful
        /// </returns>
        public bool StartCreateItem(ItemId itemId, int count)
        {
            var (recipes, initialInventory, targetItem) = CreateInitialData();
            
            var solverResult = CraftChainerCraftingSolver.Solve(recipes, initialInventory, targetItem);
            
            // 
            // The item could not be created
            if (solverResult == null)
            {
                return false;
            }
            
            CraftChainerNetworkContext.SetCraftChainRecipeQue(solverResult, targetItem);
            return true;
            
            #region Internal
            
            (List<CraftingSolverRecipe> recipes, Dictionary<ItemId, int> initialInventory, CraftingSolverItem targetItem) CreateInitialData()
            {
                var recipeResults = new List<CraftingSolverRecipe>();
                foreach (var crafterComponent in CraftChainerNetworkContext.CrafterComponents)
                {
                    recipeResults.Add(crafterComponent.CraftingSolverRecipe);
                }
                
                var initialInventoryResults = new Dictionary<ItemId, int>();
                foreach (var chest in CraftChainerNetworkContext.ProviderChests)
                {
                    foreach (var item in chest.Inventory)
                    {
                        if (initialInventoryResults.ContainsKey(item.Id))
                        {
                            initialInventoryResults[item.Id] += item.Count;
                        }
                        else
                        {
                            initialInventoryResults[item.Id] = item.Count;
                        }
                    }
                }
                
                var target = new CraftingSolverItem(itemId, count);
                
                return (recipeResults, initialInventoryResults, target);
            }
            
  #endregion
        }
        
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        public string SaveKey { get; } = typeof(CraftChainerMainComputerComponent).FullName;
        public string GetSaveState()
        {
            return JsonConvert.SerializeObject(new ChainerMainComputerComponentJsonObject(this));
        }
    }
    
    public class ChainerMainComputerComponentJsonObject
    {
        [JsonProperty("nodeId")] public int NodeId { get; set; }
        
        public ChainerMainComputerComponentJsonObject(){}
        public ChainerMainComputerComponentJsonObject(CraftChainerMainComputerComponent component)
        {
            NodeId = component.NodeId.AsPrimitive();
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Sub/CraftInventoryView.cs
```cs
using System;
using System.Collections.Generic;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Main;
using Core.Master;
using Game.CraftChainer.Util;
using Mooresmaster.Model.CraftRecipesModule;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Sub
{
    //TODO CraftITemView
    public class CraftInventoryView : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform craftMaterialParent;
        [SerializeField] private RectTransform craftResultParent;
        
        [SerializeField] private CraftButton craftButton;
        [SerializeField] private Button nextRecipeButton;
        [SerializeField] private Button prevRecipeButton;
        
        [SerializeField] private TMP_Text itemNameText;
        [SerializeField] private TMP_Text recipeCountText;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private readonly List<ItemSlotObject> _craftMaterialSlotList = new();
        private ItemSlotObject _craftResultSlot;
        private ILocalPlayerInventory _localPlayerInventory;
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        
        private int CraftRecipeCount => _currentItemRecipes.CraftRecipes.Count;
        private RecipeViewerItemRecipes _currentItemRecipes;
        private int _currentIndex;
        
        [Inject]
        public void Construct(ILocalPlayerInventory localPlayerInventory, ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;
            _localPlayerInventory = localPlayerInventory;
            _localPlayerInventory.OnItemChange.Subscribe(_ =>
            {
                if (_currentItemRecipes != null && _currentIndex < CraftRecipeCount)
                {
                    UpdateCraftButton(_currentItemRecipes.CraftRecipes[_currentIndex]);
                }
            });
            
            nextRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex++;
                if (CraftRecipeCount <= _currentIndex) _currentIndex = 0;
                DisplayRecipe(_currentIndex);
            });
            
            prevRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex--;
                if (_currentIndex < 0) _currentIndex = CraftRecipeCount - 1;
                DisplayRecipe(_currentIndex);
            });
            
            craftButton.OnCraftFinish.Subscribe(_ =>
            {
                if (_currentItemRecipes == null || CraftRecipeCount == 0)
                {
                    return;
                }
                
                var currentCraftGuid = _currentItemRecipes.CraftRecipes[_currentIndex].CraftRecipeGuid;
                ClientContext.VanillaApi.SendOnly.Craft(currentCraftGuid);
            }).AddTo(this);
        }
        
        private void UpdateCraftButton(CraftRecipeMasterElement craftRecipe)
        {
            craftButton.SetInteractable(IsCraftable(craftRecipe));
        }
        
        public void SetRecipes(RecipeViewerItemRecipes recipeViewerItemRecipes)
        {
            _currentItemRecipes = recipeViewerItemRecipes;
            _currentIndex = 0;
        }
        
        public void DisplayRecipe(int index)
        {
            var craftRecipe = _currentItemRecipes.CraftRecipes[index];
            
            ClearSlotObject();
            
            SetMaterialSlot();
            
            SetResultSlot();
            
            UpdateButtonAndText();
            
            #region InternalMethod
            
            void ClearSlotObject()
            {
                foreach (var materialSlot in _craftMaterialSlotList) Destroy(materialSlot.gameObject);
                _craftMaterialSlotList.Clear();
                if (_craftResultSlot != null) Destroy(_craftResultSlot.gameObject);
            }
            
            void SetMaterialSlot()
            {
                foreach (var requiredItem in craftRecipe.RequiredItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, craftMaterialParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _craftMaterialSlotList.Add(itemSlotObject);
                    
                    // 
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetResultSlot()
            {
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(craftRecipe.CraftResultItemGuid);
                _craftResultSlot = Instantiate(itemSlotObjectPrefab, craftResultParent);
                _craftResultSlot.SetItem(itemViewData, craftRecipe.CraftResultCount);
            }
            
            void UpdateButtonAndText()
            {
                prevRecipeButton.interactable = CraftRecipeCount != 1;
                nextRecipeButton.interactable = CraftRecipeCount != 1;
                recipeCountText.text = $"{_currentIndex + 1} / {CraftRecipeCount}";
                craftButton.SetCraftTime(craftRecipe.CraftTime);
                UpdateCraftButton(craftRecipe);
                
                var itemName = MasterHolder.ItemMaster.GetItemMaster(craftRecipe.CraftResultItemGuid).Name;
                itemNameText.text = itemName;
            }
            
            void OnClickMaterialItem(ItemSlotObject itemSlotObject)
            {
                var itemId = itemSlotObject.ItemViewData.ItemId;
                var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
                _onClickItem.OnNext(itemRecipes);
            }
            
            #endregion
        }
        
        /// <summary>
        ///     
        ///     1<see cref="IsAllItemCraftable" />
        /// </summary>
        private bool IsCraftable(CraftRecipeMasterElement craftRecipeMasterElement)
        {
            var itemPerCount = new Dictionary<ItemId, int>();
            foreach (var item in _localPlayerInventory)
            {
                if (item.Id == ItemMaster.EmptyItemId) continue;
                if (itemPerCount.ContainsKey(item.Id))
                    itemPerCount[item.Id] += item.Count;
                else
                    itemPerCount.Add(item.Id, item.Count);
            }
            
            foreach (var requiredItem in craftRecipeMasterElement.RequiredItems)
            {
                var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                
                if (!itemPerCount.ContainsKey(itemId)) return false;
                if (itemPerCount[itemId] < requiredItem.Count) return false;
            }
            
            return true;
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryMoveUtil/ItemMoveInventoryInfo.cs
```cs
using UnityEngine;

namespace Server.Protocol.PacketResponse.Util.InventoryMoveUtil
{
    public class ItemMoveInventoryInfo
    {
        public readonly ItemMoveInventoryType ItemMoveInventoryType;
        public readonly Vector3Int Pos; // TODO instance id
        
        /// <summary>
        ///     
        /// </summary>
        /// <param name="itemMoveInventoryType"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public ItemMoveInventoryInfo(ItemMoveInventoryType itemMoveInventoryType, Vector3Int blockPos = default)
        {
            ItemMoveInventoryType = itemMoveInventoryType;
            Pos = blockPos;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/UIState/PlayerInventoryState.cs
```cs
using System.Threading;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.Inventory.RecipeViewer;
using Client.Input;
using Client.Network.API;
using Cysharp.Threading.Tasks;
using Game.PlayerInventory.Interface;

namespace Client.Game.InGame.UI.UIState
{
    public class PlayerInventoryState : IUIState
    {
        private readonly RecipeViewerView _recipeViewerView;
        private readonly LocalPlayerInventoryController _localPlayerInventoryController;
        private readonly PlayerInventoryViewController _playerInventoryViewController;
        
        private CancellationTokenSource _cancellationTokenSource;
        
        public PlayerInventoryState(RecipeViewerView recipeViewerView,PlayerInventoryViewController playerInventoryViewController, LocalPlayerInventoryController localPlayerInventoryController, InitialHandshakeResponse handshakeResponse)
        {
            _recipeViewerView = recipeViewerView;
            _playerInventoryViewController = playerInventoryViewController;
            _localPlayerInventoryController = localPlayerInventoryController;
            
            _playerInventoryViewController.SetActive(false); //TODO 
            _recipeViewerView.SetActive(false);
            
            //
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var item = handshakeResponse.Inventory.MainInventory[i];
                _localPlayerInventoryController.SetMainItem(i, item);
            }
            
            _localPlayerInventoryController.SetGrabItem(handshakeResponse.Inventory.GrabItem);
        }
        
        public UIStateEnum GetNextUpdate()
        {
            if (InputManager.UI.CloseUI.GetKeyDown || InputManager.UI.OpenInventory.GetKeyDown) return UIStateEnum.GameScreen;
            
            return UIStateEnum.Current;
        }
        
        public void OnEnter(UIStateEnum lastStateEnum)
        {
            _recipeViewerView.SetActive(true);
            _playerInventoryViewController.SetActive(true);
            _playerInventoryViewController.SetSubInventory(new EmptySubInventory());
            
            _cancellationTokenSource = new CancellationTokenSource();
            UpdatePlayerInventory(_cancellationTokenSource.Token).Forget();
            
            InputManager.MouseCursorVisible(true);
        }
        
        public void OnExit()
        {
            _cancellationTokenSource.Cancel();
            _cancellationTokenSource = null;
            
            _recipeViewerView.SetActive(false);
            _playerInventoryViewController.SetActive(false);
        }
        
        /// <summary>
        ///     
        ///     
        /// </summary>
        private async UniTask UpdatePlayerInventory(CancellationToken ct)
        {
            var invResponse = await ClientContext.VanillaApi.Response.GetMyPlayerInventory(ct);
            
            for (var i = 0; i < PlayerInventoryConst.MainInventorySize; i++)
            {
                var item = invResponse.MainInventory[i];
                _localPlayerInventoryController.SetMainItem(i, item);
            }
            
            _localPlayerInventoryController.SetGrabItem(invResponse.GrabItem);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Item.Interface/IItemStack.cs
```cs
using Core.Master;

namespace Core.Item.Interface
{
    public interface IItemStack
    {
        ItemId Id { get; }
        int Count { get; }
        
        /// <summary>
        ///     ID
        ///     
        ///     ID
        /// </summary>
        ItemInstanceId ItemInstanceId { get; }
        
        ItemProcessResult AddItem(IItemStack receiveItemStack);
        IItemStack SubItem(int subCount);
        
        /// <summary>
        ///     true
        ///     falce
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        bool IsAllowedToAdd(IItemStack item);
        
        /// <summary>
        ///     true
        ///     true
        ///     IDfalse
        /// </summary>
        /// <returns>true</returns>
        bool IsAllowedToAddWithRemain(IItemStack item);
        
        //  modding
        // I added it for the time being, but left it alone because I have no use for it. I'm keeping it because I might use it for modding or something, but I don't support its operation.
        public ItemStackMetaData GetMeta(string key);
        public bool TryGetMeta(string key, out ItemStackMetaData value); 
        public IItemStack SetMeta(string key, ItemStackMetaData value);
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/InventoryService/InventoryItemMoveService.cs
```cs
using System;
using Core.Inventory;
using Game.Context;
using UnityEngine;

namespace Server.Protocol.PacketResponse.Util.InventoryService
{
    public static class InventoryItemMoveService
    {
        public static void Move(IOpenableInventory fromInventory, int fromSlot, IOpenableInventory toInventory, int toSlot, int itemCount)
        {
            try
            {
                ExecuteMove(fromInventory, fromSlot, toInventory, toSlot, itemCount);
            }
            catch (ArgumentOutOfRangeException e)
            {
                //TODO 
                var fromInventoryName = fromInventory.GetType().Name;
                var toInventoryName = toInventory.GetType().Name;
                Debug.Log(
                    $"InventoryItemMoveService.Move: \n {e.Message} \n fromInventory={fromInventoryName} fromSlot={fromSlot} toInventory={toInventoryName} toSlot={toSlot} itemCount={itemCount}  \n {e.StackTrace}");
            }
            catch (Exception e)
            {
                Debug.Log(e);
            }
        }
        
        private static void ExecuteMove(IOpenableInventory fromInventory, int fromSlot, IOpenableInventory toInventory, int toSlot, int itemCount)
        {
            //
            if (fromInventory.GetHashCode() == toInventory.GetHashCode() && fromSlot == toSlot) return;
            
            
            //
            var originItem = fromInventory.GetItem(fromSlot);
            //
            if (originItem.Count < itemCount) itemCount = originItem.Count;
            
            //
            var moveItem = ServerContext.ItemStackFactory.Create(originItem.Id, itemCount);
            
            var destinationInventoryItem = toInventory.GetItem(toSlot);
            
            //
            //ID
            if (destinationInventoryItem.Count == 0 || originItem.Id == destinationInventoryItem.Id)
            {
                //
                var replaceItem = toInventory.ReplaceItem(toSlot, moveItem);
                
                //
                //NullItem
                var playerItemCount = originItem.Count - itemCount;
                var addItem = ServerContext.ItemStackFactory.Create(originItem.Id, playerItemCount);
                var remainItem = replaceItem.AddItem(addItem).ProcessResultItemStack;
                
                //
                fromInventory.SetItem(fromSlot, remainItem);
            }
            //ID
            //
            else if (itemCount == originItem.Count)
            {
                toInventory.SetItem(toSlot, originItem);
                fromInventory.SetItem(fromSlot, destinationInventoryItem);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Other/ConnectingInventoryListPriorityInsertItemServiceTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks.Service;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Other
{
    public class ConnectingInventoryListPriorityInsertItemServiceTest
    {
        /// <summary>
        ///     
        /// </summary>
        [Test]
        public void Test()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var inventoryList = new List<IBlockInventory>();
            
            //112
            var inventory1 = new DummyBlockInventory(1, 1);
            var inventory2 = new DummyBlockInventory();
            var inventory3 = new DummyBlockInventory();
            inventoryList.Add(inventory1);
            inventoryList.Add(inventory2);
            inventoryList.Add(inventory3);
            
            var componentPos = new BlockPositionInfo(Vector3Int.zero, BlockDirection.North, Vector3Int.one);
            var inputConnectorComponent = new BlockConnectorComponent<IBlockInventory>(null, null, componentPos);
            
            var targets = (Dictionary<IBlockInventory, ConnectedInfo>)inputConnectorComponent.ConnectedTargets;
            
            foreach (var inventory in inventoryList) targets.Add(inventory, new ConnectedInfo());
            
            var service = new ConnectingInventoryListPriorityInsertItemService(inputConnectorComponent);
            
            service.InsertItem(itemStackFactory.Create(new ItemId(1), 4));
            service.InsertItem(itemStackFactory.Create(new ItemId(2), 3));
            service.InsertItem(itemStackFactory.Create(new ItemId(3), 2));
            service.InsertItem(itemStackFactory.Create(new ItemId(4), 1));
            
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 4), inventory1.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 3), inventory2.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), inventory3.InsertedItems[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(4), 1), inventory2.InsertedItems[1]);
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MasterHolder.cs
```cs
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class MasterHolder
    {
        public static ItemMaster ItemMaster { get; private set; }
        public static BlockMaster BlockMaster { get; private set; }
        public static ChallengeMaster ChallengeMaster { get; private set; }
        public static CraftRecipeMaster CraftRecipeMaster { get; private set; }
        public static MachineRecipesMaster MachineRecipesMaster { get; private set; }
        public static MapObjectMaster MapObjectMaster { get; private set; }
        
        public static void Load(MasterJsonFileContainer masterJsonFileContainer)
        {
            ItemMaster = new ItemMaster(GetJson(masterJsonFileContainer, new JsonFileName("items")));
            BlockMaster = new BlockMaster(GetJson(masterJsonFileContainer, new JsonFileName("blocks")), ItemMaster);
            ChallengeMaster = new ChallengeMaster(GetJson(masterJsonFileContainer, new JsonFileName("challenges")));
            
            CraftRecipeMaster = new CraftRecipeMaster(GetJson(masterJsonFileContainer, new JsonFileName("craftRecipes")));
            
            MachineRecipesMaster = new MachineRecipesMaster(GetJson(masterJsonFileContainer, new JsonFileName("machineRecipes")));
            MapObjectMaster = new MapObjectMaster(GetJson(masterJsonFileContainer, new JsonFileName("mapObjects")));
        }
        
        private static JToken GetJson(MasterJsonFileContainer masterJsonFileContainer, JsonFileName jsonFileName)
        {
            var index = 0; // TODO modjson
            var jsonContent = masterJsonFileContainer.ConfigJsons[index].JsonContents[jsonFileName];
            
            return (JToken)JsonConvert.DeserializeObject(jsonContent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Blocks/RailComponent.cs
```cs
using Game.Block.Interface.Component;
using Game.Train.RailGraph;

namespace Game.Train.Blocks
{
    /// <summary>
    /// 
    /// 
    /// </summary>
    public class RailComponent : IBlockComponent
    {
        // 
        public bool IsDestroy { get; private set; }

        // RailNode
        public RailNode FrontNode { get; private set; }
        public RailNode BackNode { get; private set; }

        // 
        public RailComponent(RailGraphDatastore railGraph)
        {
            // RailGraph
            FrontNode = new RailNode(railGraph);
            BackNode = new RailNode(railGraph);
            FrontNode.SetOppositeNode(BackNode);
            BackNode.SetOppositeNode(FrontNode);
        }

        /// <summary>
        /// 
        /// </summary>
        public void Destroy()
        {
            IsDestroy = true;
        }

    }
}

```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/PacketTest/RequestBlockInventoryTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using MessagePack;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Server.Protocol.PacketResponse.BlockInventoryRequestProtocol;

namespace Tests.CombinedTest.Server.PacketTest
{
    public class RequestBlockInventoryTest
    {
        private const int InputSlotNum = 2;
        private const int OutPutSlotNum = 3;
        
        //
        [Test]
        public void MachineInventoryRequest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(5, 10), BlockDirection.North, out var machineBlock);
            var machineComponent = machineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            machineComponent.SetItem(0, itemStackFactory.Create(new ItemId(1), 2));
            machineComponent.SetItem(2, itemStackFactory.Create(new ItemId(4), 5));
            
            //
            var data = MessagePackSerializer.Deserialize<BlockInventoryResponseProtocolMessagePack>(packet.GetPacketResponse(RequestBlock(new Vector3Int(5, 10)))[0].ToArray());
            
            Assert.AreEqual(InputSlotNum + OutPutSlotNum, data.Items.Length); // slot num
            
            
            Assert.AreEqual(ForUnitTestModBlockId.MachineId, data.BlockId); // block id
            
            Assert.AreEqual(1, data.Items[0].Id.AsPrimitive()); // item id
            Assert.AreEqual(2, data.Items[0].Count); // item count
            
            Assert.AreEqual(0, data.Items[1].Id.AsPrimitive());
            Assert.AreEqual(0, data.Items[1].Count);
            
            Assert.AreEqual(4, data.Items[2].Id.AsPrimitive());
            Assert.AreEqual(5, data.Items[2].Count);
        }
        
        private List<byte> RequestBlock(Vector3Int pos)
        {
            return MessagePackSerializer.Serialize(new RequestBlockInventoryRequestProtocolMessagePack(pos)).ToList();
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/PowerGenerator/VanillaElectricGeneratorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Core.Const;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Event;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json;

namespace Game.Block.Blocks.PowerGenerator
{
    public class VanillaElectricGeneratorComponent : IElectricGenerator, IBlockInventory, IOpenableInventory, IBlockSaveState, IUpdatableBlockComponent
    {
        private readonly BlockComponentManager _blockComponentManager = new();
        private readonly Dictionary<ItemId, FuelItemsElement> _fuelSettings;
        
        private readonly ElectricPower _infinityPower;
        private readonly bool _isInfinityPower;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        private ItemId _currentFuelItemId = ItemMaster.EmptyItemId;
        private double _remainingFuelTime;
        
        public VanillaElectricGeneratorComponent(VanillaPowerGeneratorProperties data)
        {
            BlockPositionInfo = data.BlockPositionInfo;
            BlockInstanceId = data.BlockInstanceId;
            _fuelSettings = data.FuelSettings;
            _isInfinityPower = data.IsInfinityPower;
            _infinityPower = data.InfinityPower;
            
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, data.FuelItemSlot);
            
            _blockComponentManager.AddComponent(data.InventoryInputConnectorComponent);
        }
        
        public VanillaElectricGeneratorComponent(Dictionary<string, string> componentStates, VanillaPowerGeneratorProperties data) : this(data)
        {
            var saveData = JsonConvert.DeserializeObject<VanillaElectricGeneratorSaveJsonObject>(componentStates[SaveKey]);
            
            var itemId = MasterHolder.ItemMaster.GetItemId(saveData.CurrentFuelItemGuid);
            _currentFuelItemId = itemId;
            _remainingFuelTime = saveData.RemainingFuelTime;
            
            for (var i = 0; i < saveData.Items.Count; i++)
            {
                _itemDataStoreService.SetItem(i, saveData.Items[i].ToItemStack());
            }
        }
        public BlockPositionInfo BlockPositionInfo { get; }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemStack);
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _itemDataStoreService.GetSlotSize();
        }
        
        public string SaveKey { get; } = typeof(VanillaElectricGeneratorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var itemGuid = MasterHolder.ItemMaster.GetItemMaster(_currentFuelItemId).ItemGuid;
            var saveData = new VanillaElectricGeneratorSaveJsonObject
            {
                CurrentFuelItemGuidStr = itemGuid.ToString(),
                RemainingFuelTime = _remainingFuelTime,
                Items = _itemDataStoreService.InventoryItems.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
            };
            
            return JsonConvert.SerializeObject(saveData);
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        
        public bool IsDestroy { get; private set; }
        
        public ElectricPower OutputEnergy()
        {
            BlockException.CheckDestroy(this);
            
            if (_isInfinityPower) return _infinityPower;
            if (_fuelSettings.TryGetValue(_currentFuelItemId, out var fuelSetting))
            {
                return (ElectricPower)fuelSetting.Power;
            }
            
            return new ElectricPower(0);
        }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        public IReadOnlyList<IItemStack> InventoryItems => _itemDataStoreService.InventoryItems;
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            return _itemDataStoreService.CreateCopiedItems();
        }
        
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.ReplaceItem(slot, itemId, count);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemId, count);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.InsertionCheck(itemStacks);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            _itemDataStoreService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _itemDataStoreService.ReplaceItem(slot, itemStack);
        }
        
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            //
            //Update
            if (_currentFuelItemId != ItemMaster.EmptyItemId)
            {
                _remainingFuelTime -= GameUpdater.UpdateSecondTime;
                
                //0NullItemId
                if (_remainingFuelTime <= 0) _currentFuelItemId = ItemMaster.EmptyItemId;
                
                return;
            }
            
            //
            //1
            for (var i = 0; i < _itemDataStoreService.GetSlotSize(); i++)
            {
                //
                var slotItemId = _itemDataStoreService.InventoryItems[i].Id;
                if (!_fuelSettings.ContainsKey(slotItemId)) continue;
                
                //ID
                _currentFuelItemId = MasterHolder.ItemMaster.GetItemId(_fuelSettings[slotItemId].ItemGuid);
                _remainingFuelTime = _fuelSettings[slotItemId].Time;
                
                //1
                _itemDataStoreService.SetItem(i, _itemDataStoreService.InventoryItems[i].SubItem(1));
                return;
            }
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            var blockInventoryUpdate = (BlockOpenableInventoryUpdateEvent)ServerContext.BlockOpenableInventoryUpdateEvent;
            var properties = new BlockOpenableInventoryUpdateEventProperties(BlockInstanceId, slot, itemStack);
            blockInventoryUpdate.OnInventoryUpdateInvoke(properties);
        }
    }
    
    public class VanillaElectricGeneratorSaveJsonObject
    {
        [JsonProperty("currentFuelItemGuid")]
        public string CurrentFuelItemGuidStr;
        [JsonIgnore] public Guid CurrentFuelItemGuid => Guid.Parse(CurrentFuelItemGuidStr);
        
        [JsonProperty("inventory")]
        public List<ItemStackSaveJsonObject> Items;
        
        [JsonProperty("remainingFuelTime")]
        public double RemainingFuelTime;
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/ChainerCrafterSaveLoadTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class ChainerCrafterSaveLoadTest
    {
        [Test]
        public void SaveLoadTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(new Vector3Int(0, 0, 0), BlockDirection.North, Vector3Int.one);

            // 
            // Create a Crafter block
            var crafterBlock = blockFactory.Create(ForUnitTestModBlockId.CraftChainerCrafter, new BlockInstanceId(1), posInfo);

            // 
            // Set the recipe
            var originalCrafter = crafterBlock.GetComponent<CraftCraftChainerCrafterComponent>();
            var inputItems = new List<CraftingSolverItem>
            {
                new(new ItemId(1), 10),
                new(new ItemId(2), 5)
            };

            var outputItems = new List<CraftingSolverItem>
            {
                new(new ItemId(3), 15)
            };

            originalCrafter.SetRecipe(inputItems, outputItems);
            
            // 
            // Get the save data
            var saveState = crafterBlock.GetSaveState();
            
            // 
            // Load the block
            var loadedBlock = blockFactory.Load( crafterBlock.BlockGuid, new BlockInstanceId(2), saveState, posInfo);
            var loadedCrafterComponent = loadedBlock.GetComponent<CraftCraftChainerCrafterComponent>();

            // ID
            // Check the node ID
            Assert.AreEqual(originalCrafter.NodeId, loadedCrafterComponent.NodeId);

            // 
            // Check the recipe settings
            Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs.Count, loadedCrafterComponent.CraftingSolverRecipe.Inputs.Count);
            Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs.Count, loadedCrafterComponent.CraftingSolverRecipe.Outputs.Count);

            for (int i = 0; i < originalCrafter.CraftingSolverRecipe.Inputs.Count; i++)
            {
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs[i].ItemId, loadedCrafterComponent.CraftingSolverRecipe.Inputs[i].ItemId);
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Inputs[i].Count, loadedCrafterComponent.CraftingSolverRecipe.Inputs[i].Count);
            }

            for (int i = 0; i < originalCrafter.CraftingSolverRecipe.Outputs.Count; i++)
            {
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs[i].ItemId, loadedCrafterComponent.CraftingSolverRecipe.Outputs[i].ItemId);
                Assert.AreEqual(originalCrafter.CraftingSolverRecipe.Outputs[i].Count, loadedCrafterComponent.CraftingSolverRecipe.Outputs[i].Count);
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/IElectricGenerator.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;

namespace Game.EnergySystem
{
    /// <summary>
    ///     
    /// </summary>
    public interface IElectricGenerator : IBlockComponent
    {
        public BlockInstanceId BlockInstanceId { get; }
        ElectricPower OutputEnergy();
    }
}
```

moorestech_client/Assets/Scripts/Client.Starter/MainGameStarter.cs
```cs
using System.Diagnostics;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.Control;
using Client.Game.InGame.Electric;
using Client.Game.InGame.Entity;
using Client.Game.InGame.Map.MapObject;
using Client.Game.InGame.Mining;
using Client.Game.InGame.Player;
using Client.Game.InGame.Presenter.Command;
using Client.Game.InGame.Presenter.PauseMenu;
using Client.Game.InGame.Presenter.Player;
using Client.Game.InGame.Tutorial;
using Client.Game.InGame.Tutorial.UIHighlight;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.Inventory.RecipeViewer;
using Client.Game.InGame.UI.Inventory.Sub;
using Client.Game.InGame.UI.UIState;
using Client.Game.InGame.UI.UIState.UIObject;
using Client.Game.InGame.World;
using Client.Game.Sequence;
using Client.Game.Skit;
using Client.Game.Skit.Starter;
using Client.Network.API;
using Game.CraftChainer.Util;
using UnityEngine;
using VContainer;
using VContainer.Unity;

namespace Client.Starter
{
    /// <summary>
    ///     
    ///     
    /// </summary>
    public class MainGameStarter : LifetimeScope
    {
        // Hierarchy
        //TODO region
        
        [Header("InHierarchy")] [SerializeField]
        private Camera mainCamera;
        
        [SerializeField] private BlockGameObjectDataStore blockGameObjectDataStore;
        [SerializeField] private MapObjectGameObjectDatastore mapObjectGameObjectDatastore;
        
        [SerializeField] private CommandUIInput commandUIInput;
        [SerializeField] private HotBarView hotBarView;
        [SerializeField] private PlayerObjectController playerObjectController;
        [SerializeField] private MapObjectMiningController mapObjectMiningController;
        
        [SerializeField] private EntityObjectDatastore entityObjectDatastore;
        
        [SerializeField] private UIStateControl uIStateControl;
        [SerializeField] private PauseMenuObject pauseMenuObject;
        [SerializeField] private DeleteBarObject deleteBarObject;
        [SerializeField] private PlayerInventoryViewController playerInventoryViewController;
        [SerializeField] private CraftInventoryView craftInventoryView;
        [SerializeField] private MachineRecipeView machineRecipeView;
        [SerializeField] private RecipeViewerView recipeViewerView;
        [SerializeField] private ItemListView itemListView;
        
        [SerializeField] private MapObjectPin mapObjectPin;
        [SerializeField] private UIHighlightTutorialManager uiHighlightTutorialManager;
        [SerializeField] private KeyControlTutorialManager keyControlTutorialManager;
        
        [SerializeField] private BlockPlacePreview blockPlacePreview;
        [SerializeField] private SaveButton saveButton;
        [SerializeField] private BackToMainMenu backToMainMenu;
        [SerializeField] private NetworkDisconnectPresenter networkDisconnectPresenter;
        [SerializeField] private ChallengeManager challengeManager;
        
        [SerializeField] private PlayerSkitStarterDetector playerSkitStarterDetector;
        [SerializeField] private SkitManager skitManager;
        
        [SerializeField] private DisplayEnergizedRange displayEnergizedRange;
        
        [SerializeField] private InGameCameraController inGameCameraController;
        
        
        private IObjectResolver _resolver;
        private string IPAddress = ServerConst.LocalServerIp;
        
        private bool isLocal;
        private Process localServerProcess;
        
        private int PlayerId = ServerConst.DefaultPlayerId;
        private int Port = ServerConst.LocalServerPort;
        
        protected override void OnDestroy()
        {
            _resolver?.Dispose();
        }
        
        public IObjectResolver StartGame(InitialHandshakeResponse initialHandshakeResponse)
        {
            var builder = new ContainerBuilder();
            
            //
            // register initial data
            builder.RegisterInstance(initialHandshakeResponse);
            
            //UI
            // register inventory UI control
            builder.Register<LocalPlayerInventoryController>(Lifetime.Singleton);
            builder.Register<ILocalPlayerInventory, LocalPlayerInventory>(Lifetime.Singleton);
            builder.RegisterEntryPoint<NetworkEventInventoryUpdater>();
            
            //
            // register presenter assembly
            builder.RegisterEntryPoint<CommonMachineBlockStateChangeProcessor>();
            builder.RegisterEntryPoint<WorldDataHandler>();
            builder.RegisterEntryPoint<PlayerPositionSender>();
            builder.RegisterEntryPoint<BlockStateEventHandler>();
            builder.RegisterEntryPoint<BlockPlaceSystem>().AsSelf();
            
            
            //UI
            // register UI control
            builder.Register<UIStateDictionary>(Lifetime.Singleton);
            builder.Register<BlockInventoryState>(Lifetime.Singleton);
            builder.Register<GameScreenState>(Lifetime.Singleton);
            builder.Register<PauseMenuState>(Lifetime.Singleton);
            builder.Register<PlayerInventoryState>(Lifetime.Singleton);
            builder.Register<DeleteBlockState>(Lifetime.Singleton);
            builder.Register<SkitState>(Lifetime.Singleton);
            builder.Register<PlaceBlockState>(Lifetime.Singleton);
            builder.Register<ItemRecipeViewerDataContainer>(Lifetime.Singleton);
            
            // 
            // register tutorial
            builder.Register<TutorialManager>(Lifetime.Singleton);
            
            //Hierarchycomponent
            // register component on hierarchy
            builder.RegisterComponent(blockGameObjectDataStore);
            builder.RegisterComponent(mapObjectGameObjectDatastore);
            
            builder.RegisterComponent(mainCamera);
            builder.RegisterComponent(commandUIInput);
            builder.RegisterComponent(hotBarView);
            
            builder.RegisterComponent(uIStateControl);
            builder.RegisterComponent(pauseMenuObject);
            builder.RegisterComponent(deleteBarObject);
            builder.RegisterComponent(saveButton);
            builder.RegisterComponent(backToMainMenu);
            builder.RegisterComponent(networkDisconnectPresenter);
            builder.RegisterComponent(mapObjectMiningController);
            
            builder.RegisterComponent(displayEnergizedRange);
            builder.RegisterComponent(entityObjectDatastore);
            builder.RegisterComponent(playerInventoryViewController);
            builder.RegisterComponent(challengeManager);
            builder.RegisterComponent(craftInventoryView);
            builder.RegisterComponent(machineRecipeView);
            builder.RegisterComponent(recipeViewerView);
            builder.RegisterComponent(itemListView);
            
            builder.RegisterComponent(mapObjectPin);
            builder.RegisterComponent(uiHighlightTutorialManager);
            builder.RegisterComponent(keyControlTutorialManager);
            
            builder.RegisterComponent(playerSkitStarterDetector);
            builder.RegisterComponent(skitManager);
            
            builder.RegisterComponent(inGameCameraController);
            
            builder.RegisterComponent<IPlayerObjectController>(playerObjectController).AsSelf();
            builder.RegisterComponent<IBlockPlacePreview>(blockPlacePreview);
            
            builder.RegisterBuildCallback(objectResolver => { });
            
            //
            // resolve dependency
            _resolver = builder.Build();
            _resolver.Resolve<BlockGameObjectDataStore>();
            _resolver.Resolve<CommandUIInput>();
            _resolver.Resolve<UIStateControl>();
            _resolver.Resolve<DisplayEnergizedRange>();
            _resolver.Resolve<EntityObjectDatastore>();
            _resolver.Resolve<ChallengeManager>();
            
            return _resolver;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Main/PlayerInventoryViewController.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using ClassLibrary;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Input;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using Game.PlayerInventory.Interface;
using UniRx;
using UnityEngine;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.Main
{
    /// <summary>
    ///     TODO 
    /// </summary>
    public class PlayerInventoryViewController : MonoBehaviour
    {
        [SerializeField] private GameObject mainInventoryObject;
        
        [SerializeField] private List<ItemSlotObject> mainInventorySlotObjects;
        [SerializeField] private ItemSlotObject grabInventorySlotObject;
        
        public Transform SubInventoryParent => subInventoryParent.transform;
        [SerializeField] private Transform subInventoryParent;
        
        //
        private readonly List<ItemSplitDragSlot> _itemSplitDraggedSlots = new();
        
        private readonly List<IDisposable> _subInventorySlotUIEventUnsubscriber = new();
        
        //Grab
        private IItemStack _grabInventoryBeforeDrag;
        private bool _isItemOneDragging;
        private bool _isItemSplitDragging;
        
        private LocalPlayerInventoryController _playerInventory;
        
        private ISubInventory _subInventory;
        
        private bool IsGrabItem => _playerInventory.GrabInventory.Id != ItemMaster.EmptyItemId;
        
        private void Awake()
        {
            foreach (var mainInventorySlotObject in mainInventorySlotObjects) mainInventorySlotObject.OnPointerEvent.Subscribe(ItemSlotUIEvent);
        }
        
        
        private void Update()
        {
            InventoryViewUpdate();
        }
        
        [Inject]
        public void Construct(LocalPlayerInventoryController playerInventory)
        {
            _playerInventory = playerInventory;
        }
        
        public void SetSubInventory(ISubInventory subInventory)
        {
            foreach (var disposable in _subInventorySlotUIEventUnsubscriber) disposable.Dispose();
            
            _subInventorySlotUIEventUnsubscriber.Clear();
            _subInventory = subInventory;
            _playerInventory.SetSubInventory(subInventory);
            foreach (var sub in _subInventory.SubInventorySlotObjects) _subInventorySlotUIEventUnsubscriber.Add(sub.OnPointerEvent.Subscribe(ItemSlotUIEvent));
        }
        
        private void ItemSlotUIEvent((ItemSlotObject slotObject, ItemUIEventType itemUIEvent) eventProperty)
        {
            var (slotObject, itemUIEvent) = eventProperty;
            var index = mainInventorySlotObjects.IndexOf(slotObject);
            if (index == -1)
                index = mainInventorySlotObjects.Count + _subInventory.SubInventorySlotObjects.IndexOf(slotObject);
            
            if (index == -1) throw new Exception("slot index not found");
            switch (itemUIEvent)
            {
                case ItemUIEventType.LeftClickDown:
                    LeftClickDown(index);
                    break;
                case ItemUIEventType.RightClickDown:
                    RightClickDown(index);
                    break;
                case ItemUIEventType.LeftClickUp:
                    LeftClickUp(index);
                    break;
                case ItemUIEventType.RightClickUp:
                    RightClickUp(index);
                    break;
                case ItemUIEventType.CursorEnter:
                    CursorEnter(index);
                    break;
                case ItemUIEventType.DoubleClick:
                    DoubleClick(index);
                    break;
                case ItemUIEventType.CursorExit: break;
                case ItemUIEventType.CursorMove: break;
                default: throw new ArgumentOutOfRangeException(nameof(itemUIEvent), itemUIEvent, null);
            }
        }
        
        
        private void DoubleClick(int slotIndex)
        {
            if (_isItemSplitDragging || _isItemOneDragging) return;
            
            
            IItemStack collectTargetItem;
            LocalMoveInventoryType fromType;
            int fromSlot;
            if (IsGrabItem)
            {
                collectTargetItem = _playerInventory.GrabInventory;
                fromType = LocalMoveInventoryType.Grab;
                fromSlot = 0;
            }
            else
            {
                collectTargetItem = _playerInventory.LocalPlayerInventory[slotIndex];
                fromType = LocalMoveInventoryType.MainOrSub;
                fromSlot = slotIndex;
            }
            
            var collectTargetSotIndex = _playerInventory.LocalPlayerInventory.Select((item, index) => new { item, index }).Where(i => i.item.Id == collectTargetItem.Id).OrderBy(i => i.item.Count).Select(i => i.index).ToList();
            
            //
            if (!IsGrabItem) collectTargetSotIndex.Remove(slotIndex);
            
            foreach (var index in collectTargetSotIndex)
            {
                var added = collectTargetItem.AddItem(_playerInventory.LocalPlayerInventory[index]);
                
                //
                var collectItemCount = _playerInventory.LocalPlayerInventory[index].Count - added.RemainderItemStack.Count;
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, index, fromType, fromSlot, collectItemCount);
                
                collectTargetItem = added.ProcessResultItemStack;
                
                //
                if (added.RemainderItemStack.Count != 0) break;
            }
        }
        
        private void CursorEnter(int slotIndex)
        {
            if (_isItemSplitDragging)
                SplitDraggingItem(slotIndex, false);
            else if (_isItemOneDragging)
                //
                PlaceOneItem(slotIndex);
        }
        
        private void RightClickUp(int slotIndex)
        {
            if (_isItemOneDragging) _isItemOneDragging = false;
        }
        
        private void LeftClickUp(int slotIndex)
        {
            //
            if (_isItemSplitDragging)
            {
                SplitDraggingItem(slotIndex, true);
                _itemSplitDraggedSlots.Clear();
                _isItemSplitDragging = false;
            }
        }
        
        
        private void RightClickDown(int slotIndex)
        {
            if (IsGrabItem)
            {
                //1
                PlaceOneItem(slotIndex);
                _isItemOneDragging = true;
            }
            else
            {
                //
                
                //
                var item = _playerInventory.LocalPlayerInventory[slotIndex];
                if (item.Id == ItemMaster.EmptyItemId) return;
                
                var halfItemCount = item.Count / 2;
                
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.Grab, 0, halfItemCount);
            }
        }
        
        private void LeftClickDown(int slotIndex)
        {
            if (IsGrabItem)
            {
                var isSlotEmpty = _playerInventory.LocalPlayerInventory[slotIndex].Id == ItemMaster.EmptyItemId;
                
                if (isSlotEmpty)
                {
                    //
                    _isItemSplitDragging = true;
                    _grabInventoryBeforeDrag = _playerInventory.GrabInventory;
                    SplitDraggingItem(slotIndex, false);
                }
                else
                {
                    _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, slotIndex, _playerInventory.GrabInventory.Count);
                }
                
                return;
            }
            
            if (InputManager.UI.ItemDirectMove.GetKey)
            {
                //
                DirectMove(slotIndex);
            }
            else
            {
                var slotItemCount = _playerInventory.LocalPlayerInventory[slotIndex].Count;
                //
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.Grab, 0, slotItemCount);
            }
        }
        
        
        private void PlaceOneItem(int slotIndex)
        {
            var oneItem = ServerContext.ItemStackFactory.Create(_playerInventory.GrabInventory.Id, 1);
            var currentItem = _playerInventory.LocalPlayerInventory[slotIndex];
            
            //
            if (!currentItem.IsAllowedToAdd(oneItem)) return;
            
            //
            _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, slotIndex, 1);
            
            //Grab
            if (_playerInventory.GrabInventory.Count == 0)
                _isItemOneDragging = false;
        }
        
        private void SplitDraggingItem(int slotIndex, bool isMoveSendData)
        {
            if (!_playerInventory.LocalPlayerInventory[slotIndex].IsAllowedToAddWithRemain(_playerInventory.GrabInventory)) return;
            
            // 
            var doNotDragging = !_itemSplitDraggedSlots.Exists(i => i.Slot == slotIndex);
            // 
            var isNotSlotOrSameItem = _playerInventory.LocalPlayerInventory[slotIndex].Id == ItemMaster.EmptyItemId || _playerInventory.LocalPlayerInventory[slotIndex].Id == _grabInventoryBeforeDrag.Id;
            
            //   
            if (doNotDragging && isNotSlotOrSameItem)
            {
                //
                _itemSplitDraggedSlots.Add(new ItemSplitDragSlot(slotIndex, _playerInventory.LocalPlayerInventory[slotIndex]));
            }
            
            //Grab
            _playerInventory.SetGrabItem(_grabInventoryBeforeDrag);
            foreach (var itemSplit in _itemSplitDraggedSlots) _playerInventory.SetMainItem(itemSplit.Slot, itemSplit.BeforeDragItem);
            
            //1
            var grabItem = _playerInventory.GrabInventory;
            var dragItemCount = grabItem.Count / _itemSplitDraggedSlots.Count;
            //
            var remainItemNum = grabItem.Count - dragItemCount * _itemSplitDraggedSlots.Count;
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            foreach (var dragSlot in _itemSplitDraggedSlots)
            {
                //
                var addedItem = dragSlot.BeforeDragItem.AddItem(itemStackFactory.Create(grabItem.Id, dragItemCount));
                var moveItemCount = addedItem.ProcessResultItemStack.Count - dragSlot.BeforeDragItem.Count;
                
                _playerInventory.MoveItem(LocalMoveInventoryType.Grab, 0, LocalMoveInventoryType.MainOrSub, dragSlot.Slot, moveItemCount, isMoveSendData);
                //
                remainItemNum += addedItem.RemainderItemStack.Count;
            }
            
            //Grab
            _playerInventory.SetGrabItem(itemStackFactory.Create(grabItem.Id, remainItemNum));
        }
        
        
        private void DirectMove(int slotIndex)
        {
            //
            var isMain = slotIndex < PlayerInventoryConst.MainInventorySize;
            
            var startIndex = isMain ? 0 : PlayerInventoryConst.MainInventorySize;
            var endIndex = isMain ? PlayerInventoryConst.MainInventorySize : PlayerInventoryConst.MainInventorySize + _subInventory.Count;
            for (var i = startIndex; i < endIndex; i++)
            {
                _playerInventory.MoveItem(LocalMoveInventoryType.MainOrSub, slotIndex, LocalMoveInventoryType.MainOrSub, i, _playerInventory.LocalPlayerInventory[slotIndex].Count);
                //
                if (_playerInventory.LocalPlayerInventory[slotIndex].Count == 0) break;
            }
        }
        
        public void SetActive(bool isActive)
        {
            mainInventoryObject.SetActive(isActive);
        }
        
        private void InventoryViewUpdate()
        {
            for (var i = 0; i < _playerInventory.LocalPlayerInventory.Count; i++)
            {
                var item = _playerInventory.LocalPlayerInventory[i];
                var itemView = ClientContext.ItemImageContainer.GetItemView(item.Id);
                
                if (i < mainInventorySlotObjects.Count)
                {
                    mainInventorySlotObjects[i].SetItem(itemView, item.Count);
                }
                else
                {
                    var subIndex = i - mainInventorySlotObjects.Count;
                    _subInventory.SubInventorySlotObjects[subIndex].SetItem(itemView, item.Count);
                }
            }
            
            grabInventorySlotObject.SetActive(IsGrabItem);
            var garbItemView = ClientContext.ItemImageContainer.GetItemView(_playerInventory.GrabInventory.Id);
            grabInventorySlotObject.SetItem(garbItemView, _playerInventory.GrabInventory.Count);
        }
    }
    
    public class ItemSplitDragSlot
    {
        public ItemSplitDragSlot(int slot, IItemStack beforeDragItem)
        {
            Slot = slot;
            BeforeDragItem = beforeDragItem;
        }
        
        public int Slot { get; }
        public IItemStack BeforeDragItem { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/CraftChain/CraftChainerCraftingSolver.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;

namespace Game.CraftChainer.CraftChain
{
    public static class CraftChainerCraftingSolver
    {
        public static Dictionary<CraftingSolverRecipeId, int> Solve(
            List<CraftingSolverRecipe> recipes,
            Dictionary<ItemId, int> initialInventory,
            CraftingSolverItem targetItem)
        {
            // Step 1: Build a mapping from items to the recipes that produce them
            // 1
            var itemsProducedByRecipe = BuildItemsProducedByRecipe(recipes);
            
            // Step 2: Initialize the initial state for BFS
            // 2BFS
            var initialState = InitializeState(initialInventory, targetItem.ItemId, targetItem.Count);
            
            // Step 3: Prepare BFS structures
            // 3BFS
            var (queue, visitedStates, bestState) = InitializeBFS(initialState);
            
            // Step 4: Perform BFS to find the optimal crafting solution
            // 4BFS
            while (queue.Count > 0)
            {
                // Dequeue the next state from the queue to explore
                // 
                var currentState = queue.Dequeue();
                
                // If the current state has already been visited, skip processing it
                // 
                if (IsStateVisited(currentState, visitedStates))
                    continue;
                
                // Mark the current state as visited to avoid revisiting it
                // 
                MarkStateAsVisited(currentState, visitedStates);
                
                // If the goal state is reached, update the best solution and continue
                // 
                if (IsGoalState(currentState))
                {
                    bestState = UpdateBestState(currentState, bestState);
                    continue;
                }
                
                // Find an item that is still needed; if none are found, continue
                // 
                var neededItem = FindNeededItem(currentState);
                if (neededItem == null)
                    continue;
                
                // Try to fulfill the needed item from existing inventory; if successful, continue
                // 
                if (TryFulfillNeedFromInventory(currentState, neededItem, queue))
                    continue;
                
                // Expand the current state by applying recipes to produce the needed item
                // 
                ExpandState(currentState, neededItem, itemsProducedByRecipe, queue);
            }

            
            // Step 5: Return the best solution found
            // 5
            return bestState?.RecipesUsed;
        }
        
        private static Dictionary<ItemId, List<CraftingSolverRecipe>> BuildItemsProducedByRecipe(List<CraftingSolverRecipe> recipes)
        {
            var itemsProduced = new Dictionary<ItemId, List<CraftingSolverRecipe>>();
            foreach (var recipe in recipes)
            {
                foreach (var output in recipe.Outputs)
                {
                    if (!itemsProduced.ContainsKey(output.ItemId))
                        itemsProduced[output.ItemId] = new List<CraftingSolverRecipe>();
                    itemsProduced[output.ItemId].Add(recipe);
                }
            }
            return itemsProduced;
        }
        
        private static CraftingSolverState InitializeState(Dictionary<ItemId, int> inventory, ItemId targetItem, int targetQty)
        {
            var state = new CraftingSolverState
            {
                Inventory = new Dictionary<ItemId, int>(inventory),
                RecipesUsed = new Dictionary<CraftingSolverRecipeId, int>(),
                MaterialUsed = 0
            };
            
            if (!state.Inventory.ContainsKey(targetItem))
                state.Inventory[targetItem] = 0;
            state.Inventory[targetItem] -= targetQty; // Negative quantity indicates a need
            
            return state;
        }
        
        private static (Queue<CraftingSolverState>, HashSet<string>, CraftingSolverState) InitializeBFS(CraftingSolverState initialState)
        {
            var queue = new Queue<CraftingSolverState>();
            queue.Enqueue(initialState);
            
            var visitedStates = new HashSet<string>();
            CraftingSolverState bestState = null;
            
            return (queue, visitedStates, bestState);
        }
        
        private static bool IsStateVisited(CraftingSolverState state, HashSet<string> visitedStates)
        {
            var key = GenerateStateKey(state);
            return visitedStates.Contains(key);
        }
        
        private static void MarkStateAsVisited(CraftingSolverState state, HashSet<string> visitedStates)
        {
            var key = GenerateStateKey(state);
            visitedStates.Add(key);
        }
        
        private static bool IsGoalState(CraftingSolverState state)
        {
            return state.Inventory.Values.All(quantity => quantity >= 0);
        }
        
        private static CraftingSolverState UpdateBestState(CraftingSolverState currentState, CraftingSolverState bestState)
        {
            if (bestState == null || currentState.MaterialUsed < bestState.MaterialUsed)
                return currentState;
            return bestState;
        }
        
        private static KeyValuePair<ItemId, int>? FindNeededItem(CraftingSolverState state)
        {
            foreach (var kvp in state.Inventory)
            {
                if (kvp.Value < 0)
                    return kvp;
            }
            return null;
        }
        
        private static bool TryFulfillNeedFromInventory(CraftingSolverState state, KeyValuePair<ItemId, int>? neededItem, Queue<CraftingSolverState> queue)
        {
            var itemId = neededItem.Value.Key;
            int quantityNeeded = -neededItem.Value.Value;
            
            if (state.Inventory.TryGetValue(itemId, out int available) && available > 0)
            {
                int used = Math.Min(available, quantityNeeded);
                var newState = CloneState(state);
                newState.Inventory[itemId] -= used; // Consume from inventory
                newState.Inventory[itemId] += quantityNeeded; // Fulfill the need
                queue.Enqueue(newState);
                return true;
            }
            return false;
        }
        
        private static void ExpandState(
            CraftingSolverState state,
            KeyValuePair<ItemId, int>? neededItem,
            Dictionary<ItemId, List<CraftingSolverRecipe>> itemsProducedByRecipe,
            Queue<CraftingSolverState> queue)
        {
            var itemId = neededItem.Value.Key;
            
            if (itemsProducedByRecipe.TryGetValue(itemId, out var producingRecipes))
            {
                var maxRunsList = producingRecipes.Select(_ => 10).ToList(); // Limit runs to prevent infinite loops
                
                var combinations = GenerateRecipeCombinations(producingRecipes, maxRunsList, state, itemId);
                
                foreach (var combination in combinations)
                {
                    var newState = ApplyRecipeCombination(state, producingRecipes, combination);
                    if (IsStateValid(newState))
                        queue.Enqueue(newState);
                }
            }
        }
        
    #region Internal
        
        private static List<int[]> GenerateRecipeCombinations(
            List<CraftingSolverRecipe> recipes,
            List<int> maxRunsList,
            CraftingSolverState state,
            ItemId itemId)
        {
            var combinations = new List<int[]>();
            int recipeCount = recipes.Count;
            int[] currentRuns = new int[recipeCount];
            
            void RecursiveGenerate(int index)
            {
                if (index == recipeCount)
                {
                    int totalProduced = state.Inventory.TryGetValue(itemId, out int existing) && existing > 0 ? existing : 0;
                    
                    for (int i = 0; i < recipeCount; i++)
                    {
                        var output = recipes[i].Outputs.FirstOrDefault(o => o.ItemId == itemId);
                        if (output != null)
                            totalProduced += currentRuns[i] * output.Count;
                    }
                    
                    if (totalProduced >= -state.Inventory[itemId])
                        combinations.Add((int[])currentRuns.Clone());
                    return;
                }
                
                for (int run = 0; run <= maxRunsList[index]; run++)
                {
                    currentRuns[index] = run;
                    RecursiveGenerate(index + 1);
                }
            }
            
            RecursiveGenerate(0);
            return combinations;
        }
        
        private static CraftingSolverState ApplyRecipeCombination(
            CraftingSolverState state,
            List<CraftingSolverRecipe> recipes,
            int[] combination)
        {
            var newState = CloneState(state);
            
            for (int i = 0; i < recipes.Count; i++)
            {
                int runs = combination[i];
                if (runs == 0) continue;
                
                var recipe = recipes[i];
                if (!newState.RecipesUsed.ContainsKey(recipe.CraftingSolverRecipeId))
                    newState.RecipesUsed[recipe.CraftingSolverRecipeId] = 0;
                newState.RecipesUsed[recipe.CraftingSolverRecipeId] += runs;
                
                foreach (var output in recipe.Outputs)
                {
                    int produced = output.Count * runs;
                    if (!newState.Inventory.ContainsKey(output.ItemId))
                        newState.Inventory[output.ItemId] = 0;
                    newState.Inventory[output.ItemId] += produced;
                }
                
                foreach (var input in recipe.Inputs)
                {
                    int required = input.Count * runs;
                    if (!newState.Inventory.ContainsKey(input.ItemId))
                        newState.Inventory[input.ItemId] = 0;
                    newState.Inventory[input.ItemId] -= required; // Negative indicates a need
                }
            }
            
            return newState;
        }
        
        private static bool IsStateValid(CraftingSolverState state)
        {
            return state.Inventory.Values.All(quantity => quantity >= -1000);
        }
        
        private static string GenerateStateKey(CraftingSolverState state)
        {
            var inventoryKey = string.Join(",", state.Inventory.OrderBy(kvp => kvp.Key).Select(kvp => $"{kvp.Key}:{kvp.Value}"));
            var recipesKey = string.Join(",", state.RecipesUsed.OrderBy(kvp => kvp.Key).Select(kvp => $"{kvp.Key}:{kvp.Value}"));
            return $"{inventoryKey}|{recipesKey}|{state.MaterialUsed}";
        }
        
        private static CraftingSolverState CloneState(CraftingSolverState state)
        {
            return new CraftingSolverState
            {
                Inventory = new Dictionary<ItemId, int>(state.Inventory),
                RecipesUsed = new Dictionary<CraftingSolverRecipeId, int>(state.RecipesUsed),
                MaterialUsed = state.MaterialUsed
            };
        }
        
    #endregion
    }
    
    public class CraftingSolverState
    {
        public int MaterialUsed;
        public Dictionary<ItemId, int> Inventory; // Negative values indicate needs
        public Dictionary<CraftingSolverRecipeId, int> RecipesUsed;
    }
}
```

moorestech_client/Assets/Scripts/Client.DebugSystem/DebugSheet/ItemGetDebugSheet.cs
```cs
using System.Collections;
using Client.Game.InGame.Context;
using Core.Master;
using UnityDebugSheet.Runtime.Core.Scripts;

namespace Client.DebugSystem
{
    public class ItemGetDebugSheet : DefaultDebugPageBase
    {
        protected override string Title => "Get Item";
        
        public override IEnumerator Initialize()
        {
            var itemIds = MasterHolder.ItemMaster.GetItemAllIds();
            foreach (var itemId in itemIds)
            {
                var itemElement = MasterHolder.ItemMaster.GetItemMaster(itemId);
                //TODO: ItemImageContainer.GetItemViewItemId
                var itemImage = ClientContext.ItemImageContainer.GetItemView(itemId); 
                var subText = $"Count:{itemElement.MaxStack}";
                
                AddButton(itemImage.ItemName, subText, icon: itemImage.ItemImage, clicked: () =>
                {
                    var playerId = ClientContext.PlayerConnectionSetting.PlayerId;
                    var command = $"give {playerId} {itemId} {itemElement.MaxStack}";
                    ClientContext.VanillaApi.SendOnly.SendCommand(command);
                });
            }
            
            yield break;
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/RecipeViewer/MachineRecipeView.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Context;
using Client.Game.InGame.UI.Inventory.Element;
using Client.Game.InGame.UI.Inventory.Sub;
using Core.Master;
using Game.CraftChainer.Util;
using TMPro;
using UniRx;
using UnityEngine;
using UnityEngine.UI;
using VContainer;

namespace Client.Game.InGame.UI.Inventory.RecipeViewer
{
    public class MachineRecipeView : MonoBehaviour
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform inputParent;
        [SerializeField] private RectTransform outputParent;
        
        [SerializeField] private Button nextRecipeButton;
        [SerializeField] private Button prevRecipeButton;
        
        [SerializeField] private TMP_Text itemNameText;
        [SerializeField] private TMP_Text recipeCountText;
        [SerializeField] private ItemSlotObject machineObject;
        
        public IObservable<RecipeViewerItemRecipes> OnClickItem => _onClickItem;
        private readonly Subject<RecipeViewerItemRecipes> _onClickItem = new();
        
        private readonly List<ItemSlotObject> _inputSlotList = new();
        private readonly List<ItemSlotObject> _outputSlotList = new();
        private ItemRecipeViewerDataContainer _itemRecipeViewerDataContainer;
        
        private int MachineRecipeCount => _currentItemRecipes.MachineRecipes[_currentBlockId].Count;
        private RecipeViewerItemRecipes _currentItemRecipes;
        private BlockId _currentBlockId;
        private int _currentIndex;
        

        [Inject]
        public void Construct(ItemRecipeViewerDataContainer itemRecipeViewerDataContainer)
        {
            machineObject.SetFrame(ItemSlotFrameType.MachineSlot);
            machineObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
            _itemRecipeViewerDataContainer = itemRecipeViewerDataContainer;

            
            nextRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex++;
                if (MachineRecipeCount <= _currentIndex) _currentIndex = 0;
                DisplayRecipe(_currentIndex);
            });
            
            prevRecipeButton.onClick.AddListener(() =>
            {
                _currentIndex--;
                if (_currentIndex < 0) _currentIndex = MachineRecipeCount - 1;
                DisplayRecipe(_currentIndex);
            });
        }
        
        public void SetRecipes(RecipeViewerItemRecipes recipeViewerItemRecipes)
        {
            _currentItemRecipes = recipeViewerItemRecipes;
            _currentIndex = 0;
            if (recipeViewerItemRecipes.MachineRecipes.Count != 0)
            {
                _currentBlockId = recipeViewerItemRecipes.MachineRecipes.First().Key;
            }
        }
        
        public void SetBlockId(BlockId blockId)
        {
            _currentBlockId = blockId;
            _currentIndex = 0;
            DisplayRecipe(_currentIndex);
        }
        
        public void DisplayRecipe(int index)
        {
            var machineRecipes = _currentItemRecipes.MachineRecipes[_currentBlockId][index];
            
            ClearSlotObject();
            
            SetInputSlot();
            SetOutputSlot();
            SetMachineSlot();
            
            UpdateButtonAndText();
            
            #region InternalMethod
            
            void ClearSlotObject()
            {
                foreach (var materialSlot in _inputSlotList) Destroy(materialSlot.gameObject);
                _inputSlotList.Clear();
                foreach (var resultSlot in _outputSlotList) Destroy(resultSlot.gameObject);
                _outputSlotList.Clear();
            }
            
            void SetInputSlot()
            {
                foreach (var requiredItem in machineRecipes.InputItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, inputParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _inputSlotList.Add(itemSlotObject);
                    
                    // 
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetOutputSlot()
            {
                foreach (var requiredItem in machineRecipes.OutputItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(requiredItem.ItemGuid);
                    var itemViewData = ClientContext.ItemImageContainer.GetItemView(itemId);
                    
                    var itemSlotObject = Instantiate(itemSlotObjectPrefab, outputParent);
                    itemSlotObject.SetItem(itemViewData, requiredItem.Count);
                    _outputSlotList.Add(itemSlotObject);
                    
                    // 
                    itemSlotObject.OnLeftClickUp.Subscribe(OnClickMaterialItem);
                }
            }
            
            void SetMachineSlot()
            {
                var blockItemId = MasterHolder.BlockMaster.GetItemId(_currentBlockId);
                var itemViewData = ClientContext.ItemImageContainer.GetItemView(blockItemId);
                machineObject.SetItem(itemViewData, 0);
            }
            
            void UpdateButtonAndText()
            {
                prevRecipeButton.interactable = MachineRecipeCount != 1;
                nextRecipeButton.interactable = MachineRecipeCount != 1;
                recipeCountText.text = $"{_currentIndex + 1} / {MachineRecipeCount}";
                
                var itemName = MasterHolder.ItemMaster.GetItemMaster(_currentItemRecipes.ResultItemId).Name;
                itemNameText.text = itemName;
            }
            
            #endregion
        }
        
        private void OnClickMaterialItem(ItemSlotObject itemSlotObject)
        {
            var itemId = itemSlotObject.ItemViewData.ItemId;
            var itemRecipes = _itemRecipeViewerDataContainer.GetItem(itemId);
            _onClickItem.OnNext(itemRecipes);
        }
        
        public void SetActive(bool isActive)
        {
            gameObject.SetActive(isActive);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/PowerGeneratorSaveLoadTest.cs
```cs
using System.Collections.Generic;
using System.Reflection;
using Core.Inventory;
using Core.Master;
using Game.Block.Blocks.PowerGenerator;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class PowerGeneratorSaveLoadTest
    {
        
        [Test]
        public void PowerGeneratorTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var fuelSlotCount = (MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GeneratorId).BlockParam as ElectricGeneratorBlockParam).FuelItemSlotCount;
            var generatorPosInfo = new BlockPositionInfo(Vector3Int.zero, BlockDirection.North, Vector3Int.one);
            var powerGeneratorBlock = blockFactory.Create(ForUnitTestModBlockId.GeneratorId, new BlockInstanceId(10), generatorPosInfo);
            var powerGenerator = powerGeneratorBlock.GetComponent<VanillaElectricGeneratorComponent>();
            
             var fuelItemId = new ItemId(5);
            const int remainingFuelTime = 567;
            
            //
            var type = typeof(VanillaElectricGeneratorComponent);
            type.GetField("_currentFuelItemId", BindingFlags.NonPublic | BindingFlags.Instance)
                .SetValue(powerGenerator, fuelItemId);
            type.GetField("_remainingFuelTime", BindingFlags.NonPublic | BindingFlags.Instance)
                .SetValue(powerGenerator, remainingFuelTime);
            var fuelItemStacks = (OpenableInventoryItemDataStoreService)type
                .GetField("_itemDataStoreService", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(powerGenerator);
            fuelItemStacks.SetItem(0, itemStackFactory.Create(new ItemId(1), 5));
            fuelItemStacks.SetItem(2, itemStackFactory.Create(new ItemId(3), 5));
            
            
            //
            var saveText = powerGenerator.GetSaveState();
            var states = new Dictionary<string, string>() { { powerGenerator.SaveKey, saveText } };
            Debug.Log(saveText);
            
            
            var blockGuid = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GeneratorId).BlockGuid;
            //
            var loadedPowerGeneratorBlock = blockFactory.Load(blockGuid, new BlockInstanceId(10), states, generatorPosInfo);
            var loadedPowerGenerator = loadedPowerGeneratorBlock.GetComponent<VanillaElectricGeneratorComponent>();
            //
            var loadedFuelItemId = (ItemId)type.GetField("_currentFuelItemId", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadedPowerGenerator);
            Assert.AreEqual(fuelItemId, loadedFuelItemId);
            
            var loadedRemainingFuelTime = (double)type
                .GetField("_remainingFuelTime", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadedPowerGenerator);
            Assert.AreEqual(remainingFuelTime, loadedRemainingFuelTime);
            
            var loadedFuelItemStacks = (OpenableInventoryItemDataStoreService)type
                .GetField("_itemDataStoreService", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadedPowerGenerator);
            
            //
            Assert.AreEqual(fuelItemStacks.GetSlotSize(), loadedFuelItemStacks.GetSlotSize());
            for (var i = 0; i < fuelSlotCount; i++)
                Assert.AreEqual(fuelItemStacks.InventoryItems[i], loadedFuelItemStacks.InventoryItems[i]);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Context/BlockGameObjectContainer.cs
```cs
using System.Collections.Generic;
using Client.Common.Asset;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem;
using Client.Game.InGame.BlockSystem.PlaceSystem;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Core.Master;
using Cysharp.Threading.Tasks;
using Game.Block.Interface;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;


namespace Client.Game.InGame.Context
{
    /// <summary>
    ///     UnityGameObject
    ///     
    /// </summary>
    public class BlockGameObjectContainer
    {
        public IReadOnlyDictionary<BlockId, BlockObjectInfo> BlockObjects => _blockObjects;
        private readonly Dictionary<BlockId, BlockObjectInfo> _blockObjects;
        private readonly BlockGameObject _missingBlockIdObject;
        
        public BlockGameObjectContainer(BlockGameObject missingBlockIdObject, Dictionary<BlockId, BlockObjectInfo> blockObjects)
        {
            _missingBlockIdObject = missingBlockIdObject;
            _blockObjects = blockObjects;
        }
        
        public static async UniTask<BlockGameObjectContainer> CreateAndLoadBlockGameObjectContainer(BlockGameObject missingBlockIdObject)
        {
            var blocks = new Dictionary<BlockId, BlockObjectInfo>();
            var tasks = new List<UniTask<BlockObjectInfo>>();
            foreach (var blockId in MasterHolder.BlockMaster.GetBlockIds())
            {
                tasks.Add(LoadBlockGameObject(blockId));
            }
            
            var results = await UniTask.WhenAll(tasks);
            foreach (var result in results)
            {
                if (result == null) continue;
                blocks.Add(result.BlockId, result);
            }
            
            return new BlockGameObjectContainer(missingBlockIdObject, blocks);
        }
        
        private static async UniTask<BlockObjectInfo> LoadBlockGameObject(BlockId blockId)
        {
            var masterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            if (masterElement.BlockPrefabAddressablesPath == null)
            {
                Debug.LogWarning($" Name:{masterElement.Name} GUID:{masterElement.BlockGuid}");
                return null;
            }
            
            var blockAsset = await AddressableLoader.LoadAsync<GameObject>(masterElement.BlockPrefabAddressablesPath);
            if (blockAsset == null)
            {
                //TODO 
                Debug.LogError($"Name:{masterElement.Name} Path:{masterElement.BlockPrefabAddressablesPath} GUID:{masterElement.BlockGuid} ");
                return null;
            }
            
            return new BlockObjectInfo(blockId, blockAsset.Asset, masterElement);
        }
        
        public BlockGameObject CreateBlock(BlockId blockId, Vector3 position, Quaternion rotation, Transform parent, Vector3Int blockPosition, BlockDirection direction)
        {
            if (!_blockObjects.TryGetValue(blockId, out var blockObjectInfo))
            {
                //ID
                return CreateMissingIdBlock();
            }
            
            //
            return CreateBlockObject();
            
            #region Internal
            
            BlockGameObject CreateMissingIdBlock()
            {
                var missingIdBlock = Object.Instantiate(_missingBlockIdObject, position, rotation, parent);
                var missingPosInfo = new BlockPositionInfo(blockPosition, direction, Vector3Int.one);
                
                //TODO nullblock master
                //missingIdBlock.Initialize(blockConfig, missingPosInfo, new NullBlockStateChangeProcessor());
                
                return missingIdBlock.GetComponent<BlockGameObject>();
            }
            
            BlockGameObject CreateBlockObject()
            {
                //ID1
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                
                //
                var block = Object.Instantiate(blockObjectInfo.BlockObjectPrefab, position, rotation, parent);
                
                //
                if (!block.TryGetComponent(out BlockGameObject blockObj))
                {
                    blockObj = block.AddComponent<BlockGameObject>();
                }
                
                //
                foreach (var mesh in blockObj.GetComponentsInChildren<MeshRenderer>())
                {
                    mesh.gameObject.AddComponent<BlockGameObjectChild>();
                    mesh.gameObject.AddComponent<MeshCollider>();
                }
                
                blockObj.gameObject.SetActive(true);
                var blockType = blockMasterElement.BlockType;
                //
                if (IsOpenableInventory(blockType)) block.gameObject.AddComponent<OpenableInventoryBlock>();
                // 
                if (IsCommonMachine(blockType)) block.gameObject.AddComponent<CommonMachineBlockStateChangeProcessor>();
                
                // 
                var posInfo = new BlockPositionInfo(blockPosition, direction, blockMasterElement.BlockSize);
                blockObj.Initialize(blockMasterElement, posInfo);
                
                return blockObj;
            }
            
            
            // todo dynamic
            bool IsOpenableInventory(string type)
            {
                return type is
                    BlockTypeConst.Chest or
                    BlockTypeConst.ElectricGenerator or
                    BlockTypeConst.ElectricMiner or
                    BlockTypeConst.ElectricMachine or
                    BlockTypeConst.GearMachine or
                    BlockTypeConst.GearMiner;
            }
            
            bool IsCommonMachine(string type)
            {
                return type is
                    BlockTypeConst.ElectricGenerator or
                    BlockTypeConst.ElectricMiner or
                    BlockTypeConst.ElectricMachine or
                    BlockTypeConst.GearMachine or
                    BlockTypeConst.GearMiner;
            }
            
            #endregion
        }
        
        public BlockPreviewObject CreatePreviewBlock(BlockId blockId)
        {
            if (!_blockObjects.TryGetValue(blockId, out var blockObjectInfo))
            {
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                throw new System.Exception($"Name:{blockMasterElement.Name} GUID:{blockMasterElement.BlockGuid}");
            }
            
            //
            var block = Object.Instantiate(blockObjectInfo.BlockObjectPrefab, Vector3.zero, Quaternion.identity);
            block.SetActive(true);
            
            var previewGameObject = block.AddComponent<BlockPreviewObject>();
            previewGameObject.SetTriggerCollider(true);
            previewGameObject.Initialize(blockId);
            
            return previewGameObject;
        }
    }
    
    public class BlockObjectInfo
    {
        public readonly BlockId BlockId;
        public readonly BlockMasterElement BlockMasterElement;
        public readonly GameObject BlockObjectPrefab;
        
        public BlockObjectInfo(BlockId blockId, GameObject blockObjectPrefab, BlockMasterElement blockMasterElement)
        {
            BlockObjectPrefab = blockObjectPrefab;
            BlockMasterElement = blockMasterElement;
            BlockId = blockId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/Dummy.cs
```cs

// Core.Mastergitignore
// This code is a script to recompile the Core.Master assembly. It is set in gitignore.
public class Dummy
{
    private const string dummyText = "2024/12/28 15:36:19";
}
```

moorestech_server/Assets/Scripts/Game.Gear/Common/GearNetwork.cs
```cs
using System;
using System.Collections.Generic;
using Game.Block.Interface;
using UnityEngine;

namespace Game.Gear.Common
{
    public class GearNetwork
    {
        public IReadOnlyList<IGearEnergyTransformer> GearTransformers => _gearTransformers;
        public IReadOnlyList<IGearGenerator> GearGenerators => _gearGenerators;
        
        private readonly Dictionary<BlockInstanceId, GearRotationInfo> _checkedGearComponents = new();
        private readonly List<IGearGenerator> _gearGenerators = new();
        private readonly List<IGearEnergyTransformer> _gearTransformers = new();
        public readonly GearNetworkId NetworkId;
        
        public GearNetwork(GearNetworkId networkId)
        {
            NetworkId = networkId;
        }
        
        public void AddGear(IGearEnergyTransformer gear)
        {
            switch (gear)
            {
                case IGearGenerator generator:
                    _gearGenerators.Add(generator);
                    break;
                default:
                    _gearTransformers.Add(gear);
                    break;
            }
        }
        
        public void RemoveGear(IGearEnergyTransformer gear)
        {
            switch (gear)
            {
                case IGearGenerator generator:
                    _gearGenerators.Remove(generator);
                    break;
                default:
                    _gearTransformers.Remove(gear);
                    break;
            }
        }
        
        public void ManualUpdate()
        {
            //RPM
            IGearGenerator fastestOriginGenerator = null;
            foreach (var gearGenerator in GearGenerators)
            {
                if (fastestOriginGenerator == null)
                {
                    fastestOriginGenerator = gearGenerator;
                    continue;
                }
                
                if (gearGenerator.GenerateRpm > fastestOriginGenerator.GenerateRpm) fastestOriginGenerator = gearGenerator;
            }
            
            if (fastestOriginGenerator == null)
            {
                //
                foreach (var transformer in GearTransformers) transformer.SupplyPower(new RPM(0), new Torque(0), true);
                return;
            }
            
            //RPM
            _checkedGearComponents.Clear();
            var generatorGearRotationInfo = new GearRotationInfo(fastestOriginGenerator.GenerateRpm, fastestOriginGenerator.GenerateIsClockwise, fastestOriginGenerator);
            _checkedGearComponents.Add(fastestOriginGenerator.BlockInstanceId, generatorGearRotationInfo);
            var rocked = false;
            foreach (var connect in fastestOriginGenerator.GetGearConnects())
            {
                rocked = CalcGearInfo(connect, generatorGearRotationInfo);
                //
                if (rocked) break;
            }
            
            if (rocked)
            {
                SetRocked();
                return;
            }
            
            //GP
            DistributeGearPower();
            
            #region Internal
            
            bool CalcGearInfo(GearConnect gearConnect, GearRotationInfo connectGearRotationInfo)
            {
                var transformer = gearConnect.Transformer;
                
                //RPM
                var isReverseRotation = IsReverseRotation(gearConnect);
                var isClockwise = isReverseRotation ? !connectGearRotationInfo.IsClockwise : connectGearRotationInfo.IsClockwise;
                RPM rpm;
                if (transformer is IGear gear &&
                    connectGearRotationInfo.EnergyTransformer is IGear connectGear &&
                    isReverseRotation)
                {
                    var gearRate = (float)connectGear.TeethCount / gear.TeethCount;
                    rpm = connectGearRotationInfo.Rpm * gearRate;
                }
                else
                {
                    rpm = connectGearRotationInfo.Rpm;
                }
                
                // 
                if (_checkedGearComponents.TryGetValue(transformer.BlockInstanceId, out var info))
                {
                    if (info.IsClockwise != isClockwise || // 
                        Math.Abs((info.Rpm - rpm).AsPrimitive()) > 0.1f) // RPM
                        return true;
                    
                    // 
                    return false;
                }
                
                if (transformer is IGearGenerator generator
                    && generator.GenerateIsClockwise != isClockwise // 
                    && fastestOriginGenerator.BlockInstanceId != transformer.BlockInstanceId // 
                   )
                    return true;
                
                // 
                var gearRotationInfo = new GearRotationInfo(rpm, isClockwise, transformer);
                _checkedGearComponents.Add(transformer.BlockInstanceId, gearRotationInfo);
                
                // 
                foreach (var connect in transformer.GetGearConnects())
                {
                    var isRocked = CalcGearInfo(connect, gearRotationInfo);
                    //
                    if (isRocked) return true;
                }
                
                return false;
            }
            
            bool IsReverseRotation(GearConnect connect)
            {
                return connect.Self.IsReverse && connect.Target.IsReverse;
            }
            
            void SetRocked()
            {
                foreach (var transformer in GearTransformers) transformer.Rocked();
                foreach (var generator in GearGenerators) generator.Rocked();
            }
            
            void DistributeGearPower()
            {
                var totalGenerateTorque = new Torque(0);
                foreach (var gearGenerator in GearGenerators) totalGenerateTorque += gearGenerator.GenerateTorque;
                
                // RPM
                var originRpm = fastestOriginGenerator.GenerateRpm;
                //
                var totalRequiredTorquePerOriginRpm = 0f;
                
                foreach (var gearConsumer in GearTransformers)
                {
                    var info = _checkedGearComponents[gearConsumer.BlockInstanceId];
                    
                    var rpm = info.Rpm;
                    var isClockwise = info.IsClockwise;
                    
                    // 
                    // 
                    var requiredTorque = gearConsumer.GetRequiredTorque(rpm, isClockwise);
                    info.RequiredTorque = requiredTorque;
                    
                    // RPM
                    // RPMRPM
                    var distributeTorque = rpm.AsPrimitive() / originRpm.AsPrimitive() * requiredTorque.AsPrimitive();
                    totalRequiredTorquePerOriginRpm += distributeTorque;
                }
                
                // GPRPM
                // 
                var distributeGearPowerRate = Mathf.Sqrt(Mathf.Min(1, totalGenerateTorque.AsPrimitive() / totalRequiredTorquePerOriginRpm));
                
                foreach (var gearConsumer in GearTransformers)
                {
                    var info = _checkedGearComponents[gearConsumer.BlockInstanceId];
                    
                    var ratedDistributeTorque = new Torque(info.RequiredTorque.AsPrimitive() * distributeGearPowerRate * (originRpm / info.Rpm).AsPrimitive());
                    var ratedDistributionRpm = info.Rpm * distributeGearPowerRate;
                    
                    gearConsumer.SupplyPower(ratedDistributionRpm, ratedDistributeTorque, info.IsClockwise);
                }
                
                foreach (var generator in _gearGenerators)
                {
                    var info = _checkedGearComponents[generator.BlockInstanceId];
                    
                    var ratedDistributeTorque = new Torque(info.RequiredTorque.AsPrimitive() * distributeGearPowerRate);
                    var ratedDistributionRpm = info.Rpm * distributeGearPowerRate;
                    
                    generator.SupplyPower(ratedDistributionRpm, ratedDistributeTorque, info.IsClockwise);
                }
            }
            
            #endregion
        }
    }
    
    public class GearRotationInfo
    {
        public readonly IGearEnergyTransformer EnergyTransformer;
        public readonly bool IsClockwise;
        public readonly RPM Rpm;
        
        public GearRotationInfo(RPM rpm, bool isClockwise, IGearEnergyTransformer energyTransformer)
        {
            Rpm = rpm;
            IsClockwise = isClockwise;
            EnergyTransformer = energyTransformer;
        }
        
        public Torque RequiredTorque { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/IElectricConsumer.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;

namespace Game.EnergySystem
{
    /// <summary>
    ///     
    /// </summary>
    public interface IElectricConsumer : IBlockComponent
    {
        public BlockInstanceId BlockInstanceId { get; }
        public ElectricPower RequestEnergy { get; }
        void SupplyEnergy(ElectricPower power);
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Electric/DisplayEnergizedRange.cs
```cs
using System.Collections.Generic;
using Client.Game.InGame.Block;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Game.InGame.UI.UIState;
using Core.Master;
using Game.PlayerInventory.Interface;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;
using VContainer;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Client.Game.InGame.Electric
{
    /// <summary>
    ///     TODO 
    /// </summary>
    public class DisplayEnergizedRange : MonoBehaviour
    {
        [SerializeField] private EnergizedRangeObject rangePrefab;
        private readonly List<EnergizedRangeObject> rangeObjects = new();
        
        private BlockGameObjectDataStore _blockGameObjectDataStore;
        private HotBarView _hotBarView;
        private ILocalPlayerInventory _localPlayerInventory;
        
        private bool isBlockPlaceState;
        
        [Inject]
        public void Construct(HotBarView hotBarView, UIStateControl uiStateControl, BlockGameObjectDataStore blockGameObjectDataStore, ILocalPlayerInventory localPlayerInventory)
        {
            _blockGameObjectDataStore = blockGameObjectDataStore;
            
            _localPlayerInventory = localPlayerInventory;
            _hotBarView = hotBarView;
            
            hotBarView.OnSelectHotBar += OnSelectHotBar;
            uiStateControl.OnStateChanged += OnStateChanged;
            blockGameObjectDataStore.OnBlockPlaced.Subscribe(OnPlaceBlock);
        }
        
        private void OnSelectHotBar(int index)
        {
            ResetRangeObject();
            CreateRangeObject();
        }
        
        private void OnStateChanged(UIStateEnum state)
        {
            if (isBlockPlaceState && state != UIStateEnum.GameScreen)
            {
                isBlockPlaceState = false;
                ResetRangeObject();
                return;
            }
            
            if (state != UIStateEnum.GameScreen) return;
            isBlockPlaceState = true;
            
            CreateRangeObject();
        }
        
        private void OnPlaceBlock(BlockGameObject blockGameObject)
        {
            if (!isBlockPlaceState) return;
            
            ResetRangeObject();
            CreateRangeObject();
        }
        
        
        private void ResetRangeObject()
        {
            foreach (var rangeObject in rangeObjects) Destroy(rangeObject.gameObject);
            rangeObjects.Clear();
        }
        
        
        private void CreateRangeObject()
        {
            var (isElectricalBlock, isPole) = IsDisplay();
            //
            if (!isElectricalBlock && !isPole) return;
            
            //
            foreach (var electricalPole in GetElectricalPoles())
            {
                var blockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(electricalPole.BlockId);
                var electricPoleParam = (ElectricPoleBlockParam)blockMasterElement.BlockParam;
                var range = isElectricalBlock ? electricPoleParam.MachineConnectionRange : electricPoleParam.PoleConnectionRange;
                
                var rangeObject = Instantiate(rangePrefab, electricalPole.transform.position, Quaternion.identity, transform);
                rangeObject.SetRange(range);
                rangeObjects.Add(rangeObject);
            }
            
            #region Internal
            
            (bool isElectricalBlock, bool isPole) IsDisplay()
            {
                var hotBarSlot = _hotBarView.SelectIndex;
                var id = _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(hotBarSlot)].Id;
                
                if (id == ItemMaster.EmptyItemId) return (false, false);
                

                if (!MasterHolder.BlockMaster.IsBlock(id)) return (false, false);
                
                var blockId = MasterHolder.BlockMaster.GetBlockId(id);
                var blockMaster = MasterHolder.BlockMaster.GetBlockMaster(blockId);
                
                return (IsElectricalBlock(blockMaster.BlockType), IsPole(blockMaster.BlockType));
            }
            
            List<BlockGameObject> GetElectricalPoles()
            {
                var resultBlocks = new List<BlockGameObject>();
                foreach (var blocks in _blockGameObjectDataStore.BlockGameObjectDictionary)
                {
                    var blockMaster = MasterHolder.BlockMaster.GetBlockMaster(blocks.Value.BlockId);
                    if (blockMaster.BlockType != BlockTypeConst.ElectricPole) continue;
                    
                    resultBlocks.Add(blocks.Value);
                }
                
                return resultBlocks;
            }
            
            //TODO 
            bool IsElectricalBlock(string type)
            {
                return type is BlockTypeConst.ElectricGenerator or BlockTypeConst.ElectricMachine or BlockTypeConst.ElectricMiner;
            }
            
            bool IsPole(string type)
            {
                return type is BlockTypeConst.ElectricPole;
            }
            
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/ItemShooterTest.cs
```cs
using System;
using Core.Const;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.ItemShooter;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Core.Block
{
    public class ItemShooterTest
    {
        [Test]
        public void ShooterTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemFactory = ServerContext.ItemStackFactory;
            
            // 
            // Item shooter tests are structured to drop once and then rise again as follows
            //   Chest
            //   
            //                  Item flow
            //          
            //       ItemShooter
            var chestPosition = new Vector3Int(0, 0, 0);
            var horizonShooter1 = new Vector3Int(0, 0, 1);
            var downShooter1 = new Vector3Int(0, -1, 2);
            var downShooter2 = new Vector3Int(0, -2, 3);
            var horizonShooter2 = new Vector3Int(0, -2, 4);
            var upShooter = new Vector3Int(0, -2, 5);
            var horizonShooter3 = new Vector3Int(0, -1, 6);
            var horizonShooter4 = new Vector3Int(0, -1, 7);
            
            var chest = AddBlock(ForUnitTestModBlockId.ChestId, chestPosition).GetComponent<VanillaChestComponent>();
            var shooter1 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter1).GetComponent<ItemShooterComponent>();
            var down1 = AddBlock(ForUnitTestModBlockId.DownItemShooter, downShooter1).GetComponent<ItemShooterComponent>();
            var down2 = AddBlock(ForUnitTestModBlockId.DownItemShooter, downShooter2).GetComponent<ItemShooterComponent>();
            var shooter2 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter2).GetComponent<ItemShooterComponent>();
            var up = AddBlock(ForUnitTestModBlockId.UpItemShooter, upShooter).GetComponent<ItemShooterComponent>();
            var shooter3 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter3).GetComponent<ItemShooterComponent>();
            var shooter4 = AddBlock(ForUnitTestModBlockId.StraightItemShooter, horizonShooter4).GetComponent<ItemShooterComponent>();
            
            chest.InsertItem(itemFactory.Create(new ItemId(1), 1));
            
            // Update
            // Call the Update of the chest
            chest.Update();
            
            // 
            // Verification of the speed inserted by default
            var shooterItem1 = GetShooterItem(shooter1);
            Assert.AreEqual(1, shooterItem1.ItemId.AsPrimitive());
            Assert.AreEqual(1, shooterItem1.CurrentSpeed);
            Assert.AreEqual(1, shooterItem1.RemainingPercent);
            
            // OK
            // Verify each value by looking at the actual value and OK if it is not extremely different
            var shootedItem = WaitInsertItem(down1, "1");
            Assert.IsTrue(0.7f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 0.8f);
            
            shootedItem = WaitInsertItem(down2, "Down1");
            Assert.IsTrue(1.2f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.5f);
            
            shootedItem = WaitInsertItem(shooter2, "Down2");
            Assert.IsTrue(1.7f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 2.0f);
            
            shootedItem = WaitInsertItem(up, "2");
            Assert.IsTrue(1.4f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.8f);
            
            shootedItem = WaitInsertItem(shooter3, "Up", up);
            Assert.IsTrue(0.9f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.3f);
            
            shootedItem = WaitInsertItem(shooter4, "3");
            Assert.IsTrue(0.6f <= shootedItem.CurrentSpeed && shootedItem.CurrentSpeed <= 1.1f);
        }
        
        private ShooterInventoryItem WaitInsertItem(ItemShooterComponent waitTarget, string tag, ItemShooterComponent waitFrom = null)
        {
            var currentTime = DateTime.Now;
            while (true)
            {
                var item = waitTarget.GetItem(0);
                if (item.Id != ItemMaster.EmptyItemId)
                {
                    // 
                    var shooterItem = GetShooterItem(waitTarget);
                    var totalSeconds = (DateTime.Now - currentTime).TotalSeconds;
                    var currentSpeed = shooterItem.CurrentSpeed;
                    // 2
                    Debug.Log($"{tag} Time: {totalSeconds:F2} Speed: {currentSpeed:F2}");
                    return shooterItem;
                }
                GameUpdater.Update();
                
                // 5
                if ((DateTime.Now - currentTime).TotalSeconds > 5)
                {
                    Assert.Fail("");
                }
            }
        }
        
        private ShooterInventoryItem GetShooterItem(ItemShooterComponent target)
        {
            var item = target.BeltConveyorItems[0];
            return item as ShooterInventoryItem;
        }
        
        private IBlock AddBlock(BlockId blockId, Vector3Int position)
        {
            var world = ServerContext.WorldBlockDatastore;
            
            world.TryAddBlock(blockId, position, BlockDirection.North, out var block);
            
            return block;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Event/EventReceive/OpenableBlockInventoryUpdateEventPacket.cs
```cs
using System;
using Core.Item.Interface;
using Game.Block.Interface.Event;
using Game.Context;
using Game.PlayerInventory.Interface;
using MessagePack;
using Server.Util.MessagePack;
using UnityEngine;

namespace Server.Event.EventReceive
{
    /// <summary>
    ///     TODO 
    /// </summary>
    public class OpenableBlockInventoryUpdateEventPacket
    {
        public const string EventTag = "va:event:blockInvUpdate";
        
        private readonly EventProtocolProvider _eventProtocolProvider;
        private readonly IBlockInventoryOpenStateDataStore _inventoryOpenStateDataStore;
        
        private DateTime _now = DateTime.Now;
        
        public OpenableBlockInventoryUpdateEventPacket(EventProtocolProvider eventProtocolProvider, IBlockInventoryOpenStateDataStore inventoryOpenStateDataStore)
        {
            _eventProtocolProvider = eventProtocolProvider;
            _inventoryOpenStateDataStore = inventoryOpenStateDataStore;
            ServerContext.BlockOpenableInventoryUpdateEvent.Subscribe(InventoryUpdateEvent);
        }
        
        
        private void InventoryUpdateEvent(BlockOpenableInventoryUpdateEventProperties properties)
        {
            //
            var playerIds = _inventoryOpenStateDataStore.GetBlockInventoryOpenPlayers(properties.BlockInstanceId);
            if (playerIds.Count == 0) return;
            
            var pos = ServerContext.WorldBlockDatastore.GetBlockPosition(properties.BlockInstanceId);
            var messagePack = new OpenableBlockInventoryUpdateEventMessagePack(pos, properties.Slot, properties.ItemStack);
            var payload = MessagePackSerializer.Serialize(messagePack);
            
            //
            foreach (var id in playerIds) _eventProtocolProvider.AddEvent(id, EventTag, payload);
        }
    }
    
    
    [MessagePackObject]
    public class OpenableBlockInventoryUpdateEventMessagePack
    {
        [Obsolete("")]
        public OpenableBlockInventoryUpdateEventMessagePack()
        {
        }
        
        public OpenableBlockInventoryUpdateEventMessagePack(Vector3Int pos, int slot, IItemStack item)
        {
            Position = new Vector3IntMessagePack(pos);
            Slot = slot;
            Item = new ItemMessagePack(item.Id, item.Count);
        }
        
        [Key(0)] public Vector3IntMessagePack Position { get; set; }
        
        [Key(1)] public int Slot { get; set; }
        
        [Key(2)] public ItemMessagePack Item { get; set; }
    }
}
```

moorestech_server/Assets/Scripts/Game.World.EventHandler/EnergyEvent/ConnectMachineToElectricSegment.cs
```cs
using Core.Master;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.World.EventHandler.EnergyEvent
{
    /// <summary>
    ///     
    /// </summary>
    public class ConnectMachineToElectricSegment<TSegment, TConsumer, TGenerator, TTransformer>
        where TSegment : EnergySegment, new()
        where TConsumer : IElectricConsumer
        where TGenerator : IElectricGenerator
        where TTransformer : IElectricTransformer
    {
        private readonly int _maxMachineConnectionRange;
        private readonly IWorldEnergySegmentDatastore<TSegment> _worldEnergySegmentDatastore;
        
        
        public ConnectMachineToElectricSegment(IWorldEnergySegmentDatastore<TSegment> worldEnergySegmentDatastore, MaxElectricPoleMachineConnectionRange maxElectricPoleMachineConnectionRange)
        {
            _worldEnergySegmentDatastore = worldEnergySegmentDatastore;
            _maxMachineConnectionRange = maxElectricPoleMachineConnectionRange.Get();
            ServerContext.WorldBlockUpdateEvent.OnBlockPlaceEvent.Subscribe(OnBlockPlace);
        }
        
        private void OnBlockPlace(BlockUpdateProperties updateProperties)
        {
            //
            var pos = updateProperties.Pos;
            var x = updateProperties.Pos.x;
            var y = updateProperties.Pos.y;
            
            //
            if (!IsElectricMachine(pos)) return;
            
            //
            var startMachineX = x - _maxMachineConnectionRange / 2;
            var startMachineY = y - _maxMachineConnectionRange / 2;
            for (var i = startMachineX; i < startMachineX + _maxMachineConnectionRange; i++)
            for (var j = startMachineY; j < startMachineY + _maxMachineConnectionRange; j++)
            {
                var polePos = new Vector3Int(i, j);
                if (!ServerContext.WorldBlockDatastore.ExistsComponent<IElectricTransformer>(polePos)) continue;
                
                //
                //
                ConnectToElectricPole(polePos, pos);
            }
        }
        
        private bool IsElectricMachine(Vector3Int pos)
        {
            return ServerContext.WorldBlockDatastore.ExistsComponent<TGenerator>(pos) ||
                   ServerContext.WorldBlockDatastore.ExistsComponent<TConsumer>(pos);
        }
        
        
        /// <summary>
        ///     
        /// </summary>
        private void ConnectToElectricPole(Vector3Int polePos, Vector3Int machinePos)
        {
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            
            //
            var block = ServerContext.WorldBlockDatastore.GetBlock(polePos);
            var pole = block.GetComponent<TTransformer>();
            //
            var configParam = block.BlockMasterElement.BlockParam as ElectricPoleBlockParam;
            var range = configParam.MachineConnectionRange;
            
            //
            var poleX = polePos.x;
            var poleY = polePos.y;
            if (poleX - range / 2 > poleX || poleX > poleX + range / 2 || poleY - range / 2 > poleY ||
                poleY > poleY + range / 2) return;
            
            //
            //
            var segment = _worldEnergySegmentDatastore.GetEnergySegment(pole);
            if (worldBlockDatastore.ExistsComponent<TGenerator>(machinePos))
                segment.AddGenerator(worldBlockDatastore.GetBlock<TGenerator>(machinePos));
            else if (worldBlockDatastore.ExistsComponent<TConsumer>(machinePos))
                segment.AddEnergyConsumer(worldBlockDatastore.GetBlock<TConsumer>(machinePos));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/IElectricTransformer.cs
```cs
using Game.Block.Interface;
using Game.Block.Interface.Component;

namespace Game.EnergySystem
{
    /// <summary>
    ///     
    /// </summary>
    public interface IElectricTransformer : IBlockComponent
    {
        public BlockInstanceId BlockInstanceId { get; }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerMainComputerInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;

namespace Game.CraftChainer.BlockComponent.Computer
{
    /// <summary>
    /// 
    /// The main computer does not take items out, so this class is for that
    /// </summary>
    public class CraftChainerMainComputerInserter : IBlockInventoryInserter
    {
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return itemStack;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaGearMachineComponent.cs
```cs
using Game.Block.Blocks.Gear;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.Block.Blocks.Machine
{
    /// <summary>
    ///     
    /// </summary>
    public class VanillaGearMachineComponent : IBlockComponent
    {
        private readonly GearEnergyTransformer _gearEnergyTransformer;
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        private readonly GearMachineBlockParam _gearMachineBlockParam;
        
        public VanillaGearMachineComponent(VanillaMachineProcessorComponent vanillaMachineProcessorComponent, GearEnergyTransformer gearEnergyTransformer, GearMachineBlockParam gearMachineBlockParam)
        {
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
            _gearEnergyTransformer = gearEnergyTransformer;
            _gearMachineBlockParam = gearMachineBlockParam;
            
            _gearEnergyTransformer.OnGearUpdate.Subscribe(OnGearUpdate);
        }
        
        private void OnGearUpdate(GearUpdateType gearUpdateType)
        {
            var requiredRpm = new RPM(_gearMachineBlockParam.RequiredRpm);
            var requireTorque = new Torque(_gearMachineBlockParam.RequireTorque);
            
            var currentElectricPower = _gearEnergyTransformer.CalcMachineSupplyPower(requiredRpm, requireTorque);
            _vanillaMachineProcessorComponent.SupplyPower(currentElectricPower);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            BlockException.CheckDestroy(this);
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Util/MachineCurrentPowerToSubSecond.cs
```cs
using Core.Update;
using Game.EnergySystem;

namespace Game.Block.Blocks.Util
{
    /// <summary>
    ///     
    /// </summary>
    public static class MachineCurrentPowerToSubSecond
    {
        public static double GetSubSecond(ElectricPower currentPower, ElectricPower requiredPower)
        {
            //0
            if (requiredPower.AsPrimitive() == 0) return GameUpdater.UpdateSecondTime;
            //
            //10050
            return GameUpdater.UpdateSecondTime * (currentPower.AsPrimitive() / (double)requiredPower.AsPrimitive());
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Miner/VanillaMinerProcessorComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.Service;
using Game.Block.Blocks.Util;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Block.Interface.State;
using Game.Context;
using Game.EnergySystem;
using Game.Map.Interface.Vein;
using MessagePack;
using Mooresmaster.Model.MineSettingsModule;
using Newtonsoft.Json;
using UniRx;

namespace Game.Block.Blocks.Miner
{
    public class VanillaMinerProcessorComponent : IOpenableBlockInventoryComponent, IBlockSaveState, IBlockStateObservable, IBlockStateDetail, IUpdatableBlockComponent
    {
        public bool IsDestroy { get; private set; }
        public ElectricPower RequestEnergy { get; }
        public IObservable<Unit> OnChangeBlockState => _blockStateChangeSubject;
        private Subject<Unit> _blockStateChangeSubject = new();
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly ConnectingInventoryListPriorityInsertItemService _connectInventoryService;
        private readonly List<IItemStack> _miningItems = new();
        
        private readonly OpenableInventoryItemDataStoreService _openableInventoryItemDataStoreService;
        private readonly BlockInstanceId _blockInstanceId;
        
        private ElectricPower _currentPower;
        
        private float _defaultMiningTime = float.MaxValue;
        private double _remainingSecond = double.MaxValue;
        
        private VanillaMinerState _lastMinerState;
        private VanillaMinerState _currentState = VanillaMinerState.Idle;
        
        public VanillaMinerProcessorComponent(BlockInstanceId blockInstanceId, ElectricPower requestPower, int outputSlotCount, BlockOpenableInventoryUpdateEvent openableInventoryUpdateEvent, BlockConnectorComponent<IBlockInventory> inputConnectorComponent, BlockPositionInfo blockPositionInfo, MineSettings mineSettings)
        {
            _blockInstanceId = blockInstanceId;
            RequestEnergy = requestPower;
            
            _blockInventoryUpdate = openableInventoryUpdateEvent;
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            _openableInventoryItemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, itemStackFactory, outputSlotCount);
            _connectInventoryService = new ConnectingInventoryListPriorityInsertItemService(inputConnectorComponent);
            
            SetMiningItem();
            
            #region Internal
            
            void SetMiningItem()
            {
                List<IMapVein> veins = ServerContext.MapVeinDatastore.GetOverVeins(blockPositionInfo.OriginalPos);
                foreach (var vein in veins) _miningItems.Add(itemStackFactory.Create(vein.VeinItemId, 1));
                if (veins.Count == 0) return;
                
                foreach (var miningSetting in mineSettings.items)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(miningSetting.ItemGuid);
                    if (itemId != veins[0].VeinItemId) continue;
                    _defaultMiningTime = miningSetting.Time;
                    _remainingSecond = _defaultMiningTime;
                    break;
                }
            }
            
            #endregion
        }
        
        public VanillaMinerProcessorComponent(Dictionary<string, string> componentStates, BlockInstanceId blockInstanceId, ElectricPower requestPower, int outputSlotCount, BlockOpenableInventoryUpdateEvent openableInventoryUpdateEvent, BlockConnectorComponent<IBlockInventory> inputConnectorComponent, BlockPositionInfo blockPositionInfo, MineSettings mineSettings)
            : this(blockInstanceId, requestPower, outputSlotCount, openableInventoryUpdateEvent, inputConnectorComponent, blockPositionInfo, mineSettings)
        {
            var saveJsonObject = JsonConvert.DeserializeObject<VanillaElectricMinerSaveJsonObject>(componentStates[SaveKey]);
            for (var i = 0; i < saveJsonObject.Items.Count; i++)
            {
                var itemStack = saveJsonObject.Items[i].ToItemStack();
                _openableInventoryItemDataStoreService.SetItem(i, itemStack);
            }
            
            _remainingSecond = saveJsonObject.RemainingSecond;
        }
        
        public void SupplyPower(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            
            _currentPower = power;
        }
        
        public string SaveKey { get; } = typeof(VanillaMinerProcessorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var saveData = new VanillaElectricMinerSaveJsonObject
            {
                RemainingSecond = _remainingSecond,
                Items = _openableInventoryItemDataStoreService.InventoryItems.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
            };
            
            return JsonConvert.SerializeObject(saveData);
        }
        
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            MinerProgressUpdate();
            CheckStateAndInvokeEventUpdate();
            
            #region Internal
            
            void MinerProgressUpdate()
            {
                var subTime = MachineCurrentPowerToSubSecond.GetSubSecond(_currentPower, RequestEnergy);
                if (subTime <= 0)
                {
                    //return
                    _currentState = VanillaMinerState.Idle;
                    return;
                }
                
                //insert
                if (!_openableInventoryItemDataStoreService.InsertionCheck(_miningItems))
                {
                    //return
                    _currentState = VanillaMinerState.Idle;
                    return;
                }
                
                _currentState = VanillaMinerState.Mining;
                
                _remainingSecond -= subTime;
                
                if (_remainingSecond <= 0)
                {
                    _remainingSecond = _defaultMiningTime;
                    
                    //
                    _openableInventoryItemDataStoreService.InsertItem(_miningItems);
                }
                
                _currentPower = new ElectricPower(0);
                InsertConnectInventory();
            }
            
            void CheckStateAndInvokeEventUpdate()
            {
                if (_lastMinerState == VanillaMinerState.Mining && _currentState == VanillaMinerState.Idle)
                {
                    //Miningidle
                    InvokeChangeStateEvent();
                    _lastMinerState = _currentState;
                    return;
                }
                
                if (_currentState == VanillaMinerState.Idle)
                    //Idle
                    return;
                
                // 
                InvokeChangeStateEvent();
            }
            
            void InvokeChangeStateEvent()
            {
                BlockException.CheckDestroy(this);
                
                _blockStateChangeSubject.OnNext(Unit.Default);
            }
            
            
            void InsertConnectInventory()
            {
                BlockException.CheckDestroy(this);
                
                for (var i = 0; i < _openableInventoryItemDataStoreService.InventoryItems.Count; i++)
                {
                    var insertedItem = _connectInventoryService.InsertItem(_openableInventoryItemDataStoreService.InventoryItems[i]);
                    _openableInventoryItemDataStoreService.SetItem(i, insertedItem);
                }
            }
            
            #endregion
        }
        
        
        public BlockStateDetail GetBlockStateDetail()
        {
            var processingRate = 1 - (float)_remainingSecond / _defaultMiningTime;
            var stateDetail = new CommonMachineBlockStateDetail(_currentPower.AsPrimitive(), RequestEnergy.AsPrimitive(), processingRate, _currentState.ToStr(), _lastMinerState.ToStr());
            var stateDetailBytes = MessagePackSerializer.Serialize(stateDetail);
            return new BlockStateDetail(CommonMachineBlockStateDetail.BlockStateDetailKey, stateDetailBytes);
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(_blockInstanceId, slot, itemStack));
        }
        
        #region Implimantion IOpenableInventory
        
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.GetItem(slot);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            _openableInventoryItemDataStoreService.SetItem(slot, itemStack);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _openableInventoryItemDataStoreService.GetSlotSize();
        }
        
        
        public IReadOnlyList<IItemStack> InventoryItems => _openableInventoryItemDataStoreService.InventoryItems;
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.ReplaceItem(slot, itemId, count);
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemStack);
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemId, count);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.InsertionCheck(itemStacks);
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            _openableInventoryItemDataStoreService.SetItem(slot, itemId, count);
        }
        
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            return _openableInventoryItemDataStoreService.ReplaceItem(slot, itemStack);
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            return _openableInventoryItemDataStoreService.CreateCopiedItems();
        }
        
        #endregion
        
        public void Destroy()
        {
            IsDestroy = true;
            _blockStateChangeSubject.Dispose();
            _blockStateChangeSubject = null;
        }
    }
    
    public enum VanillaMinerState
    {
        Idle,
        Mining,
    }
    
    public static class ProcessStateExtension
    {
        /// <summary>
        ///     <see cref="ProcessState" />String
        ///     EnumToString
        /// </summary>
        public static string ToStr(this VanillaMinerState state)
        {
            return state switch
            {
                VanillaMinerState.Idle => "idle",
                VanillaMinerState.Mining =>"mining",
                _ => throw new ArgumentOutOfRangeException(nameof(state), state, null),
            };
        }
    }
    
    public class VanillaElectricMinerSaveJsonObject
    {
        [JsonProperty("items")]
        public List<ItemStackSaveJsonObject> Items;
        [JsonProperty("remainingSecond")]
        public double RemainingSecond;
    }
}
```

moorestech_server/Assets/Scripts/Server.Boot/MoorestechServerDIContainerGenerator.cs
```cs
using System.IO;
using Core.Item;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Event;
using Game.Block.Factory;
using Game.Block.Interface;
using Game.Block.Interface.Event;
using Game.Challenge;
using Game.Context;
using Game.CraftChainer;
using Game.CraftChainer.CraftNetwork;
using Game.CraftChainer.Util;
using Game.Crafting.Interface;
using Game.EnergySystem;
using Game.Entity;
using Game.Entity.Interface;
using Game.Gear.Common;
using Game.Map;
using Game.Map.Interface.Json;
using Game.Map.Interface.MapObject;
using Game.Map.Interface.Vein;
using Game.PlayerInventory;
using Game.PlayerInventory.Event;
using Game.PlayerInventory.Interface;
using Game.PlayerInventory.Interface.Event;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.Train.RailGraph;
using Game.World;
using Game.World.DataStore;
using Game.World.DataStore.WorldSettings;
using Game.World.EventHandler.EnergyEvent;
using Game.World.EventHandler.EnergyEvent.EnergyService;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using Mod.Config;
using Mod.Loader;
using Newtonsoft.Json;
using Server.Event;
using Server.Event.EventReceive;
using Server.Protocol;

namespace Server.Boot
{
    public class MoorestechServerDIContainerGenerator
    {
        //TODO 
        public (PacketResponseCreator, ServiceProvider) Create(string serverDirectory)
        {
            GameUpdater.ResetUpdate();
            
            //
            var modDirectory = Path.Combine(serverDirectory, "mods");
            
            // 
            var modResource = new ModsResource(modDirectory);
            var configJsons = ModJsonStringLoader.GetConfigString(modResource);
            var configJsonFileContainer = new MasterJsonFileContainer(configJsons);
            MasterHolder.Load(configJsonFileContainer);
            
            var initializerCollection = new ServiceCollection();
            initializerCollection.AddSingleton(configJsonFileContainer);
            initializerCollection.AddSingleton<IItemStackFactory, ItemStackFactory>();
            initializerCollection.AddSingleton<VanillaIBlockTemplates, VanillaIBlockTemplates>();
            initializerCollection.AddSingleton<IBlockFactory, BlockFactory>();
            
            initializerCollection.AddSingleton<IWorldBlockDatastore, WorldBlockDatastore>();
            initializerCollection.AddSingleton<IWorldBlockUpdateEvent, WorldBlockUpdateEvent>();
            initializerCollection.AddSingleton<IBlockOpenableInventoryUpdateEvent, BlockOpenableInventoryUpdateEvent>();
            initializerCollection.AddSingleton<GearNetworkDatastore>();
            initializerCollection.AddSingleton<RailGraphDatastore>();

            var mapPath = Path.Combine(serverDirectory, "map", "map.json");
            initializerCollection.AddSingleton(JsonConvert.DeserializeObject<MapInfoJson>(File.ReadAllText(mapPath)));
            initializerCollection.AddSingleton<IMapVeinDatastore, MapVeinDatastore>();
            
            var initializerProvider = initializerCollection.BuildServiceProvider();
            var serverContext = new ServerContext(initializerProvider);
            
            
            //
            var services = new ServiceCollection();
            
            //
            services.AddSingleton<EventProtocolProvider, EventProtocolProvider>();
            services.AddSingleton<IWorldSettingsDatastore, WorldSettingsDatastore>();
            services.AddSingleton<IPlayerInventoryDataStore, PlayerInventoryDataStore>();
            services.AddSingleton<IBlockInventoryOpenStateDataStore, BlockInventoryOpenStateDataStore>();
            services.AddSingleton<IWorldEnergySegmentDatastore<EnergySegment>, WorldEnergySegmentDatastore<EnergySegment>>();
            services.AddSingleton<MaxElectricPoleMachineConnectionRange, MaxElectricPoleMachineConnectionRange>();
            services.AddSingleton<IEntitiesDatastore, EntitiesDatastore>();
            services.AddSingleton<IEntityFactory, EntityFactory>(); // TODO Context
            services.AddSingleton<GearNetworkDatastore>();
            services.AddSingleton<RailGraphDatastore>();

            services.AddSingleton<ItemRecipeViewerDataContainer>();
            
            services.AddSingleton<IMapObjectDatastore, MapObjectDatastore>();
            services.AddSingleton<IMapObjectFactory, MapObjectFactory>();
            
            services.AddSingleton(configJsonFileContainer);
            services.AddSingleton<ChallengeDatastore, ChallengeDatastore>();
            services.AddSingleton<ChallengeEvent, ChallengeEvent>();
            
            //JSON
            services.AddSingleton(modResource);
            services.AddSingleton<IWorldSaveDataSaver, WorldSaverForJson>();
            services.AddSingleton<IWorldSaveDataLoader, WorldLoaderFromJson>();
            services.AddSingleton(new SaveJsonFileName("save_1.json"));
            services.AddSingleton(JsonConvert.DeserializeObject<MapInfoJson>(File.ReadAllText(mapPath)));
            
            //
            services.AddSingleton<IMainInventoryUpdateEvent, MainInventoryUpdateEvent>();
            services.AddSingleton<IGrabInventoryUpdateEvent, GrabInventoryUpdateEvent>();
            services.AddSingleton<CraftEvent, CraftEvent>();
            
            //
            services.AddSingleton<ChangeBlockStateEventPacket>();
            services.AddSingleton<MainInventoryUpdateEventPacket>();
            services.AddSingleton<OpenableBlockInventoryUpdateEventPacket>();
            services.AddSingleton<GrabInventoryUpdateEventPacket>();
            services.AddSingleton<PlaceBlockEventPacket>();
            services.AddSingleton<RemoveBlockToSetEventPacket>();
            services.AddSingleton<CompletedChallengeEventPacket>();
            
            services.AddSingleton<EnergyConnectUpdaterContainer<EnergySegment, IElectricConsumer, IElectricGenerator, IElectricTransformer>>();
            
            services.AddSingleton<MapObjectUpdateEventPacket>();
            
            //
            services.AddSingleton<AssembleSaveJsonText, AssembleSaveJsonText>();
            
            
            var serviceProvider = services.BuildServiceProvider();
            var packetResponse = new PacketResponseCreator(serviceProvider);
            
            //
            //TODO DI VContinerRegisterEntryPoint
            serviceProvider.GetService<MainInventoryUpdateEventPacket>();
            serviceProvider.GetService<OpenableBlockInventoryUpdateEventPacket>();
            serviceProvider.GetService<GrabInventoryUpdateEventPacket>();
            serviceProvider.GetService<PlaceBlockEventPacket>();
            serviceProvider.GetService<RemoveBlockToSetEventPacket>();
            serviceProvider.GetService<CompletedChallengeEventPacket>();
            
            serviceProvider.GetService<GearNetworkDatastore>();
            serviceProvider.GetService<RailGraphDatastore>();
            serviceProvider.GetService<EnergyConnectUpdaterContainer<EnergySegment, IElectricConsumer, IElectricGenerator, IElectricTransformer>>();
            
            serviceProvider.GetService<ChangeBlockStateEventPacket>();
            serviceProvider.GetService<MapObjectUpdateEventPacket>();
            
            serverContext.SetMainServiceProvider(serviceProvider);
            
            // CraftChainer
            CraftChainerEntryPoint.Entry();
            
            // 
            GameUpdater.ResetTime();
            
            return (packetResponse, serviceProvider);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/BeltConveyorSaveLoadTest.cs
```cs
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class BeltConveyorSaveLoadTest
    {
        [Test]
        public void NormalSaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var beltPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(1), beltPosInfo);
            
            var belt = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            //_inventoryItems
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(belt);
            
            //
            inventoryItems[0] = new VanillaBeltConveyorInventoryItem(new ItemId(1), new ItemInstanceId(0))
            {
                RemainingPercent = 0.3f,
            };
            inventoryItems[2] = new VanillaBeltConveyorInventoryItem(new ItemId(2), new ItemInstanceId(0))
            {
                RemainingPercent = 0.5f,
            };
            inventoryItems[3] = new VanillaBeltConveyorInventoryItem(new ItemId(5), new ItemInstanceId(0))
            {
                RemainingPercent = 1f,
            };
            
            
            //
            var str = belt.GetSaveState();
            var states = new Dictionary<string, string>() { { belt.SaveKey, str } };
            Debug.Log(str);
            
            
            //
            var blockConnector = new BlockConnectorComponent<IBlockInventory>(null, null, beltPosInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(blockConnector);
            
            var newBelt = new VanillaBeltConveyorComponent(states, 4, 4000, beltConveyorConnector, BeltConveyorSlopeType.Straight);
            var newInventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(newBelt);
            
            //
            Assert.AreEqual(inventoryItems.Length, newInventoryItems.Length);
            Assert.AreEqual(1, newInventoryItems[0].ItemId.AsPrimitive());
            Assert.AreEqual(0.3f, newInventoryItems[0].RemainingPercent);
            Assert.AreEqual(2, newInventoryItems[2].ItemId.AsPrimitive());
            Assert.AreEqual(0.5f, newInventoryItems[2].RemainingPercent);
            Assert.AreEqual(5, newInventoryItems[3].ItemId.AsPrimitive());
            Assert.AreEqual(1f, newInventoryItems[3].RemainingPercent);
        }
        
        [Test]
        public void GearSaveLoadTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var beltPosInfo = new BlockPositionInfo(new Vector3Int(0, 0), BlockDirection.North, Vector3Int.one);
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.GearBeltConveyor, new BlockInstanceId(1), beltPosInfo);
            
            var belt = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            //_inventoryItems
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(belt);
            
            //
            inventoryItems[0] = new VanillaBeltConveyorInventoryItem(new ItemId(1), new ItemInstanceId(0))
            {
                RemainingPercent = 0.3f,
            };
            inventoryItems[2] = new VanillaBeltConveyorInventoryItem(new ItemId(2), new ItemInstanceId(0))
            {
                RemainingPercent = 0.5f,
            };
            inventoryItems[3] = new VanillaBeltConveyorInventoryItem(new ItemId(5), new ItemInstanceId(0))
            {
                RemainingPercent = 1f,
            };
            
            
            //
            var str = belt.GetSaveState();
            var states = new Dictionary<string, string>() { { belt.SaveKey, str } };
            Debug.Log(str);
            
            
            //
            var blockConnector = new BlockConnectorComponent<IBlockInventory>(null, null, beltPosInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(blockConnector); 
            
            var newBelt = new VanillaBeltConveyorComponent(states, 4, 4000, beltConveyorConnector, BeltConveyorSlopeType.Straight);
            var newInventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(newBelt);
            
            //
            Assert.AreEqual(inventoryItems.Length, newInventoryItems.Length);
            Assert.AreEqual(1, newInventoryItems[0].ItemId.AsPrimitive());
            Assert.AreEqual(0.3f, newInventoryItems[0].RemainingPercent);
            Assert.AreEqual(2, newInventoryItems[2].ItemId.AsPrimitive());
            Assert.AreEqual(0.5f, newInventoryItems[2].RemainingPercent);
            Assert.AreEqual(5, newInventoryItems[3].ItemId.AsPrimitive());
            Assert.AreEqual(1f, newInventoryItems[3].RemainingPercent);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/CraftChainer/CraftChainerSolverTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;

namespace Tests.UnitTest.Game.CraftChainer
{
    /// <summary>
    ///  legend
    /// 
    /// recipesStr
    /// : ,     ,  
    /// RecipeId:OutputItemName Count, OutputItemName Count  InputItemName Count, InputItemName Count
    ///
    /// initialInventoryStr
    ///  
    /// ItemName Count
    ///
    /// targetItemStr
    ///  
    /// ItemName Count
    ///
    /// expectedStr
    /// :
    /// RecipeId:UseRecipeCount
    /// 
    /// </summary>
    public class CraftChainerSolverTest
    {
        [Test]
        public void TestCase01()
        {
            var recipesStr = @"
1:A 1  B 1, C 2
2:B 1  C 2";
            var initialInventoryStr = @"
B 1";
            var targetItem = "A 1";
            var expectedStr = @""; // 
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase02()
        {
            var recipesStr = @"
1:A 1  B 1, C 2
2:B 1  C 2";
            var initialInventoryStr = @""; // 
            var targetItem = "A 1";
            var expectedStr = @""; // 
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase03()
        {
            var recipesStr = @"
1:D 1  E 8
2:E 4  F 2
3:E 4  G 2";
            var initialInventoryStr = @""; // 
            var targetItem = "D 1";
            var expectedStr = @""; // 
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase04()
        {
            var recipesStr = @"
1:A 1  B 2
2:A 1  B 4";
            var initialInventoryStr = @"
B 3";
            var targetItem = "A 1";
            var expectedStr = @"
1:1"; // 11
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase05()
        {
            var recipesStr = @"
1:A 1  B 3
2:B 1  C 2
3:B 1  D 2
4:D 1  E 1";
            var initialInventoryStr = @"
C 4
D 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:2
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase06()
        {
            var recipesStr = @"
1:A 1  B 2, C 2
2:C 1  D 1
3:B 1, C 1  D 3";
            var initialInventoryStr = @"
B 1
D 10";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
3:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase07()
        {
            var recipesStr = @"
1:X 1  Y 1, Z 1
2:Y 1  W 5
3:Z 1  W 10";
            var initialInventoryStr = @"
W 15";
            var targetItem = "X 1";
            var expectedStr = @"
1:1
2:1
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase08()
        {
            var recipesStr = @"
1:A 1  B 2, C 1
2:A 1  B 1, D 2
3:B 1  E 3
4:C 1  E 2
5:D 1  E 1";
            var initialInventoryStr = @"
E 10";
            var targetItem = "A 2";
            var expectedStr = @"
2:2
3:2
5:4";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase09()
        {
            var recipesStr = @"
1:A 1  B 10
2:B 1  C 5
3:C 1  D 2
4:D 1  E 1";
            var initialInventoryStr = @"
C 2
E 10";
            var targetItem = "A 1";
            var expectedStr = @""; // 
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase10()
        {
            var recipesStr = @"
1:A 1  B 1
2:B 3  C 2
3:C 5  D 1";
            var initialInventoryStr = @"
D 1";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:1
3:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase11()
        {
            var recipesStr = @"
1:A 1  B 1, C 2
2:B 1  D 3
3:C 1  D 2
4:D 1  E 1
5:B 1  F 1
6:C 1  G 1";
            var initialInventoryStr = @"
D 1
F 1
G 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
5:1
6:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase12()
        {
            var recipesStr = @"
1:A 1  B 1, C 1
2:B 1  C 2
3:C 1  E 1
4:E 1  B 1
5:B 1  D 1";
            var initialInventoryStr = @"
D 2";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
3:1
4:1
5:2";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase13()
        {
            var recipesStr = @"
1:A 1  B1 1, B2 1, B3 1, B4 1
2:B1 1  C1 1
3:B2 1  C2 1
4:B3 1  C3 1
5:B4 1  C4 1
6:C1 1  D 1
7:C2 1  D 1
8:C3 1  D 1
9:C4 1  D 1";
            var initialInventoryStr = @"
D 5";
            var targetItem = "A 1";
            var expectedStr = @"
1:1
2:1
3:1
4:1
5:1
6:1
7:1
8:1
9:1";
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        [Test]
        public void TestCase14()
        {
            var recipesStr = @"
1:A 1  B 2
2:B 1  C 2
3:B 1  D 1";
            var initialInventoryStr = @"
C 1
D 1";
            var targetItem = "A 1";
            var expectedStr = @""; // 
            ExecuteTest(recipesStr, initialInventoryStr, targetItem, expectedStr);
        }
        
        
        private void ExecuteTest(
            string recipesStr,
            string initialInventoryStr,
            string targetItemStr,
            string expectedStr)
        {
            var (recipes, initialInventory, targetItem, expected) = ParseInput(recipesStr, initialInventoryStr, targetItemStr, expectedStr);
            var actual = CraftChainerCraftingSolver.Solve(recipes, initialInventory, targetItem);
            
            if (expected == null)
            {
                Assert.IsNull(actual);
                return;
            }
            
            Assert.IsNotNull(actual);
            Assert.AreEqual(expected.Count, actual.Count);
            
            foreach (var kvp in expected)
            {
                Assert.IsTrue(actual.ContainsKey(kvp.Key));
                Assert.AreEqual(kvp.Value, actual[kvp.Key]);
            }
        }
        
        private (List<CraftingSolverRecipe> recipes, Dictionary<ItemId, int> initialInventory, CraftingSolverItem targetItem, Dictionary<CraftingSolverRecipeId, int> expected) ParseInput(
            string recipesStr,
            string initialInventoryStr,
            string targetItemStr,
            string expectedStr)
        {
            var recipes = ParseRecipes();
            var initialInventory = ParseInitialInventory();
            var targetItem = ParseTargetItem();
            var expected = ParseExpected();
            
            return (recipes, initialInventory, targetItem, expected);
            
            #region Internal
            
            List<CraftingSolverRecipe> ParseRecipes()
            {
                var result = new List<CraftingSolverRecipe>();
                
                var recipeLines = recipesStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x));
                foreach (var recipeLine in recipeLines)
                {
                    var recipeId = new CraftingSolverRecipeId(int.Parse(recipeLine.Split(':')[0]));
                    var inputItemsStr = recipeLine.Split(':')[1].Split('')[1].Trim();
                    var outputItemStr = recipeLine.Split(':')[1].Split('')[0].Trim();
                    
                    var inputItems = ParseRecipeItems(inputItemsStr);
                    var outputItems = ParseRecipeItems(outputItemStr);
                    
                    result.Add(new CraftingSolverRecipe(recipeId, inputItems, outputItems));
                }
                
                return result;
            }
            
            Dictionary<ItemId, int> ParseInitialInventory()
            {
                var result = new Dictionary<ItemId, int>();
                
                var inventoryLines = initialInventoryStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x));
                foreach (var inventoryLine in inventoryLines)
                {
                    var itemName = inventoryLine.Split(' ')[0];
                    var itemId = new ItemId(GetItemId(itemName));
                    var quantity = int.Parse(inventoryLine.Split(' ')[1]);
                    
                    result.Add(itemId, quantity);
                }
                
                return result;
            }
            
            CraftingSolverItem ParseTargetItem()
            {
                var itemName = targetItemStr.Split(' ')[0];
                var itemId = new ItemId(GetItemId(itemName));
                var quantity = int.Parse(targetItemStr.Split(' ')[1]);
                
                return new CraftingSolverItem(itemId, quantity);
            }
            
            Dictionary<CraftingSolverRecipeId, int> ParseExpected()
            {
                var result = new Dictionary<CraftingSolverRecipeId, int>();
                
                var expectedLines = expectedStr.Split('\n').Where(x => !string.IsNullOrWhiteSpace(x)).ToList();
                if (expectedLines.Count == 0)
                {
                    return null;
                }
                
                foreach (var expectedLine in expectedLines)
                {
                    var recipeId = new CraftingSolverRecipeId(int.Parse(expectedLine.Split(':')[0]));
                    var quantity = int.Parse(expectedLine.Split(':')[1]);
                    
                    result.Add(recipeId, quantity);
                }
                
                return result;
            }
            
            List<CraftingSolverItem> ParseRecipeItems(string itemRecipes)
            {
                var result = new List<CraftingSolverItem>();
                foreach (var item in itemRecipes.Split(','))
                {
                    var trimItem = item.Trim();
                    var itemName = trimItem.Split(' ')[0];
                    var itemId = new ItemId(GetItemId(itemName));
                    var quantity = int.Parse(trimItem.Split(' ')[1]);
                    
                    result.Add(new CraftingSolverItem(itemId, quantity));
                }
                return result;
            }
            
  #endregion
        }
        
        private int _nextItemId = 1;
        private Dictionary<string, int> _itemNameToId = new();
        
        private int GetItemId(string itemName)
        {
            // ID
            // 
            if (!_itemNameToId.TryGetValue(itemName, out var itemId))
            {
                itemId = _nextItemId++;
                _itemNameToId[itemName] = itemId;
            }
            return itemId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/PowerGeneratorTest.cs
```cs
using System;
using System.Reflection;
using Core.Const;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.PowerGenerator;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class PowerGeneratorTest
    {
        private const int FuelItem1Id = 0;
        private const int FuelItem2Id = 1;
        
        [Test]
        public void UseFuelTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one);
            var powerGenerator = blockFactory.Create(ForUnitTestModBlockId.GeneratorId, new BlockInstanceId(10), posInfo);
            var generatorComponent = powerGenerator.GetComponent<VanillaElectricGeneratorComponent>();
            var generatorConfigParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GeneratorId).BlockParam as ElectricGeneratorBlockParam;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var fuelItem1 = itemStackFactory.Create(generatorConfigParam.FuelItems[FuelItem1Id].ItemGuid, 1);
            var fuelItem2 = itemStackFactory.Create(generatorConfigParam.FuelItems[FuelItem2Id].ItemGuid, 1);
            
            
            //
            var endTime1 = DateTime.Now.AddSeconds(generatorConfigParam.FuelItems[FuelItem1Id].Time);
            
            //
            generatorComponent.InsertItem(fuelItem1);
            
            //1
            GameUpdater.UpdateWithWait();
            
            //
            Assert.AreEqual(generatorConfigParam.FuelItems[FuelItem1Id].Power, generatorComponent.OutputEnergy().AsPrimitive());
            
            //
            while (endTime1.AddSeconds(0.1).CompareTo(DateTime.Now) == 1)
            {
                GameUpdater.UpdateWithWait();
            }
            
            //
            //
            var fuelItemId = (ItemId)typeof(VanillaElectricGeneratorComponent).GetField("_currentFuelItemId",
                    BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(generatorComponent);
            Assert.AreEqual(ItemMaster.EmptyItemId, fuelItemId);
            
            //2
            generatorComponent.InsertItem(fuelItem1);
            generatorComponent.InsertItem(fuelItem2);
            
            //1
            endTime1 = DateTime.Now.AddSeconds(generatorConfigParam.FuelItems[FuelItem1Id].Time);
            while (endTime1.AddSeconds(0.3).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //2
            fuelItemId = (ItemId)typeof(VanillaElectricGeneratorComponent).GetField("_currentFuelItemId",
                    BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(generatorComponent);
            var fuelItemId2 = MasterHolder.ItemMaster.GetItemId(generatorConfigParam.FuelItems[FuelItem2Id].ItemGuid);
            Assert.AreEqual(fuelItemId2, fuelItemId);
            
            //2
            var endTime2 = DateTime.Now.AddSeconds(generatorConfigParam.FuelItems[FuelItem2Id].Time);
            while (endTime2.AddSeconds(0.1).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //2
            fuelItemId = (ItemId)typeof(VanillaElectricGeneratorComponent).GetField("_currentFuelItemId",
                    BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(generatorComponent);
            Assert.AreEqual(ItemMaster.EmptyItemId, fuelItemId);
        }
        
        [Test]
        public void InfinityGeneratorTet()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var posInfo = new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one);
            var powerGenerator = blockFactory.Create(ForUnitTestModBlockId.InfinityGeneratorId, new BlockInstanceId(10), posInfo);
            var generatorComponent = powerGenerator.GetComponent<VanillaElectricGeneratorComponent>();
            
            var generatorConfigParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.InfinityGeneratorId).BlockParam as ElectricGeneratorBlockParam;
            
            //1
            GameUpdater.UpdateWithWait();
            
            //
            Assert.AreEqual(generatorConfigParam.InfinityPower, generatorComponent.OutputEnergy().AsPrimitive());
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/VanillaIBlockTemplates.cs
```cs
using System.Collections.Generic;
using Game.Block.Event;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface.Event;
using static Mooresmaster.Model.BlocksModule.BlockMasterElement;

namespace Game.Block.Factory
{
    /// <summary>
    ///     
    /// </summary>
    public class VanillaIBlockTemplates
    {
        public readonly Dictionary<string, IBlockTemplate> BlockTypesDictionary;
        
        public VanillaIBlockTemplates(IBlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            var blockInventoryEvent = blockInventoryUpdateEvent as BlockOpenableInventoryUpdateEvent;
            
            //TODO 
            BlockTypesDictionary = new Dictionary<string, IBlockTemplate>();
            BlockTypesDictionary.Add(BlockTypeConst.Block, new VanillaDefaultBlock());
            BlockTypesDictionary.Add(BlockTypeConst.BeltConveyor, new VanillaBeltConveyorTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.ElectricPole, new VanillaElectricPoleTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.Chest, new VanillaChestTemplate());
            
            BlockTypesDictionary.Add(BlockTypeConst.ElectricMachine, new VanillaMachineTemplate(blockInventoryEvent));
            BlockTypesDictionary.Add(BlockTypeConst.ElectricGenerator, new VanillaPowerGeneratorTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.ElectricMiner, new VanillaMinerTemplate(blockInventoryEvent));
            
            BlockTypesDictionary.Add(BlockTypeConst.ItemShooter, new VanillaItemShooterTemplate());
            
            BlockTypesDictionary.Add(BlockTypeConst.Gear, new VanillaGearTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.Shaft, new VanillaShaftTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.SimpleGearGenerator, new VanillaSimpleGearGeneratorTemplate());
            BlockTypesDictionary.Add(BlockTypeConst.GearMiner, new VanillaGearMinerTemplate(blockInventoryEvent));
            BlockTypesDictionary.Add(BlockTypeConst.GearMachine, new VanillaGearMachineTemplate(blockInventoryEvent));
            BlockTypesDictionary.Add(BlockTypeConst.GearBeltConveyor, new VanillaGearBeltConveyorTemplate());
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/BlockPlaceToConnectionBlockTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Block.Blocks.Chest;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.World.Interface.DataStore;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    /// <summary>
    ///     
    /// </summary>
    public class BlockPlaceToConnectionBlockTest
    {
        /// <summary>
        ///     
        ///     
        /// </summary>
        [Test]
        public void BeltConveyorConnectMachineTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            //
            BlockPlaceToGetMachineIdAndConnectorId(
                0, 10,
                0, 9, BlockDirection.North, blockFactory, world);
            
            //
            BlockPlaceToGetMachineIdAndConnectorId(
                10, 0,
                9, 0, BlockDirection.East, blockFactory, world);
            
            //
            BlockPlaceToGetMachineIdAndConnectorId(
                0, -10,
                0, -9, BlockDirection.South, blockFactory, world);
            
            //
            BlockPlaceToGetMachineIdAndConnectorId(
                -10, 0,
                -9, 0, BlockDirection.West, blockFactory, world);
        }
        
        private void BlockPlaceToGetMachineIdAndConnectorId(
            int machineX, int machineZ,
            int conveyorX, int conveyorZ,
            BlockDirection direction, IBlockFactory blockFactory, IWorldBlockDatastore world)
        {
            //
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(machineX, 0, machineZ), direction, out var vanillaMachine);
            
            //
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(conveyorX, 0, conveyorZ), direction, out var beltConveyor);
            
            //
            var connectedMachine = (VanillaMachineBlockInventoryComponent)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets.First().Key;
            
            //
            var machineInventory = vanillaMachine.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            Assert.IsTrue(connectedMachine == machineInventory);
        }
        
        /// <summary>
        ///     
        ///     
        ///     
        /// </summary>
        [Test]
        public void MachineConnectToBeltConveyorTest()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            var blockFactory = ServerContext.BlockFactory;
            
            //
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var vanillaMachine);
            
            //4
            var beltConveyorTransforms = new List<(Vector3Int, BlockDirection)>
            {
                (new Vector3Int(1, 0, 0), BlockDirection.North),
                (new Vector3Int(0, 0, 1), BlockDirection.East),
                (new Vector3Int(-1, 0, 0), BlockDirection.South),
                (new Vector3Int(0, 0, -1), BlockDirection.West),
            };
            foreach (var (position, direction) in beltConveyorTransforms) world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, position, direction, out _);
            
            //
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)vanillaMachine.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            Assert.AreEqual(4, connectInventory.Count);
            
            //
            world.RemoveBlock(new Vector3Int(1, 0, 0));
            world.RemoveBlock(new Vector3Int(-1, 0, 0));
            //
            Assert.AreEqual(2, connectInventory.Count);
            world.RemoveBlock(new Vector3Int(0, 0, 1));
            world.RemoveBlock(new Vector3Int(0, 0, -1));
            
            //
            Assert.AreEqual(0, connectInventory.Count);
        }
        
        
        /// <summary>
        ///     
        ///     
        /// </summary>
        [Test]
        public void BeltConveyorToChestConnectTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            //
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 0), BlockDirection.North, out var vanillaChest);
            
            
            //
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(0, 0, -1), BlockDirection.North, vanillaChest);
            
            //
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(-1, 0, 0), BlockDirection.East, vanillaChest);
            
            //
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(0, 0, 1), BlockDirection.South, vanillaChest);
            
            //
            BeltConveyorPlaceAndCheckConnector(new Vector3Int(1, 0, 0), BlockDirection.West, vanillaChest);
        }
        
        private void BeltConveyorPlaceAndCheckConnector(Vector3Int beltConveyorPos, BlockDirection direction, IBlock targetChest)
        {
            ServerContext.WorldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, beltConveyorPos, direction, out var northBeltConveyor);
            
            var connector = (VanillaChestComponent)northBeltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets.First().Key;
            
            Assert.AreEqual(targetChest.BlockInstanceId, connector.BlockInstanceId);
        }
        
        /// <summary>
        ///     ()
        /// </summary>
        [Test]
        public void NotConnectableBlockTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            
            //
            world.TryAddBlock(ForUnitTestModBlockId.MachineId, new Vector3Int(0, 0), BlockDirection.North, out var machine);
            world.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 1), BlockDirection.North, out var chest);
            
            //
            var machineConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)machine.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            //
            Assert.AreEqual(0, machineConnectInventory.Count);
            
            //
            var chestConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)chest.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            //
            Assert.AreEqual(0, chestConnectInventory.Count);
        }
        
        
        /// <summary>
        ///     1x1x1
        /// </summary>
        [Test]
        public void MultiBlockConnectTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var world = ServerContext.WorldBlockDatastore;
            
            //
            
            //
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(2, 0, 3), BlockDirection.North, out _);
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(2, 0, -1), BlockDirection.South, out _);
            
            //
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(3, 0, 3), BlockDirection.North, out _);
            world.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(1, 0, -1), BlockDirection.South, out _);
            
            //
            world.TryAddBlock(ForUnitTestModBlockId.MultiBlockGeneratorId, new Vector3Int(0, 0), BlockDirection.North, out var multiBlock);
            
            // 
            var connector = (Dictionary<IBlockInventory, ConnectedInfo>)multiBlock.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            
            // 
            Assert.AreEqual(2, connector.Count);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/PlaceSystem/BlockPlaceSystem.cs
```cs
using System;
using System.Collections.Generic;
using ClassLibrary;
using Client.Common;
using Client.Game.InGame.Block;
using Client.Game.InGame.Context;
using Client.Game.InGame.Player;
using Client.Game.InGame.SoundEffect;
using Client.Game.InGame.UI.Inventory;
using Client.Game.InGame.UI.Inventory.Main;
using Client.Input;
using Core.Master;
using Game.Block.Interface;
using Game.PlayerInventory.Interface;
using Server.Protocol.PacketResponse;
using UnityEngine;
using UnityEngine.EventSystems;
using VContainer.Unity;

namespace Client.Game.InGame.BlockSystem.PlaceSystem
{
    /// <summary>
    ///     
    /// </summary>
    public class BlockPlaceSystem : IPostTickable
    {
        public static BlockPlaceSystem Instance;
        
        private const float PlaceableMaxDistance = 100f;
        private readonly IBlockPlacePreview _blockPlacePreview;
        private readonly HotBarView _hotBarView;
        private readonly ILocalPlayerInventory _localPlayerInventory;
        private readonly Camera _mainCamera;
        private readonly PlayerObjectController _playerObjectController;
        private readonly BlockPlacePointCalculator _blockPlacePointCalculator;
        
        private BlockDirection _currentBlockDirection = BlockDirection.North;
        private Vector3Int? _clickStartPosition;
        private int _clickStartHeightOffset;
        private int _baseHeight;
        private bool? _isStartZDirection;
        private List<PlaceInfo> _currentPlaceInfos = new();
        
        private bool _enableBlockPlace;
        
        private int _heightOffset;
        
        public BlockPlaceSystem(
            Camera mainCamera,
            HotBarView hotBarView,
            IBlockPlacePreview blockPlacePreview,
            ILocalPlayerInventory localPlayerInventory,
            BlockGameObjectDataStore blockGameObjectDataStore,
            PlayerObjectController playerObjectController
        )
        {
            Instance = this;
            _hotBarView = hotBarView;
            _mainCamera = mainCamera;
            _blockPlacePreview = blockPlacePreview;
            _localPlayerInventory = localPlayerInventory;
            _playerObjectController = playerObjectController;
            _blockPlacePointCalculator = new BlockPlacePointCalculator(blockGameObjectDataStore);
        }
        
        public static void SetEnableBlockPlace(bool enable)
        {
            if (Instance == null) return;
            
            Instance._enableBlockPlace = enable;
            
            if (enable)
            {
                Instance._clickStartHeightOffset = -1;
                Instance._baseHeight = Mathf.RoundToInt(Instance._playerObjectController.Position.y);
            }
            else
            {
                Instance._blockPlacePreview.SetActive(false);
            }
        }
        
        public void PostTick()
        {
            if (!_enableBlockPlace) return;
            
            UpdateHeightOffset();
            BlockDirectionControl();
            GroundClickControl();
            
            #region Internal
            
            void UpdateHeightOffset()
            {
                if (UnityEngine.Input.GetKeyDown(KeyCode.Q)) //TODO InputManager
                    _heightOffset--;
                else if (UnityEngine.Input.GetKeyDown(KeyCode.E)) _heightOffset++;
            }
            
            void BlockDirectionControl()
            {
                if (InputManager.Playable.BlockPlaceRotation.GetKeyDown)
                    // 
                    _currentBlockDirection = _currentBlockDirection.HorizonRotation();
                
                //TODo 
                if (UnityEngine.Input.GetKey(KeyCode.LeftShift) && InputManager.Playable.BlockPlaceRotation.GetKeyDown)
                    _currentBlockDirection = _currentBlockDirection.VerticalRotation();
            }
            
            #endregion
        }
        
        private int _lastSelectedIndex = -1;
        
        private void GroundClickControl()
        {
            var selectIndex = _hotBarView.SelectIndex;
            if (selectIndex != _lastSelectedIndex)
            {
                _clickStartPosition = null;
                _lastSelectedIndex = selectIndex;
                _clickStartHeightOffset = _heightOffset;
            }
            
            var itemId = _localPlayerInventory[PlayerInventoryConst.HotBarSlotToInventorySlot(selectIndex)].Id;
            var hitPoint = Vector3.zero;
            
            //
            _blockPlacePreview.SetActive(false);
            
            if (!MasterHolder.BlockMaster.IsBlock(itemId)) return; // 
            if (!TryGetRayHitPosition(out hitPoint, out var boundingBoxSurface)) return; // ray
            
            // calculate place point
            var blockId = MasterHolder.BlockMaster.GetBlockId(itemId);
            var holdingBlockMaster = MasterHolder.BlockMaster.GetBlockMaster(blockId);
            var placePoint = CalcPlacePoint();
            
            if (!IsBlockPlaceableDistance(PlaceableMaxDistance)) return; // 
            
            _blockPlacePreview.SetActive(true);
            
            //UI
            if (InputManager.Playable.ScreenLeftClick.GetKeyDown && !EventSystem.current.IsPointerOverGameObject())
            {
                _clickStartPosition = placePoint;
                _clickStartHeightOffset = _heightOffset;
            }
            
            //
            //display preview and get collision with ground
            var groundDetects = new List<bool>();
            if (_clickStartPosition.HasValue)
            {
                if (_clickStartPosition.Value == placePoint)
                {
                    _isStartZDirection = null;
                }
                else if (!_isStartZDirection.HasValue)
                {
                    _isStartZDirection = Mathf.Abs(placePoint.z - _clickStartPosition.Value.z) > Mathf.Abs(placePoint.x - _clickStartPosition.Value.x);
                }
                
                _currentPlaceInfos = _blockPlacePointCalculator.CalculatePoint(_clickStartPosition.Value, placePoint, _isStartZDirection ?? true, _currentBlockDirection, holdingBlockMaster);
                groundDetects = _blockPlacePreview.SetPreviewAndGroundDetect(_currentPlaceInfos, holdingBlockMaster);
            }
            else
            {
                _isStartZDirection = null;
                _currentPlaceInfos = _blockPlacePointCalculator.CalculatePoint(placePoint, placePoint, true, _currentBlockDirection, holdingBlockMaster);
                groundDetects = _blockPlacePreview.SetPreviewAndGroundDetect(_currentPlaceInfos, holdingBlockMaster);
            }
            
            // Placeable
            // update placeable
            for (var i = 0; i < groundDetects.Count; i++)
            {
                // 
                // if collision with ground, cannot place
                if (groundDetects[i])
                {
                    _currentPlaceInfos[i].Placeable = false;
                }
            }
            
            // 
            // send block place info to server
            if (InputManager.Playable.ScreenLeftClick.GetKeyUp)
            {
                _heightOffset = _clickStartHeightOffset;
                _clickStartPosition = null;
                ClientContext.VanillaApi.SendOnly.PlaceHotBarBlock(_currentPlaceInfos, selectIndex);
                SoundEffectManager.Instance.PlaySoundEffect(SoundEffectType.PlaceBlock);
            }
            
            #region Internal
            
            bool IsBlockPlaceableDistance(float maxDistance)
            {
                var placePosition = (Vector3)placePoint;
                var playerPosition = _playerObjectController.transform.position;
                
                return Vector3.Distance(playerPosition, placePosition) <= maxDistance;
            }
            
            Vector3Int CalcPlacePoint()
            {
                var rotateAction = _currentBlockDirection.GetCoordinateConvertAction();
                var rotatedSize = rotateAction(holdingBlockMaster.BlockSize).Abs();
                
                if (boundingBoxSurface == null)
                {
                    var point = Vector3Int.zero;
                    point.x = Mathf.FloorToInt(hitPoint.x + (rotatedSize.x % 2 == 0 ? 0.5f : 0));
                    point.z = Mathf.FloorToInt(hitPoint.z + (rotatedSize.z % 2 == 0 ? 0.5f : 0));
                    point.y = Mathf.FloorToInt(hitPoint.y);
                    
                    point += new Vector3Int(0, _heightOffset, 0);
                    point -= new Vector3Int(rotatedSize.x, 0, rotatedSize.z) / 2;
                    
                    return point;
                }
                
                switch (boundingBoxSurface.PreviewSurfaceType)
                {
                    case PreviewSurfaceType.YX_Origin:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z) - Mathf.RoundToInt(rotatedSize.z / 2f)
                        );
                    case PreviewSurfaceType.YX_Z:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z) + Mathf.RoundToInt(rotatedSize.z / 2f)
                        );
                    case PreviewSurfaceType.YZ_Origin:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x) - Mathf.RoundToInt(rotatedSize.x / 2f),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z)
                        );
                    case PreviewSurfaceType.YZ_X:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x) + Mathf.RoundToInt(rotatedSize.x / 2f),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z)
                        );
                    
                    case PreviewSurfaceType.XZ_Origin:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x),
                            Mathf.FloorToInt(hitPoint.y) - rotatedSize.y,
                            Mathf.FloorToInt(hitPoint.z)
                        );
                    case PreviewSurfaceType.XZ_Y:
                        return new Vector3Int(
                            Mathf.FloorToInt(hitPoint.x),
                            Mathf.FloorToInt(hitPoint.y),
                            Mathf.FloorToInt(hitPoint.z)
                        );
                    
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
            
            #endregion
        }
        
        
        private bool TryGetRayHitPosition(out Vector3 pos,out BlockPreviewBoundingBoxSurface surface)
        {
            surface = null;
            pos = Vector3Int.zero;
            var ray = _mainCamera.ScreenPointToRay(UnityEngine.Input.mousePosition);
            
            //ray
            if (!Physics.Raycast(ray, out var hit, float.PositiveInfinity, LayerConst.Without_Player_MapObject_Block_LayerMask)) return false;
            //ray
            if (
                !hit.transform.TryGetComponent<GroundGameObject>(out _) &&
                !hit.transform.TryGetComponent(out surface)
            )
            {
                return false;
            }
            
            //0,0ray
            pos = hit.point;
            
            return true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaMachineProcessorComponent.cs
```cs
using System;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Blocks.Util;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.EnergySystem;
using MessagePack;
using Mooresmaster.Model.MachineRecipesModule;
using UniRx;

namespace Game.Block.Blocks.Machine
{
    public class VanillaMachineProcessorComponent : IBlockStateObservable, IUpdatableBlockComponent
    {
        public ProcessState CurrentState { get; private set; } = ProcessState.Idle;
        
        public double RemainingSecond { get; private set; }
        
        public Guid RecipeGuid => _processingRecipe?.MachineRecipeGuid ?? Guid.Empty;
        public IObservable<Unit> OnChangeBlockState => _changeState;
        private readonly Subject<Unit> _changeState = new();
        
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        
        public readonly ElectricPower RequestPower;
        
        private ElectricPower _currentPower;
        private ProcessState _lastState = ProcessState.Idle;
        private MachineRecipeMasterElement _processingRecipe;
        
        
        public VanillaMachineProcessorComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            MachineRecipeMasterElement machineRecipe, ElectricPower requestPower)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            _processingRecipe = machineRecipe;
            RequestPower = requestPower;
            
            //TODO 
        }
        
        public VanillaMachineProcessorComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            ProcessState currentState, double remainingSecond, MachineRecipeMasterElement processingRecipe,
            ElectricPower requestPower)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            
            _processingRecipe = processingRecipe;
            RequestPower = requestPower;
            RemainingSecond = remainingSecond;
            
            CurrentState = currentState;
        }
        
        
        public BlockStateDetail GetBlockStateDetail()
        {
            BlockException.CheckDestroy(this);
            
            var processingRate = _processingRecipe != null ? 1 - (float)RemainingSecond / _processingRecipe.Time : 0;
            var stateDetail = new CommonMachineBlockStateDetail(_currentPower.AsPrimitive(), RequestPower.AsPrimitive(), processingRate, CurrentState.ToStr(), _lastState.ToStr());
            var currentState = MessagePackSerializer.Serialize(stateDetail);
            return new BlockStateDetail(CommonMachineBlockStateDetail.BlockStateDetailKey, currentState);
        }
        
        public void SupplyPower(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            _currentPower = power;
        }
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            switch (CurrentState)
            {
                case ProcessState.Idle:
                    Idle();
                    break;
                case ProcessState.Processing:
                    Processing();
                    break;
            }
            
            //
            if (_lastState != CurrentState || CurrentState == ProcessState.Processing)
            {
                _changeState.OnNext(Unit.Default);
                _lastState = CurrentState;
            }
        }
        
        private void Idle()
        {
            var isGetRecipe = _vanillaMachineInputInventory.TryGetRecipeElement(out var recipe);
            var isStartProcess = CurrentState == ProcessState.Idle && isGetRecipe &&
                   _vanillaMachineInputInventory.IsAllowedToStartProcess() &&
                   _vanillaMachineOutputInventory.IsAllowedToOutputItem(recipe);
            
            if (isStartProcess)
            {
                CurrentState = ProcessState.Processing;
                _processingRecipe = recipe;
                _vanillaMachineInputInventory.ReduceInputSlot(_processingRecipe);
                RemainingSecond = _processingRecipe.Time;
            }
        }
        
        private void Processing()
        {
            RemainingSecond -= MachineCurrentPowerToSubSecond.GetSubSecond(_currentPower, RequestPower);
            if (RemainingSecond <= 0)
            {
                CurrentState = ProcessState.Idle;
                _vanillaMachineOutputInventory.InsertOutputSlot(_processingRecipe);
            }
            
            //
            _currentPower = new ElectricPower(0);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
    
    public static class ProcessStateExtension
    {
        /// <summary>
        ///     <see cref="ProcessState" />String
        ///     EnumToString
        /// </summary>
        public static string ToStr(this ProcessState state)
        {
            return state switch
            {
                ProcessState.Idle => VanillaMachineBlockStateConst.IdleState,
                ProcessState.Processing => VanillaMachineBlockStateConst.ProcessingState,
                _ => throw new ArgumentOutOfRangeException(nameof(state), state, null),
            };
        }
    }
    
    public enum ProcessState
    {
        Idle,
        Processing,
    }
}
```

moorestech_server/Assets/Scripts/Game.EnergySystem/EnergySegment.cs
```cs
using System.Collections.Generic;
using Core.Update;
using Game.Block.Interface;
using UniRx;

namespace Game.EnergySystem
{
    /// <summary>
    ///     
    /// </summary>
    public class EnergySegment
    {
        private readonly Dictionary<BlockInstanceId, IElectricConsumer> _consumers = new();
        private readonly Dictionary<BlockInstanceId, IElectricTransformer> _energyTransformers = new();
        private readonly Dictionary<BlockInstanceId, IElectricGenerator> _generators = new();
        
        public EnergySegment()
        {
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        public IReadOnlyDictionary<BlockInstanceId, IElectricConsumer> Consumers => _consumers;
        
        public IReadOnlyDictionary<BlockInstanceId, IElectricGenerator> Generators => _generators;
        
        public IReadOnlyDictionary<BlockInstanceId, IElectricTransformer> EnergyTransformers => _energyTransformers;
        
        private void Update()
        {
            //
            var powers = new ElectricPower(0);
            foreach (var key in _generators.Keys) powers += _generators[key].OutputEnergy();
            
            //
            var requester = new ElectricPower(0);
            foreach (var key in _consumers.Keys) requester += _consumers[key].RequestEnergy;
            
            //
            var powerRate = powers / requester;
            if (1 < powerRate.AsPrimitive()) powerRate = new ElectricPower(1);
            
            //
            foreach (var key in _consumers.Keys)
                _consumers[key].SupplyEnergy(_consumers[key].RequestEnergy * powerRate);
        }
        
        public void AddEnergyConsumer(IElectricConsumer electricConsumer)
        {
            if (_consumers.ContainsKey(electricConsumer.BlockInstanceId)) return;
            _consumers.Add(electricConsumer.BlockInstanceId, electricConsumer);
        }
        
        public void RemoveEnergyConsumer(IElectricConsumer electricConsumer)
        {
            if (!_consumers.ContainsKey(electricConsumer.BlockInstanceId)) return;
            _consumers.Remove(electricConsumer.BlockInstanceId);
        }
        
        public void AddGenerator(IElectricGenerator generator)
        {
            if (_generators.ContainsKey(generator.BlockInstanceId)) return;
            _generators.Add(generator.BlockInstanceId, generator);
        }
        
        public void RemoveGenerator(IElectricGenerator generator)
        {
            if (!_generators.ContainsKey(generator.BlockInstanceId)) return;
            _generators.Remove(generator.BlockInstanceId);
        }
        
        public void AddEnergyTransformer(IElectricTransformer electricTransformer)
        {
            if (_energyTransformers.ContainsKey(electricTransformer.BlockInstanceId)) return;
            _energyTransformers.Add(electricTransformer.BlockInstanceId, electricTransformer);
        }
        
        public void RemoveEnergyTransformer(IElectricTransformer electricTransformer)
        {
            if (!_energyTransformers.ContainsKey(electricTransformer.BlockInstanceId)) return;
            _energyTransformers.Remove(electricTransformer.BlockInstanceId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Template/CraftChainerTransporterTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Factory.BlockTemplate;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.CraftChainer.BlockComponent.Template
{
    public class CraftChainerTransporterTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var transporterParam = blockMasterElement.BlockParam as CraftChainerTransporterBlockParam;
            
            var transporterComponent = componentStates == null ?
                new CraftChainerTransporterComponent() :
                new CraftChainerTransporterComponent(componentStates);
            
            var slopeType = transporterParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            var connectorComponent = BlockTemplateUtil.CreateInventoryConnector(transporterParam.InventoryConnectors, blockPositionInfo);
            var beltConveyorConnector = new CraftChainerTransporterInserter(connectorComponent, transporterComponent.NodeId);
            var itemCount = transporterParam.TransporterConveyorItemCount;
            var time = transporterParam.TimeOfItemEnterToExit;
            
            var beltComponent = componentStates == null ?
                new VanillaBeltConveyorComponent(itemCount, time, beltConveyorConnector, slopeType) :
                new VanillaBeltConveyorComponent(componentStates, itemCount, time, beltConveyorConnector, slopeType);
            
            var components = new List<IBlockComponent>
            {
                beltComponent,
                connectorComponent,
                transporterComponent,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/Generate/GeneratedJson.cs
```cs
using System.IO;
using System.Runtime.Serialization.Json;
using NUnit.Framework;
using UnityEngine;

namespace Tests.CombinedTest.Core.Generate
{
    /// <summary>
    ///     
    /// </summary>
    public class GeneratedJson
    {
        [Test]
        public void Json()
        {
            var seed = 2119350917;
            var recipeNum = 40;
            var recipe = RecipeGenerate.MakeRecipe(seed, recipeNum);
            
            // JSON
            var st = new MemoryStream(); // 
            var serializer = new DataContractJsonSerializer(typeof(Recipe)); // 
            serializer.WriteObject(st, recipe); // 
            
            // 
            st.Position = 0;
            var reader = new StreamReader(st);
            Debug.Log(reader.ReadToEnd());
            
            
            Assert.True(true);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/MachineRecipeMaster.cs
```cs
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.MachineRecipesModule;

namespace Core.Master
{
    public static class MachineRecipeMasterUtil
    {
        public static bool TryGetRecipeElement(BlockId blockId, IReadOnlyList<IItemStack> inputSlot,out MachineRecipeMasterElement recipe)
        {
            var itemIds = new List<ItemId>(inputSlot.Count);
            foreach (var inputItem in inputSlot)
            {
                if (inputItem.Id == ItemMaster.EmptyItemId) continue;
                itemIds.Add(inputItem.Id);
            }
            
            return MasterHolder.MachineRecipesMaster.TryGetRecipeElement(blockId, itemIds, out recipe);
        }
        
        public static bool RecipeConfirmation(this MachineRecipeMasterElement recipe, BlockId blockId, IReadOnlyList<IItemStack> inputSlot)
        {
            var recipeBlockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            if (recipeBlockId != blockId) return false;
            
            // 
            var okCnt = 0;
            foreach (var slot in inputSlot)
            {
                if (slot.Id == ItemMaster.EmptyItemId )
                { 
                  continue;  
                }
                var slotGuid = MasterHolder.ItemMaster.GetItemMaster(slot.Id).ItemGuid;
                okCnt += recipe.InputItems.Count(input => slotGuid == input.ItemGuid && input.Count <= slot.Count);
            }
            
            return okCnt == recipe.InputItems.Length;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/CraftChainerTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.CraftChainer.BlockComponent;
using Game.CraftChainer.BlockComponent.Computer;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.CraftChain;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using static Tests.Module.TestMod.ForUnitTestModBlockId;

namespace Tests.CombinedTest.Game
{
    public class CraftChainerTest
    {
        public ItemId ItemAId;
        public ItemId ItemBId;
        public ItemId ItemCId;
        
        [SetUp]
        public void SetupCraftChainerTest()
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            Guid itemAGuid = new("189672cb-6811-4080-bde1-1f9ff0ec63ff");
            Guid itemBGuid = new("547791fe-bfd8-4748-aafa-c7449391eca5");
            Guid itemCGuid = new("c8d16ba4-8a7d-4ab1-80a4-5a9c0a119627");
            ItemAId = MasterHolder.ItemMaster.GetItemId(itemAGuid);
            ItemBId = MasterHolder.ItemMaster.GetItemId(itemBGuid);
            ItemCId = MasterHolder.ItemMaster.GetItemId(itemCGuid);
        }
        
        [Test]
        public void CreateItemA1ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 5),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 1, true);
        }
        
        [Test]
        public void CreateItemA2ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 10),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 2, true);
        }
        
        [Test]
        public void CreateItemA3ChainerTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 15),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 3, true);
        }
        
        [Test]
        public void CreateItemBTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 2),
            };
            ExecuteChainerCraftTest(chestItems, ItemBId, 1, true);
        }
        
        [Test]
        public void NoneItemFailCraftTest()
        {
            ExecuteChainerCraftTest(new List<(ItemId id,int count)>(), ItemAId, 1, false);
        }
        
        [Test]
        public void OneItemIsNotEnoughFailCraftTest()
        {
            var chestItems = new List<(ItemId id,int count)>
            {
                (ItemCId, 4),
            };
            ExecuteChainerCraftTest(chestItems, ItemAId, 1, false);
        }
        
        public void ExecuteChainerCraftTest(List<(ItemId id,int count)> materials, ItemId targetId, int targetCount, bool isSuccess)
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            // 
            // Create a network
            var network = CreateNetwork();
            
            // 
            // Set items in the provider chest
            var materialItemStacks = new List<IItemStack>();
            foreach (var (id, count) in materials)
            {
                var item = ServerContext.ItemStackFactory.Create(id, count);
                materialItemStacks.Add(item);
            }
            network.SetProviderChestItem(materialItemStacks);
            
            // 
            // Item creation request to the main computer
            var success = network.SetRequestMainComputer(targetId, targetCount);
            Assert.AreEqual(isSuccess, success);
            
            // 
            if (!isSuccess)
            {
                return;
            }
            
            // 10
            // Fail if not crafted after 10 seconds
            var now = DateTime.Now;
            
            while (true)
            {
                try
                {
                    GameUpdater.UpdateWithWait();
                }
                catch (Exception e)
                {
                    ExportItemLog();
                    Debug.LogException(e);
                    throw;
                }
                
                if (network.OnMainComputerItemExist(targetId, targetCount))
                {
                    Debug.Log("Success Time:" + (DateTime.Now - now).TotalSeconds);
                    Assert.Pass();
                    break;
                }
                
                if (DateTime.Now - now > TimeSpan.FromSeconds(10))
                {
                    ExportItemLog();
                    var block = ServerContext.WorldBlockDatastore.GetBlock(new Vector3Int(2, 0, 1));
                    Assert.Fail("Failed to create item");
                }
            }
        }
        
        
        private void ExportItemLog()
        {
            foreach (var blocks in ServerContext.WorldBlockDatastore.BlockMasterDictionary.Values)
            {
                if (!blocks.Block.ComponentManager.TryGetComponent<IBlockInventory>(out var blockComponent))
                {
                    continue;
                }
                
                var slotSize = blockComponent.GetSlotSize();
                for (int i = 0; i < slotSize; i++)
                {
                    var item = blockComponent.GetItem(i);
                    if (item.Id == ItemMaster.EmptyItemId)
                    {
                        continue;
                    }
                    
                    var pos = blocks.BlockPositionInfo.OriginalPos;
                    var type = blocks.Block.BlockMasterElement.BlockType;
                    var itemName = MasterHolder.ItemMaster.GetItemMaster(item.Id).Name;
                    Debug.Log($"Type:{type} {pos} Slot:{i}, ItemName: \"{itemName}\" Count: {item.Count}");
                }
            }
        }
        
        private CraftChainerTestNetworkContainer CreateNetwork()
        {
            //
            // Image diagram
            // https://miro.com/app/board/uXjVOPclBmk=/?moveToWidget=3458764607209547942&cot=10

            // 
            // Parts of the craft chainer
            AddBlock(CraftChainerTransporter, 1, 0, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 0, 1, BlockDirection.South);
            AddBlock(CraftChainerTransporter, 1, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 2, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 3, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 3, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 4, 1, BlockDirection.East);
            AddBlock(CraftChainerTransporter, 4, 0, BlockDirection.South);
            AddBlock(CraftChainerTransporter, 4, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 3, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 2, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 1, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, 0, -1, BlockDirection.West);
            AddBlock(CraftChainerTransporter, -1, -1, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 0, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 1, BlockDirection.North);
            AddBlock(CraftChainerTransporter, -1, 2, BlockDirection.East);
            var providerChest = AddBlock(CraftChainerProviderChest, 0, 2, BlockDirection.North);
            var crafter1 = AddBlock(CraftChainerCrafter, 2, 2, BlockDirection.North); // C -> B
            var crafter2 = AddBlock(CraftChainerCrafter, 4, 2, BlockDirection.North); // B + C -> A
            var mainComputer = AddBlock(CraftChainerMainComputer, 0, 0, BlockDirection.North);
            
            // 
            // Parts of the factory
            AddBlock(CraftChainerBeltConveyor, 2, 3, BlockDirection.North);
            AddBlock(CraftChainerBeltConveyor, 4, 3, BlockDirection.North);
            
            AddBlock(CraftChainerBeltConveyor, 0, 5, BlockDirection.South);
            AddBlock(CraftChainerBeltConveyor, 1, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 2, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 3, 5, BlockDirection.West);
            AddBlock(CraftChainerBeltConveyor, 4, 5, BlockDirection.West);
            
            AddBlock(CraftChainerBeltConveyor, 0, 4, BlockDirection.South);
            AddBlock(CraftChainerBeltConveyor, 0, 3, BlockDirection.South);
            AddBlock(CraftChainerMachine1, 2, 4, BlockDirection.North); // C -> B
            AddBlock(CraftChainerMachine2, 4, 4, BlockDirection.North); // B + C -> A
            
            var container = new CraftChainerTestNetworkContainer(mainComputer, crafter1, crafter2, providerChest);
            
            // 
            // Recipe setting
            var inputItem1 = new List<CraftingSolverItem>
            {
                new(ItemCId, 2),
            };
            var outputItem1 = new List<CraftingSolverItem>
            {
                new(ItemBId, 1),
            };
            container.SetCrafter1Recipe(inputItem1, outputItem1);
            
            var inputItem2 = new List<CraftingSolverItem>
            {
                new(ItemBId, 2),
                new(ItemCId, 1),
            };
            var outputItem2 = new List<CraftingSolverItem>
            {
                new(ItemAId, 1),
            };
            container.SetCrafter2Recipe(inputItem2, outputItem2);
            
            // assert chain network
            var computerComputer = mainComputer.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
            Assert.AreEqual(computerComputer.CraftChainerNetworkContext.CrafterComponents.Count, 2);
            Assert.AreEqual(computerComputer.CraftChainerNetworkContext.ProviderChests.Count, 1);
            
            
            return container;
        }
        
        private IBlock AddBlock(BlockId blockId, int x, int z, BlockDirection direction)
        {
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            worldBlockDatastore.TryAddBlock(blockId, new Vector3Int(x, 0, z), direction, out var block);
            
            return block;
        }
        
        public class CraftChainerTestNetworkContainer
        {
            public readonly IBlock MainComputer;
            public readonly IBlock Crafter1;
            public readonly IBlock Crafter2;
            public readonly IBlock ProviderChest;
            public CraftChainerTestNetworkContainer(IBlock mainComputer, IBlock crafter1, IBlock crafter2, IBlock providerChest)
            {
                MainComputer = mainComputer;
                Crafter1 = crafter1;
                Crafter2 = crafter2;
                ProviderChest = providerChest;
            }
            
            public void SetCrafter1Recipe(List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                SetCrafterRecipe(Crafter1, inputItems, outputItem);
            }
            public void SetCrafter2Recipe(List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                SetCrafterRecipe(Crafter2, inputItems, outputItem);
            }
            
            private void SetCrafterRecipe(IBlock crafter, List<CraftingSolverItem> inputItems, List<CraftingSolverItem> outputItem)
            {
                var crafterComponent = crafter.ComponentManager.GetComponent<CraftCraftChainerCrafterComponent>();
                crafterComponent.SetRecipe(inputItems, outputItem);
            }
            
            public void SetProviderChestItem(List<IItemStack> items)
            {
                var chestComponent = ProviderChest.ComponentManager.GetComponent<VanillaChestComponent>();
                chestComponent.InsertItem(items);
            }
            
            public bool SetRequestMainComputer(ItemId item, int count)
            {
                var mainComputerComponent = MainComputer.ComponentManager.GetComponent<CraftChainerMainComputerComponent>();
                return mainComputerComponent.StartCreateItem(item, count);
            }
            
            public bool OnMainComputerItemExist(ItemId targetItem, int count)
            {
                var chest = MainComputer.ComponentManager.GetComponent<VanillaChestComponent>();
                
                var existCount = 0;
                foreach (var item in chest.InventoryItems)
                {
                    if (item.Id == targetItem)
                    {
                        existCount += item.Count;
                    }
                }
                
                return existCount >= count;
            }
        }
    }
    
}
```

moorestech_server/Assets/Scripts/Game.Train/Blocks/StationComponent.cs
```cs
using Game.Block.Interface.Component;
using Game.Train.Train;
namespace Game.Train.Blocks
{
    public class StationComponent : IBlockComponent
    {
        public string StationName { get; }

        // 
        private int _stationLength;

        // 
        private TrainUnit _currentTrain;

        // IBlockComponent
        public bool IsDestroy { get; private set; }

        public StationComponent(int stationLength, string stationName = "DefaultStation")
        {
            _stationLength = stationLength;
            _currentTrain = null;
            IsDestroy = false;
            StationName = stationName;
        }


        // 
        public bool TrainArrived(TrainUnit train)
        {
            // 
            if (_currentTrain != null)
            {
                return false;
            }

            // 
            _currentTrain = train;
            return true;
        }

        // 
        public bool TrainDeparted(TrainUnit train)
        {
            // 
            if (_currentTrain == null)
            {
                return false;
            }

            // 
            _currentTrain = null;
            return true;
        }


        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Transporter/CraftChainerTransporterInserter.cs
```cs
using Core.Item.Interface;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;
using Game.CraftChainer.CraftNetwork;

namespace Game.CraftChainer.BlockComponent
{
    /// <summary>
    /// 
    /// Class for determining which craft node the item should be inserted into and inserting it
    /// </summary>
    public class CraftChainerTransporterInserter : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        private readonly CraftChainerNodeId _startChainerNodeId;
        
        public CraftChainerTransporterInserter(BlockConnectorComponent<IBlockInventory> blockConnectorComponent, CraftChainerNodeId startChainerNodeId)
        {
            _blockConnectorComponent = blockConnectorComponent;
            _startChainerNodeId = startChainerNodeId;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            var context = CraftChainerMainComputerManager.Instance.GetChainerNetworkContext(_startChainerNodeId);
            if (context == null)
            {
                return itemStack;
            }
            
            // transporter1
            // In the case of a transporter, it is assumed that the item has already been reduced to one
            return context.InsertNodeNetworkNextBlock(itemStack, _startChainerNodeId, _blockConnectorComponent);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/Define/ItemObjectContainer.cs
```cs
using System;
using Client.Common;
using Core.Const;
using Core.Master;
using UnityEngine;

namespace Client.Game.InGame.Define
{
    /// <summary>
    ///     TODO alpha2.0
    /// </summary>
    [Obsolete("Alpha2.0")]
    [CreateAssetMenu(fileName = "ItemObjectContainer", menuName = "moorestech/ItemObjectContainer", order = 0)]
    public class ItemObjectContainer : ScriptableObject
    {
        [SerializeField] private ItemObjectData[] itemObjects;
        
        public ItemObjectData GetItemPrefab(ItemId itemId)
        {
            var itemGuid = MasterHolder.ItemMaster.GetItemMaster(itemId).ItemGuid;
            foreach (var itemObject in itemObjects)
            {
                if (itemObject.ItemGuid == itemGuid)
                {
                    return itemObject;
                }
            }
            
            return null;
        }
    }
    
    [Serializable]
    public class ItemObjectData
    {
        public Guid ItemGuid => Guid.Parse(itemGuid);
        public GameObject ItemPrefab => itemPrefab;
        public Vector3 Position => position;
        public Vector3 Rotation => rotation;
        
        [SerializeField] private string itemGuid;
        [SerializeField] private GameObject itemPrefab;
        [SerializeField] private Vector3 position;
        [SerializeField] private Vector3 rotation;
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/Generate/RecipeGenerate.cs
```cs
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace Tests.CombinedTest.Core.Generate
{
    public static class RecipeGenerate
    {
        public static Recipe MakeRecipe(int seed, int recipeNum)
        {
            var random = new Random(seed);
            var recipes = new List<Recipes>();
            for (var i = 0; i < recipeNum; i++) recipes.Add(new Recipes(random));
            
            return new Recipe(recipes.ToArray());
        }
    }
    
    [DataContract]
    public class Recipe
    {
        [DataMember(Name = "recipes")] public Recipes[] Recipes;
        
        public Recipe(Recipes[] recipes)
        {
            Recipes = recipes;
        }
    }
    
    [DataContract]
    public class Recipes
    {
        [DataMember(Name = "BlockID")] public int BlockID;
        [DataMember(Name = "input")] public InputItem[] Input;
        [DataMember(Name = "output")] public OutputItem[] Output;
        [DataMember(Name = "time")] public int Time;
        
        public Recipes(Random r)
        {
            var inputNumber = r.Next(1, 11);
            var tmpInput = new List<InputItem>();
            for (var i = 0; i < inputNumber; i++)
            {
                //IDID
                int id;
                do
                {
                    id = r.Next(1, 1001);
                }
                while (tmpInput.Find(x => x.ID == id) != null);
                
                tmpInput.Add(new InputItem(id, r.Next(1, 101)));
            }
            
            Input = tmpInput.ToArray();
            
            
            var outputnum = r.Next(1, 11);
            var tmpOutput = new List<OutputItem>();
            for (var i = 0; i < outputnum; i++)
            {
                //IDID
                var id = r.Next(1, 1001);
                while (tmpOutput.Find(x => x.ID == id) != null) id = r.Next(1, 1001);
                
                tmpOutput.Add(new OutputItem(id, r.Next(1, 101), 1));
            }
            
            Output = tmpOutput.ToArray();
            
            
            BlockID = r.Next(0, 101);
            Time = r.Next(1, 4) * 1000;
        }
    }
    
    [DataContract]
    public class InputItem
    {
        [DataMember(Name = "count")] public int Count;
        [DataMember(Name = "id")] public int ID;
        
        public InputItem(int id, int count)
        {
            ID = id;
            Count = count;
        }
    }
    
    [DataContract]
    public class OutputItem
    {
        [DataMember(Name = "count")] public int Count;
        [DataMember(Name = "id")] public int ID;
        [DataMember(Name = "percent")] public double Percent;
        
        public OutputItem(int id, int count, double percent)
        {
            ID = id;
            Count = count;
            Percent = percent;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BlockSystem.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Core.Update;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.State;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UniRx;
using UnityEngine;

namespace Game.Block.Blocks
{
    public class BlockSystem : IBlock
    {
        public BlockInstanceId BlockInstanceId { get; }
        public BlockId BlockId { get; }
        public Guid BlockGuid => BlockMasterElement.BlockGuid;
        public BlockMasterElement BlockMasterElement { get; }
        public IBlockComponentManager ComponentManager => _blockComponentManager;
        private readonly BlockComponentManager _blockComponentManager = new();
        public BlockPositionInfo BlockPositionInfo { get; }
        public IObservable<BlockState> BlockStateChange => _onBlockStateChange;
        private readonly Subject<BlockState> _onBlockStateChange = new();
        
        
        
        private readonly IDisposable _blockUpdateDisposable;
        
        private readonly List<IUpdatableBlockComponent> _updatableComponents;
        private readonly List<IBlockStateDetail> _blockStateDetails;
        
        
        public BlockSystem(BlockInstanceId blockInstanceId, Guid blockGuid, List<IBlockComponent> blockComponents, BlockPositionInfo blockPositionInfo)
        {
            BlockInstanceId = blockInstanceId;
            BlockPositionInfo = blockPositionInfo;
            BlockId = MasterHolder.BlockMaster.GetBlockId(blockGuid);
            BlockMasterElement = MasterHolder.BlockMaster.GetBlockMaster(BlockId);
            
            _blockComponentManager = new BlockComponentManager();
            _blockComponentManager.AddComponents(blockComponents);
            
            // 
            foreach (var blockState in _blockComponentManager.GetComponents<IBlockStateObservable>())
            {
                blockState.OnChangeBlockState.Subscribe(_ => { _onBlockStateChange.OnNext(GetBlockState()); });
            }
            
            // NOTE 
            _updatableComponents = _blockComponentManager.GetComponents<IUpdatableBlockComponent>();
            _blockStateDetails = _blockComponentManager.GetComponents<IBlockStateDetail>();
            
            _blockUpdateDisposable = GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        public BlockState GetBlockState()
        {
            var detailStates = new Dictionary<string, byte[]>();
            foreach (var component in _blockStateDetails)
            {
                var detailState = component.GetBlockStateDetail();
                detailStates.Add(detailState.Key, detailState.Value);
            }
            
            return new BlockState(detailStates);
        }
        
        public Dictionary<string,string> GetSaveState()
        {
            var result = new Dictionary<string, string>();
            
            var components = _blockComponentManager.GetComponents<IBlockSaveState>();
            foreach (var component in components)
            {
                var key = component.SaveKey;
                var value = component.GetSaveState();
                
                result.Add(key, value);
            }
            
            return result;
        }
        
        private void Update()
        {
            foreach (var component in _updatableComponents)
            {
                component.Update();
            }
        }
        
        public void Destroy()
        {
            _blockUpdateDisposable.Dispose();
            
            try
            {
                _blockComponentManager.Destroy();
            }
            catch (Exception e)
            {
                Debug.LogError("");
                Debug.LogException(e);
                throw;
            }
        }
        
        public bool Equals(IBlock other)
        {
            if (other is null) return false;
            return BlockInstanceId == other.BlockInstanceId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Core/Block/MachineRecipeConfigTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;

namespace Tests.UnitTest.Core.Block
{
    public class MachineRecipeConfigTest
    {
        /// <summary>
        ///     
        /// </summary>
        [TestCase(1, new int[2] { 1, 2 }, 3, 1)]
        [TestCase(1, new int[2] { 2, 1 }, 3, 1)]
        [TestCase(3, new int[3] { 1, 2, 3 }, 5, 1)]
        [TestCase(3, new int[3] { 2, 1, 3 }, 5, 1)]
        public void RecipeInputItemBlockIdTest(int BlocksId, int[] items, int output0Id, double output0Percent)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var input = new List<IItemStack>();
            items.ToList().ForEach(i => input.Add(itemStackFactory.Create(new ItemId(i), 1)));
            
            MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)BlocksId, input, out var ans);
            
            Assert.AreEqual(output0Id, MasterHolder.ItemMaster.GetItemId(ans.OutputItems[0].ItemGuid).AsPrimitive());
            Assert.AreEqual(output0Percent, ans.OutputItems[0].Percent);
        }
        
        [TestCase(3, new int[4] { 2, 1, 0, 5 }, 0)] //
        [TestCase(0, new int[3] { 2, 1, 0 }, 0)] // not exist test
        [TestCase(3, new int[3] { 4, 1, 0 }, 0)]
        [TestCase(10, new int[1] { 2 }, 0)]
        [TestCase(0, new int[0], 0)]
        [TestCase(1, new int[2] { 2, 1 }, 1)] // exist test
        public void NullRecipeTest(int BlocksId, int[] items, int outputLength)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var input = new List<IItemStack>();
            items.ToList().ForEach(i => input.Add(itemStackFactory.Create(new ItemId(i), 1)));
            
            var ans = MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)BlocksId, input, out _);
            Assert.AreEqual(outputLength == 1, ans);
        }
        
        [TestCase(1, new int[2] { 1, 2 }, new int[2] { 3, 1 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 3 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 30 }, true)]
        [TestCase(1, new int[2] { 2, 1 }, new int[2] { 1, 1 }, false)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 2, 3, 4 }, true)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 4, 6, 8 }, true)]
        [TestCase(3, new int[3] { 1, 2, 3 }, new int[3] { 4, 6, 1 }, false)]
        [TestCase(3, new int[3] { 2, 1, 3 }, new int[3] { 3, 2, 4 }, true)]
        [TestCase(3, new int[3] { 2, 1, 3 }, new int[3] { 3, 1, 4 }, false)]
        [TestCase(3, new int[4] { 2, 1, 0, 5 }, new int[4] { 3, 1, 4, 5 }, false)]
        public void RecipeConfirmationTest(int blocksId, int[] items, int[] itemcount, bool ans)
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var itemStacks = new List<IItemStack>();
            for (var i = 0; i < items.Length; i++)
            {
                var itemId = new ItemId(items[i]);
                itemStacks.Add(itemStackFactory.Create(itemId, itemcount[i]));
            }
            
            MachineRecipeMasterUtil.TryGetRecipeElement((BlockId)blocksId, itemStacks, out var machineRecipeElement);
            
            if (!ans && machineRecipeElement == null)
            {
                Assert.Pass();
                return;
            }
            
            var a = machineRecipeElement.RecipeConfirmation((BlockId)blocksId, itemStacks);
            Assert.AreEqual(ans, a);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Service/ConnectingInventoryListPriorityInsertItemService.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.Connector;
using Game.Block.Component;
using Game.Block.Interface.Component;

namespace Game.Block.Blocks.Service
{
    /// <summary>
    /// 
    /// A system that keeps putting items in order.
    /// </summary>
    public class ConnectingInventoryListPriorityInsertItemService : IBlockInventoryInserter
    {
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        
        private int _index = -1;
        
        public ConnectingInventoryListPriorityInsertItemService(BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockConnectorComponent = blockConnectorComponent;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            IReadOnlyList<IBlockInventory> inventories = _blockConnectorComponent.ConnectedTargets.Keys.ToArray();
            
            for (var i = 0; i < inventories.Count && itemStack.Id != ItemMaster.EmptyItemId; i++)
                lock (inventories)
                {
                    AddIndex();
                    itemStack = inventories[_index].InsertItem(itemStack);
                }
            
            return itemStack;
        }
        
        private void AddIndex()
        {
            _index++;
            if (_blockConnectorComponent.ConnectedTargets.Count <= _index) _index = 0;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/State/CommonMachineBlockStateDetail.cs
```cs
using System;
using MessagePack;

namespace Game.Block.Interface.State
{
    /// <summary>
    ///     
    /// </summary>
    [Serializable]
    [MessagePackObject]
    public class CommonMachineBlockStateDetail
    {
        public const string BlockStateDetailKey = "CommonMachine";
        
        /// <summary>
        ///     
        /// </summary>
        [Key(0)] public string CurrentStateType;
        
        /// <summary>
        ///     
        /// </summary>
        [Key(1)] public string PreviousStateType;
        
        /// <summary>
        ///     
        ///     
        /// </summary>
        [Key(2)] public float PowerRate;
        
        /// <summary>
        ///     
        /// </summary>
        [Key(3)] public float ProcessingRate;
        
        public CommonMachineBlockStateDetail(float currentPower, float requestPower, float processingRate, string currentStateType, string previousStateType)
        {
            PowerRate = requestPower == 0 ? 1.0f : currentPower / requestPower;
            this.ProcessingRate = processingRate;
            CurrentStateType = currentStateType;
            PreviousStateType = previousStateType;
        }
        
        [Obsolete("")]
        public CommonMachineBlockStateDetail()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearBeltConveyorTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearBeltConveyorTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private static BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var gearBeltParam = blockMasterElement.BlockParam as GearBeltConveyorBlockParam;
            
            var gearEnergyTransformerConnector = new BlockConnectorComponent<IGearEnergyTransformer>(
                gearBeltParam.Gear.GearConnects,
                gearBeltParam.Gear.GearConnects,
                blockPositionInfo
            );
            var inventoryConnector = BlockTemplateUtil.CreateInventoryConnector(gearBeltParam.InventoryConnectors, blockPositionInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(inventoryConnector); 
            
            var slopeType = gearBeltParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            var itemCount = gearBeltParam.BeltConveyorItemCount;
            
            // RPM0
            // Gear belt conveyors have different speeds depending on the RPM, so the default is 0
            var time = 0;
            
            var vanillaBeltConveyorComponent = componentStates == null ? 
                    new VanillaBeltConveyorComponent(itemCount, time, beltConveyorConnector, slopeType) :
                    new VanillaBeltConveyorComponent(componentStates, itemCount, time, beltConveyorConnector,slopeType);
            
            var gearBeltConveyorComponent = new GearBeltConveyorComponent(vanillaBeltConveyorComponent, blockInstanceId, gearBeltParam.BeltConveyorSpeed, (Torque)gearBeltParam.RequireTorque, gearEnergyTransformerConnector);
            
            var blockComponents = new List<IBlockComponent>
            {
                gearBeltConveyorComponent,
                vanillaBeltConveyorComponent,
                gearEnergyTransformerConnector,
                inventoryConnector
            };
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, blockComponents, blockPositionInfo);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/SlopeBlockPlaceSystem.cs
```cs
using System;
using System.Collections.Generic;
using Client.Common;
using Core.Master;
using Game.Block.Interface;
using Game.Context;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem
{
    public class SlopeBlockPlaceSystem
    {
        public static readonly int GroundLayerMask = LayerMask.GetMask("Ground");
        
        /// <summary>
        ///     TODO 
        /// </summary>
        public static Vector3 GetBlockPositionToPlacePosition(Vector3Int blockPosition, BlockDirection blockDirection, BlockId blockId)
        {
            // BlockDirection
            var blockSize = MasterHolder.BlockMaster.GetBlockMaster(blockId).BlockSize;
            var originPos = blockDirection.GetBlockModelOriginPos(blockPosition, blockSize);
            
            return originPos;
        }
        
        [Obsolete("")]
        public static (Vector3 position, Quaternion rotation, Vector3 scale) GetSlopeBeltConveyorTransform(string blockType, Vector3Int blockPosition, BlockDirection blockDirection, Vector3Int blockSize)
        {
            //+0.5
            var blockObjectPos = blockPosition.AddBlockPlaceOffset(); //TODo 
            
            var frontPoint = GetGroundPoint(GetBlockFrontRayOffset(blockDirection) + blockObjectPos);
            var backPoint = GetGroundPoint(-GetBlockFrontRayOffset(blockDirection) + blockObjectPos);
            
            //
            var hypotenuse = Vector3.Distance(frontPoint, backPoint);
            //
            var height = Mathf.Abs(frontPoint.y - backPoint.y);
            var blockY = GetBlockFourCornerMaxHeight(blockPosition, blockDirection, blockSize);
            //
            var blockAngle = Mathf.Asin(height / hypotenuse) * Mathf.Rad2Deg;
            
            
            var resultBlockPos = new Vector3(blockObjectPos.x, blockY + 0.3f, blockObjectPos.y);
            var blockRotation = GetRotation(blockDirection, blockAngle, frontPoint.y > backPoint.y);
            var blockScale = new Vector3(1, 1, hypotenuse);
            
            if (!BlockSlopeDeformationType.IsDeformation(blockType))
            {
                blockRotation = blockDirection.GetRotation();
                blockScale = Vector3.one;
            }
            
            return (resultBlockPos, blockRotation, blockScale);
        }
        
        public static Vector3 GetGroundPoint(Vector3 pos, Color debugRayColor = default)
        {
            var checkRay = new Ray(new Vector3(pos.x, 1000, pos.z), Vector3.down);
            Debug.DrawRay(checkRay.origin, checkRay.direction * 1000, debugRayColor, 3);
            
            if (!Physics.Raycast(checkRay, out var checkHit, 1500, GroundLayerMask)) throw new Exception(" pos:" + pos + " layer:" + GroundLayerMask);
            return checkHit.point;
        }
        
        public static float GetBlockFourCornerMaxHeight(Vector3Int blockPos, BlockDirection blockDirection, Vector3Int blockSize)
        {
            var (minPos, maxPos) = blockPos.GetWorldBlockBoundingBox(blockDirection, blockSize);
            var heights = new List<float>
            {
                GetGroundPoint(new Vector2(minPos.x, minPos.y), Color.red).y,
                GetGroundPoint(new Vector2(minPos.x, maxPos.y), Color.magenta).y,
                GetGroundPoint(new Vector2(maxPos.x, minPos.y), Color.cyan).y,
                GetGroundPoint(new Vector2(maxPos.x, maxPos.y), Color.blue).y,
            };
            
            return Mathf.Max(heights.ToArray());
        }
        
        private static Vector3 GetBlockFrontRayOffset(BlockDirection blockDirection)
        {
            return blockDirection switch
            {
                BlockDirection.North => new Vector3(0, 0, 0.5f),
                BlockDirection.East => new Vector3(0.5f, 0, 0),
                BlockDirection.South => new Vector3(0, 0, -0.5f),
                BlockDirection.West => new Vector3(-0.5f, 0, 0),
                _ => throw new ArgumentOutOfRangeException(nameof(blockDirection), blockDirection, null),
            };
        }
        
        private static Quaternion GetRotation(BlockDirection blockDirection, float blockAngle, bool isFrontUp)
        {
            blockAngle = isFrontUp ? -blockAngle : blockAngle;
            var defaultAngle = blockDirection.GetRotation().eulerAngles;
            return Quaternion.Euler(blockAngle, defaultAngle.y, defaultAngle.z);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/MinerBlockInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class MinerBlockInventoryView : CommonBlockInventoryViewBase 
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private ItemSlotObject minerResourceSlot;
        [SerializeField] private RectTransform minerResultsParent;
        
        [SerializeField] private ProgressArrowView minerProgressArrow;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            
            var itemList = new List<IItemStack>();
            var param = blockGameObject.BlockMasterElement.BlockParam;
            var outputCount = param switch
            {
                ElectricMinerBlockParam blockParam => blockParam.OutputItemSlotCount, // TODO master interface
                GearMinerBlockParam blockParam => blockParam.OutputItemSlotCount,
                _ => 0
            };
            
            for (var i = 0; i < outputCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, minerResultsParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            UpdateItemList(itemList);
        }
        
        private void Update()
        {
            // 
            var commonProcessor = (CommonMachineBlockStateChangeProcessor)_blockGameObject.BlockStateChangeProcessors.FirstOrDefault(x => x as CommonMachineBlockStateChangeProcessor);
            if (commonProcessor == null) return;
            
            minerProgressArrow.SetProgress(commonProcessor.CurrentMachineState?.ProcessingRate ?? 0.0f);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaGearMachineTemplate.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Game.Block.Blocks;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.EnergySystem;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaGearMachineTemplate : IBlockTemplate
    {
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdateEvent;
        
        public VanillaGearMachineTemplate(BlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            _blockInventoryUpdateEvent = blockInventoryUpdateEvent;
        }
        
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private IBlock GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var machineParam = blockMasterElement.BlockParam as GearMachineBlockParam;
            var inventoryConnectorComponent = BlockTemplateUtil.CreateInventoryConnector(machineParam.InventoryConnectors, blockPositionInfo);
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(blockMasterElement.BlockGuid);
            var (input, output) = BlockTemplateUtil.GetMachineIOInventory(blockId, blockInstanceId, machineParam, inventoryConnectorComponent, _blockInventoryUpdateEvent);
            
            var connectSetting = machineParam.Gear.GearConnects;
            var gearConnector = new BlockConnectorComponent<IGearEnergyTransformer>(connectSetting, connectSetting, blockPositionInfo);
            var requiredTorque = new Torque(machineParam.RequireTorque);
            var gearEnergyTransformer = new GearEnergyTransformer(requiredTorque, blockInstanceId, gearConnector);
            
            var requirePower = new ElectricPower(machineParam.RequireTorque * machineParam.RequiredRpm);
            
            // 
            // Load the parameters or create new ones
            var processor = componentStates == null ? 
                new VanillaMachineProcessorComponent(input, output, null, requirePower) :
                BlockTemplateUtil.MachineLoadState(componentStates, input, output, requirePower);
            
            var blockInventory = new VanillaMachineBlockInventoryComponent(input, output);
            var machineSave = new VanillaMachineSaveComponent(input, output, processor);
            
            var machineComponent = new VanillaGearMachineComponent(processor, gearEnergyTransformer, machineParam);
            
            var components = new List<IBlockComponent>
            {
                blockInventory,
                machineSave,
                processor,
                machineComponent,
                inventoryConnectorComponent,
                gearConnector,
                gearEnergyTransformer,
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/MinerMiningTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Update;
using Game.Block.Blocks.Miner;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using Game.Map.Interface.Vein;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class MinerMiningTest
    {
        //
        [Test]
        public void MiningTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //
            var (mapVein, pos) = GetMapVein();
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ElectricMinerId, pos, BlockDirection.North, out _);
            var miner = worldBlockDatastore.GetBlock(pos);
            var minerComponent = miner.GetComponent<VanillaMinerProcessorComponent>();
            
            var miningItems = (List<IItemStack>)typeof(VanillaMinerProcessorComponent).GetField("_miningItems", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(minerComponent);
            var miningItemId = miningItems[0].Id;
            var miningTime = (float)typeof(VanillaMinerProcessorComponent).GetField("_defaultMiningTime", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(minerComponent);
            
            
            var dummyInventory = new DummyBlockInventory();
            //
            //
            var minerConnectors = (Dictionary<IBlockInventory, ConnectedInfo>)miner.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            minerConnectors.Add(dummyInventory, new ConnectedInfo());
            
            //
            var segment = new EnergySegment();
            segment.AddEnergyConsumer(miner.GetComponent<IElectricConsumer>());
            segment.AddGenerator(new TestElectricGenerator(new ElectricPower(10000), new BlockInstanceId(10)));
            
            var mineEndTime = DateTime.Now.AddSeconds(miningTime);
            
            
            //
            //1
            while (mineEndTime.AddSeconds(0.05).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //1
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id);
            Assert.AreEqual(1, dummyInventory.InsertedItems[0].Count);
            
            //
            minerConnectors.Remove(dummyInventory);
            
            //2
            mineEndTime = DateTime.Now.AddSeconds(miningTime * 2);
            while (mineEndTime.AddSeconds(0.05).CompareTo(DateTime.Now) == 1) GameUpdater.UpdateWithWait();
            
            //2
            var outputSlot = miner.GetComponent<VanillaMinerProcessorComponent>().InventoryItems[0];
            Assert.AreEqual(miningItemId, outputSlot.Id);
            Assert.AreEqual(2, outputSlot.Count);
            
            //
            minerConnectors.Add(dummyInventory, new ConnectedInfo());
            
            //
            GameUpdater.UpdateWithWait();
            
            //2
            Assert.AreEqual(miningItemId, dummyInventory.InsertedItems[0].Id);
            Assert.AreEqual(3, dummyInventory.InsertedItems[0].Count);
        }
        
        public static (IMapVein mapVein, Vector3Int pos) GetMapVein()
        {
            var pos = new Vector3Int(0, 0);
            for (var i = 0; i < 500; i++)
            for (var j = 0; j < 500; j++)
            {
                List<IMapVein> veins = ServerContext.MapVeinDatastore.GetOverVeins(new Vector3Int(i, j));
                if (veins.Count == 0) continue;
                
                return (veins[0], new Vector3Int(i, j));
            }
            
            return (null, pos);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineBlockInventoryComponent.cs
```cs
using System.Collections.Generic;
using System.Collections.ObjectModel;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;

namespace Game.Block.Blocks.Machine.Inventory
{
    public class VanillaMachineBlockInventoryComponent : IOpenableBlockInventoryComponent
    {
        public IReadOnlyList<IItemStack> InventoryItems
        {
            get
            {
                BlockException.CheckDestroy(this);
                var items = new List<IItemStack>();
                items.AddRange(_vanillaMachineInputInventory.InputSlot);
                items.AddRange(_vanillaMachineOutputInventory.OutputSlot);
                return items;
            }
        }
        
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        
        public VanillaMachineBlockInventoryComponent(VanillaMachineInputInventory vanillaMachineInputInventory, VanillaMachineOutputInventory vanillaMachineOutputInventory)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
        }
        
        public IItemStack ReplaceItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            return ReplaceItem(slot, item);
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //
            var item = _vanillaMachineInputInventory.InsertItem(itemStack);
            return item;
        }
        
        public IItemStack InsertItem(ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            return _vanillaMachineInputInventory.InsertItem(item);
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
                return _vanillaMachineInputInventory.InputSlot[slot];
            
            slot -= _vanillaMachineInputInventory.InputSlot.Count;
            return _vanillaMachineOutputInventory.OutputSlot[slot];
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
            {
                _vanillaMachineInputInventory.SetItem(slot, itemStack);
            }
            else
            {
                slot -= _vanillaMachineInputInventory.InputSlot.Count;
                _vanillaMachineOutputInventory.SetItem(slot, itemStack);
            }
        }
        
        public void SetItem(int slot, ItemId itemId, int count)
        {
            BlockException.CheckDestroy(this);
            
            var item = ServerContext.ItemStackFactory.Create(itemId, count);
            SetItem(slot, item);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            
            return _vanillaMachineInputInventory.InputSlot.Count + _vanillaMachineOutputInventory.OutputSlot.Count;
        }
        
        public ReadOnlyCollection<IItemStack> CreateCopiedItems()
        {
            BlockException.CheckDestroy(this);
            
            var items = new List<IItemStack>();
            items.AddRange(_vanillaMachineInputInventory.InputSlot);
            items.AddRange(_vanillaMachineOutputInventory.OutputSlot);
            return new ReadOnlyCollection<IItemStack>(items);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            //
            return _vanillaMachineInputInventory.InsertItem(itemStacks);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            return _vanillaMachineInputInventory.InsertionCheck(itemStacks);
        }
        
        /// <summary>
        ///     ID
        /// </summary>
        /// <param name="slot"></param>
        /// <param name="itemStack"></param>
        /// <returns></returns>
        public IItemStack ReplaceItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            ItemProcessResult result;
            if (slot < _vanillaMachineInputInventory.InputSlot.Count)
            {
                //ID
                var item = _vanillaMachineInputInventory.InputSlot[slot];
                if (item.Id == itemStack.Id)
                {
                    result = item.AddItem(itemStack);
                    _vanillaMachineInputInventory.SetItem(slot, result.ProcessResultItemStack);
                    return result.RemainderItemStack;
                }
                
                //
                _vanillaMachineInputInventory.SetItem(slot, itemStack);
                return item;
            }
            else
            {
                //
                slot -= _vanillaMachineInputInventory.InputSlot.Count;
                
                var item = _vanillaMachineOutputInventory.OutputSlot[slot];
                
                if (item.Id == itemStack.Id)
                {
                    result = item.AddItem(itemStack);
                    _vanillaMachineOutputInventory.SetItem(slot, result.ProcessResultItemStack);
                    return result.RemainderItemStack;
                }
                
                _vanillaMachineOutputInventory.SetItem(slot, itemStack);
                return item;
            }
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
    }
}
```

moorestech_server/Assets/Scripts/Server.Protocol/PacketResponse/Util/CollectBeltConveyorItems.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Entity.Interface;
using Game.Entity.Interface.EntityInstance;
using Game.World.Interface.DataStore;
using UnityEngine;


namespace Server.Protocol.PacketResponse.Util
{
    /// <summary>
    ///     
    /// </summary>
    public static class CollectBeltConveyorItems
    {
        public const float DefaultBeltConveyorHeight = 0.3f;
        
        public static List<IEntity> CollectItem(IEntityFactory entityFactory)
        {
            var result = new List<IEntity>();
            result.AddRange(CollectItemFromWorld(entityFactory));
            
            return result;
        }
        
        public static List<IEntity> CollectItemFromWorld(IEntityFactory entityFactory)
        {
            var result = new List<IEntity>();
            
            //TODO 
            foreach (KeyValuePair<BlockInstanceId, WorldBlockData> blockMaster in ServerContext.WorldBlockDatastore.BlockMasterDictionary)
            {
                var block = blockMaster.Value.Block;
                var pos = blockMaster.Value.BlockPositionInfo.OriginalPos;
                // TODO 
                if (!block.TryGetComponent<IItemCollectableBeltConveyor>(out var component))
                {
                    continue;
                }
                
                var direction = ServerContext.WorldBlockDatastore.GetBlockDirection(pos);
                result.AddRange(CollectItemFromBeltConveyor(entityFactory, component, pos, direction));
            }
            
            return result;
        }
        
        static Dictionary<ItemInstanceId,float> _itemInstanceIdToPercent = new Dictionary<ItemInstanceId, float>();
        
        private static List<IEntity> CollectItemFromBeltConveyor(IEntityFactory entityFactory, IItemCollectableBeltConveyor beltConveyor, Vector3Int pos, BlockDirection blockDirection)
        {
            var result = new List<IEntity>();
            for (var i = 0; i < beltConveyor.BeltConveyorItems.Count; i++)
            {
                var beltConveyorItem = beltConveyor.BeltConveyorItems[i];
                if (beltConveyorItem == null) continue;
                if (beltConveyorItem.ItemId == ItemMaster.EmptyItemId) continue;
                
                // 1- 
                var percent = 1f - (float)beltConveyorItem.RemainingPercent;
                
                var last = _itemInstanceIdToPercent.GetValueOrDefault(beltConveyorItem.ItemInstanceId);
                _itemInstanceIdToPercent[beltConveyorItem.ItemInstanceId] = percent;
                
                var diff = percent - last;
                var instanceId = beltConveyorItem.ItemInstanceId;
                UnityEngine.Debug.Log($"CollectItemFrom Last:{last:F3} Current:{percent:F3} Diff:{diff:F3} {instanceId}");
                
                float entityX = pos.x;
                float entityZ = pos.z;
                switch (blockDirection)
                {
                    case BlockDirection.North:
                        entityX += 0.5f; //0.5
                        entityZ += percent;
                        break;
                    case BlockDirection.South:
                        entityX += 0.5f;
                        entityZ += 1 - percent; //1
                        break;
                    case BlockDirection.East:
                        entityX += percent;
                        entityZ += 0.5f;
                        break;
                    case BlockDirection.West:
                        entityX += 1 - percent;
                        entityZ += 0.5f;
                        break;
                }
                
                //0.3
                var y = pos.y + DefaultBeltConveyorHeight;
                
                if (beltConveyor.SlopeType == BeltConveyorSlopeType.Up)
                {
                    y += percent;
                    y += 0.1f;
                }
                else if (beltConveyor.SlopeType == BeltConveyorSlopeType.Down)
                {
                    y -= percent;
                    y += 0.1f;
                    y++;
                }
                
                var position = new Vector3(entityX, y, entityZ);
                var itemEntity = (ItemEntity)entityFactory.CreateEntity(VanillaEntityType.VanillaItem, new EntityInstanceId(beltConveyorItem.ItemInstanceId.AsPrimitive()), position);
                itemEntity.SetState(beltConveyorItem.ItemId, 1);
                
                result.Add(itemEntity);
            }
            
            return result;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/FastBeltConveyorTest.cs
```cs
using Core.Master;
using Core.Update;
using Game.Block.Interface;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class FastBeltConveyorTest
    {
        /// <summary>
        /// TODO 13
        /// TODO Testing a conveyor belt that moves 3 blocks per frame
        /// </summary>
        public void OneFramePer3BlockBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            //PlaceBlock(ForUnitTestModBlockId.FastBeltConveyor, new Vector3Int(0, 0, 0));
            //PlaceBlock(ForUnitTestModBlockId.FastBeltConveyor, new Vector3Int(0, 0, 1));
            //PlaceBlock(ForUnitTestModBlockId.FastBeltConveyor, new Vector3Int(0, 0, 2));
            
            GameUpdater.SpecifiedDeltaTimeUpdate(1);
        }
        
        IBlock PlaceBlock(BlockId blockId, Vector3Int position)
        {
            var world = ServerContext.WorldBlockDatastore;
            
            world.TryAddBlock(blockId, position, BlockDirection.North, out var block);
            return block;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests.Module/TestElectricGenerator.cs
```cs
using Game.Block.Interface;
using Game.EnergySystem;

namespace Tests.Module
{
    //
    public class TestElectricGenerator : IElectricGenerator
    {
        private readonly ElectricPower _power;
        
        public TestElectricGenerator(ElectricPower power, BlockInstanceId blockInstanceId)
        {
            _power = power;
            BlockInstanceId = blockInstanceId;
        }
        
        public BlockInstanceId BlockInstanceId { get; }
        
        public ElectricPower OutputEnergy()
        {
            return _power;
        }
        
        public bool IsDestroy { get; }
        
        public void Destroy()
        {
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/BlockComponent/Computer/CraftChainerNetworkContext.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.CraftChainer.BlockComponent.Crafter;
using Game.CraftChainer.BlockComponent.ProviderChest;
using Game.CraftChainer.CraftChain;
using Game.CraftChainer.CraftNetwork;
using UnityEngine;

namespace Game.CraftChainer.BlockComponent.Computer
{
    public class CraftChainerNetworkContext
    {
        // 
        // Information about the chain network
        public IReadOnlyList<CraftChainerProviderChestComponent> ProviderChests => _providerChests;
        private readonly List<CraftChainerProviderChestComponent> _providerChests = new();
        public IReadOnlyList<CraftCraftChainerCrafterComponent> CrafterComponents => _crafterComponents;
        private readonly List<CraftCraftChainerCrafterComponent> _crafterComponents = new();
        private readonly Dictionary<CraftChainerNodeId, ICraftChainerNode> _nodes = new();
        
        // 
        // Information about the main computer that holds this context
        private readonly BlockConnectorComponent<IBlockInventory> _mainComputerConnector; 
        private readonly ICraftChainerNode _mainComputerNode;
        
        // 
        // Information about the item currently being crafted
        private readonly Dictionary<ItemInstanceId,CraftChainerNodeId> _requestedMoveItems = new();
        // 
        // How many items of each item type must be placed in each node?
        private Dictionary<ItemId,Dictionary<CraftChainerNodeId,int>> _craftChainRecipeQue = new();
        
        public CraftChainerNetworkContext(BlockConnectorComponent<IBlockInventory> mainComputerConnector, ICraftChainerNode mainComputerNode)
        {
            _mainComputerConnector = mainComputerConnector;
            _mainComputerNode = mainComputerNode;
        }
        
        public bool IsExistNode(CraftChainerNodeId nodeId)
        {
            return _nodes.ContainsKey(nodeId);
        }
        
        public void SetCraftChainRecipeQue(Dictionary<CraftingSolverRecipeId, int> solvedResults, CraftingSolverItem targetItem)
        {
            var craftRecipeIdMap = GetCraftRecipeIdMap();
            
            _craftChainRecipeQue = CreateRecipeQue(solvedResults, craftRecipeIdMap);
            // 
            _craftChainRecipeQue.Add(targetItem.ItemId, new Dictionary<CraftChainerNodeId, int> {{_mainComputerNode.NodeId, targetItem.Count}});
            
            #region Internal
            
            Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent> GetCraftRecipeIdMap()
            {
                var map = new Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent>();
                foreach (var crafter in _crafterComponents)
                {
                    var recipeId = crafter.CraftingSolverRecipe.CraftingSolverRecipeId;
                    if (recipeId != CraftingSolverRecipeId.InvalidId)
                    {
                        map[recipeId] = crafter;
                    }
                }
                return map;
            }
            
            Dictionary<ItemId, Dictionary<CraftChainerNodeId,int>> CreateRecipeQue(Dictionary<CraftingSolverRecipeId, int> solved, Dictionary<CraftingSolverRecipeId, CraftCraftChainerCrafterComponent> recipes)
            {
                var result = new Dictionary<ItemId, Dictionary<CraftChainerNodeId,int>>();
                foreach (var solvedResult in solved)
                {
                    var crafter = recipes[solvedResult.Key];
                    var recipe = crafter.CraftingSolverRecipe;
                    foreach (var inputItems in recipe.Inputs)
                    {
                        var count = inputItems.Count * solvedResult.Value;
                        if (result.TryGetValue(inputItems.ItemId, out var que))
                        {
                            if (!que.TryAdd(crafter.NodeId,count))
                            {
                                que[crafter.NodeId] += count;
                            }
                        }
                        else
                        {
                            result[inputItems.ItemId] = new Dictionary<CraftChainerNodeId, int>()
                            {
                                { crafter.NodeId, count }
                            };
                        }
                    }
                }
                
                return result;
            }
            
            #endregion
        }
        
        /// <summary>
        /// 
        /// Re-search the network of the craft chain
        /// </summary>
        public void ReSearchNetwork()
        {
            _providerChests.Clear();
            _crafterComponents.Clear();
            _nodes.Clear();
            
            _nodes.Add(_mainComputerNode.NodeId, _mainComputerNode);
            
            // 
            // Simply search by depth-first search and add the chests found on the way to the list
            Search(_mainComputerConnector);
            
            #region Internal
            
            void Search(BlockConnectorComponent<IBlockInventory> connector)
            {
                foreach (var connectedTarget in connector.ConnectedTargets)
                {
                    var targetBlock = connectedTarget.Value.TargetBlock;
                    if (!targetBlock.TryGetComponent<ICraftChainerNode>(out var node))
                    {
                        continue;
                    }
                    if (!_nodes.TryAdd(node.NodeId, node))
                    {
                        continue;
                    }
                    
                    if (targetBlock.TryGetComponent<CraftChainerProviderChestComponent>(out var chest))
                    {
                        _providerChests.Add(chest);
                    }
                    if (targetBlock.TryGetComponent<CraftCraftChainerCrafterComponent>(out var crafter))
                    {
                        _crafterComponents.Add(crafter);
                    }
                    if (targetBlock.TryGetComponent<BlockConnectorComponent<IBlockInventory>>(out var nextConnector))
                    {
                        Search(nextConnector);
                    }
                }
            }
            
            #endregion
        }
        
        /// <summary>
        /// ID
        /// Get the next block to insert from the item ID and connected connector, and insert it if possible
        /// </summary>
        public IItemStack InsertNodeNetworkNextBlock(IItemStack item, CraftChainerNodeId startChainerNodeId, BlockConnectorComponent<IBlockInventory> blockConnector)
        {
            if (item.Id == ItemMaster.EmptyItemId) return item;
            
            // 
            var targetNodeId = GetTargetNodeId(item);
            if (targetNodeId == CraftChainerNodeId.Invalid)
            {
                return item;
            }
            
            // 
            var result = ExecuteBfs(targetNodeId);
            if (result == null || result.Count == 0)
            {
                return item;
            }
            
            // 
            var nextInventory = result[0].Item2;
            if (!nextInventory.InsertionCheck(new List<IItemStack> {item}))
            {
                return item;
            }
            
            // 
            DebugExportCraftChainRecipeQueLog();
            UpdateCraftQue();
            
            // 
            return nextInventory.InsertItem(item);
            
            #region Internal
            
            CraftChainerNodeId GetTargetNodeId(IItemStack item)
            {
                // 
                // If the destination is already specified, return it as it is
                if (_requestedMoveItems.TryGetValue(item.ItemInstanceId, out var nodeId))
                {
                    return nodeId;
                }
                
                // 
                // Check if the current item is a crafting target material
                if (!_craftChainRecipeQue.TryGetValue(item.Id, out var craftQue))
                {
                    return CraftChainerNodeId.Invalid;
                }
                
                // 
                // It is a crafting target material, so get one of them
                foreach (var nodeReminder in craftQue)
                {
                    return nodeReminder.Key;
                }
                
                // Invalid
                // If no destination is specified, return Invalid
                return CraftChainerNodeId.Invalid;
            }
            
            List<(CraftChainerNodeId,IBlockInventory)> ExecuteBfs(CraftChainerNodeId targetNode)
            {
                var idToConnector = new Dictionary<CraftChainerNodeId, (BlockConnectorComponent<IBlockInventory> connector, IBlockInventory blockInventory)>();
                var searchQueue = new Queue<CraftChainerNodeId>();
                var searched = new HashSet<CraftChainerNodeId>();
                var reverseSearch = new Dictionary<CraftChainerNodeId, CraftChainerNodeId>();
                var stepLog = new Dictionary<CraftChainerNodeId, int>();
                var isFound = false;
                
                searchQueue.Enqueue(startChainerNodeId);
                searched.Add(startChainerNodeId);
                idToConnector[startChainerNodeId] = (blockConnector, null);
                stepLog[startChainerNodeId] = 0;
                
                // 
                // Loop until the queue is empty
                while (0 < searchQueue.Count)
                {
                    var searchingId = searchQueue.Dequeue();
                    if (searchingId == targetNode)
                    {
                        isFound = true;
                        break;
                    }
                    
                    var step = stepLog[searchingId] + 1;
                    foreach (var connectedTarget in idToConnector[searchingId].connector.ConnectedTargets)
                    {
                        var targetBlock = connectedTarget.Value.TargetBlock;
                        var next = GetNext(targetBlock);
                        
                        // ChainerNode
                        // Ignore if the connection destination is not a ChainerNode
                        if (!next.HasValue) continue;
                        
                        var (nodeId, nextConnector, blockInventory) = next.Value;
                        
                        // 
                        // Ignore if already searched
                        if (searched.Contains(nodeId)) continue;
                        
                        searched.Add(nodeId); // Mark as searched before enqueuing
                        reverseSearch[nodeId] = searchingId;
                        idToConnector[nodeId] = (nextConnector, blockInventory);
                        stepLog[nodeId] = step;
                        searchQueue.Enqueue(nodeId);
                    }
                }
                
                if (!isFound)
                {
                    return null;
                }
                
                // 
                // Follow the path
                var result = new List<(CraftChainerNodeId,IBlockInventory)>();
                var current = targetNode;
                while (current != startChainerNodeId)
                {
                    result.Add((current,idToConnector[current].blockInventory));
                    current = reverseSearch[current];
                }
                
                result.Reverse();
                return result;
            }
            
            (CraftChainerNodeId nodeId, BlockConnectorComponent<IBlockInventory> connector, IBlockInventory blockInventory)? GetNext(IBlock block)
            {
                if (!block.TryGetComponent<ICraftChainerNode>(out var node)) return null;
                if (node.NodeId == startChainerNodeId) return null;
                if (!block.TryGetComponent<BlockConnectorComponent<IBlockInventory>>(out var connector)) return null;
                if (!block.TryGetComponent<IBlockInventory>(out var inventory)) return null;
                
                return (node.NodeId, connector, inventory);
            }
            
            void UpdateCraftQue()
            {
                // 
                // Only newly inserted items are updated, so items that already have a destination specified are ignored
                if (_requestedMoveItems.ContainsKey(item.ItemInstanceId))
                {
                    return;
                }
                
                // 
                // Update the craft queue information
                var craftQue = _craftChainRecipeQue[item.Id];
                var reminder = craftQue[targetNodeId];
                reminder--;
                if (reminder <= 0)
                {
                    craftQue.Remove(targetNodeId);
                }
                else
                {
                    craftQue[targetNodeId] = reminder;
                }
                
                // 
                // Keep the destination of the calculated item
                _requestedMoveItems[item.ItemInstanceId] = targetNodeId;
            }
            
            void DebugExportCraftChainRecipeQueLog()
            {
                // return
                // If you want to use it, remove this return
                return;
                
                var str = "";
                
                foreach (var ques in _craftChainRecipeQue)
                {
                    foreach (var que in ques.Value)
                    {
                        var crafter = _crafterComponents.Find(c => c.NodeId == que.Key);
                        if (crafter != null)
                        {
                            var outputId = crafter.CraftingSolverRecipe.Outputs[0].ItemId;
                            var outItemName = MasterHolder.ItemMaster.GetItemMaster(outputId).Name;
                            var itemName = MasterHolder.ItemMaster.GetItemMaster(ques.Key).Name;
                            
                            str += $"Id {itemName} Count {que.Value} Output {outItemName},  ";
                        }
                    }
                }
                
                Debug.Log(str);
            }
            #endregion
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SimpleTrainTest.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Game.Context;
using Game.Train.RailGraph;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game
{
    public class SimpleTrainTest
    {
        [Test]
        // 
        // A test in which a train on rails moves towards a designated station
        public void SimpleTrainMoveTest()
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);

            // TODO 1
            // TODO 2
            // TODO 

            // TODO 

            // TODO 1
            // TODO 

            // TODO 

            // TODO passfail
            //
        }

        [Test]
        // 0-1-2-3
        public void DijkstraTest0()
        {

            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //railGraphDatastore
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            var node0 = new RailNode(railGraphDatastore);
            var node1 = new RailNode(railGraphDatastore);
            var node2 = new RailNode(railGraphDatastore);
            var node3 = new RailNode(railGraphDatastore);
            node0.ConnectNode(node1, 1);
            node1.ConnectNode(node2, 1);
            node2.ConnectNode(node3, 1);

            // node0node3
            var outListPath = railGraphDatastore.FindShortestPath(node0, node3);

            //
            Assert.AreEqual(4, outListPath.Count);
            Assert.AreEqual(node0, outListPath[0]);
            Assert.AreEqual(node1, outListPath[1]);
            Assert.AreEqual(node2, outListPath[2]);
            Assert.AreEqual(node3, outListPath[3]);
        }


        [Test]
        // 0=(1,2)=3
        public void DijkstraTest1()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //railGraphDatastore
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            var node0 = new RailNode(railGraphDatastore);
            var node1 = new RailNode(railGraphDatastore);
            var node2 = new RailNode(railGraphDatastore);
            var node3 = new RailNode(railGraphDatastore);
            node0.ConnectNode(node1, 123);
            node0.ConnectNode(node2, 345);
            node1.ConnectNode(node3, 400);
            node2.ConnectNode(node3, 1);

            // node0node3
            var outListPath = railGraphDatastore.FindShortestPath(node0, node3);

            //
            Assert.AreEqual(3, outListPath.Count);
            Assert.AreEqual(node0, outListPath[0]);
            Assert.AreEqual(node2, outListPath[1]);
            Assert.AreEqual(node3, outListPath[2]);
        }


        [Test]
        //
        public void DijkstraTest2()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            //10000101
            const int nodenum_powerexponent = 4;
            int nodenum = (int)System.Math.Pow(10, nodenum_powerexponent);
            Debug.Log(nodenum);

            RailNode[] nodeList = new RailNode[nodenum];
            for (int i = 0; i < nodenum; i++)
            {
                nodeList[i] = new RailNode(railGraphDatastore);
            }
            //(*10)0-9
            for (int i = 0; i < nodenum; i++)
            {
                for (int j = 0; j < 10; j++)
                {
                    var next = (i * 10) % nodenum + j;
                    nodeList[i].ConnectNode(nodeList[next], 1);
                }
            }

            //4
            // 11451419
            //11451451
            //14514514
            //45145141
            //51411419
            int testnum = 1234;//1234567
            for (int i = 0; i < testnum; i++)
            {
                int rand0 = Random.Range(0, nodenum);
                int rand1 = Random.Range(0, nodenum);
                var node_start = nodeList[rand0];
                var node_end = nodeList[rand1];
                var outListPath = railGraphDatastore.FindShortestPath(node_start, node_end);
                // outListPath4+1
                if (outListPath.Count > 5)
                {
                    Debug.Log(rand0);
                    Debug.Log(rand1);
                }
                Assert.LessOrEqual(outListPath.Count, nodenum_powerexponent + 1);
            }
        }





        [Test]
        //Y
        public void Y_NodeCheck()
        {
            //Notion
            //YABC1C2D1D2
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //railGraphDatastore
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            var nodeA = new RailNode(railGraphDatastore);
            var nodeB = new RailNode(railGraphDatastore);
            var nodeC1 = new RailNode(railGraphDatastore);
            var nodeC2 = new RailNode(railGraphDatastore);
            var nodeD1 = new RailNode(railGraphDatastore);
            var nodeD2 = new RailNode(railGraphDatastore);
            nodeA.ConnectNode(nodeC1, 3782);
            nodeB.ConnectNode(nodeC1, 67329);
            nodeC1.ConnectNode(nodeD1, 71894);
            nodeD2.ConnectNode(nodeC2, 17380);
            nodeC2.ConnectNode(nodeA, 28973);
            nodeC2.ConnectNode(nodeB, 718);

            //
            // nodeAnodeD
            var outListPath = railGraphDatastore.FindShortestPath(nodeA, nodeD1);

            //
            Assert.AreEqual(3, outListPath.Count);
            Assert.AreEqual(nodeA, outListPath[0]);
            Assert.AreEqual(nodeC1, outListPath[1]);
            Assert.AreEqual(nodeD1, outListPath[2]);

            //
            outListPath = railGraphDatastore.FindShortestPath(nodeD2, nodeA);

            //
            Assert.AreEqual(3, outListPath.Count);
            Assert.AreEqual(nodeD2, outListPath[0]);
            Assert.AreEqual(nodeC2, outListPath[1]);
            Assert.AreEqual(nodeA, outListPath[2]);

            //AB
            outListPath = railGraphDatastore.FindShortestPath(nodeA, nodeB);
            Assert.AreEqual(0, outListPath.Count);

            //D1D2
            nodeD1.ConnectNode(nodeD2, 721);
            outListPath = railGraphDatastore.FindShortestPath(nodeA, nodeB);
            Assert.AreEqual(6, outListPath.Count);
            Assert.AreEqual(nodeA, outListPath[0]);
            Assert.AreEqual(nodeC1, outListPath[1]);
            Assert.AreEqual(nodeD1, outListPath[2]);
            Assert.AreEqual(nodeD2, outListPath[3]);
            Assert.AreEqual(nodeC2, outListPath[4]);
            Assert.AreEqual(nodeB, outListPath[5]);
        }



        //RailGraphDatastoreGetConnectedNodes
        [Test]
        public void ConnectedNodesTest()
        {
            //YABC1C2D1D2
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            //railGraphDatastore
            var railGraphDatastore = serviceProvider.GetService<RailGraphDatastore>();

            var nodeA = new RailNode(railGraphDatastore);
            var nodeB = new RailNode(railGraphDatastore);
            var nodeC = new RailNode(railGraphDatastore);

            nodeA.ConnectNode(nodeB, 10);
            nodeA.ConnectNode(nodeC, 20);

            var connectedNodes = nodeA.ConnectedNodes.ToList();

            Assert.AreEqual(2, connectedNodes.Count);
            Assert.IsTrue(connectedNodes.Contains(nodeB));
            Assert.IsTrue(connectedNodes.Contains(nodeC));
        }

        //RailPositionmoveForward1
        [Test]
        public void MoveForward_LongTrain_MovesAcrossMultipleNodes()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var railGraph = serviceProvider.GetService<RailGraphDatastore>();

            // 
            var nodeA = new RailNode(railGraph);
            var nodeB = new RailNode(railGraph);
            var nodeC = new RailNode(railGraph);
            var nodeD = new RailNode(railGraph);
            var nodeE = new RailNode(railGraph);

            // 
            nodeB.ConnectNode(nodeA, 10);//9
            nodeC.ConnectNode(nodeB, 15);//
            nodeD.ConnectNode(nodeC, 20);//
            nodeE.ConnectNode(nodeD, 25);//14

            // 50AE
            var nodes = new List<RailNode> { nodeA, nodeB, nodeC, nodeD, nodeE };
            var railPosition = new RailPosition(nodes, 50, 9); // AB9

            //
            var remainingDistance = railPosition.MoveForward(6); // 6A
            // Assert
            Assert.AreEqual(0, remainingDistance); // A3

            //E
            var list = railPosition.TestGet_railNodes();
            Assert.AreEqual(nodeA, list[0]);
            Assert.AreEqual(nodeB, list[1]);
            Assert.AreEqual(nodeC, list[2]);
            Assert.AreEqual(nodeD, list[3]);
            Assert.AreEqual(nodeE, list[4]);

            //
            remainingDistance = railPosition.MoveForward(4); // 3A1
            // Assert
            Assert.AreEqual(nodeA, railPosition.GetNodeApproaching()); // 
            Assert.AreEqual(1, remainingDistance); //
            Assert.AreEqual(nodeB, railPosition.GetNodeJustPassed()); // 
        }

        //RailPositionmoveForward2
        [Test]
        public void MoveBackward_LongTrain_MovesAcrossMultipleNodes()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var railGraph = serviceProvider.GetService<RailGraphDatastore>();

            // 
            // 
            var nodeA1 = new RailNode(railGraph);
            var nodeB1 = new RailNode(railGraph);
            var nodeC1 = new RailNode(railGraph);
            var nodeD1 = new RailNode(railGraph);
            var nodeE1 = new RailNode(railGraph);
            // 
            var nodeA2 = new RailNode(railGraph);
            var nodeB2 = new RailNode(railGraph);
            var nodeC2 = new RailNode(railGraph);
            var nodeD2 = new RailNode(railGraph);
            var nodeE2 = new RailNode(railGraph);

            // 
            nodeB1.ConnectNode(nodeA1, 10);//5
            nodeC1.ConnectNode(nodeB1, 15);//
            nodeD1.ConnectNode(nodeC1, 20);//
            nodeE1.ConnectNode(nodeD1, 25);//10

            nodeD2.ConnectNode(nodeE2, 25);
            nodeC2.ConnectNode(nodeD2, 20);
            nodeB2.ConnectNode(nodeC2, 15);
            nodeA2.ConnectNode(nodeB2, 10);

            nodeA1.SetOppositeNode(nodeA2);//RailConmponent
            nodeB1.SetOppositeNode(nodeB2);
            nodeC1.SetOppositeNode(nodeC2);
            nodeD1.SetOppositeNode(nodeD2);
            nodeE1.SetOppositeNode(nodeE2);
            nodeA2.SetOppositeNode(nodeA1);
            nodeB2.SetOppositeNode(nodeB1);
            nodeC2.SetOppositeNode(nodeC1);
            nodeD2.SetOppositeNode(nodeD1);
            nodeE2.SetOppositeNode(nodeE1);
            {  //ReverseMoveForward()
                var nodes = new List<RailNode> { nodeA1, nodeB1, nodeC1, nodeD1, nodeE1 };
                var railPosition = new RailPosition(nodes, 50, 5); // AB5
                railPosition.Reverse();//E15
                //E
                var list = railPosition.TestGet_railNodes();
                Assert.AreEqual(nodeE2, list[0]);
                Assert.AreEqual(nodeD2, list[1]);
                Assert.AreEqual(nodeC2, list[2]);
                Assert.AreEqual(nodeB2, list[3]);
                Assert.AreEqual(nodeA2, list[4]);
                Assert.AreEqual(15, railPosition.GetDistanceToNextNode());
                var remainingDistance = railPosition.MoveForward(6); // 6E
                Assert.AreEqual(9, railPosition.GetDistanceToNextNode());
                Assert.AreEqual(0, remainingDistance);

                list = railPosition.TestGet_railNodes();//B-CA
                Assert.AreEqual(4, list.Count);
                Assert.AreEqual(nodeE2, list[0]);
                Assert.AreEqual(nodeD2, list[1]);
                Assert.AreEqual(nodeC2, list[2]);
                Assert.AreEqual(nodeB2, list[3]);
            }

            { //MoveForward()
                // 50AE
                var nodes = new List<RailNode> { nodeA1, nodeB1, nodeC1, nodeD1, nodeE1 };
                var railPosition = new RailPosition(nodes, 50, 5); // AB5

                //
                var remainingDistance = railPosition.MoveForward(-11); // 11E

                Assert.AreEqual(6, railPosition.GetDistanceToNextNode()); //
                Assert.AreEqual(nodeB1, railPosition.GetNodeApproaching()); // nodeA511
                Assert.AreEqual(nodeC1, railPosition.GetNodeJustPassed()); // 

                var list = railPosition.TestGet_railNodes(); Assert.AreEqual(4, list.Count);
                Assert.AreEqual(nodeB1, list[0]);
                Assert.AreEqual(nodeC1, list[1]);
                Assert.AreEqual(nodeD1, list[2]);
                Assert.AreEqual(nodeE1, list[3]);
            }
        }

    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaElectricMachineComponent.cs
```cs
using Game.Block.Interface;
using Game.EnergySystem;

namespace Game.Block.Blocks.Machine
{
    /// <summary>
    ///     
    /// </summary>
    public class VanillaElectricMachineComponent : IElectricConsumer
    {
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        
        public VanillaElectricMachineComponent(BlockInstanceId blockInstanceId, VanillaMachineProcessorComponent vanillaMachineProcessorComponent)
        {
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
            BlockInstanceId = blockInstanceId;
        }
        public BlockInstanceId BlockInstanceId { get; }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        #region IBlockElectric implementation
        
        public ElectricPower RequestEnergy => _vanillaMachineProcessorComponent.RequestPower;
        
        public void SupplyEnergy(ElectricPower power)
        {
            BlockException.CheckDestroy(this);
            
            _vanillaMachineProcessorComponent.SupplyPower(power);
        }
        
        #endregion
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Train/TrainUnit.cs
```cs
using System.Collections.Generic;

namespace Game.Train.Train
{
    /// <summary>
    /// 
    /// RailPosition
    /// 
    /// </summary>
    public class TrainUnit
    {
        // 
        private List<TrainCar> _trainFormation;
        private int _currentSpeed;
        private bool _isRunning;

        // 
        public void AddTrainCar(TrainCar trainCar)
        {
        }

        // 
        public void CalcSpeed(int speed)
        {
            _currentSpeed = speed;
        }

    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/OpenableInventoryBlock.cs
```cs
using UnityEngine;

namespace Client.Game.InGame.BlockSystem
{
    //todo ID
    public class OpenableInventoryBlock : MonoBehaviour
    {
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/ChestLogicTest.cs
```cs
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Blocks.Chest;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Random = System.Random;

namespace Tests.CombinedTest.Core
{
    public class ChestLogicTest
    {
        //
        [Test]
        public void BeltConveyorInsertChestLogicTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var random = new Random(4123);
            
            var id = new ItemId(random.Next(1, 11));
            var count = 1;
            var item = itemStackFactory.Create(id, count);
            
            var chest = blockFactory.Create(ForUnitTestModBlockId.ChestId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var chestComponent = chest.GetComponent<VanillaChestComponent>();
            
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            beltConveyorComponent.InsertItem(item);
            
            var beltConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            beltConnectInventory.Add(chestComponent, new ConnectedInfo());
            
            
            while (!chestComponent.GetItem(0).Equals(item)) GameUpdater.UpdateWithWait();
            
            Assert.True(chestComponent.GetItem(0).Equals(item));
        }
        
        [Test]
        public void BeltConveyorOutputChestLogicTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            
            var chest = blockFactory.Create(ForUnitTestModBlockId.ChestId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var chestComponent = chest.GetComponent<VanillaChestComponent>();
            
            var beltconveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(0), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltconveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            chestComponent.SetItem(0, new ItemId(1), 1);
            
            var chestConnectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)chest.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            chestConnectInventory.Add(beltConveyorComponent, new ConnectedInfo());
            GameUpdater.UpdateWithWait();
            
            
            Assert.AreEqual(chestComponent.GetItem(0).Count, 0);
        }
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/UI/Inventory/Block/MachineBlockInventoryView.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Client.Game.InGame.Block;
using Client.Game.InGame.BlockSystem.StateProcessor;
using Client.Game.InGame.UI.Inventory.Element;
using Core.Item.Interface;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using TMPro;
using UnityEngine;

namespace Client.Game.InGame.UI.Inventory.Block
{
    public class MachineBlockInventoryView : CommonBlockInventoryViewBase
    {
        [SerializeField] private ItemSlotObject itemSlotObjectPrefab;
        
        [SerializeField] private RectTransform machineInputItemParent;
        [SerializeField] private RectTransform machineOutputItemParent;
        [SerializeField] private TMP_Text machineBlockNameText;
        
        [SerializeField] private ProgressArrowView machineProgressArrow;
        
        private BlockGameObject _blockGameObject;
        
        public override void Initialize(BlockGameObject blockGameObject)
        {
            base.Initialize(blockGameObject);
            _blockGameObject = blockGameObject;
            
            var itemList = new List<IItemStack>();
            
            // GearMachineParamElectricMachineParam
            var param = blockGameObject.BlockMasterElement.BlockParam as IMachineParam;
            
            
            for (var i = 0; i < param.InputSlotCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, machineInputItemParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            for (var i = 0; i < param.OutputSlotCount; i++)
            {
                var slotObject = Instantiate(itemSlotObjectPrefab, machineOutputItemParent);
                _blockItemSlotObjects.Add(slotObject);
                itemList.Add(ServerContext.ItemStackFactory.CreatEmpty());
            }
            
            machineBlockNameText.text = blockGameObject.BlockMasterElement.Name;
            UpdateItemList(itemList);
        }
        
        private void Update()
        {
            // 
            var commonProcessor = (CommonMachineBlockStateChangeProcessor)_blockGameObject.BlockStateChangeProcessors.FirstOrDefault(x => x as CommonMachineBlockStateChangeProcessor);
            if (commonProcessor == null) return;
            
            machineProgressArrow.SetProgress(commonProcessor.CurrentMachineState?.ProcessingRate ?? 0.0f);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/ItemShooter/ItemShooterComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Mooresmaster.Model.BlocksModule;
using Newtonsoft.Json;
using UnityEngine;

namespace Game.Block.Blocks.ItemShooter
{
    public class ItemShooterComponent : IItemCollectableBeltConveyor, IBlockInventory, IBlockSaveState, IUpdatableBlockComponent
    {
        public BeltConveyorSlopeType SlopeType { get; }
        public IReadOnlyList<IOnBeltConveyorItem> BeltConveyorItems => _inventoryItems;
        private readonly ShooterInventoryItem[] _inventoryItems;
        
        private readonly BlockConnectorComponent<IBlockInventory> _blockConnectorComponent;
        private readonly ItemShooterBlockParam _itemShooterBlockParam;
        private const float InsertItemInterval = 1f; // TODO to master
        
        private float _lastInsertElapsedTime = float.MaxValue;
        
        public ItemShooterComponent(BlockConnectorComponent<IBlockInventory> blockConnectorComponent, ItemShooterBlockParam itemShooterBlockParam)
        {
            _blockConnectorComponent = blockConnectorComponent;
            _itemShooterBlockParam = itemShooterBlockParam;
            SlopeType = itemShooterBlockParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            
            _inventoryItems = new ShooterInventoryItem[_itemShooterBlockParam.InventoryItemNum];
        }
        
        public ItemShooterComponent(Dictionary<string, string> componentStates, BlockConnectorComponent<IBlockInventory> blockConnectorComponent, ItemShooterBlockParam itemShooterBlockParam) :
            this(blockConnectorComponent, itemShooterBlockParam)
        {
            var items = JsonConvert.DeserializeObject<List<ItemShooterItemJsonObject>>(componentStates[SaveKey]);
            for (var i = 0; i < items.Count; i++)
            {
                var item = items[i];
                if (item.ItemStackSave == null) continue;
                
                var id = MasterHolder.ItemMaster.GetItemId(item.ItemStackSave.ItemGuid);
                _inventoryItems[i] = new ShooterInventoryItem(id, ItemInstanceId.Create(), (float)item.CurrentSpeed)
                {
                    RemainingPercent = (float)items[i].RemainingPercent
                };
            }
        }
        
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            _lastInsertElapsedTime += (float)GameUpdater.UpdateSecondTime;
            var count = _inventoryItems.Length;
            
            for (var i = 0; i < count; i++)
            {
                var item = _inventoryItems[i];
                if (item == null) continue;
                
                if (item.RemainingPercent <= 0)
                {
                    var insertItem = ServerContext.ItemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
                    
                    if (_blockConnectorComponent.ConnectedTargets.Count == 0) continue;
                    
                    var connector = _blockConnectorComponent.ConnectedTargets.First();
                    var target = connector.Key;
                    if (target is ItemShooterComponent shooter)
                    {
                        _inventoryItems[i] = shooter.InsertItemFromShooter(item);
                    }
                    else
                    {
                        var output = connector.Key.InsertItem(insertItem);
                        
                        //nullItem
                        if (output.Id == ItemMaster.EmptyItemId) _inventoryItems[i] = null;
                    }
                    
                    continue;
                }
                
                //
                var deltaTime = (float)GameUpdater.UpdateSecondTime; // floatdobule
                item.RemainingPercent -= deltaTime * _itemShooterBlockParam.ItemShootSpeed * item.CurrentSpeed;
                item.RemainingPercent = Math.Clamp(item.RemainingPercent, 0, 1);
                
                // velocity
                item.CurrentSpeed += _itemShooterBlockParam.Acceleration * deltaTime;
                item.CurrentSpeed = Mathf.Clamp(item.CurrentSpeed, 0, float.MaxValue);
            }
        }
        
        private ShooterInventoryItem InsertItemFromShooter(ShooterInventoryItem inventoryItem)
        {
            BlockException.CheckDestroy(this);
            
            for (var i = 0; i < _inventoryItems.Length; i++)
            {
                if (_inventoryItems[i] != null) continue;
                
                _inventoryItems[i] = inventoryItem;
                _inventoryItems[i].RemainingPercent = 1;
                return null;
            }
            
            return inventoryItem;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            // 
            if (_lastInsertElapsedTime < InsertItemInterval) return itemStack;
            
            // 
            for (var i = 0; i < _inventoryItems.Length; i++)
            {
                if (_inventoryItems[i] != null) continue;
                
                _inventoryItems[i] = new ShooterInventoryItem(itemStack.Id, itemStack.ItemInstanceId, _itemShooterBlockParam.InitialShootSpeed);
                //
                _lastInsertElapsedTime = 0;
                return itemStack.SubItem(1);
            }
            
            return itemStack;
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            // 
            var nullCount = 0;
            foreach (var inventoryItem in _inventoryItems)
            {
                if (inventoryItem == null) nullCount++;
            }
            // 
            if (nullCount == 0) return false;
            
            // 1
            if (itemStacks.Count == 1 && itemStacks[0].Count == 1) return true;
            
            return false;
        }
        
        public IItemStack GetItem(int slot)
        {
            var itemStackFactory = ServerContext.ItemStackFactory;
            var item = _inventoryItems[slot];
            return item == null ? itemStackFactory.CreatEmpty() : itemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            _inventoryItems[slot] = new ShooterInventoryItem(itemStack.Id, itemStack.ItemInstanceId, _itemShooterBlockParam.InitialShootSpeed);
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            return _inventoryItems.Length;
        }
        
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public string SaveKey { get; } = typeof(ItemShooterComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            var items = _inventoryItems.Select(item => new ItemShooterItemJsonObject(item)).ToList();
            return JsonConvert.SerializeObject(items);
        }
    }
    
    public class ItemShooterItemJsonObject
    {
        [JsonProperty("itemStack")] public ItemStackSaveJsonObject ItemStackSave;
        
        [JsonProperty("remainingTime")] public double RemainingPercent;
        
        [JsonProperty("currentSpeed")] public double CurrentSpeed;
        
        public ItemShooterItemJsonObject(ShooterInventoryItem shooterInventoryItem)
        {
            if (shooterInventoryItem == null)
            {
                ItemStackSave = null;
                RemainingPercent = 0;
                CurrentSpeed = 0;
                return;
            }
            
            var item = ServerContext.ItemStackFactory.Create(shooterInventoryItem.ItemId, 1);
            ItemStackSave = new ItemStackSaveJsonObject(item);
            RemainingPercent = shooterInventoryItem.RemainingPercent;
            CurrentSpeed = shooterInventoryItem.CurrentSpeed;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Server/CollectBeltConveyorItemsTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Reflection;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Entity.Interface;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Server.Protocol.PacketResponse.Util;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Server
{
    public class CollectBeltConveyorItemsTest
    {
        //41
        private const double RemainingTime = 0.5;
        private const int ItemInstanceId = 100;
        
        private readonly List<Vector2Int> _plusPlayerCoordinate = new() { new Vector2Int(0, 0) };
        
        /// <summary>
        ///     
        /// </summary>
        [Test]
        public void BlockDirectionItemPositionTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var worldDataStore = ServerContext.WorldBlockDatastore;
            var entityFactory = serviceProvider.GetService<IEntityFactory>();
            
            //x,y 
            
            //
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.North, worldDataStore);
            
            //
            var itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //
            const float defaultY = CollectBeltConveyorItems.DefaultBeltConveyorHeight;
            Assert.AreEqual(0.5, itemEntity.Position.x); //0,0Z0.5 
            Assert.AreEqual(defaultY, itemEntity.Position.y); //23Y0
            Assert.AreEqual(0.75, itemEntity.Position.z); //4113/4
            //
            Assert.AreEqual(ItemInstanceId, itemEntity.InstanceId.AsPrimitive());
            Assert.AreEqual(VanillaEntityType.VanillaItem, itemEntity.EntityType);
            
            
            //
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.East, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //
            Assert.AreEqual(0.75, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.5, itemEntity.Position.z);
            
            
            //
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.South, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //
            Assert.AreEqual(0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.25, itemEntity.Position.z);
            
            
            //
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.West, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //
            Assert.AreEqual(0.25, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(0.5, itemEntity.Position.z);
            
            
            //xy
            //
            worldDataStore.RemoveBlock(new Vector3Int(0, 0, 0));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.North, worldDataStore);
            
            //
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //
            Assert.AreEqual(-0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.25, itemEntity.Position.z); //-13/4-0.25
            
            
            //
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.East, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //
            Assert.AreEqual(-0.25, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.5, itemEntity.Position.z);
            
            
            //
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.South, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //
            Assert.AreEqual(-0.5, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.75, itemEntity.Position.z);
            
            
            //
            worldDataStore.RemoveBlock(new Vector3Int(-1, 0, -1));
            CreateOneItemInsertedItem(new Vector3Int(-1, 0, -1), BlockDirection.West, worldDataStore);
            itemEntity = CollectBeltConveyorItems.CollectItem(entityFactory)[0];
            //
            Assert.AreEqual(-0.75, itemEntity.Position.x);
            Assert.AreEqual(defaultY, itemEntity.Position.y);
            Assert.AreEqual(-0.5, itemEntity.Position.z);
        }
        
        
        /// <summary>
        ///     InstanceId
        /// </summary>
        [Test]
        public void ItemInstanceIdTest()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldDataStore = ServerContext.WorldBlockDatastore;
            
            worldDataStore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(0, 0, 1), BlockDirection.North, out var belt2);
            //
            
            var belt1 = CreateOneItemInsertedItem(new Vector3Int(0, 0, 0), BlockDirection.North, worldDataStore);
            
            //4
            var now = DateTime.Now;
            while (DateTime.Now - now < TimeSpan.FromSeconds(RemainingTime * 1.1)) GameUpdater.UpdateWithWait();
            
            //
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventory2Items = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(belt2.GetComponent<VanillaBeltConveyorComponent>());
            
            //InstanceId
            Assert.AreEqual(ItemInstanceId, inventory2Items[3].ItemInstanceId.AsPrimitive());
        }
        
        
        private IBlock CreateOneItemInsertedItem(Vector3Int pos, BlockDirection blockDirection, IWorldBlockDatastore datastore)
        {
            datastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, pos, blockDirection, out var beltConveyor);
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            //_inventoryItems
            var inventoryItemsField = typeof(VanillaBeltConveyorComponent).GetField("_inventoryItems", BindingFlags.NonPublic | BindingFlags.Instance);
            var inventoryItems = (VanillaBeltConveyorInventoryItem[])inventoryItemsField.GetValue(beltConveyorComponent);
            
            inventoryItems[0] = new VanillaBeltConveyorInventoryItem(new ItemId(1), new ItemInstanceId(ItemInstanceId));
            inventoryItems[1] = null;
            inventoryItems[2] = null;
            inventoryItems[3] = null;
            
            inventoryItems[0].RemainingPercent = 0.25f;
            
            return beltConveyor;
        }
    }
}
```

moorestech_server/Assets/Scripts/Core.Master/MachineRecipesMaster.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Mooresmaster.Loader.MachineRecipesModule;
using Mooresmaster.Model.MachineRecipesModule;
using Newtonsoft.Json.Linq;

namespace Core.Master
{
    public class MachineRecipesMaster
    {
        public readonly MachineRecipes MachineRecipes; // TODO 
        private readonly Dictionary<string, MachineRecipeMasterElement> _machineRecipesByRecipeKey;
        
        public MachineRecipesMaster(JToken jToken)
        {
            MachineRecipes = MachineRecipesLoader.Load(jToken);
            
            _machineRecipesByRecipeKey = new Dictionary<string, MachineRecipeMasterElement>();
            BuildMachineRecipes();
            
            #region Internal
            
            void BuildMachineRecipes()
            {
                foreach (var recipe in MachineRecipes.Data)
                {
                    var inputItemIds = new List<ItemId>();
                    foreach (var inputItem in recipe.InputItems)
                    {
                        var itemId = MasterHolder.ItemMaster.GetItemId(inputItem.ItemGuid);
                        inputItemIds.Add(itemId);
                    }
                    
                    var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
                    
                    var key = GetRecipeElementKey(blockId, inputItemIds);
                    _machineRecipesByRecipeKey.Add(key, recipe);
                }
            }
            
            #endregion
        }
        
        public bool TryGetRecipeElement(BlockId blockId, List<ItemId> inputItemIds, out MachineRecipeMasterElement recipe)
        {
            var key = GetRecipeElementKey(blockId, inputItemIds);
            return _machineRecipesByRecipeKey.TryGetValue(key, out recipe);
        }
        
        public MachineRecipeMasterElement GetRecipeElement(Guid machineRecipeGuid)
        {
            return MachineRecipes.Data.ToList().Find(x => x.MachineRecipeGuid == machineRecipeGuid);
        }
        
        private static string GetRecipeElementKey(BlockId blockId, List<ItemId> itemIds)
        {
            StringBuilder items = new StringBuilder();
            items.Append(blockId);
            
            itemIds.Sort((a, b) => a.AsPrimitive() - b.AsPrimitive());
            itemIds.ForEach(i =>
            {
                items.Append('_');
                items.Append(i.AsPrimitive());
            });
            
            return items.ToString();
        }
    }
    
    public static class MachineRecipeMasterExtension
    {
        public static ItemId GetBlockItemId(this MachineRecipeMasterElement recipe)
        {
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            return MasterHolder.BlockMaster.GetItemId(blockId);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Train/Train/TrainCar.cs
```cs
namespace Game.Train.Train
{
    public class TrainCar
    {
        //  (0)
        public int TractionForce { get; private set; }

        //  (0?)
        public int InventorySlots { get; private set; }

        public TrainCar(int tractionForce, int inventorySlots)
        {
            TractionForce = tractionForce;
            InventorySlots = inventorySlots;
        }

    }

}

```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/VanillaMachineSaveComponent.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Item.Interface;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Newtonsoft.Json;

namespace Game.Block.Blocks.Machine
{
    public class VanillaMachineSaveComponent : IBlockSaveState
    {
        private readonly VanillaMachineInputInventory _vanillaMachineInputInventory;
        private readonly VanillaMachineOutputInventory _vanillaMachineOutputInventory;
        private readonly VanillaMachineProcessorComponent _vanillaMachineProcessorComponent;
        
        public VanillaMachineSaveComponent(
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            VanillaMachineProcessorComponent vanillaMachineProcessorComponent)
        {
            _vanillaMachineInputInventory = vanillaMachineInputInventory;
            _vanillaMachineOutputInventory = vanillaMachineOutputInventory;
            _vanillaMachineProcessorComponent = vanillaMachineProcessorComponent;
        }
        public bool IsDestroy { get; private set; }
        
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        [Obsolete("")] // TODO 
        public static string SaveKeyStatic => typeof(VanillaMachineSaveComponent).FullName;
        public string SaveKey { get; } = typeof(VanillaMachineSaveComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            // JsonObject
            var jsonObject = new VanillaMachineJsonObject
            {
                InputSlot = _vanillaMachineInputInventory.InputSlot.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
                OutputSlot = _vanillaMachineOutputInventory.OutputSlot.Select(item => new ItemStackSaveJsonObject(item)).ToList(),
                State = (int)_vanillaMachineProcessorComponent.CurrentState,
                RemainingTime = _vanillaMachineProcessorComponent.RemainingSecond,
                RecipeGuidStr = _vanillaMachineProcessorComponent.RecipeGuid.ToString(),
            };
            
            return JsonConvert.SerializeObject(jsonObject);
        }
    }
    
    public class VanillaMachineJsonObject
    {
        [JsonProperty("inputSlot")]
        public List<ItemStackSaveJsonObject> InputSlot;
        [JsonProperty("outputSlot")]
        public List<ItemStackSaveJsonObject> OutputSlot;
        [JsonProperty("recipeGuid")]
        public string RecipeGuidStr;
        [JsonIgnore]
        public Guid RecipeGuid => Guid.Parse(RecipeGuidStr);
        
        [JsonProperty("remainingTime")]
        public double RemainingTime;
        
        [JsonProperty("state")]
        public int State;
    }
}
```

moorestech_client/Assets/Scripts/Client.Game/InGame/BlockSystem/StateProcessor/CommonMachineBlockStateChangeProcessor.cs
```cs
using System;
using Game.Block.Blocks.Machine;
using Game.Block.Interface.State;
using Server.Event.EventReceive;
using UnityEngine;

namespace Client.Game.InGame.BlockSystem.StateProcessor
{
    /// <summary>
    /// TODO 
    /// </summary>
    public class CommonMachineBlockStateChangeProcessor : MonoBehaviour, IBlockStateChangeProcessor
    {
        public CommonMachineBlockStateDetail CurrentMachineState { get; private set; }
        
        
        private void Awake()
        {
        }
        
        private void Start()
        {

        }
        
        
        public void OnChangeState(BlockStateMessagePack blockState)
        {
            CurrentMachineState = blockState.GetStateDetail<CommonMachineBlockStateDetail>(CommonMachineBlockStateDetail.BlockStateDetailKey);
            var currentState = CurrentMachineState.CurrentStateType;
            var previousState = CurrentMachineState.PreviousStateType;
            
            switch (currentState)
            {
                case VanillaMachineBlockStateConst.ProcessingState:
                    if (previousState == VanillaMachineBlockStateConst.IdleState)
                    {
                    }
                    
                    break;
                case VanillaMachineBlockStateConst.IdleState:
                    break;
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/GearMachineSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Game.PlayerInventory;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class GearMachineSaveLoadTest
    {
        //
        //
        [Test]
        public void InventoryBlockTest()
        {
            //
            var (blockFactory, worldBlockDatastore, _, assembleSaveJsonText, _) = CreateBlockTestModule();
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GearMachine, new Vector3Int(0, 0), BlockDirection.North, out var gearMachineBlock);
            var machineInventory = gearMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            
            //
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(1), 3));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 1));
            
            //
            gearMachineBlock.GetComponent<GearEnergyTransformer>().SupplyPower(new RPM(1000), new Torque(1000), true);
            GameUpdater.UpdateWithWait();
            //
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(5), 6));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 4));
            
            //
            //
            var vanillaMachineProcessor = gearMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            //
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("RemainingSecond")
                .SetValue(vanillaMachineProcessor, 0.3);
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("CurrentState")
                .SetValue(vanillaMachineProcessor, ProcessState.Processing);
            
            //
            var outputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(machineInventory);
            
            outputInventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            outputInventory.SetItem(2, itemStackFactory.Create(new ItemId(3), 2));
            
            //ID
            var recipeId = vanillaMachineProcessor.RecipeGuid;
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            //
            worldBlockDatastore.RemoveBlock(new Vector3Int(0, 0));
            
            
            //
            var (_, loadWorldBlockDatastore, _, _, loadJsonFile) = CreateBlockTestModule();
            
            loadJsonFile.Load(json);
            
            var loadMachineBlock = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            
            //IDintID
            Assert.AreEqual(gearMachineBlock.BlockId, loadMachineBlock.BlockId);
            Assert.AreEqual(gearMachineBlock.BlockInstanceId, loadMachineBlock.BlockInstanceId);
            
            
            //
            var machineProcessor = loadMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            Assert.AreEqual(0.3, machineProcessor.RemainingSecond);
            //ID
            Assert.AreEqual(recipeId, machineProcessor.RecipeGuid);
            //
            Assert.AreEqual(ProcessState.Processing, machineProcessor.CurrentState);
            
            
            var loadMachineInventory = loadMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            //
            var inputInventoryField = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(5), 6), inputInventoryField.InputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 4), inputInventoryField.InputSlot[1]);
            
            //
            var outputInventoryField = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.CreatEmpty(), outputInventoryField.OutputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 1), outputInventoryField.OutputSlot[1]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), outputInventoryField.OutputSlot[2]);
        }
        
        private (IBlockFactory, IWorldBlockDatastore, PlayerInventoryDataStore, AssembleSaveJsonText, WorldLoaderFromJson)
            CreateBlockTestModule()
        {
            var (packet, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var playerInventoryDataStore = serviceProvider.GetService<PlayerInventoryDataStore>();
            var loadJsonFile = serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson;
            
            return (blockFactory, worldBlockDatastore, playerInventoryDataStore, assembleSaveJsonText, loadJsonFile);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineOutputInventory.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Service;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Event;
using Game.Context;
using Mooresmaster.Model.MachineRecipesModule;
using UniRx;

namespace Game.Block.Blocks.Machine.Inventory
{
    public class VanillaMachineOutputInventory
    {
        public IReadOnlyList<IItemStack> OutputSlot => _itemDataStoreService.InventoryItems;
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly ConnectingInventoryListPriorityInsertItemService _connectInventoryService;
        private readonly BlockInstanceId _blockInstanceId;
        
        private readonly int _inputSlotSize;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        public VanillaMachineOutputInventory(int outputSlot, IItemStackFactory itemStackFactory,
            BlockOpenableInventoryUpdateEvent blockInventoryUpdate, BlockInstanceId blockInstanceId, int inputSlotSize, BlockConnectorComponent<IBlockInventory> blockConnectorComponent)
        {
            _blockInventoryUpdate = blockInventoryUpdate;
            _blockInstanceId = blockInstanceId;
            _inputSlotSize = inputSlotSize;
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, itemStackFactory, outputSlot);
            _connectInventoryService = new ConnectingInventoryListPriorityInsertItemService(blockConnectorComponent);
            GameUpdater.UpdateObservable.Subscribe(_ => Update());
        }
        
        private void Update()
        {
            InsertConnectInventory();
        }
        
        /// <summary>
        ///     
        /// </summary>
        /// <param name="machineRecipe"></param>
        /// <returns>true</returns>
        public bool IsAllowedToOutputItem(MachineRecipeMasterElement machineRecipe)
        {
            foreach (var itemOutput in machineRecipe.OutputItems)
            {
                var outputItemId = MasterHolder.ItemMaster.GetItemId(itemOutput.ItemGuid);
                var outputItemStack = ServerContext.ItemStackFactory.Create(outputItemId, itemOutput.Count);
                
                var isAllowed = OutputSlot.Aggregate(false, (current, slot) => slot.IsAllowedToAdd(outputItemStack) || current);
                
                if (!isAllowed) return false;
            }
            
            return true;
        }
        
        public void InsertOutputSlot(MachineRecipeMasterElement machineRecipe)
        {
            //
            foreach (var itemOutput in machineRecipe.OutputItems)
                for (var i = 0; i < OutputSlot.Count; i++)
                {
                    var outputItemId = MasterHolder.ItemMaster.GetItemId(itemOutput.ItemGuid);
                    var outputItemStack = ServerContext.ItemStackFactory.Create(outputItemId, itemOutput.Count);
                    
                    if (!OutputSlot[i].IsAllowedToAdd(outputItemStack)) continue;
                    
                    var item = OutputSlot[i].AddItem(outputItemStack).ProcessResultItemStack;
                    _itemDataStoreService.SetItem(i, item);
                    break;
                }
        }
        
        private void InsertConnectInventory()
        {
            for (var i = 0; i < OutputSlot.Count; i++)
                _itemDataStoreService.SetItem(i, _connectInventoryService.InsertItem(OutputSlot[i]));
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(
                _blockInstanceId, slot + _inputSlotSize, itemStack));
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block.Interface/Component/IBlockInventory.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Game.Block.Interface.ComponentAttribute;

namespace Game.Block.Interface.Component
{
    /// <summary>
    ///     
    ///     
    /// </summary>
    [DisallowMultiple]
    public interface IBlockInventory : IBlockComponent
    {
        public IItemStack InsertItem(IItemStack itemStack);
        public bool InsertionCheck(List<IItemStack> itemStacks);
        
        public IItemStack GetItem(int slot);
        void SetItem(int slot, IItemStack itemStack);
        public int GetSlotSize();
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearMachineIoTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Gear;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.MachineRecipesModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class GearMachineIoTest
    {
        public int GearMachineRecipeIndex = 3;
        
        //
        [Test]
        public void ItemProcessingOutputTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[GearMachineRecipeIndex];
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var block = blockFactory.Create(blockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var blockInventory = block.GetComponent<VanillaMachineBlockInventoryComponent>();
            foreach (var inputItem in recipe.InputItems)
            {
                blockInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var gearEnergyTransformer = block.GetComponent<GearEnergyTransformer>();
            var gearMachineParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearMachine).BlockParam as GearMachineBlockParam;
            var machineProcessor = block.GetComponent<VanillaMachineProcessorComponent>();
            
            //
            var craftTime = DateTime.Now.AddSeconds(recipe.Time);
            while (craftTime.AddSeconds(0.4).CompareTo(DateTime.Now) == 1)
            {
                var requiredRpm = new RPM(gearMachineParam.RequiredRpm);
                var requiredTorque = new Torque(gearMachineParam.RequireTorque);
                gearEnergyTransformer.SupplyPower(requiredRpm, requiredTorque, true);
                machineProcessor.Update();
                GameUpdater.Wait();
                GameUpdater.UpdateDeltaTime();
            }
            
            //
            AssertInventory(blockInventory, recipe);
        }
        
        
        [Test]
        // RPM
        public void NotEnoughTorqueOrRpmTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[GearMachineRecipeIndex];
            
            var recipeBlockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var lackRpmBlock = blockFactory.Create(recipeBlockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var lackTorqueBlock = blockFactory.Create(recipeBlockId, new BlockInstanceId(2), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.zero));
            
            var lackRpmInventory = lackRpmBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            var lackTorqueInventory = lackTorqueBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            foreach (var inputItem in recipe.InputItems)
            {
                lackRpmInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
                lackTorqueInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var lackRpmGearMachine = lackRpmBlock.GetComponent<GearEnergyTransformer>();
            var lackTorqueGearMachine = lackTorqueBlock.GetComponent<GearEnergyTransformer>();
            var gearMachineParam = lackRpmBlock.BlockMasterElement.BlockParam as GearMachineBlockParam;
            
            var lackRpmProcessor = lackRpmBlock.GetComponent<VanillaMachineProcessorComponent>();
            var lackTorqueProcessor = lackTorqueBlock.GetComponent<VanillaMachineProcessorComponent>();
            
            //
            var craftTime = DateTime.Now.AddSeconds(recipe.Time * 2);
            while (craftTime.AddSeconds(0.3).CompareTo(DateTime.Now) == 1)
            {
                var rpm = new RPM(gearMachineParam.RequiredRpm / 2f);
                lackRpmGearMachine.SupplyPower(rpm, new Torque(gearMachineParam.RequireTorque), true);
                lackTorqueGearMachine.SupplyPower(new RPM(gearMachineParam.RequiredRpm), (Torque)gearMachineParam.RequireTorque / 2f, true);
                
                lackRpmProcessor.Update();
                lackTorqueProcessor.Update();
                
                GameUpdater.Wait();
                GameUpdater.UpdateDeltaTime();
            }
            
            //
            AssertInventory(lackRpmInventory, recipe);
            AssertInventory(lackTorqueInventory, recipe);
        }
        
        private void AssertInventory(VanillaMachineBlockInventoryComponent inventory, MachineRecipeMasterElement recipe)
        {
            (List<IItemStack> input, List<IItemStack> output) = GetInputOutputSlot(inventory);
            
            Assert.AreEqual(0, input.Count);
            foreach (var inputItem in input) Assert.AreEqual(ItemMaster.EmptyItemId, inputItem.Id);
            
            Assert.AreNotEqual(0, output.Count);
            for (var i = 0; i < output.Count; i++)
            {
                var outputItemId = MasterHolder.ItemMaster.GetItemId(recipe.OutputItems[i].ItemGuid);
                Assert.AreEqual(outputItemId, output[i].Id);
                Assert.AreEqual(recipe.OutputItems[i].Count, output[i].Count);
            }
        }
        
        private (List<IItemStack>, List<IItemStack>) GetInputOutputSlot(VanillaMachineBlockInventoryComponent vanillaMachineInventory)
        {
            var vanillaMachineInputInventory = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            var vanillaMachineOutputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            
            var inputSlot = vanillaMachineInputInventory.InputSlot.Where(i => i.Count != 0).ToList();
            inputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            var outputSlot = vanillaMachineOutputInventory.OutputSlot.Where(i => i.Count != 0).ToList();
            outputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            return (inputSlot, outputSlot);
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/GearBeltConveyorTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.Gear.Common;
using Microsoft.Extensions.DependencyInjection;
using Mooresmaster.Model.BlockConnectInfoModule;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class GearBeltConveyorTest
    {
        // 100%
        [Test]
        public void OutputTestWhenTorqueSuppliedRateIs100()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            const int id = 2;
            const int count = 3;
            var item = itemStackFactory.Create(new ItemId(id), count);
            var dummy = new DummyBlockInventory();
            
            
            // gearBeltConveyor
            var gearBeltConveyorPosition = new Vector3Int(0, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.GearBeltConveyor, gearBeltConveyorPosition, BlockDirection.North, out var gearBeltConveyor);
            var beltConveyorComponent = gearBeltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)gearBeltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            connectInventory.Add(dummy, new ConnectedInfo());
            
            // generator
            var generatorPosition = new Vector3Int(1, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SimpleGearGenerator, generatorPosition, BlockDirection.East, out var generator);
            
            // testGear
            var testGearPosition = new Vector3Int(2, 0, 0);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.SmallGear, testGearPosition, BlockDirection.East, out var testGear);
            
            var gearNetworkDatastore = serviceProvider.GetService<GearNetworkDatastore>();
            IReadOnlyDictionary<GearNetworkId, GearNetwork> gearNetwork = gearNetworkDatastore.GearNetworks;
            
            
            const int torqueRate = 1;
            const int generatorRpm = 10;
            var gearBeltConveyorBlockParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.GearBeltConveyor).BlockParam as GearBeltConveyorBlockParam;
            var duration = 1f / (generatorRpm * torqueRate * gearBeltConveyorBlockParam.BeltConveyorSpeed);
            var expectedEndTime = DateTime.Now.AddSeconds(duration);
            var startTime = DateTime.Now;
            beltConveyorComponent.InsertItem(item);
            
            // for (var i = 0; i < 100; i++)
            // {
            //     GameUpdater.UpdateWithWait();
            // }
            var c = 0;
            while (!dummy.IsItemExists)
            {
                c++;
                GameUpdater.UpdateWithWait();
                var elapsed = DateTime.Now - startTime;
                if (elapsed.TotalSeconds > 20) Assert.Fail();
            }
            
            Assert.True(dummy.IsItemExists);
            
            var now = DateTime.Now;
            Debug.Log($"{now} {expectedEndTime}\n{(now - startTime).TotalSeconds}\n{(expectedEndTime - now).TotalSeconds}\n{duration}\n{c}");
            Assert.True(now <= expectedEndTime.AddSeconds(0.4));
            Assert.True(expectedEndTime.AddSeconds(-0.4) <= now);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.CraftChainer/Util/ItemRecipeViewerDataContainer.cs
```cs
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Mooresmaster.Model.CraftRecipesModule;
using Mooresmaster.Model.MachineRecipesModule;

namespace Game.CraftChainer.Util
{
    // TODO 
    public class ItemRecipeViewerDataContainer
    {
        private readonly Dictionary<ItemId, RecipeViewerItemRecipes> _recipeViewerElements = new();
        
        public ItemRecipeViewerDataContainer()
        {
            // 
            // Get the recipe of the machine to create the item
            var machineRecipeDictionary = new Dictionary<ItemId, List<MachineRecipeMasterElement>>();
            foreach (var machineRecipeMaster in MasterHolder.MachineRecipesMaster.MachineRecipes.Data)
            {
                foreach (var outputItem in machineRecipeMaster.OutputItems)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(outputItem.ItemGuid);
                    if (!machineRecipeDictionary.ContainsKey(itemId))
                    {
                        machineRecipeDictionary.Add(itemId, new List<MachineRecipeMasterElement>());
                    }
                    
                    machineRecipeDictionary[itemId].Add(machineRecipeMaster);
                }
            }
            
            // 
            // Get the craft recipe to create the item
            foreach (var itemId in MasterHolder.ItemMaster.GetItemAllIds())
            {
                var resultCraftRecipes = MasterHolder.CraftRecipeMaster.GetResultItemCraftRecipes(itemId).ToList();
                
                // 
                // Create a machine recipe for each machine to create the item
                var resultMachineRecipes = new Dictionary<BlockId, List<MachineRecipeMasterElement>>();
                if (machineRecipeDictionary.TryGetValue(itemId, out var machineRecipesList))
                {
                    foreach (var machineRecipe in machineRecipesList)
                    {
                        var blockId = MasterHolder.BlockMaster.GetBlockId(machineRecipe.BlockGuid);
                        if (resultMachineRecipes.ContainsKey(blockId))
                        {
                            resultMachineRecipes[blockId].Add(machineRecipe);
                        }
                        else
                        {
                            resultMachineRecipes.Add(blockId, new List<MachineRecipeMasterElement> { machineRecipe });
                        }
                    }
                }
                
                _recipeViewerElements.Add(itemId, new RecipeViewerItemRecipes(resultCraftRecipes, resultMachineRecipes, itemId));
            }
            
            // 
            // Exclude items with no recipes
            var removeList = new List<ItemId>();
            foreach (var kv in _recipeViewerElements)
            {
                var itemId = kv.Key;
                var recipe = kv.Value;
                
                if (recipe.CraftRecipes.Count == 0 && recipe.MachineRecipes.Count == 0)
                {
                    removeList.Add(itemId);
                }
            }
            foreach (var itemId in removeList)
            {
                _recipeViewerElements.Remove(itemId);
            }
        }
        
        public RecipeViewerItemRecipes GetItem(ItemId itemId)
        {
            return _recipeViewerElements.GetValueOrDefault(itemId);
        }
    }
    
    public class RecipeViewerItemRecipes
    {
        public readonly ItemId ResultItemId;
        
        //TODO mod
        public readonly List<CraftRecipeMasterElement> CraftRecipes;
        public readonly Dictionary<BlockId, List<MachineRecipeMasterElement>> MachineRecipes;
        
        public RecipeViewerItemRecipes(List<CraftRecipeMasterElement> craftRecipes, Dictionary<BlockId, List<MachineRecipeMasterElement>> machineRecipes, ItemId resultItemId)
        {
            CraftRecipes = craftRecipes;
            MachineRecipes = machineRecipes;
            ResultItemId = resultItemId;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/UnitTest/Game/SaveLoad/MachineSaveLoadTest.cs
```cs
using System.Reflection;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.PlayerInventory;
using Game.SaveLoad.Interface;
using Game.SaveLoad.Json;
using Game.World.Interface.DataStore;
using Microsoft.Extensions.DependencyInjection;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;
using Assert = UnityEngine.Assertions.Assert;

namespace Tests.UnitTest.Game.SaveLoad
{
    public class MachineSaveLoadTest
    {
        //
        //
        [Test]
        public void InventoryBlockTest()
        {
            //
            var (blockFactory, worldBlockDatastore, _, assembleSaveJsonText, _) = CreateBlockTestModule();
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.MachineId , new Vector3Int(0, 0), BlockDirection.North, out var machineBlock);
            var machineInventory = machineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            
            
            //
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(1), 3));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 1));
            //
            GameUpdater.UpdateWithWait();
            //
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(5), 6));
            machineInventory.InsertItem(itemStackFactory.Create(new ItemId(2), 4));
            
            //
            //
            var vanillaMachineProcessor = machineBlock.GetComponent<VanillaMachineProcessorComponent>();
            //
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("RemainingSecond")
                .SetValue(vanillaMachineProcessor, 0.3);
            typeof(VanillaMachineProcessorComponent)
                .GetProperty("CurrentState")
                .SetValue(vanillaMachineProcessor, ProcessState.Processing);
            
            //
            var outputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(machineInventory);
            
            outputInventory.SetItem(1, itemStackFactory.Create(new ItemId(1), 1));
            outputInventory.SetItem(2, itemStackFactory.Create(new ItemId(3), 2));
            
            //ID
            var recipeId = vanillaMachineProcessor.RecipeGuid;
            
            var json = assembleSaveJsonText.AssembleSaveJson();
            Debug.Log(json);
            //
            worldBlockDatastore.RemoveBlock(new Vector3Int(0, 0));
            
            
            //
            var (_, loadWorldBlockDatastore, _, _, loadJsonFile) = CreateBlockTestModule();
            
            loadJsonFile.Load(json);
            
            var loadMachineBlock = loadWorldBlockDatastore.GetBlock(new Vector3Int(0, 0));
            
            //IDintID
            Assert.AreEqual(machineBlock.BlockId, loadMachineBlock.BlockId);
            Assert.AreEqual(machineBlock.BlockInstanceId, loadMachineBlock.BlockInstanceId);
            
            
            //
            var machineProcessor = loadMachineBlock.GetComponent<VanillaMachineProcessorComponent>();
            Assert.AreEqual(0.3, machineProcessor.RemainingSecond);
            //ID
            Assert.AreEqual(recipeId, machineProcessor.RecipeGuid);
            //
            Assert.AreEqual(ProcessState.Processing, machineProcessor.CurrentState);
            
            
            var loadMachineInventory = loadMachineBlock.GetComponent<VanillaMachineBlockInventoryComponent>();
            //
            var inputInventoryField = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(5), 6), inputInventoryField.InputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(2), 4), inputInventoryField.InputSlot[1]);
            
            //
            var outputInventoryField = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(loadMachineInventory);
            Assert.AreEqual(itemStackFactory.CreatEmpty(), outputInventoryField.OutputSlot[0]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(1), 1), outputInventoryField.OutputSlot[1]);
            Assert.AreEqual(itemStackFactory.Create(new ItemId(3), 2), outputInventoryField.OutputSlot[2]);
        }
        
        private (IBlockFactory, IWorldBlockDatastore, PlayerInventoryDataStore, AssembleSaveJsonText, WorldLoaderFromJson)
            CreateBlockTestModule()
        {
            var (packet, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var blockFactory = ServerContext.BlockFactory;
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            var assembleSaveJsonText = serviceProvider.GetService<AssembleSaveJsonText>();
            var playerInventoryDataStore = serviceProvider.GetService<PlayerInventoryDataStore>();
            var loadJsonFile = serviceProvider.GetService<IWorldSaveDataLoader>() as WorldLoaderFromJson;
            
            return (blockFactory, worldBlockDatastore, playerInventoryDataStore, assembleSaveJsonText, loadJsonFile);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/Machine/Inventory/VanillaMachineInputInventory.cs
```cs
using System.Collections.Generic;
using Core.Inventory;
using Core.Item.Interface;
using Core.Master;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Event;
using Game.Context;
using Mooresmaster.Model.MachineRecipesModule;

namespace Game.Block.Blocks.Machine.Inventory
{
    /// <summary>
    ///     
    ///     InsertInput
    /// </summary>
    public class VanillaMachineInputInventory
    {
        private readonly BlockId _blockId;
        
        private readonly BlockOpenableInventoryUpdateEvent _blockInventoryUpdate;
        private readonly BlockInstanceId _blockInstanceId;
        private readonly OpenableInventoryItemDataStoreService _itemDataStoreService;
        
        public VanillaMachineInputInventory(BlockId blockId, int inputSlot, BlockOpenableInventoryUpdateEvent blockInventoryUpdate, BlockInstanceId blockInstanceId)
        {
            _blockId = blockId;
            _blockInventoryUpdate = blockInventoryUpdate;
            _blockInstanceId = blockInstanceId;
            _itemDataStoreService = new OpenableInventoryItemDataStoreService(InvokeEvent, ServerContext.ItemStackFactory, inputSlot);
        }
        
        public IReadOnlyList<IItemStack> InputSlot => _itemDataStoreService.InventoryItems;
        
        public bool IsAllowedToStartProcess()
        {
            //ID
            if (TryGetRecipeElement(out var recipe))
            {
                //
                return recipe.RecipeConfirmation(_blockId, InputSlot);
            }
            return false;
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            return _itemDataStoreService.InsertItem(itemStack);
        }
        
        public List<IItemStack> InsertItem(List<IItemStack> itemStacks)
        {
            return _itemDataStoreService.InsertItem(itemStacks);
        }
        
        public bool TryGetRecipeElement(out MachineRecipeMasterElement recipe)
        {
            return MachineRecipeMasterUtil.TryGetRecipeElement(_blockId, InputSlot, out recipe);
        }
        
        public void ReduceInputSlot(MachineRecipeMasterElement recipe)
        {
            //input
            foreach (var item in recipe.InputItems)
                for (var i = 0; i < InputSlot.Count; i++)
                {
                    var itemId = MasterHolder.ItemMaster.GetItemId(item.ItemGuid);
                    
                    if (_itemDataStoreService.InventoryItems[i].Id != itemId || item.Count > InputSlot[i].Count) continue;
                    //
                    _itemDataStoreService.SetItem(i, InputSlot[i].SubItem(item.Count));
                    break;
                }
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            _itemDataStoreService.SetItem(slot, itemStack);
        }
        
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            return _itemDataStoreService.InsertionCheck(itemStacks);
        }
        
        private void InvokeEvent(int slot, IItemStack itemStack)
        {
            _blockInventoryUpdate.OnInventoryUpdateInvoke(new BlockOpenableInventoryUpdateEventProperties(
                _blockInstanceId, slot, itemStack));
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/BeltConveyorTest.cs
```cs
using System;
using System.Collections.Generic;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Component;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Block.Interface.Extension;
using Game.Context;
using Mooresmaster.Model.BlockConnectInfoModule;
using Mooresmaster.Model.BlocksModule;
using NUnit.Framework;
using Server.Boot;
using Tests.Module;
using Tests.Module.TestMod;
using UnityEngine;
using Random = System.Random;

namespace Tests.CombinedTest.Core
{
    /// <summary>
    ///     
    /// </summary>
    public class BeltConveyorTest
    {
        //
        [Test]
        public void FullInsertAndChangeConnectorBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //2
            {
                var id = new ItemId(random.Next(0, 10));
                
                var item = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount + 1);
                var beltConveyor = ServerContext.BlockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var endTime = DateTime.Now.AddSeconds(beltConveyorParam.TimeOfItemEnterToExit);
                
                while (DateTime.Now < endTime.AddSeconds(0.1))
                {
                    item = beltConveyorComponent.InsertItem(item);
                    GameUpdater.UpdateWithWait();
                }
                
                Assert.AreEqual(item.Count, 1);
                
                var dummy = new DummyBlockInventory();
                
                var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
                connectInventory.Add(dummy, new ConnectedInfo());
                GameUpdater.UpdateWithWait();
                
                Assert.AreEqual(itemStackFactory.Create(id, 1).ToString(), dummy.InsertedItems[0].ToString());
            }
        }
        
        //
        [Test]
        public void InsertBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            
            var id = new ItemId(2);
            const int count = 3;
            var item = itemStackFactory.Create(id, count);
            var dummy = new DummyBlockInventory();
            
            // 
            var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
            
            var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
            connectInventory.Add(dummy, new ConnectedInfo());
            
            var expectedEndTime = DateTime.Now.AddSeconds(beltConveyorParam.TimeOfItemEnterToExit);
            var outputItem = beltConveyorComponent.InsertItem(item);
            
            //5 
            while (!dummy.IsItemExists) GameUpdater.UpdateWithWait();
            
            
            //
            Assert.True(DateTime.Now <= expectedEndTime.AddSeconds(0.1));
            Assert.True(expectedEndTime.AddSeconds(-0.1) <= DateTime.Now);
            
            Debug.Log($"{(DateTime.Now - expectedEndTime).TotalSeconds}");
            
            Assert.True(outputItem.Equals(itemStackFactory.Create(id, count - 1)));
            var tmp = itemStackFactory.Create(id, 1);
            Debug.Log($"{tmp} {dummy.InsertedItems[0]}");
            Assert.AreEqual(tmp.ToString(), dummy.InsertedItems[0].ToString());
        }
        
        //
        [Test]
        public void FullInsertBeltConveyorTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var beltConveyorParam = MasterHolder.BlockMaster.GetBlockMaster(ForUnitTestModBlockId.BeltConveyorId).BlockParam as BeltConveyorBlockParam;
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //2
            {
                var id = new ItemId(random.Next(1, 11));
                var item = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount + 1);
                var dummy = new DummyBlockInventory(beltConveyorParam.BeltConveyorItemCount);
                var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId, new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var connectInventory = (Dictionary<IBlockInventory, ConnectedInfo>)beltConveyor.GetComponent<BlockConnectorComponent<IBlockInventory>>().ConnectedTargets;
                connectInventory.Add(dummy, new ConnectedInfo());
                
                while (!dummy.IsItemExists)
                {
                    item = beltConveyorComponent.InsertItem(item);
                    GameUpdater.UpdateWithWait();
                }
                
                Assert.True(item.Equals(itemStackFactory.Create(id, 0)));
                var tmp = itemStackFactory.Create(id, beltConveyorParam.BeltConveyorItemCount);
                Assert.True(dummy.InsertedItems[0].Equals(tmp));
            }
        }
        
        //
        [Test]
        public void Insert2ItemBeltConveyorTest()
        {
            var (_, serviceProvider) =
                new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            var blockFactory = ServerContext.BlockFactory;
            var itemStackFactory = ServerContext.ItemStackFactory;
            
            var random = new Random(4123);
            for (var i = 0; i < 2; i++) //2
            {
                //
                var item1 = itemStackFactory.Create(new ItemId(random.Next(1, 11)), random.Next(1, 10));
                var item2 = itemStackFactory.Create(new ItemId(random.Next(1, 11)), random.Next(1, 10));
                
                var beltConveyor = blockFactory.Create(ForUnitTestModBlockId.BeltConveyorId , new BlockInstanceId(int.MaxValue), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
                var beltConveyorComponent = beltConveyor.GetComponent<VanillaBeltConveyorComponent>();
                
                var item1Out = beltConveyorComponent.InsertItem(item1);
                var item2Out = beltConveyorComponent.InsertItem(item2);
                
                Assert.True(item1Out.Equals(item1.SubItem(1)));
                Assert.True(item2Out.Equals(item2));
            }
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Game/BeltConveyorInsertTest.cs
```cs
using System;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Chest;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Game
{
    public class BeltConveyorInsertTest
    {
        //2
        [Test]
        public void TwoItemIoTest()
        {
            var (_, saveServiceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var worldBlockDatastore = ServerContext.WorldBlockDatastore;
            
            //
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, Vector3Int.zero, BlockDirection.North, out var inputChest);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.BeltConveyorId, new Vector3Int(0, 0, 1), BlockDirection.North, out var beltConveyor);
            worldBlockDatastore.TryAddBlock(ForUnitTestModBlockId.ChestId, new Vector3Int(0, 0, 2), BlockDirection.North, out var outputChest);
            
            //2
            var inputChestComponent = inputChest.GetComponent<VanillaChestComponent>();
            inputChestComponent.SetItem(0, new ItemId(1), 2);
            
            //6
            var now = DateTime.Now;
            while (DateTime.Now - now < TimeSpan.FromSeconds(5)) GameUpdater.UpdateWithWait();
            
            //
            Assert.AreEqual(0, inputChestComponent.GetItem(0).Count);
            //
            var outputChestComponent = outputChest.GetComponent<VanillaChestComponent>();
            Assert.AreEqual(2, outputChestComponent.GetItem(0).Count);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/BlockTemplateUtil.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using Core.Master;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Component;
using Game.Block.Event;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Game.EnergySystem;
using Mooresmaster.Model.BlocksModule;
using Mooresmaster.Model.InventoryConnectsModule;
using Newtonsoft.Json;

namespace Game.Block.Factory.BlockTemplate
{
    public class BlockTemplateUtil
    {
        public static BlockConnectorComponent<IBlockInventory> CreateInventoryConnector(InventoryConnects inventoryConnects, BlockPositionInfo blockPositionInfo)
        {
            return new BlockConnectorComponent<IBlockInventory>(inventoryConnects.InputConnects, inventoryConnects.OutputConnects, blockPositionInfo);
        }
        
        // TODO 
        public static (VanillaMachineInputInventory, VanillaMachineOutputInventory) GetMachineIOInventory(
            BlockId blockId,BlockInstanceId blockInstanceId,
            IMachineParam machineParam, 
            BlockConnectorComponent<IBlockInventory> blockConnectorComponent,
            BlockOpenableInventoryUpdateEvent blockInventoryUpdateEvent)
        {
            var inputSlotCount = machineParam.InputSlotCount;
            var outputSlotCount = machineParam.OutputSlotCount;
            
            var input = new VanillaMachineInputInventory(
                blockId, inputSlotCount,
                blockInventoryUpdateEvent, blockInstanceId);
            
            var output = new VanillaMachineOutputInventory(
                outputSlotCount, ServerContext.ItemStackFactory, blockInventoryUpdateEvent, blockInstanceId,
                inputSlotCount, blockConnectorComponent);
            
            return (input, output);
        }
        
        public static VanillaMachineProcessorComponent MachineLoadState(
            Dictionary<string, string> componentStates,
            VanillaMachineInputInventory vanillaMachineInputInventory,
            VanillaMachineOutputInventory vanillaMachineOutputInventory,
            ElectricPower requestPower)
        {
            var state = componentStates[VanillaMachineSaveComponent.SaveKeyStatic];
            var jsonObject = JsonConvert.DeserializeObject<VanillaMachineJsonObject>(state);
            
            var inputItems = jsonObject.InputSlot.Select(item => item.ToItemStack()).ToList();
            for (var i = 0; i < inputItems.Count; i++)
            {
                vanillaMachineInputInventory.SetItem(i, inputItems[i]);
            }
            
            var outputItems = jsonObject.OutputSlot.Select(item => item.ToItemStack()).ToList();
            for (var i = 0; i < outputItems.Count; i++)
            {
                vanillaMachineOutputInventory.SetItem(i, outputItems[i]);
            }
            
            var recipe = jsonObject.RecipeGuid == Guid.Empty ?
                null :
                MasterHolder.MachineRecipesMaster.GetRecipeElement(jsonObject.RecipeGuid);
            
            var processor = new VanillaMachineProcessorComponent(
                vanillaMachineInputInventory,
                vanillaMachineOutputInventory,
                (ProcessState)jsonObject.State,
                jsonObject.RemainingTime,
                recipe,
                requestPower);
            
            return processor;
        }
    }
}
```

moorestech_server/Assets/Scripts/Tests/CombinedTest/Core/MachineIOTest.cs
```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Core.Const;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Machine;
using Game.Block.Blocks.Machine.Inventory;
using Game.Block.Interface;
using Game.Block.Interface.Extension;
using Game.Context;
using Game.EnergySystem;
using NUnit.Framework;
using Server.Boot;
using Tests.Module.TestMod;
using UnityEngine;

namespace Tests.CombinedTest.Core
{
    public class MachineIOTest
    {
        //
        [Test]
        public void ItemProcessingOutputTest()
        {
            var (_, serviceProvider) = new MoorestechServerDIContainerGenerator().Create(TestModDirectory.ForUnitTestModDirectory);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            var blockFactory = ServerContext.BlockFactory;
            
            var recipe = MasterHolder.MachineRecipesMaster.MachineRecipes.Data[0];
            
            
            var blockId = MasterHolder.BlockMaster.GetBlockId(recipe.BlockGuid);
            var block = blockFactory.Create(blockId, new BlockInstanceId(1), new BlockPositionInfo(Vector3Int.one, BlockDirection.North, Vector3Int.one));
            var blockInventory = block.GetComponent<VanillaMachineBlockInventoryComponent>();
            foreach (var inputItem in recipe.InputItems)
            {
                blockInventory.InsertItem(itemStackFactory.Create(inputItem.ItemGuid, inputItem.Count));
            }
            
            var blockMachineComponent = block.GetComponent<VanillaElectricMachineComponent>();
            
            var craftTime = DateTime.Now.AddSeconds(recipe.Time);
            //
            while (craftTime.AddSeconds(0.2).CompareTo(DateTime.Now) == 1)
            {
                blockMachineComponent.SupplyEnergy(new ElectricPower(10000));
                GameUpdater.UpdateWithWait();
            }
            
            //
            (List<IItemStack> input, List<IItemStack> output) = GetInputOutputSlot(blockInventory);
            
            Assert.AreEqual(0, input.Count);
            foreach (var inputItem in input) Assert.AreEqual(ItemMaster.EmptyItemId, inputItem.Id);
            
            Assert.AreNotEqual(0, output.Count);
            for (var i = 0; i < output.Count; i++)
            {
                var expectedOutputId = MasterHolder.ItemMaster.GetItemId(recipe.OutputItems[i].ItemGuid);
                Assert.AreEqual(expectedOutputId, output[i].Id);
                Assert.AreEqual(recipe.OutputItems[i].Count, output[i].Count);
            }
        }
        
        public (List<IItemStack>, List<IItemStack>) GetInputOutputSlot(VanillaMachineBlockInventoryComponent vanillaMachineInventory)
        {
            var vanillaMachineInputInventory = (VanillaMachineInputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineInputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            var vanillaMachineOutputInventory = (VanillaMachineOutputInventory)typeof(VanillaMachineBlockInventoryComponent)
                .GetField("_vanillaMachineOutputInventory", BindingFlags.NonPublic | BindingFlags.Instance)
                .GetValue(vanillaMachineInventory);
            
            var inputSlot = vanillaMachineInputInventory.InputSlot.Where(i => i.Count != 0).ToList();
            inputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            var outputSlot = vanillaMachineOutputInventory.OutputSlot.Where(i => i.Count != 0).ToList();
            outputSlot.Sort((a, b) => a.Id.AsPrimitive() - b.Id.AsPrimitive());
            
            return (inputSlot, outputSlot);
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Blocks/BeltConveyor/VanillaBeltConveyorComponent.cs
```cs
using System.Collections.Generic;
using Core.Item.Interface;
using Core.Master;
using Core.Update;
using Game.Block.Blocks.Connector;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Game.Context;
using Newtonsoft.Json;

namespace Game.Block.Blocks.BeltConveyor
{
    /// <summary>
    ///     
    /// </summary>
    public class VanillaBeltConveyorComponent : IBlockInventory, IBlockSaveState, IItemCollectableBeltConveyor, IUpdatableBlockComponent
    {
        public BeltConveyorSlopeType SlopeType { get; }
        public IReadOnlyList<IOnBeltConveyorItem> BeltConveyorItems => _inventoryItems;
        private readonly VanillaBeltConveyorInventoryItem[] _inventoryItems;
        
        private readonly IBlockInventoryInserter _blockInventoryInserter;
        private readonly int _inventoryItemNum;
        
        private double _timeOfItemEnterToExit; //
        
        public VanillaBeltConveyorComponent(int inventoryItemNum, float timeOfItemEnterToExit, IBlockInventoryInserter blockInventoryInserter, BeltConveyorSlopeType slopeType)
        {
            SlopeType = slopeType;
            _inventoryItemNum = inventoryItemNum;
            _timeOfItemEnterToExit = timeOfItemEnterToExit;
            _blockInventoryInserter = blockInventoryInserter;
            
            _inventoryItems = new VanillaBeltConveyorInventoryItem[inventoryItemNum];
        }
        
        public VanillaBeltConveyorComponent(Dictionary<string, string> componentStates, int inventoryItemNum, float timeOfItemEnterToExit, IBlockInventoryInserter blockInventoryInserter, BeltConveyorSlopeType slopeType) :
            this(inventoryItemNum, timeOfItemEnterToExit, blockInventoryInserter, slopeType)
        {
            var itemJsons = JsonConvert.DeserializeObject<List<string>>(componentStates[SaveKey]);
            for (var i = 0; i < itemJsons.Count; i++)
            {
                if (itemJsons[i] != null)
                {
                    _inventoryItems[i] = VanillaBeltConveyorInventoryItem.LoadItem(itemJsons[i]);
                }
            }
        }
        
        public IItemStack InsertItem(IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //
            if (_inventoryItems[^1] != null)
                //
                return itemStack;
            
            _inventoryItems[^1] = new VanillaBeltConveyorInventoryItem(itemStack.Id, itemStack.ItemInstanceId);
            
            //
            return itemStack.SubItem(1);
        }
        public bool InsertionCheck(List<IItemStack> itemStacks)
        {
            BlockException.CheckDestroy(this);
            
            // 
            if (_inventoryItems[^1] != null) return false;
            
            // 1
            if (itemStacks.Count == 1 && itemStacks[0].Count == 1) return true;
            
            return false;
        }
        
        public int GetSlotSize()
        {
            BlockException.CheckDestroy(this);
            
            return _inventoryItems.Length;
        }
        
        public IItemStack GetItem(int slot)
        {
            BlockException.CheckDestroy(this);
            
            var itemStackFactory = ServerContext.ItemStackFactory;
            if (_inventoryItems[slot] == null) return itemStackFactory.CreatEmpty();
            return itemStackFactory.Create(_inventoryItems[slot].ItemId, 1);
        }
        
        public void SetItem(int slot, IItemStack itemStack)
        {
            BlockException.CheckDestroy(this);
            
            //TODO lock
            _inventoryItems[slot] = new VanillaBeltConveyorInventoryItem(itemStack.Id, itemStack.ItemInstanceId);
        }
        
        public bool IsDestroy { get; private set; }
        public void Destroy()
        {
            IsDestroy = true;
        }
        
        public string SaveKey { get; } = typeof(VanillaBeltConveyorComponent).FullName;
        public string GetSaveState()
        {
            BlockException.CheckDestroy(this);
            
            var saveItems = new List<string>();
            foreach (var t in _inventoryItems)
            {
                saveItems.Add(t?.GetSaveJsonString());
            }
            
            return JsonConvert.SerializeObject(saveItems);
        }
        
        /// <summary>
        ///     
        ///     Update
        ///     TODO 
        /// </summary>
        public void Update()
        {
            BlockException.CheckDestroy(this);
            
            //TODO lock
            var count = _inventoryItems.Length;
            
            for (var i = 0; i < count; i++)
            {
                var item = _inventoryItems[i];
                if (item == null) continue;
                
                //
                var nextIndexStartTime = i * (1f / _inventoryItemNum);
                var isNextInsertable = item.RemainingPercent <= nextIndexStartTime;
                
                //
                if (isNextInsertable && i != 0)
                {
                    if (_inventoryItems[i - 1] == null)
                    {
                        _inventoryItems[i - 1] = item;
                        _inventoryItems[i] = null;
                    }
                }
                
                //
                if (i == 0 && item.RemainingPercent <= 0)
                {
                    var insertItem = ServerContext.ItemStackFactory.Create(item.ItemId, 1, item.ItemInstanceId);
                    
                    var output = _blockInventoryInserter.InsertItem(insertItem);
                    
                    //nullItem
                    if (output.Id == ItemMaster.EmptyItemId) _inventoryItems[i] = null;
                    
                    continue;
                }
                
                // 
                var diff = (float)(GameUpdater.UpdateSecondTime * (1f / (float)_timeOfItemEnterToExit));
                var last = item.RemainingPercent;
                item.RemainingPercent -= diff;
                var current = item.RemainingPercent;
                
                if (item.ItemInstanceId.AsPrimitive() != 0)
                {
                    UnityEngine.Debug.Log($"Belt Last:{last:F3} Current:{current:F3} Diff:{diff:F3} {item.ItemInstanceId}");
                }
            }
        }
        
        public void SetTimeOfItemEnterToExit(double time)
        {
            _timeOfItemEnterToExit = time;
        }
    }
}
```

moorestech_server/Assets/Scripts/Game.Block/Factory/BlockTemplate/VanillaBeltConveyorTemplate.cs
```cs
using System.Collections.Generic;
using Game.Block.Blocks;
using Game.Block.Blocks.BeltConveyor;
using Game.Block.Interface;
using Game.Block.Interface.Component;
using Mooresmaster.Model.BlocksModule;

namespace Game.Block.Factory.BlockTemplate
{
    public class VanillaBeltConveyorTemplate : IBlockTemplate
    {
        public IBlock New(BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            return GetBlock(null, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        public IBlock Load(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            //TODo UP blet?
            return GetBlock(componentStates, blockMasterElement, blockInstanceId, blockPositionInfo);
        }
        
        private BlockSystem GetBlock(Dictionary<string, string> componentStates, BlockMasterElement blockMasterElement, BlockInstanceId blockInstanceId, BlockPositionInfo blockPositionInfo)
        {
            var beltParam = blockMasterElement.BlockParam as BeltConveyorBlockParam;
            
            var slopeType = beltParam.SlopeType switch
            {
                ItemShooterBlockParam.SlopeTypeConst.Up => BeltConveyorSlopeType.Up,
                ItemShooterBlockParam.SlopeTypeConst.Down => BeltConveyorSlopeType.Down,
                ItemShooterBlockParam.SlopeTypeConst.Straight => BeltConveyorSlopeType.Straight
            };
            var connectorComponent = BlockTemplateUtil.CreateInventoryConnector(beltParam.InventoryConnectors, blockPositionInfo);
            var beltConveyorConnector = new VanillaBeltConveyorBlockInventoryInserter(connectorComponent);
            var itemCount = beltParam.BeltConveyorItemCount;
            var time = beltParam.TimeOfItemEnterToExit;
            
            var beltComponent = componentStates == null ? 
                new VanillaBeltConveyorComponent(itemCount, time, beltConveyorConnector, slopeType) : 
                new VanillaBeltConveyorComponent(componentStates, itemCount, time, beltConveyorConnector, slopeType);
            
            
            var components = new List<IBlockComponent>
            {
                beltComponent,
                connectorComponent
            };
            
            return new BlockSystem(blockInstanceId, blockMasterElement.BlockGuid, components, blockPositionInfo);
        }
    }
}
```


# Instructions

TODOTODO

# 
- 
- 
- 
- 
